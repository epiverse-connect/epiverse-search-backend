package_name,file_name,content,tokenized_content,sentence_count,content_cleaned,cluster_id
AMR,bug_drug_combinations.md,"# Determine Bug-Drug Combinations

```r
bug_drug_combinations(x, col_mo = NULL, FUN = mo_shortname, ...)

## S3 method for class 'bug_drug_combinations'
format(
  x,
  translate_ab = ""name (ab, atc)"",
  language = get_AMR_locale(),
  minimum = 30,
  combine_SI = TRUE,
  add_ab_group = TRUE,
  remove_intrinsic_resistant = FALSE,
  decimal.mark = getOption(""OutDec""),
  big.mark = ifelse(decimal.mark == "","", ""."", "",""),
  ...
)
```

## Arguments

- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `FUN`: the function to call on the `mo` column to transform the microorganism codes - the default is `mo_shortname()`
- `...`: arguments passed on to `FUN`
- `translate_ab`: a character of length 1 containing column names of the antibiotics data set
- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see **Source**.
- `combine_SI`: a logical to indicate whether values S and I should be summed, so resistance will be based on only R - the default is `TRUE`
- `add_ab_group`: a logical to indicate where the group of the antimicrobials must be included as a first column
- `remove_intrinsic_resistant`: logical to indicate that rows and columns with 100% resistance for all tested antimicrobials must be removed from the table
- `decimal.mark`: the character to be used to indicate the numeric decimal point.
- `big.mark`: character; if not empty used as mark between every `big.interval` decimals **before** (hence `big`) the decimal point.

## Returns

The function `bug_drug_combinations()` returns a data.frame with columns ""mo"", ""ab"", ""S"", ""I"", ""R"" and ""total"".

## Description

Determine antimicrobial resistance (AMR) of all bug-drug combinations in your data set where at least 30 (default) isolates are available per species. Use `format()` on the result to prettify it to a publishable/printable format, see **Examples**.

## Details

The function `format()` calculates the resistance per bug-drug combination and returns a table ready for reporting/publishing. Use `combine_SI = TRUE` (default) to test R vs. S+I and `combine_SI = FALSE` to test R+I vs. S. This table can also directly be used in R Markdown / Quarto without the need for e.g. `knitr::kable()`.

## Examples

```r
# example_isolates is a data set available in the AMR package.
# run ?example_isolates for more info.
example_isolates


x <- bug_drug_combinations(example_isolates)
head(x)
format(x, translate_ab = ""name (atc)"")

# Use FUN to change to transformation of microorganism codes
bug_drug_combinations(example_isolates,
  FUN = mo_gramstain
)

bug_drug_combinations(example_isolates,
  FUN = function(x) {
    ifelse(x == as.mo(""Escherichia coli""),
      ""E. coli"",
      ""Others""
    )
  }
)
```



","['Determine Bug-Drug Combinations```rbug_drug_combinations(x, col_mo = NULL, FUN = mo_shortname, ...) S3 method for class \'bug_drug_combinations\'format(  x,  translate_ab = ""name (ab, atc)"",  language = get_AMR_locale(),  minimum = 30,  combine_SI = TRUE,  add_ab_group = TRUE,  remove_intrinsic_resistant = FALSE,  decimal.mark = getOption(""OutDec""),  big.mark = ifelse(decimal.mark == "","", "".', '"", "",""),  ...)``` Arguments- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `FUN`: the function to call on the `mo` column to transform the microorganism codes - the default is `mo_shortname()`- `...`: arguments passed on to `FUN`- `translate_ab`: a character of length 1 containing column names of the antibiotics data set- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `minimum`: the minimum allowed number of available (tested) isolates.', 'Any isolate count lower than `minimum` will return `NA` with a warning.', 'The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `combine_SI`: a logical to indicate whether values S and I should be summed, so resistance will be based on only R - the default is `TRUE`- `add_ab_group`: a logical to indicate where the group of the antimicrobials must be included as a first column- `remove_intrinsic_resistant`: logical to indicate that rows and columns with 100% resistance for all tested antimicrobials must be removed from the table- `decimal.mark`: the character to be used to indicate the numeric decimal point.- `big.mark`: character; if not empty used as mark between every `big.interval` decimals before (hence `big`) the decimal point.', 'ReturnsThe function `bug_drug_combinations()` returns a data.frame with columns ""mo"", ""ab"", ""S"", ""I"", ""R"" and ""total"".', 'DescriptionDetermine antimicrobial resistance (AMR) of all bug-drug combinations in your data set where at least 30 (default) isolates are available per species.', 'Use `format()` on the result to prettify it to a publishable/printable format, see Examples.', 'DetailsThe function `format()` calculates the resistance per bug-drug combination and returns a table ready for reporting/publishing.', 'Use `combine_SI = TRUE` (default) to test R vs. S+I and `combine_SI = FALSE` to test R+I vs. S. This table can also directly be used in R Markdown / Quarto without the need for e.g.', 'Examples```r example_isolates is a data set available in the AMR package.', 'run ?example_isolates for more info.example_isolatesx <- bug_drug_combinations(example_isolates)head(x)format(x, translate_ab = ""name (atc)"") Use FUN to change to transformation of microorganism codesbug_drug_combinations(example_isolates,  FUN = mo_gramstain)bug_drug_combinations(example_isolates,  FUN = function(x) {    ifelse(x == as.mo(""Escherichia coli""),      ""E. coli"",      ""Others""    )  })```']",1," Determine Bug-Drug Combinations```rbug_drug_combinations(x, col_mo = NULL, FUN = mo_shortname, ...) S3 method for class 'bug_drug_combinations'format(  x,  translate_ab = ""name (ab, atc)"",  language = get_AMR_locale(),  minimum = 30,  combine_SI = TRUE,  add_ab_group = TRUE,  remove_intrinsic_resistant = FALSE,  decimal.mark = getOption(""OutDec""),  big.mark = ifelse(decimal.mark == "","", ""."", "",""),  ...)``` Arguments- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `FUN`: the function to call on the `mo` column to transform the microorganism codes - the default is `mo_shortname()`- `...`: arguments passed on to `FUN`- `translate_ab`: a character of length 1 containing column names of the antibiotics data set- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `combine_SI`: a logical to indicate whether values S and I should be summed, so resistance will be based on only R - the default is `TRUE`- `add_ab_group`: a logical to indicate where the group of the antimicrobials must be included as a first column- `remove_intrinsic_resistant`: logical to indicate that rows and columns with 100% resistance for all tested antimicrobials must be removed from the table- `decimal.mark`: the character to be used to indicate the numeric decimal point.- `big.mark`: character; if not empty used as mark between every `big.interval` decimals before (hence `big`) the decimal point. ReturnsThe function `bug_drug_combinations()` returns a data.frame with columns ""mo"", ""ab"", ""S"", ""I"", ""R"" and ""total"". DescriptionDetermine antimicrobial resistance (AMR) of all bug-drug combinations in your data set where at least 30 (default) isolates are available per species. Use `format()` on the result to prettify it to a publishable/printable format, see Examples. DetailsThe function `format()` calculates the resistance per bug-drug combination and returns a table ready for reporting/publishing. Use `combine_SI = TRUE` (default) to test R vs. S+I and `combine_SI = FALSE` to test R+I vs. S. This table can also directly be used in R Markdown / Quarto without the need for e.g. `knitr::kable()`. Examples```r example_isolates is a data set available in the AMR package. run ?example_isolates for more info.example_isolatesx <- bug_drug_combinations(example_isolates)head(x)format(x, translate_ab = ""name (atc)"") Use FUN to change to transformation of microorganism codesbug_drug_combinations(example_isolates,  FUN = mo_gramstain)bug_drug_combinations(example_isolates,  FUN = function(x) {    ifelse(x == as.mo(""Escherichia coli""),      ""E. coli"",      ""Others""    )  })```",0
AMR,as.sir.md," data

# Translate MIC and Disk Diffusion to SIR, or Clean Existing SIR Data

## Format

An object of class `sir` (inherits from `ordered`, `factor`) of length 1.

## Source

For interpretations of minimum inhibitory concentration (MIC) values and disk diffusion diameters:

 * M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data , 2011-2023, **Clinical and Laboratory Standards Institute** (CLSI). [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).
 * M100 Performance Standard for Antimicrobial Susceptibility Testing , 2011-2023, **Clinical and Laboratory Standards Institute** (CLSI). [https://clsi.org/standards/products/microbiology/documents/m100/](https://clsi.org/standards/products/microbiology/documents/m100/).
 * Breakpoint tables for interpretation of MICs and zone diameters , 2011-2023, **European Committee on Antimicrobial Susceptibility Testing** (EUCAST). [https://www.eucast.org/clinical_breakpoints](https://www.eucast.org/clinical_breakpoints).

```r
as.sir(x, ...)

NA_sir_

is.sir(x)

is_sir_eligible(x, threshold = 0.05)

## S3 method for class 'mic'
as.sir(
  x,
  mo = NULL,
  ab = deparse(substitute(x)),
  guideline = getOption(""AMR_guideline"", ""EUCAST""),
  uti = NULL,
  conserve_capped_values = FALSE,
  add_intrinsic_resistance = FALSE,
  reference_data = AMR::clinical_breakpoints,
  include_screening = getOption(""AMR_include_screening"", FALSE),
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'disk'
as.sir(
  x,
  mo = NULL,
  ab = deparse(substitute(x)),
  guideline = getOption(""AMR_guideline"", ""EUCAST""),
  uti = NULL,
  add_intrinsic_resistance = FALSE,
  reference_data = AMR::clinical_breakpoints,
  include_screening = getOption(""AMR_include_screening"", FALSE),
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'data.frame'
as.sir(
  x,
  ...,
  col_mo = NULL,
  guideline = getOption(""AMR_guideline"", ""EUCAST""),
  uti = NULL,
  conserve_capped_values = FALSE,
  add_intrinsic_resistance = FALSE,
  reference_data = AMR::clinical_breakpoints,
  include_screening = getOption(""AMR_include_screening"", FALSE),
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human"")
)

sir_interpretation_history(clean = FALSE)
```

## Arguments

- `x`: vector of values (for class `mic`: MIC values in mg/L, for class `disk`: a disk diffusion radius in millimetres)
- `...`: for using on a data.frame : names of columns to apply `as.sir()` on (supports tidy selection such as `column1:column4`). Otherwise: arguments passed on to methods.
- `threshold`: maximum fraction of invalid antimicrobial interpretations of `x`, see **Examples**
- `mo`: any (vector of) text that can be coerced to valid microorganism codes with `as.mo()`, can be left empty to determine it automatically
- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`
- `guideline`: defaults to EUCAST 2023 (the latest implemented EUCAST guideline in the clinical_breakpoints data set), but can be set with the package option `AMR_guideline`. Currently supports EUCAST (2011-2023) and CLSI (2011-2023), see **Details**.
- `uti`: (Urinary Tract Infection) A vector with logical s (`TRUE` or `FALSE`) to specify whether a UTI specific interpretation from the guideline should be chosen. For using `as.sir()` on a data.frame , this can also be a column containing logical s or when left blank, the data set will be searched for a column 'specimen', and rows within this column containing 'urin' (such as 'urine', 'urina') will be regarded isolates from a UTI. See **Examples**.
- `conserve_capped_values`: a logical to indicate that MIC values starting with `"">""` (but not `"">=""`) must always return ""R"" , and that MIC values starting with `""<""` (but not `""<=""`) must always return ""S""
- `add_intrinsic_resistance`: **(only useful when using a EUCAST guideline)** a logical to indicate whether intrinsic antibiotic resistance must also be considered for applicable bug-drug combinations, meaning that e.g. ampicillin will always return ""R"" in **Klebsiella** species. Determination is based on the intrinsic_resistant data set, that itself is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021).
- `reference_data`: a data.frame to be used for interpretation, which defaults to the clinical_breakpoints data set. Changing this argument allows for using own interpretation guidelines. This argument must contain a data set that is equal in structure to the clinical_breakpoints data set (same column names and column types). Please note that the `guideline` argument will be ignored when `reference_data` is manually set.
- `include_screening`: a logical to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`. Can also be set with the package option `AMR_include_screening`.
- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`. Can also be set with the package option `AMR_include_PKPD`.
- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"". ECOFF stands for Epidemiological Cut-Off values. The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `clean`: a logical to indicate whether previously stored results should be forgotten after returning the 'logbook' with results

## Returns

Ordered factor with new class `sir`

## Description

Interpret minimum inhibitory concentration (MIC) values and disk diffusion diameters according to EUCAST or CLSI, or clean up existing SIR values. This transforms the input to a new class `sir`, which is an ordered factor with levels `S < I < R`.

Currently available breakpoint guidelines are EUCAST 2011-2023 and CLSI 2011-2023, and available breakpoint types are ""ECOFF"", ""animal"", and ""human"".

All breakpoints used for interpretation are publicly available in the clinical_breakpoints data set.

## Details

**Note: The clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org) and the public use of this `AMR` package has been endorsed by CLSI and EUCAST, please see clinical_breakpoints for more information.**

### How it Works

 The `as.sir()` function works in four ways:

1. For cleaning raw / untransformed data . The data will be cleaned to only contain values S, I and R and will try its best to determine this with some intelligence. For example, mixed values with SIR interpretations and MIC values such as `""\<0.25; S""` will be coerced to `""S""`. Combined interpretations for multiple test methods (as seen in laboratory records) such as `""S; S""` will be coerced to `""S""`, but a value like `""S; I""` will return `NA` with a warning that the input is unclear.
2. For interpreting minimum inhibitory concentration (MIC) values according to EUCAST or CLSI. You must clean your MIC values first using `as.mic()`, that also gives your columns the new data class `mic`. Also, be sure to have a column with microorganism names or codes. It will be found automatically, but can be set manually using the `mo` argument.
   
    * Using `dplyr`, SIR interpretation can be done very easily with either:
      
       
      
      ```
      your_data %\\>% mutate_if(is.mic, as.sir)
      your_data %\\>% mutate(across(where(is.mic), as.sir))
      ```
    * Operators like ""\\<="" will be stripped before interpretation. When using `conserve_capped_values = TRUE`, an MIC value of e.g. ""\\>2"" will always return ""R"", even if the breakpoint according to the chosen guideline is ""\\>=4"". This is to prevent that capped values from raw laboratory data would not be treated conservatively. The default behaviour (`conserve_capped_values = FALSE`) considers ""\\>2"" to be lower than ""\\>=4"" and might in this case return ""S"" or ""I"".
3. For interpreting disk diffusion diameters according to EUCAST or CLSI. You must clean your disk zones first using `as.disk()`, that also gives your columns the new data class `disk`. Also, be sure to have a column with microorganism names or codes. It will be found automatically, but can be set manually using the `mo` argument.
   
    * Using `dplyr`, SIR interpretation can be done very easily with either:
      
       
      
      ```
      your_data %\\>% mutate_if(is.disk, as.sir)
      your_data %\\>% mutate(across(where(is.disk), as.sir))
      ```
4. For interpreting a complete data set , with automatic determination of MIC values, disk diffusion diameters, microorganism names or codes, and antimicrobial test results. This is done very simply by running `as.sir(your_data)`.

For points 2, 3 and 4: Use ‘sir_interpretation_history()’ to retrieve a data.frame (or tibble if the `tibble` package is installed) with all results of the last `as.sir()` call.

### Supported Guidelines

 For interpreting MIC values as well as disk diffusion diameters, currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023).

Thus, the `guideline` argument must be set to e.g., `""EUCAST 2023""` or `""CLSI 2023""`. By simply using `""EUCAST""` (the default) or `""CLSI""` as input, the latest included version of that guideline will automatically be selected. You can set your own data set using the `reference_data` argument. The `guideline` argument will then be ignored.

You can set the default guideline with the package option `AMR_guideline` (e.g. in your `.Rprofile` file), such as:

 

```
options(AMR_guideline = ""CLSI"")
  options(AMR_guideline = ""CLSI 2018"")
  options(AMR_guideline = ""EUCAST 2020"")
  # or to reset:
  options(AMR_guideline = NULL)
```

 

### After Interpretation

 After using `as.sir()`, you can use the `eucast_rules()` defined by EUCAST to (1) apply inferred susceptibility and resistance based on results of other antimicrobials and (2) apply intrinsic resistance based on taxonomic properties of a microorganism.

### Machine-Readable Clinical Breakpoints

 The repository of this package [contains a machine-readable version](https://github.com/msberends/AMR/blob/main/data-raw/clinical_breakpoints.txt) of all guidelines. This is a CSV file consisting of 29 747 rows and 12 columns. This file is machine-readable, since it contains one row for every unique combination of the test method (MIC or disk diffusion), the antimicrobial drug and the microorganism. This allows for easy implementation of these rules in laboratoryinformation systems (LIS) . Note that it only contains interpretation guidelines for humans - interpretation guidelines from CLSI for animals were removed.

### Other

 The function `is.sir()` detects if the input contains class `sir`. If the input is a data.frame , it iterates over all columns and returns a logical vector.

The function `is_sir_eligible()` returns `TRUE` when a columns contains at most 5% invalid antimicrobial interpretations (not S and/or I and/or R), and `FALSE` otherwise. The threshold of 5% can be set with the `threshold` argument. If the input is a data.frame , it iterates over all columns and returns a logical vector.


`NA_sir_` is a missing value of the new `sir` class, analogous to e.g. base  's `NA_character_`.

## Interpretation of SIR

 In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):

 * S - Susceptible, standard dosing regimen
   
   A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.
 * I - Susceptible, increased exposure **A microorganism is categorised as ""Susceptible, Increased exposure**"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.
 * R = Resistant
   
   A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.
   
    * **Exposure** is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.

This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
example_isolates
summary(example_isolates) # see all SIR results at a glance

# For INTERPRETING disk diffusion and MIC values -----------------------

# a whole data set, even with combined MIC values and disk zones
df <- data.frame(
  microorganism = ""Escherichia coli"",
  AMP = as.mic(8),
  CIP = as.mic(0.256),
  GEN = as.disk(18),
  TOB = as.disk(16),
  ERY = ""R""
)
as.sir(df)

# return a 'logbook' about the results:
sir_interpretation_history()

# for single values
as.sir(
  x = as.mic(2),
  mo = as.mo(""S. pneumoniae""),
  ab = ""AMP"",
  guideline = ""EUCAST""
)

as.sir(
  x = as.disk(18),
  mo = ""Strep pneu"", # `mo` will be coerced with as.mo()
  ab = ""ampicillin"", # and `ab` with as.ab()
  guideline = ""EUCAST""
)


# the dplyr way
if (require(""dplyr"")) {
  df %>% mutate_if(is.mic, as.sir)
  df %>% mutate_if(function(x) is.mic(x) | is.disk(x), as.sir)
  df %>% mutate(across(where(is.mic), as.sir))
  df %>% mutate_at(vars(AMP:TOB), as.sir)
  df %>% mutate(across(AMP:TOB, as.sir))

  df %>%
    mutate_at(vars(AMP:TOB), as.sir, mo = .$microorganism)

  # to include information about urinary tract infections (UTI)
  data.frame(
    mo = ""E. coli"",
    NIT = c(""<= 2"", 32),
    from_the_bladder = c(TRUE, FALSE)
  ) %>%
    as.sir(uti = ""from_the_bladder"")

  data.frame(
    mo = ""E. coli"",
    NIT = c(""<= 2"", 32),
    specimen = c(""urine"", ""blood"")
  ) %>%
    as.sir() # automatically determines urine isolates

  df %>%
    mutate_at(vars(AMP:TOB), as.sir, mo = ""E. coli"", uti = TRUE)
}

# For CLEANING existing SIR values ------------------------------------

as.sir(c(""S"", ""I"", ""R"", ""A"", ""B"", ""C""))
as.sir(""<= 0.002; S"") # will return ""S""
sir_data <- as.sir(c(rep(""S"", 474), rep(""I"", 36), rep(""R"", 370)))
is.sir(sir_data)
plot(sir_data) # for percentages
barplot(sir_data) # for frequencies

# the dplyr way
if (require(""dplyr"")) {
  example_isolates %>%
    mutate_at(vars(PEN:RIF), as.sir)
  # same:
  example_isolates %>%
    as.sir(PEN:RIF)

  # fastest way to transform all columns with already valid AMR results to class `sir`:
  example_isolates %>%
    mutate_if(is_sir_eligible, as.sir)

  # since dplyr 1.0.0, this can also be:
  # example_isolates %>%
  #   mutate(across(where(is_sir_eligible), as.sir))
}
```

## See Also

`as.mic()`, `as.disk()`, `as.mo()`



","['data Translate MIC and Disk Diffusion to SIR, or Clean Existing SIR Data FormatAn object of class `sir` (inherits from `ordered`, `factor`) of length 1.', 'SourceFor interpretations of minimum inhibitory concentration (MIC) values and disk diffusion diameters:  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data , 2011-2023, Clinical and Laboratory Standards Institute (CLSI).', 'M100 Performance Standard for Antimicrobial Susceptibility Testing , 2011-2023, Clinical and Laboratory Standards Institute (CLSI).', 'Breakpoint tables for interpretation of MICs and zone diameters , 2011-2023, European Committee on Antimicrobial Susceptibility Testing (EUCAST).', '[https://www.eucast.org/clinical_breakpoints](https://www.eucast.org/clinical_breakpoints).```ras.sir(x, ...)NA_sir_is.sir(x)is_sir_eligible(x, threshold = 0.05) S3 method for class \'mic\'as.sir(  x,  mo = NULL,  ab = deparse(substitute(x)),  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  conserve_capped_values = FALSE,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'disk\'as.sir(  x,  mo = NULL,  ab = deparse(substitute(x)),  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'data.frame\'as.sir(  x,  ...,  col_mo = NULL,  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  conserve_capped_values = FALSE,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""))sir_interpretation_history(clean = FALSE)``` Arguments- `x`: vector of values (for class `mic`: MIC values in mg/L, for class `disk`: a disk diffusion radius in millimetres)- `...`: for using on a data.frame : names of columns to apply `as.sir()` on (supports tidy selection such as `column1:column4`).', 'Otherwise: arguments passed on to methods.- `threshold`: maximum fraction of invalid antimicrobial interpretations of `x`, see Examples- `mo`: any (vector of) text that can be coerced to valid microorganism codes with `as.mo()`, can be left empty to determine it automatically- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`- `guideline`: defaults to EUCAST 2023 (the latest implemented EUCAST guideline in the clinical_breakpoints data set), but can be set with the package option `AMR_guideline`.', 'Currently supports EUCAST (2011-2023) and CLSI (2011-2023), see Details.- `uti`: (Urinary Tract Infection) A vector with logical s (`TRUE` or `FALSE`) to specify whether a UTI specific interpretation from the guideline should be chosen.', ""For using `as.sir()` on a data.frame , this can also be a column containing logical s or when left blank, the data set will be searched for a column 'specimen', and rows within this column containing 'urin' (such as 'urine', 'urina') will be regarded isolates from a UTI."", 'See Examples.- `conserve_capped_values`: a logical to indicate that MIC values starting with `"">""` (but not `"">=""`) must always return ""R"" , and that MIC values starting with `""<""` (but not `""<=""`) must always return ""S""- `add_intrinsic_resistance`: (only useful when using a EUCAST guideline) a logical to indicate whether intrinsic antibiotic resistance must also be considered for applicable bug-drug combinations, meaning that e.g.', 'ampicillin will always return ""R"" in Klebsiella species.', ""Determination is based on the intrinsic_resistant data set, that itself is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021).- `reference_data`: a data.frame to be used for interpretation, which defaults to the clinical_breakpoints data set."", 'Changing this argument allows for using own interpretation guidelines.', 'This argument must contain a data set that is equal in structure to the clinical_breakpoints data set (same column names and column types).', 'Please note that the `guideline` argument will be ignored when `reference_data` is manually set.- `include_screening`: a logical to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`.', 'Can also be set with the package option `AMR_include_screening`.- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`.', 'Can also be set with the package option `AMR_include_PKPD`.- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"".', 'ECOFF stands for Epidemiological Cut-Off values.', 'The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', ""Values will be coerced using `as.mo()`.- `clean`: a logical to indicate whether previously stored results should be forgotten after returning the 'logbook' with results ReturnsOrdered factor with new class `sir` DescriptionInterpret minimum inhibitory concentration (MIC) values and disk diffusion diameters according to EUCAST or CLSI, or clean up existing SIR values."", 'This transforms the input to a new class `sir`, which is an ordered factor with levels `S < I < R`.Currently available breakpoint guidelines are EUCAST 2011-2023 and CLSI 2011-2023, and available breakpoint types are ""ECOFF"", ""animal"", and ""human"".All breakpoints used for interpretation are publicly available in the clinical_breakpoints data set.', 'DetailsNote: The clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org) and the public use of this `AMR` package has been endorsed by CLSI and EUCAST, please see clinical_breakpoints for more information.', 'How it Works The `as.sir()` function works in four ways:1.', 'For cleaning raw / untransformed data .', 'The data will be cleaned to only contain values S, I and R and will try its best to determine this with some intelligence.', 'For example, mixed values with SIR interpretations and MIC values such as `""\\<0.25; S""` will be coerced to `""S""`.', 'Combined interpretations for multiple test methods (as seen in laboratory records) such as `""S; S""` will be coerced to `""S""`, but a value like `""S; I""` will return `NA` with a warning that the input is unclear.2.', 'For interpreting minimum inhibitory concentration (MIC) values according to EUCAST or CLSI.', 'You must clean your MIC values first using `as.mic()`, that also gives your columns the new data class `mic`.', 'Also, be sure to have a column with microorganism names or codes.', 'It will be found automatically, but can be set manually using the `mo` argument.', 'Using `dplyr`, SIR interpretation can be done very easily with either:                         ```      your_data %\\\\>% mutate_if(is.mic, as.sir)      your_data %\\\\>% mutate(across(where(is.mic), as.sir))      ```     Operators like ""\\\\<="" will be stripped before interpretation.', 'When using `conserve_capped_values = TRUE`, an MIC value of e.g.', '""\\\\>2"" will always return ""R"", even if the breakpoint according to the chosen guideline is ""\\\\>=4"".', 'This is to prevent that capped values from raw laboratory data would not be treated conservatively.', 'The default behaviour (`conserve_capped_values = FALSE`) considers ""\\\\>2"" to be lower than ""\\\\>=4"" and might in this case return ""S"" or ""I"".3.', 'For interpreting disk diffusion diameters according to EUCAST or CLSI.', 'You must clean your disk zones first using `as.disk()`, that also gives your columns the new data class `disk`.', 'Also, be sure to have a column with microorganism names or codes.', 'It will be found automatically, but can be set manually using the `mo` argument.', 'Using `dplyr`, SIR interpretation can be done very easily with either:                         ```      your_data %\\\\>% mutate_if(is.disk, as.sir)      your_data %\\\\>% mutate(across(where(is.disk), as.sir))      ```4.', 'For interpreting a complete data set , with automatic determination of MIC values, disk diffusion diameters, microorganism names or codes, and antimicrobial test results.', 'This is done very simply by running `as.sir(your_data)`.For points 2, 3 and 4: Use ‘sir_interpretation_history()’ to retrieve a data.frame (or tibble if the `tibble` package is installed) with all results of the last `as.sir()` call.', 'Supported Guidelines For interpreting MIC values as well as disk diffusion diameters, currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023).Thus, the `guideline` argument must be set to e.g., `""EUCAST 2023""` or `""CLSI 2023""`.', 'By simply using `""EUCAST""` (the default) or `""CLSI""` as input, the latest included version of that guideline will automatically be selected.', 'You can set your own data set using the `reference_data` argument.', 'The `guideline` argument will then be ignored.You can set the default guideline with the package option `AMR_guideline` (e.g.', 'in your `.Rprofile` file), such as: ```options(AMR_guideline = ""CLSI"")  options(AMR_guideline = ""CLSI 2018"")  options(AMR_guideline = ""EUCAST 2020"")   or to reset:  options(AMR_guideline = NULL)```  After Interpretation After using `as.sir()`, you can use the `eucast_rules()` defined by EUCAST to (1) apply inferred susceptibility and resistance based on results of other antimicrobials and (2) apply intrinsic resistance based on taxonomic properties of a microorganism.', 'Machine-Readable Clinical Breakpoints The repository of this package [contains a machine-readable version](https://github.com/msberends/AMR/blob/main/data-raw/clinical_breakpoints.txt) of all guidelines.', 'This is a CSV file consisting of 29 747 rows and 12 columns.', 'This file is machine-readable, since it contains one row for every unique combination of the test method (MIC or disk diffusion), the antimicrobial drug and the microorganism.', 'This allows for easy implementation of these rules in laboratoryinformation systems (LIS) .', 'Note that it only contains interpretation guidelines for humans - interpretation guidelines from CLSI for animals were removed.', 'Other The function `is.sir()` detects if the input contains class `sir`.', 'If the input is a data.frame , it iterates over all columns and returns a logical vector.The function `is_sir_eligible()` returns `TRUE` when a columns contains at most 5% invalid antimicrobial interpretations (not S and/or I and/or R), and `FALSE` otherwise.', 'The threshold of 5% can be set with the `threshold` argument.', 'If the input is a data.frame , it iterates over all columns and returns a logical vector.`NA_sir_` is a missing value of the new `sir` class, analogous to e.g.', 'Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.', 'I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.', 'R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.', 'Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight.', 'Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```rexample_isolatessummary(example_isolates)  see all SIR results at a glance For INTERPRETING disk diffusion and MIC values ----------------------- a whole data set, even with combined MIC values and disk zonesdf <- data.frame(  microorganism = ""Escherichia coli"",  AMP = as.mic(8),  CIP = as.mic(0.256),  GEN = as.disk(18),  TOB = as.disk(16),  ERY = ""R"")as.sir(df) return a \'logbook\' about the results:sir_interpretation_history() for single valuesas.sir(  x = as.mic(2),  mo = as.mo(""S. pneumoniae""),  ab = ""AMP"",  guideline = ""EUCAST"")as.sir(  x = as.disk(18),  mo = ""Strep pneu"",  `mo` will be coerced with as.mo()  ab = ""ampicillin"",  and `ab` with as.ab()  guideline = ""EUCAST"") the dplyr wayif (require(""dplyr"")) {  df %>% mutate_if(is.mic, as.sir)  df %>% mutate_if(function(x) is.mic(x) | is.disk(x), as.sir)  df %>% mutate(across(where(is.mic), as.sir))  df %>% mutate_at(vars(AMP:TOB), as.sir)  df %>% mutate(across(AMP:TOB, as.sir))  df %>%    mutate_at(vars(AMP:TOB), as.sir, mo = .$microorganism)   to include information about urinary tract infections (UTI)  data.frame(    mo = ""E. coli"",    NIT = c(""<= 2"", 32),    from_the_bladder = c(TRUE, FALSE)  ) %>%    as.sir(uti = ""from_the_bladder"")  data.frame(    mo = ""E. coli"",    NIT = c(""<= 2"", 32),    specimen = c(""urine"", ""blood"")  ) %>%    as.sir()  automatically determines urine isolates  df %>%    mutate_at(vars(AMP:TOB), as.sir, mo = ""E. coli"", uti = TRUE)} For CLEANING existing SIR values ------------------------------------as.sir(c(""S"", ""I"", ""R"", ""A"", ""B"", ""C""))as.sir(""<= 0.002; S"")  will return ""S""sir_data <- as.sir(c(rep(""S"", 474), rep(""I"", 36), rep(""R"", 370)))is.sir(sir_data)plot(sir_data)  for percentagesbarplot(sir_data)  for frequencies the dplyr wayif (require(""dplyr"")) {  example_isolates %>%    mutate_at(vars(PEN:RIF), as.sir)   same:  example_isolates %>%    as.sir(PEN:RIF)   fastest way to transform all columns with already valid AMR results to class `sir`:  example_isolates %>%    mutate_if(is_sir_eligible, as.sir)   since dplyr 1.0.0, this can also be:   example_isolates %>%     mutate(across(where(is_sir_eligible), as.sir))}``` See Also`as.mic()`, `as.disk()`, `as.mo()`']",1," data Translate MIC and Disk Diffusion to SIR, or Clean Existing SIR Data FormatAn object of class `sir` (inherits from `ordered`, `factor`) of length 1. SourceFor interpretations of minimum inhibitory concentration (MIC) values and disk diffusion diameters:  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data , 2011-2023, Clinical and Laboratory Standards Institute (CLSI). [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).  M100 Performance Standard for Antimicrobial Susceptibility Testing , 2011-2023, Clinical and Laboratory Standards Institute (CLSI). [https://clsi.org/standards/products/microbiology/documents/m100/](https://clsi.org/standards/products/microbiology/documents/m100/).  Breakpoint tables for interpretation of MICs and zone diameters , 2011-2023, European Committee on Antimicrobial Susceptibility Testing (EUCAST). [https://www.eucast.org/clinical_breakpoints](https://www.eucast.org/clinical_breakpoints).```ras.sir(x, ...)NA_sir_is.sir(x)is_sir_eligible(x, threshold = 0.05) S3 method for class 'mic'as.sir(  x,  mo = NULL,  ab = deparse(substitute(x)),  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  conserve_capped_values = FALSE,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'disk'as.sir(  x,  mo = NULL,  ab = deparse(substitute(x)),  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'data.frame'as.sir(  x,  ...,  col_mo = NULL,  guideline = getOption(""AMR_guideline"", ""EUCAST""),  uti = NULL,  conserve_capped_values = FALSE,  add_intrinsic_resistance = FALSE,  reference_data = AMR::clinical_breakpoints,  include_screening = getOption(""AMR_include_screening"", FALSE),  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""))sir_interpretation_history(clean = FALSE)``` Arguments- `x`: vector of values (for class `mic`: MIC values in mg/L, for class `disk`: a disk diffusion radius in millimetres)- `...`: for using on a data.frame : names of columns to apply `as.sir()` on (supports tidy selection such as `column1:column4`). Otherwise: arguments passed on to methods.- `threshold`: maximum fraction of invalid antimicrobial interpretations of `x`, see Examples- `mo`: any (vector of) text that can be coerced to valid microorganism codes with `as.mo()`, can be left empty to determine it automatically- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`- `guideline`: defaults to EUCAST 2023 (the latest implemented EUCAST guideline in the clinical_breakpoints data set), but can be set with the package option `AMR_guideline`. Currently supports EUCAST (2011-2023) and CLSI (2011-2023), see Details.- `uti`: (Urinary Tract Infection) A vector with logical s (`TRUE` or `FALSE`) to specify whether a UTI specific interpretation from the guideline should be chosen. For using `as.sir()` on a data.frame , this can also be a column containing logical s or when left blank, the data set will be searched for a column 'specimen', and rows within this column containing 'urin' (such as 'urine', 'urina') will be regarded isolates from a UTI. See Examples.- `conserve_capped_values`: a logical to indicate that MIC values starting with `"">""` (but not `"">=""`) must always return ""R"" , and that MIC values starting with `""<""` (but not `""<=""`) must always return ""S""- `add_intrinsic_resistance`: (only useful when using a EUCAST guideline) a logical to indicate whether intrinsic antibiotic resistance must also be considered for applicable bug-drug combinations, meaning that e.g. ampicillin will always return ""R"" in Klebsiella species. Determination is based on the intrinsic_resistant data set, that itself is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021).- `reference_data`: a data.frame to be used for interpretation, which defaults to the clinical_breakpoints data set. Changing this argument allows for using own interpretation guidelines. This argument must contain a data set that is equal in structure to the clinical_breakpoints data set (same column names and column types). Please note that the `guideline` argument will be ignored when `reference_data` is manually set.- `include_screening`: a logical to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`. Can also be set with the package option `AMR_include_screening`.- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`. Can also be set with the package option `AMR_include_PKPD`.- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"". ECOFF stands for Epidemiological Cut-Off values. The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `clean`: a logical to indicate whether previously stored results should be forgotten after returning the 'logbook' with results ReturnsOrdered factor with new class `sir` DescriptionInterpret minimum inhibitory concentration (MIC) values and disk diffusion diameters according to EUCAST or CLSI, or clean up existing SIR values. This transforms the input to a new class `sir`, which is an ordered factor with levels `S < I < R`.Currently available breakpoint guidelines are EUCAST 2011-2023 and CLSI 2011-2023, and available breakpoint types are ""ECOFF"", ""animal"", and ""human"".All breakpoints used for interpretation are publicly available in the clinical_breakpoints data set. DetailsNote: The clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org) and the public use of this `AMR` package has been endorsed by CLSI and EUCAST, please see clinical_breakpoints for more information. How it Works The `as.sir()` function works in four ways:1. For cleaning raw / untransformed data . The data will be cleaned to only contain values S, I and R and will try its best to determine this with some intelligence. For example, mixed values with SIR interpretations and MIC values such as `""\<0.25; S""` will be coerced to `""S""`. Combined interpretations for multiple test methods (as seen in laboratory records) such as `""S; S""` will be coerced to `""S""`, but a value like `""S; I""` will return `NA` with a warning that the input is unclear.2. For interpreting minimum inhibitory concentration (MIC) values according to EUCAST or CLSI. You must clean your MIC values first using `as.mic()`, that also gives your columns the new data class `mic`. Also, be sure to have a column with microorganism names or codes. It will be found automatically, but can be set manually using the `mo` argument.        Using `dplyr`, SIR interpretation can be done very easily with either:                         ```      your_data %\\>% mutate_if(is.mic, as.sir)      your_data %\\>% mutate(across(where(is.mic), as.sir))      ```     Operators like ""\\<="" will be stripped before interpretation. When using `conserve_capped_values = TRUE`, an MIC value of e.g. ""\\>2"" will always return ""R"", even if the breakpoint according to the chosen guideline is ""\\>=4"". This is to prevent that capped values from raw laboratory data would not be treated conservatively. The default behaviour (`conserve_capped_values = FALSE`) considers ""\\>2"" to be lower than ""\\>=4"" and might in this case return ""S"" or ""I"".3. For interpreting disk diffusion diameters according to EUCAST or CLSI. You must clean your disk zones first using `as.disk()`, that also gives your columns the new data class `disk`. Also, be sure to have a column with microorganism names or codes. It will be found automatically, but can be set manually using the `mo` argument.        Using `dplyr`, SIR interpretation can be done very easily with either:                         ```      your_data %\\>% mutate_if(is.disk, as.sir)      your_data %\\>% mutate(across(where(is.disk), as.sir))      ```4. For interpreting a complete data set , with automatic determination of MIC values, disk diffusion diameters, microorganism names or codes, and antimicrobial test results. This is done very simply by running `as.sir(your_data)`.For points 2, 3 and 4: Use ‘sir_interpretation_history()’ to retrieve a data.frame (or tibble if the `tibble` package is installed) with all results of the last `as.sir()` call. Supported Guidelines For interpreting MIC values as well as disk diffusion diameters, currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023).Thus, the `guideline` argument must be set to e.g., `""EUCAST 2023""` or `""CLSI 2023""`. By simply using `""EUCAST""` (the default) or `""CLSI""` as input, the latest included version of that guideline will automatically be selected. You can set your own data set using the `reference_data` argument. The `guideline` argument will then be ignored.You can set the default guideline with the package option `AMR_guideline` (e.g. in your `.Rprofile` file), such as: ```options(AMR_guideline = ""CLSI"")  options(AMR_guideline = ""CLSI 2018"")  options(AMR_guideline = ""EUCAST 2020"")   or to reset:  options(AMR_guideline = NULL)```  After Interpretation After using `as.sir()`, you can use the `eucast_rules()` defined by EUCAST to (1) apply inferred susceptibility and resistance based on results of other antimicrobials and (2) apply intrinsic resistance based on taxonomic properties of a microorganism. Machine-Readable Clinical Breakpoints The repository of this package [contains a machine-readable version](https://github.com/msberends/AMR/blob/main/data-raw/clinical_breakpoints.txt) of all guidelines. This is a CSV file consisting of 29 747 rows and 12 columns. This file is machine-readable, since it contains one row for every unique combination of the test method (MIC or disk diffusion), the antimicrobial drug and the microorganism. This allows for easy implementation of these rules in laboratoryinformation systems (LIS) . Note that it only contains interpretation guidelines for humans - interpretation guidelines from CLSI for animals were removed. Other The function `is.sir()` detects if the input contains class `sir`. If the input is a data.frame , it iterates over all columns and returns a logical vector.The function `is_sir_eligible()` returns `TRUE` when a columns contains at most 5% invalid antimicrobial interpretations (not S and/or I and/or R), and `FALSE` otherwise. The threshold of 5% can be set with the `threshold` argument. If the input is a data.frame , it iterates over all columns and returns a logical vector.`NA_sir_` is a missing value of the new `sir` class, analogous to e.g. base  's `NA_character_`. Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.  I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.  R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.        Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates. Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rexample_isolatessummary(example_isolates)  see all SIR results at a glance For INTERPRETING disk diffusion and MIC values ----------------------- a whole data set, even with combined MIC values and disk zonesdf <- data.frame(  microorganism = ""Escherichia coli"",  AMP = as.mic(8),  CIP = as.mic(0.256),  GEN = as.disk(18),  TOB = as.disk(16),  ERY = ""R"")as.sir(df) return a 'logbook' about the results:sir_interpretation_history() for single valuesas.sir(  x = as.mic(2),  mo = as.mo(""S. pneumoniae""),  ab = ""AMP"",  guideline = ""EUCAST"")as.sir(  x = as.disk(18),  mo = ""Strep pneu"",  `mo` will be coerced with as.mo()  ab = ""ampicillin"",  and `ab` with as.ab()  guideline = ""EUCAST"") the dplyr wayif (require(""dplyr"")) {  df %>% mutate_if(is.mic, as.sir)  df %>% mutate_if(function(x) is.mic(x) | is.disk(x), as.sir)  df %>% mutate(across(where(is.mic), as.sir))  df %>% mutate_at(vars(AMP:TOB), as.sir)  df %>% mutate(across(AMP:TOB, as.sir))  df %>%    mutate_at(vars(AMP:TOB), as.sir, mo = .$microorganism)   to include information about urinary tract infections (UTI)  data.frame(    mo = ""E. coli"",    NIT = c(""<= 2"", 32),    from_the_bladder = c(TRUE, FALSE)  ) %>%    as.sir(uti = ""from_the_bladder"")  data.frame(    mo = ""E. coli"",    NIT = c(""<= 2"", 32),    specimen = c(""urine"", ""blood"")  ) %>%    as.sir()  automatically determines urine isolates  df %>%    mutate_at(vars(AMP:TOB), as.sir, mo = ""E. coli"", uti = TRUE)} For CLEANING existing SIR values ------------------------------------as.sir(c(""S"", ""I"", ""R"", ""A"", ""B"", ""C""))as.sir(""<= 0.002; S"")  will return ""S""sir_data <- as.sir(c(rep(""S"", 474), rep(""I"", 36), rep(""R"", 370)))is.sir(sir_data)plot(sir_data)  for percentagesbarplot(sir_data)  for frequencies the dplyr wayif (require(""dplyr"")) {  example_isolates %>%    mutate_at(vars(PEN:RIF), as.sir)   same:  example_isolates %>%    as.sir(PEN:RIF)   fastest way to transform all columns with already valid AMR results to class `sir`:  example_isolates %>%    mutate_if(is_sir_eligible, as.sir)   since dplyr 1.0.0, this can also be:   example_isolates %>%     mutate(across(where(is_sir_eligible), as.sir))}``` See Also`as.mic()`, `as.disk()`, `as.mo()`",0
AMR,mdro.md,"# Determine Multidrug-Resistant Organisms (MDRO)

## Source

See the supported guidelines above for the list of publications used for this function.

```r
mdro(
  x = NULL,
  guideline = ""CMI2012"",
  col_mo = NULL,
  info = interactive(),
  pct_required_classes = 0.5,
  combine_SI = TRUE,
  verbose = FALSE,
  only_sir_columns = FALSE,
  ...
)

custom_mdro_guideline(..., as_factor = TRUE)

brmo(x = NULL, only_sir_columns = FALSE, ...)

mrgn(x = NULL, only_sir_columns = FALSE, ...)

mdr_tb(x = NULL, only_sir_columns = FALSE, ...)

mdr_cmi2012(x = NULL, only_sir_columns = FALSE, ...)

eucast_exceptional_phenotypes(x = NULL, only_sir_columns = FALSE, ...)
```

## Arguments

- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`. Can be left blank for automatic determination.
- `guideline`: a specific guideline to follow, see sections **Supported international / national guidelines** and **Using Custom Guidelines** below. When left empty, the publication by Magiorakos **et al.** (see below) will be followed.
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions
- `pct_required_classes`: minimal required percentage of antimicrobial classes that must be available per isolate, rounded down. For example, with the default guideline, 17 antimicrobial classes must be available for **S. aureus**. Setting this `pct_required_classes` argument to `0.5` (default) means that for every **S. aureus** isolate at least 8 different classes must be available. Any lower number of available classes will return `NA` for that isolate.
- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so resistance is only considered when isolates are R, not I. As this is the default behaviour of the `mdro()` function, it follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section 'Interpretation of S, I and R' below. When using `combine_SI = FALSE`, resistance is considered when isolates are R or I.
- `verbose`: a logical to turn Verbose mode on and off (default is off). In Verbose mode, the function does not return the MDRO results, but instead returns a data set in logbook form with extensive info about which isolates would be MDRO-positive, or why they are not.
- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)
- `...`: in case of `custom_mdro_guideline()`: a set of rules, see section **Using Custom Guidelines** below. Otherwise: column name of an antibiotic, see section **Antibiotics** below.
- `as_factor`: a logical to indicate whether the returned value should be an ordered factor (`TRUE`, default), or otherwise a character vector

## Returns

 * CMI 2012 paper - function `mdr_cmi2012()` or `mdro()`:
   
   Ordered factor with levels `Negative` \< `Multi-drug-resistant (MDR)` \< `Extensively drug-resistant (XDR)` \< `Pandrug-resistant (PDR)`
 * TB guideline - function `mdr_tb()` or `mdro(..., guideline = ""TB"")`:
   
   Ordered factor with levels `Negative` \< `Mono-resistant` \< `Poly-resistant` \< `Multi-drug-resistant` \< `Extensively drug-resistant`
 * German guideline - function `mrgn()` or `mdro(..., guideline = ""MRGN"")`:
   
   Ordered factor with levels `Negative` \< `3MRGN` \< `4MRGN`
 * Everything else, except for custom guidelines:
   
   Ordered factor with levels `Negative` \< `Positive, unconfirmed` \< `Positive`. The value `""Positive, unconfirmed""` means that, according to the guideline, it is not entirely sure if the isolate is multi-drug resistant and this should be confirmed with additional (e.g. molecular) tests

## Description

Determine which isolates are multidrug-resistant organisms (MDRO) according to international, national and custom guidelines.

## Details

These functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see **Examples**.

For the `pct_required_classes` argument, values above 1 will be divided by 100. This is to support both fractions (`0.75` or `3/4`) and percentages (`75`).

Note: Every test that involves the Enterobacteriaceae family, will internally be performed using its newly named **order** Enterobacterales, since the Enterobacteriaceae family has been taxonomically reclassified by Adeolu **et al.** in 2016. Before that, Enterobacteriaceae was the only family under the Enterobacteriales (with an i) order. All species under the old Enterobacteriaceae family are still under the new Enterobacterales (without an i) order, but divided into multiple families. The way tests are performed now by this `mdro()` function makes sure that results from before 2016 and after 2016 are identical.

## Supported International / National Guidelines

 Currently supported guidelines are (case-insensitive):

 * `guideline = ""CMI2012""` (default)
   
   Magiorakos AP, Srinivasan A **et al.** ""Multidrug-resistant, extensively drug-resistant and pandrug-resistant bacteria: an international expert proposal for interim standard definitions for acquired resistance."" Clinical Microbiology and Infection (2012) (tools:::Rd_expr_doi(""10.1111/j.1469-0691.2011.03570.x"") )
 * `guideline = ""EUCAST3.3""` (or simply `guideline = ""EUCAST""`)
   
   The European international guideline - EUCAST Expert Rules Version 3.3 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf))
 * `guideline = ""EUCAST3.2""`
   
   The European international guideline - EUCAST Expert Rules Version 3.2 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf))
 * `guideline = ""EUCAST3.1""`
   
   The European international guideline - EUCAST Expert Rules Version 3.1 ""Intrinsic Resistance and Exceptional Phenotypes Tables"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf))
 * `guideline = ""TB""`
   
   The international guideline for multi-drug resistant tuberculosis - World Health Organization ""Companion handbook to the WHO guidelines for the programmatic management of drug-resistant tuberculosis"" ([link](https://www.who.int/publications/i/item/9789241548809))
 * `guideline = ""MRGN""`
   
   The German national guideline - Mueller et al. (2015) Antimicrobial Resistance and Infection Control 4:7; tools:::Rd_expr_doi(""10.1186/s13756-015-0047-6"")
 * `guideline = ""BRMO""`
   
   The Dutch national guideline - Rijksinstituut voor Volksgezondheid en Milieu ""WIP-richtlijn BRMO (Bijzonder Resistente Micro-Organismen) (ZKH)"" ([link](https://www.rivm.nl/wip-richtlijn-brmo-bijzonder-resistente-micro-organismen-zkh))

Please suggest your own (country-specific) guidelines by letting us know: [https://github.com/msberends/AMR/issues/new](https://github.com/msberends/AMR/issues/new).

## Using Custom Guidelines

 Custom guidelines can be set with the `custom_mdro_guideline()` function. This is of great importance if you have custom rules to determine MDROs in your hospital, e.g., rules that are dependent on ward, state of contact isolation or other variables in your data.

If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules. Rules must be set using what considers to be the 'formula notation'. The rule is written **before** the tilde (`~`) and the consequence of the rule is written **after** the tilde:

 

```
custom <- custom_mdro_guideline(CIP == ""R"" & age > 60 ~ ""Elderly Type A"",
                           ERY == ""R"" & age > 60 ~ ""Elderly Type B"")
```

 

If a row/an isolate matches the first rule, the value after the first `~` (in this case **'Elderly Type A'**) will be set as MDRO value. Otherwise, the second rule will be tried and so on. The number of rules is unlimited.

You can print the rules set in the console for an overview. Colours will help reading it if your console supports colours.

 

```
custom
#> A set of custom MDRO rules:
#>   1. CIP is ""R"" and age is higher than 60 -> Elderly Type A
#>   2. ERY is ""R"" and age is higher than 60 -> Elderly Type B
#>   3. Otherwise -> Negative
#>
#> Unmatched rows will return NA.
```

 

The outcome of the function can be used for the `guideline` argument in the `mdro()` function:


 

```
x <- mdro(example_isolates,
     guideline = custom)
table(x)
#>       Negative Elderly Type A Elderly Type B
#>           1070            198            732
```

 

Rules can also be combined with other custom rules by using `c()`:


 

```
x <- mdro(example_isolates,
     guideline = c(custom,
                   custom_mdro_guideline(ERY == ""R"" & age > 50 ~ ""Elderly Type C"")))
table(x)
#>       Negative Elderly Type A Elderly Type B Elderly Type C
#>            961            198            732            109
```

 

The rules set (the `custom` object in this case) could be exported to a shared file location using `saveRDS()` if you collaborate with multiple users. The custom rules set could then be imported using `readRDS()`.

## Antibiotics

 To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g. `TIC = NULL` to skip ticarcillin). Manually defined but non-existing columns will be skipped with a warning.

The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`. These are shown below in the format 'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))', sorted alphabetically:

Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no))

## Interpretation of SIR

 In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):

 * S - Susceptible, standard dosing regimen
   
   A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.
 * I - Susceptible, increased exposure **A microorganism is categorised as ""Susceptible, Increased exposure**"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.
 * R = Resistant
   
   A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.
   
    * **Exposure** is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.

This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.

## Examples

```r
out <- mdro(example_isolates, guideline = ""EUCAST"")
str(out)
table(out)

out <- mdro(example_isolates,
  guideline = custom_mdro_guideline(
    AMX == ""R"" ~ ""Custom MDRO 1"",
    VAN == ""R"" ~ ""Custom MDRO 2""
  )
)
table(out)


if (require(""dplyr"")) {
  example_isolates %>%
    mdro() %>%
    table()

  # no need to define `x` when used inside dplyr verbs:
  example_isolates %>%
    mutate(MDRO = mdro()) %>%
    pull(MDRO) %>%
    table()
}
```



","['Determine Multidrug-Resistant Organisms (MDRO) SourceSee the supported guidelines above for the list of publications used for this function.```rmdro(  x = NULL,  guideline = ""CMI2012"",  col_mo = NULL,  info = interactive(),  pct_required_classes = 0.5,  combine_SI = TRUE,  verbose = FALSE,  only_sir_columns = FALSE,  ...)custom_mdro_guideline(..., as_factor = TRUE)brmo(x = NULL, only_sir_columns = FALSE, ...)mrgn(x = NULL, only_sir_columns = FALSE, ...)mdr_tb(x = NULL, only_sir_columns = FALSE, ...)mdr_cmi2012(x = NULL, only_sir_columns = FALSE, ...)eucast_exceptional_phenotypes(x = NULL, only_sir_columns = FALSE, ...)``` Arguments- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`.', 'Can be left blank for automatic determination.- `guideline`: a specific guideline to follow, see sections Supported international / national guidelines and Using Custom Guidelines below.', 'When left empty, the publication by Magiorakos et al.', '(see below) will be followed.- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions- `pct_required_classes`: minimal required percentage of antimicrobial classes that must be available per isolate, rounded down.', 'For example, with the default guideline, 17 antimicrobial classes must be available for S. aureus.', 'Setting this `pct_required_classes` argument to `0.5` (default) means that for every S. aureus isolate at least 8 different classes must be available.', 'Any lower number of available classes will return `NA` for that isolate.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so resistance is only considered when isolates are R, not I.', ""As this is the default behaviour of the `mdro()` function, it follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section 'Interpretation of S, I and R' below."", 'When using `combine_SI = FALSE`, resistance is considered when isolates are R or I.- `verbose`: a logical to turn Verbose mode on and off (default is off).', 'In Verbose mode, the function does not return the MDRO results, but instead returns a data set in logbook form with extensive info about which isolates would be MDRO-positive, or why they are not.- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `...`: in case of `custom_mdro_guideline()`: a set of rules, see section Using Custom Guidelines below.', 'Otherwise: column name of an antibiotic, see section Antibiotics below.- `as_factor`: a logical to indicate whether the returned value should be an ordered factor (`TRUE`, default), or otherwise a character vector Returns  CMI 2012 paper - function `mdr_cmi2012()` or `mdro()`:      Ordered factor with levels `Negative` \\< `Multi-drug-resistant (MDR)` \\< `Extensively drug-resistant (XDR)` \\< `Pandrug-resistant (PDR)`  TB guideline - function `mdr_tb()` or `mdro(..., guideline = ""TB"")`:      Ordered factor with levels `Negative` \\< `Mono-resistant` \\< `Poly-resistant` \\< `Multi-drug-resistant` \\< `Extensively drug-resistant`  German guideline - function `mrgn()` or `mdro(..., guideline = ""MRGN"")`:      Ordered factor with levels `Negative` \\< `3MRGN` \\< `4MRGN`  Everything else, except for custom guidelines:      Ordered factor with levels `Negative` \\< `Positive, unconfirmed` \\< `Positive`.', 'The value `""Positive, unconfirmed""` means that, according to the guideline, it is not entirely sure if the isolate is multi-drug resistant and this should be confirmed with additional (e.g.', 'molecular) tests DescriptionDetermine which isolates are multidrug-resistant organisms (MDRO) according to international, national and custom guidelines.', 'This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.For the `pct_required_classes` argument, values above 1 will be divided by 100.', 'This is to support both fractions (`0.75` or `3/4`) and percentages (`75`).Note: Every test that involves the Enterobacteriaceae family, will internally be performed using its newly named order Enterobacterales, since the Enterobacteriaceae family has been taxonomically reclassified by Adeolu et al.', 'Before that, Enterobacteriaceae was the only family under the Enterobacteriales (with an i) order.', 'All species under the old Enterobacteriaceae family are still under the new Enterobacterales (without an i) order, but divided into multiple families.', 'The way tests are performed now by this `mdro()` function makes sure that results from before 2016 and after 2016 are identical.', 'Supported International / National Guidelines Currently supported guidelines are (case-insensitive):  `guideline = ""CMI2012""` (default)      Magiorakos AP, Srinivasan A et al.', '""Multidrug-resistant, extensively drug-resistant and pandrug-resistant bacteria: an international expert proposal for interim standard definitions for acquired resistance.""', 'Clinical Microbiology and Infection (2012) (tools:::Rd_expr_doi(""10.1111/j.1469-0691.2011.03570.x"") )  `guideline = ""EUCAST3.3""` (or simply `guideline = ""EUCAST""`)      The European international guideline - EUCAST Expert Rules Version 3.3 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf))  `guideline = ""EUCAST3.2""`      The European international guideline - EUCAST Expert Rules Version 3.2 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf))  `guideline = ""EUCAST3.1""`      The European international guideline - EUCAST Expert Rules Version 3.1 ""Intrinsic Resistance and Exceptional Phenotypes Tables"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf))  `guideline = ""TB""`      The international guideline for multi-drug resistant tuberculosis - World Health Organization ""Companion handbook to the WHO guidelines for the programmatic management of drug-resistant tuberculosis"" ([link](https://www.who.int/publications/i/item/9789241548809))  `guideline = ""MRGN""`      The German national guideline - Mueller et al.', '(2015) Antimicrobial Resistance and Infection Control 4:7; tools:::Rd_expr_doi(""10.1186/s13756-015-0047-6"")  `guideline = ""BRMO""`      The Dutch national guideline - Rijksinstituut voor Volksgezondheid en Milieu ""WIP-richtlijn BRMO (Bijzonder Resistente Micro-Organismen) (ZKH)"" ([link](https://www.rivm.nl/wip-richtlijn-brmo-bijzonder-resistente-micro-organismen-zkh))Please suggest your own (country-specific) guidelines by letting us know: [https://github.com/msberends/AMR/issues/new](https://github.com/msberends/AMR/issues/new).', 'Using Custom Guidelines Custom guidelines can be set with the `custom_mdro_guideline()` function.', 'This is of great importance if you have custom rules to determine MDROs in your hospital, e.g., rules that are dependent on ward, state of contact isolation or other variables in your data.If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules.', ""Rules must be set using what considers to be the 'formula notation'."", 'The rule is written before the tilde (`~`) and the consequence of the rule is written after the tilde: ```custom <- custom_mdro_guideline(CIP == ""R"" & age > 60 ~ ""Elderly Type A"",                           ERY == ""R"" & age > 60 ~ ""Elderly Type B"")``` If a row/an isolate matches the first rule, the value after the first `~` (in this case \'Elderly Type A\') will be set as MDRO value.', 'Otherwise, the second rule will be tried and so on.', 'The number of rules is unlimited.You can print the rules set in the console for an overview.', 'Colours will help reading it if your console supports colours.', '```custom> A set of custom MDRO rules:>   1.', 'CIP is ""R"" and age is higher than 60 -> Elderly Type A>   2.', 'ERY is ""R"" and age is higher than 60 -> Elderly Type B>   3.', 'Otherwise -> Negative>> Unmatched rows will return NA.``` The outcome of the function can be used for the `guideline` argument in the `mdro()` function: ```x <- mdro(example_isolates,     guideline = custom)table(x)>       Negative Elderly Type A Elderly Type B>           1070            198            732``` Rules can also be combined with other custom rules by using `c()`: ```x <- mdro(example_isolates,     guideline = c(custom,                   custom_mdro_guideline(ERY == ""R"" & age > 50 ~ ""Elderly Type C"")))table(x)>       Negative Elderly Type A Elderly Type B Elderly Type C>            961            198            732            109``` The rules set (the `custom` object in this case) could be exported to a shared file location using `saveRDS()` if you collaborate with multiple users.', 'The custom rules set could then be imported using `readRDS()`.', 'Antibiotics To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g.', '`TIC = NULL` to skip ticarcillin).', 'Manually defined but non-existing columns will be skipped with a warning.The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`.', 'These are shown below in the format \'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))\', sorted alphabetically:Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no)) Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.', 'I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.', 'R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.', 'Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight.', 'Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.', 'Examples```rout <- mdro(example_isolates, guideline = ""EUCAST"")str(out)table(out)out <- mdro(example_isolates,  guideline = custom_mdro_guideline(    AMX == ""R"" ~ ""Custom MDRO 1"",    VAN == ""R"" ~ ""Custom MDRO 2""  ))table(out)if (require(""dplyr"")) {  example_isolates %>%    mdro() %>%    table()   no need to define `x` when used inside dplyr verbs:  example_isolates %>%    mutate(MDRO = mdro()) %>%    pull(MDRO) %>%    table()}```']",1," Determine Multidrug-Resistant Organisms (MDRO) SourceSee the supported guidelines above for the list of publications used for this function.```rmdro(  x = NULL,  guideline = ""CMI2012"",  col_mo = NULL,  info = interactive(),  pct_required_classes = 0.5,  combine_SI = TRUE,  verbose = FALSE,  only_sir_columns = FALSE,  ...)custom_mdro_guideline(..., as_factor = TRUE)brmo(x = NULL, only_sir_columns = FALSE, ...)mrgn(x = NULL, only_sir_columns = FALSE, ...)mdr_tb(x = NULL, only_sir_columns = FALSE, ...)mdr_cmi2012(x = NULL, only_sir_columns = FALSE, ...)eucast_exceptional_phenotypes(x = NULL, only_sir_columns = FALSE, ...)``` Arguments- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`. Can be left blank for automatic determination.- `guideline`: a specific guideline to follow, see sections Supported international / national guidelines and Using Custom Guidelines below. When left empty, the publication by Magiorakos et al. (see below) will be followed.- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions- `pct_required_classes`: minimal required percentage of antimicrobial classes that must be available per isolate, rounded down. For example, with the default guideline, 17 antimicrobial classes must be available for S. aureus. Setting this `pct_required_classes` argument to `0.5` (default) means that for every S. aureus isolate at least 8 different classes must be available. Any lower number of available classes will return `NA` for that isolate.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so resistance is only considered when isolates are R, not I. As this is the default behaviour of the `mdro()` function, it follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section 'Interpretation of S, I and R' below. When using `combine_SI = FALSE`, resistance is considered when isolates are R or I.- `verbose`: a logical to turn Verbose mode on and off (default is off). In Verbose mode, the function does not return the MDRO results, but instead returns a data set in logbook form with extensive info about which isolates would be MDRO-positive, or why they are not.- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `...`: in case of `custom_mdro_guideline()`: a set of rules, see section Using Custom Guidelines below. Otherwise: column name of an antibiotic, see section Antibiotics below.- `as_factor`: a logical to indicate whether the returned value should be an ordered factor (`TRUE`, default), or otherwise a character vector Returns  CMI 2012 paper - function `mdr_cmi2012()` or `mdro()`:      Ordered factor with levels `Negative` \< `Multi-drug-resistant (MDR)` \< `Extensively drug-resistant (XDR)` \< `Pandrug-resistant (PDR)`  TB guideline - function `mdr_tb()` or `mdro(..., guideline = ""TB"")`:      Ordered factor with levels `Negative` \< `Mono-resistant` \< `Poly-resistant` \< `Multi-drug-resistant` \< `Extensively drug-resistant`  German guideline - function `mrgn()` or `mdro(..., guideline = ""MRGN"")`:      Ordered factor with levels `Negative` \< `3MRGN` \< `4MRGN`  Everything else, except for custom guidelines:      Ordered factor with levels `Negative` \< `Positive, unconfirmed` \< `Positive`. The value `""Positive, unconfirmed""` means that, according to the guideline, it is not entirely sure if the isolate is multi-drug resistant and this should be confirmed with additional (e.g. molecular) tests DescriptionDetermine which isolates are multidrug-resistant organisms (MDRO) according to international, national and custom guidelines. DetailsThese functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.For the `pct_required_classes` argument, values above 1 will be divided by 100. This is to support both fractions (`0.75` or `3/4`) and percentages (`75`).Note: Every test that involves the Enterobacteriaceae family, will internally be performed using its newly named order Enterobacterales, since the Enterobacteriaceae family has been taxonomically reclassified by Adeolu et al. in 2016. Before that, Enterobacteriaceae was the only family under the Enterobacteriales (with an i) order. All species under the old Enterobacteriaceae family are still under the new Enterobacterales (without an i) order, but divided into multiple families. The way tests are performed now by this `mdro()` function makes sure that results from before 2016 and after 2016 are identical. Supported International / National Guidelines Currently supported guidelines are (case-insensitive):  `guideline = ""CMI2012""` (default)      Magiorakos AP, Srinivasan A et al. ""Multidrug-resistant, extensively drug-resistant and pandrug-resistant bacteria: an international expert proposal for interim standard definitions for acquired resistance."" Clinical Microbiology and Infection (2012) (tools:::Rd_expr_doi(""10.1111/j.1469-0691.2011.03570.x"") )  `guideline = ""EUCAST3.3""` (or simply `guideline = ""EUCAST""`)      The European international guideline - EUCAST Expert Rules Version 3.3 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf))  `guideline = ""EUCAST3.2""`      The European international guideline - EUCAST Expert Rules Version 3.2 ""Intrinsic Resistance and Unusual Phenotypes"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf))  `guideline = ""EUCAST3.1""`      The European international guideline - EUCAST Expert Rules Version 3.1 ""Intrinsic Resistance and Exceptional Phenotypes Tables"" ([link](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf))  `guideline = ""TB""`      The international guideline for multi-drug resistant tuberculosis - World Health Organization ""Companion handbook to the WHO guidelines for the programmatic management of drug-resistant tuberculosis"" ([link](https://www.who.int/publications/i/item/9789241548809))  `guideline = ""MRGN""`      The German national guideline - Mueller et al. (2015) Antimicrobial Resistance and Infection Control 4:7; tools:::Rd_expr_doi(""10.1186/s13756-015-0047-6"")  `guideline = ""BRMO""`      The Dutch national guideline - Rijksinstituut voor Volksgezondheid en Milieu ""WIP-richtlijn BRMO (Bijzonder Resistente Micro-Organismen) (ZKH)"" ([link](https://www.rivm.nl/wip-richtlijn-brmo-bijzonder-resistente-micro-organismen-zkh))Please suggest your own (country-specific) guidelines by letting us know: [https://github.com/msberends/AMR/issues/new](https://github.com/msberends/AMR/issues/new). Using Custom Guidelines Custom guidelines can be set with the `custom_mdro_guideline()` function. This is of great importance if you have custom rules to determine MDROs in your hospital, e.g., rules that are dependent on ward, state of contact isolation or other variables in your data.If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules. Rules must be set using what considers to be the 'formula notation'. The rule is written before the tilde (`~`) and the consequence of the rule is written after the tilde: ```custom <- custom_mdro_guideline(CIP == ""R"" & age > 60 ~ ""Elderly Type A"",                           ERY == ""R"" & age > 60 ~ ""Elderly Type B"")``` If a row/an isolate matches the first rule, the value after the first `~` (in this case 'Elderly Type A') will be set as MDRO value. Otherwise, the second rule will be tried and so on. The number of rules is unlimited.You can print the rules set in the console for an overview. Colours will help reading it if your console supports colours. ```custom> A set of custom MDRO rules:>   1. CIP is ""R"" and age is higher than 60 -> Elderly Type A>   2. ERY is ""R"" and age is higher than 60 -> Elderly Type B>   3. Otherwise -> Negative>> Unmatched rows will return NA.``` The outcome of the function can be used for the `guideline` argument in the `mdro()` function: ```x <- mdro(example_isolates,     guideline = custom)table(x)>       Negative Elderly Type A Elderly Type B>           1070            198            732``` Rules can also be combined with other custom rules by using `c()`: ```x <- mdro(example_isolates,     guideline = c(custom,                   custom_mdro_guideline(ERY == ""R"" & age > 50 ~ ""Elderly Type C"")))table(x)>       Negative Elderly Type A Elderly Type B Elderly Type C>            961            198            732            109``` The rules set (the `custom` object in this case) could be exported to a shared file location using `saveRDS()` if you collaborate with multiple users. The custom rules set could then be imported using `readRDS()`. Antibiotics To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g. `TIC = NULL` to skip ticarcillin). Manually defined but non-existing columns will be skipped with a warning.The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`. These are shown below in the format 'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))', sorted alphabetically:Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no)) Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.  I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.  R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.        Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates. Examples```rout <- mdro(example_isolates, guideline = ""EUCAST"")str(out)table(out)out <- mdro(example_isolates,  guideline = custom_mdro_guideline(    AMX == ""R"" ~ ""Custom MDRO 1"",    VAN == ""R"" ~ ""Custom MDRO 2""  ))table(out)if (require(""dplyr"")) {  example_isolates %>%    mdro() %>%    table()   no need to define `x` when used inside dplyr verbs:  example_isolates %>%    mutate(MDRO = mdro()) %>%    pull(MDRO) %>%    table()}```",0
AMR,kurtosis.md,"# Kurtosis of the Sample

```r
kurtosis(x, na.rm = FALSE, excess = FALSE)

## Default S3 method:
kurtosis(x, na.rm = FALSE, excess = FALSE)

## S3 method for class 'matrix'
kurtosis(x, na.rm = FALSE, excess = FALSE)

## S3 method for class 'data.frame'
kurtosis(x, na.rm = FALSE, excess = FALSE)
```

## Arguments

- `x`: a vector of values, a matrix or a data.frame
- `na.rm`: a logical to indicate whether `NA` values should be stripped before the computation proceeds
- `excess`: a logical to indicate whether the **excess kurtosis** should be returned, defined as the kurtosis minus 3.

## Description

Kurtosis is a measure of the ""tailedness"" of the probability distribution of a real-valued random variable. A normal distribution has a kurtosis of 3 and a excess kurtosis of 0.

## Examples

```r
kurtosis(rnorm(10000))
kurtosis(rnorm(10000), excess = TRUE)
```

## See Also

`skewness()`



","[""Kurtosis of the Sample```rkurtosis(x, na.rm = FALSE, excess = FALSE) Default S3 method:kurtosis(x, na.rm = FALSE, excess = FALSE) S3 method for class 'matrix'kurtosis(x, na.rm = FALSE, excess = FALSE) S3 method for class 'data.frame'kurtosis(x, na.rm = FALSE, excess = FALSE)``` Arguments- `x`: a vector of values, a matrix or a data.frame- `na.rm`: a logical to indicate whether `NA` values should be stripped before the computation proceeds- `excess`: a logical to indicate whether the excess kurtosis should be returned, defined as the kurtosis minus 3."", 'DescriptionKurtosis is a measure of the ""tailedness"" of the probability distribution of a real-valued random variable.', 'A normal distribution has a kurtosis of 3 and a excess kurtosis of 0.', 'Examples```rkurtosis(rnorm(10000))kurtosis(rnorm(10000), excess = TRUE)``` See Also`skewness()`']",1," Kurtosis of the Sample```rkurtosis(x, na.rm = FALSE, excess = FALSE) Default S3 method:kurtosis(x, na.rm = FALSE, excess = FALSE) S3 method for class 'matrix'kurtosis(x, na.rm = FALSE, excess = FALSE) S3 method for class 'data.frame'kurtosis(x, na.rm = FALSE, excess = FALSE)``` Arguments- `x`: a vector of values, a matrix or a data.frame- `na.rm`: a logical to indicate whether `NA` values should be stripped before the computation proceeds- `excess`: a logical to indicate whether the excess kurtosis should be returned, defined as the kurtosis minus 3. DescriptionKurtosis is a measure of the ""tailedness"" of the probability distribution of a real-valued random variable. A normal distribution has a kurtosis of 3 and a excess kurtosis of 0. Examples```rkurtosis(rnorm(10000))kurtosis(rnorm(10000), excess = TRUE)``` See Also`skewness()`",0
AMR,AMR.md," package

# The `AMR` Package

## Source

To cite AMR in publications use:

Berends MS, Luz CF, Friedrich AW, Sinha BNM, Albers CJ, Glasner C (2022). ""AMR: An R Package for Working with Antimicrobial Resistance Data."" **Journal of Statistical Software**, **104**(3), 1-31. tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")

A BibTeX entry for LaTeX users is:

```
@Article{,
  title = {{AMR}: An {R} Package for Working with Antimicrobial Resistance Data},
  author = {Matthijs S. Berends and Christian F. Luz and Alexander W. Friedrich and Bhanu N. M. Sinha and Casper J. Albers and Corinna Glasner},
  journal = {Journal of Statistical Software},
  year = {2022},
  volume = {104},
  number = {3},
  pages = {1--31},
  doi = {10.18637/jss.v104.i03},
}
```

## Description

Welcome to the `AMR` package.

The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/#copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods. Our aim is to provide a standard for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting. [Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!

This work was published in the Journal of Statistical Software (Volume 104(3); tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") ) and formed the basis of two PhD theses (tools:::Rd_expr_doi(""10.33612/diss.177417131"") and tools:::Rd_expr_doi(""10.33612/diss.192486375"") ).

After installing this package, R knows [list(""~52 000 microorganisms"")](https://msberends.github.io/AMR/reference/microorganisms.html) (updated December 2022) and all [list(""~600 antibiotic, antimycotic and antiviral drugs"")](https://msberends.github.io/AMR/reference/antibiotics.html) by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values. The integral clinical breakpoint guidelines from CLSI and EUCAST are included, even with epidemiological cut-off (ECOFF) values. It supports and can read any data format, including WHONET data. This package works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013). It was designed to work in any setting, including those with verylimited resources . It was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the public [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl).

The `AMR` package is available in English, Chinese, Czech, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian. Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages.

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## See Also

Useful links:

 * [https://msberends.github.io/AMR/](https://msberends.github.io/AMR/)
 * [https://github.com/msberends/AMR](https://github.com/msberends/AMR)
 * Report bugs at [https://github.com/msberends/AMR/issues](https://github.com/msberends/AMR/issues)

## Author(s)

Maintainer : Matthijs S. Berends m.s.berends@umcg.nl ([ORCID](https://orcid.org/0000-0001-7620-1800))

Authors:

 * Christian F. Luz ([ORCID](https://orcid.org/0000-0001-5809-5995)) [contributor]
 * Dennis Souverein ([ORCID](https://orcid.org/0000-0003-0455-0336)) [contributor]
 * Erwin E. A. Hassing [contributor]

Other contributors:

 * Casper J. Albers ([ORCID](https://orcid.org/0000-0002-9213-6743)) [thesis advisor]
 * Peter Dutey-Magni ([ORCID](https://orcid.org/0000-0002-8942-9836)) [contributor]
 * Judith M. Fonville [contributor]
 * Alex W. Friedrich ([ORCID](https://orcid.org/0000-0003-4881-038X)) [thesis advisor]
 * Corinna Glasner ([ORCID](https://orcid.org/0000-0003-1241-1328)) [thesis advisor]
 * Eric H. L. C. M. Hazenberg [contributor]
 * Gwen Knight ([ORCID](https://orcid.org/0000-0002-7263-9896)) [contributor]
 * Annick Lenglet ([ORCID](https://orcid.org/0000-0003-2013-8405)) [contributor]
 * Bart C. Meijer [contributor]
 * Dmytro Mykhailenko [contributor]
 * Anton Mymrikov [contributor]
 * Andrew P. Norgan ([ORCID](https://orcid.org/0000-0002-2955-2066)) [contributor]
 * Sofia Ny ([ORCID](https://orcid.org/0000-0002-2017-1363)) [contributor]
 * Jonas Salm [contributor]
 * Rogier P. Schade [contributor]
 * Bhanu N. M. Sinha ([ORCID](https://orcid.org/0000-0003-1634-0010)) [thesis advisor]
 * Anthony Underwood ([ORCID](https://orcid.org/0000-0002-8547-4277)) [contributor]
 * Anita Williams ([ORCID](https://orcid.org/0000-0002-5295-8451)) [contributor]



","['package The `AMR` Package SourceTo cite AMR in publications use:Berends MS, Luz CF, Friedrich AW, Sinha BNM, Albers CJ, Glasner C (2022).', '""AMR: An R Package for Working with Antimicrobial Resistance Data.""', 'Journal of Statistical Software, 104(3), 1-31. tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")A BibTeX entry for LaTeX users is:```@Article{,  title = {{AMR}: An {R} Package for Working with Antimicrobial Resistance Data},  author = {Matthijs S. Berends and Christian F. Luz and Alexander W. Friedrich and Bhanu N. M. Sinha and Casper J. Albers and Corinna Glasner},  journal = {Journal of Statistical Software},  year = {2022},  volume = {104},  number = {3},  pages = {1--31},  doi = {10.18637/jss.v104.i03},}``` DescriptionWelcome to the `AMR` package.The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods.', 'Our aim is to provide a standard for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting.', '[Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!This work was published in the Journal of Statistical Software (Volume 104(3); tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") ) and formed the basis of two PhD theses (tools:::Rd_expr_doi(""10.33612/diss.177417131"") and tools:::Rd_expr_doi(""10.33612/diss.192486375"") ).After installing this package, R knows [list(""~52 000 microorganisms"")](https://msberends.github.io/AMR/reference/microorganisms.html) (updated December 2022) and all [list(""~600 antibiotic, antimycotic and antiviral drugs"")](https://msberends.github.io/AMR/reference/antibiotics.html) by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values.', 'The integral clinical breakpoint guidelines from CLSI and EUCAST are included, even with epidemiological cut-off (ECOFF) values.', 'It supports and can read any data format, including WHONET data.', 'This package works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013).', 'It was designed to work in any setting, including those with verylimited resources .', 'It was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the public [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl).The `AMR` package is available in English, Chinese, Czech, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian.', 'Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'See AlsoUseful links:  [https://msberends.github.io/AMR/](https://msberends.github.io/AMR/)  [https://github.com/msberends/AMR](https://github.com/msberends/AMR)  Report bugs at [https://github.com/msberends/AMR/issues](https://github.com/msberends/AMR/issues) Author(s)Maintainer : Matthijs S. Berends m.s.berends@umcg.nl ([ORCID](https://orcid.org/0000-0001-7620-1800))Authors:  Christian F. Luz ([ORCID](https://orcid.org/0000-0001-5809-5995)) [contributor]  Dennis Souverein ([ORCID](https://orcid.org/0000-0003-0455-0336)) [contributor]  Erwin E. A. Hassing [contributor]Other contributors:  Casper J. Albers ([ORCID](https://orcid.org/0000-0002-9213-6743)) [thesis advisor]  Peter Dutey-Magni ([ORCID](https://orcid.org/0000-0002-8942-9836)) [contributor]  Judith M. Fonville [contributor]  Alex W. Friedrich ([ORCID](https://orcid.org/0000-0003-4881-038X)) [thesis advisor]  Corinna Glasner ([ORCID](https://orcid.org/0000-0003-1241-1328)) [thesis advisor]  Eric H. L. C. M. Hazenberg [contributor]  Gwen Knight ([ORCID](https://orcid.org/0000-0002-7263-9896)) [contributor]  Annick Lenglet ([ORCID](https://orcid.org/0000-0003-2013-8405)) [contributor]  Bart C. Meijer [contributor]  Dmytro Mykhailenko [contributor]  Anton Mymrikov [contributor]  Andrew P. Norgan ([ORCID](https://orcid.org/0000-0002-2955-2066)) [contributor]  Sofia Ny ([ORCID](https://orcid.org/0000-0002-2017-1363)) [contributor]  Jonas Salm [contributor]  Rogier P. Schade [contributor]  Bhanu N. M. Sinha ([ORCID](https://orcid.org/0000-0003-1634-0010)) [thesis advisor]  Anthony Underwood ([ORCID](https://orcid.org/0000-0002-8547-4277)) [contributor]  Anita Williams ([ORCID](https://orcid.org/0000-0002-5295-8451)) [contributor]']",1," package The `AMR` Package SourceTo cite AMR in publications use:Berends MS, Luz CF, Friedrich AW, Sinha BNM, Albers CJ, Glasner C (2022). ""AMR: An R Package for Working with Antimicrobial Resistance Data."" Journal of Statistical Software, 104(3), 1-31. tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")A BibTeX entry for LaTeX users is:```@Article{,  title = {{AMR}: An {R} Package for Working with Antimicrobial Resistance Data},  author = {Matthijs S. Berends and Christian F. Luz and Alexander W. Friedrich and Bhanu N. M. Sinha and Casper J. Albers and Corinna Glasner},  journal = {Journal of Statistical Software},  year = {2022},  volume = {104},  number = {3},  pages = {1--31},  doi = {10.18637/jss.v104.i03},}``` DescriptionWelcome to the `AMR` package.The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods. Our aim is to provide a standard for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting. [Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!This work was published in the Journal of Statistical Software (Volume 104(3); tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") ) and formed the basis of two PhD theses (tools:::Rd_expr_doi(""10.33612/diss.177417131"") and tools:::Rd_expr_doi(""10.33612/diss.192486375"") ).After installing this package, R knows [list(""~52 000 microorganisms"")](https://msberends.github.io/AMR/reference/microorganisms.html) (updated December 2022) and all [list(""~600 antibiotic, antimycotic and antiviral drugs"")](https://msberends.github.io/AMR/reference/antibiotics.html) by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values. The integral clinical breakpoint guidelines from CLSI and EUCAST are included, even with epidemiological cut-off (ECOFF) values. It supports and can read any data format, including WHONET data. This package works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013). It was designed to work in any setting, including those with verylimited resources . It was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the public [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl).The `AMR` package is available in English, Chinese, Czech, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian. Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages. Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). See AlsoUseful links:  [https://msberends.github.io/AMR/](https://msberends.github.io/AMR/)  [https://github.com/msberends/AMR](https://github.com/msberends/AMR)  Report bugs at [https://github.com/msberends/AMR/issues](https://github.com/msberends/AMR/issues) Author(s)Maintainer : Matthijs S. Berends m.s.berends@umcg.nl ([ORCID](https://orcid.org/0000-0001-7620-1800))Authors:  Christian F. Luz ([ORCID](https://orcid.org/0000-0001-5809-5995)) [contributor]  Dennis Souverein ([ORCID](https://orcid.org/0000-0003-0455-0336)) [contributor]  Erwin E. A. Hassing [contributor]Other contributors:  Casper J. Albers ([ORCID](https://orcid.org/0000-0002-9213-6743)) [thesis advisor]  Peter Dutey-Magni ([ORCID](https://orcid.org/0000-0002-8942-9836)) [contributor]  Judith M. Fonville [contributor]  Alex W. Friedrich ([ORCID](https://orcid.org/0000-0003-4881-038X)) [thesis advisor]  Corinna Glasner ([ORCID](https://orcid.org/0000-0003-1241-1328)) [thesis advisor]  Eric H. L. C. M. Hazenberg [contributor]  Gwen Knight ([ORCID](https://orcid.org/0000-0002-7263-9896)) [contributor]  Annick Lenglet ([ORCID](https://orcid.org/0000-0003-2013-8405)) [contributor]  Bart C. Meijer [contributor]  Dmytro Mykhailenko [contributor]  Anton Mymrikov [contributor]  Andrew P. Norgan ([ORCID](https://orcid.org/0000-0002-2955-2066)) [contributor]  Sofia Ny ([ORCID](https://orcid.org/0000-0002-2017-1363)) [contributor]  Jonas Salm [contributor]  Rogier P. Schade [contributor]  Bhanu N. M. Sinha ([ORCID](https://orcid.org/0000-0003-1634-0010)) [thesis advisor]  Anthony Underwood ([ORCID](https://orcid.org/0000-0002-8547-4277)) [contributor]  Anita Williams ([ORCID](https://orcid.org/0000-0002-5295-8451)) [contributor]",0
AMR,mean_amr_distance.md,"# Calculate the Mean AMR Distance

```r
mean_amr_distance(x, ...)

## S3 method for class 'sir'
mean_amr_distance(x, ..., combine_SI = TRUE)

## S3 method for class 'data.frame'
mean_amr_distance(x, ..., combine_SI = TRUE)

amr_distance_from_row(amr_distance, row)
```

## Arguments

- `x`: a vector of class sir , mic or disk , or a data.frame containing columns of any of these classes
- `...`: variables to select (supports tidyselect language such as `column1:column4` and `where(is.mic)`, and can thus also be antibiotic selectors
- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the input only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`
- `amr_distance`: the outcome of `mean_amr_distance()`
- `row`: an index, such as a row number

## Description

Calculates a normalised mean for antimicrobial resistance between multiple observations, to help to identify similar isolates without comparing antibiograms by hand.

## Details

The mean AMR distance is effectively [the Z-score](https://en.wikipedia.org/wiki/Standard_score); a normalised numeric value to compare AMR test results which can help to identify similar isolates, without comparing antibiograms by hand.

MIC values (see `as.mic()`) are transformed with `log2()` first; their distance is thus calculated as `(log2(x) - mean(log2(x))) / sd(log2(x))`.

SIR values (see `as.sir()`) are transformed using `""S""` = 1, `""I""` = 2, and `""R""` = 3. If `combine_SI` is `TRUE` (default), the `""I""` will be considered to be 1.

For data sets, the mean AMR distance will be calculated per column, after which the mean per row will be returned, see **Examples**.

Use `amr_distance_from_row()` to subtract distances from the distance of one row, see **Examples**.

## Interpretation

 Isolates with distances less than 0.01 difference from each other should be considered similar. Differences lower than 0.025 should be considered suspicious.

## Examples

```r
sir <- random_sir(10)
sir
mean_amr_distance(sir)

mic <- random_mic(10)
mic
mean_amr_distance(mic)
# equal to the Z-score of their log2:
(log2(mic) - mean(log2(mic))) / sd(log2(mic))

disk <- random_disk(10)
disk
mean_amr_distance(disk)

y <- data.frame(
  id = LETTERS[1:10],
  amox = random_sir(10, ab = ""amox"", mo = ""Escherichia coli""),
  cipr = random_disk(10, ab = ""cipr"", mo = ""Escherichia coli""),
  gent = random_mic(10, ab = ""gent"", mo = ""Escherichia coli""),
  tobr = random_mic(10, ab = ""tobr"", mo = ""Escherichia coli"")
)
y
mean_amr_distance(y)
y$amr_distance <- mean_amr_distance(y, where(is.mic))
y[order(y$amr_distance), ]

if (require(""dplyr"")) {
  y %>%
    mutate(
      amr_distance = mean_amr_distance(y),
      check_id_C = amr_distance_from_row(amr_distance, id == ""C"")
    ) %>%
    arrange(check_id_C)
}
if (require(""dplyr"")) {
  # support for groups
  example_isolates %>%
    filter(mo_genus() == ""Enterococcus"" & mo_species() != """") %>%
    select(mo, TCY, carbapenems()) %>%
    group_by(mo) %>%
    mutate(dist = mean_amr_distance(.)) %>%
    arrange(mo, dist)
}
```



","[""Calculate the Mean AMR Distance```rmean_amr_distance(x, ...) S3 method for class 'sir'mean_amr_distance(x, ..., combine_SI = TRUE) S3 method for class 'data.frame'mean_amr_distance(x, ..., combine_SI = TRUE)amr_distance_from_row(amr_distance, row)``` Arguments- `x`: a vector of class sir , mic or disk , or a data.frame containing columns of any of these classes- `...`: variables to select (supports tidyselect language such as `column1:column4` and `where(is.mic)`, and can thus also be antibiotic selectors- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the input only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`- `amr_distance`: the outcome of `mean_amr_distance()`- `row`: an index, such as a row number DescriptionCalculates a normalised mean for antimicrobial resistance between multiple observations, to help to identify similar isolates without comparing antibiograms by hand."", 'DetailsThe mean AMR distance is effectively [the Z-score](https://en.wikipedia.org/wiki/Standard_score); a normalised numeric value to compare AMR test results which can help to identify similar isolates, without comparing antibiograms by hand.MIC values (see `as.mic()`) are transformed with `log2()` first; their distance is thus calculated as `(log2(x) - mean(log2(x))) / sd(log2(x))`.SIR values (see `as.sir()`) are transformed using `""S""` = 1, `""I""` = 2, and `""R""` = 3.', 'If `combine_SI` is `TRUE` (default), the `""I""` will be considered to be 1.For data sets, the mean AMR distance will be calculated per column, after which the mean per row will be returned, see Examples.Use `amr_distance_from_row()` to subtract distances from the distance of one row, see Examples.', 'Interpretation Isolates with distances less than 0.01 difference from each other should be considered similar.', 'Differences lower than 0.025 should be considered suspicious.', 'Examples```rsir <- random_sir(10)sirmean_amr_distance(sir)mic <- random_mic(10)micmean_amr_distance(mic) equal to the Z-score of their log2:(log2(mic) - mean(log2(mic))) / sd(log2(mic))disk <- random_disk(10)diskmean_amr_distance(disk)y <- data.frame(  id = LETTERS[1:10],  amox = random_sir(10, ab = ""amox"", mo = ""Escherichia coli""),  cipr = random_disk(10, ab = ""cipr"", mo = ""Escherichia coli""),  gent = random_mic(10, ab = ""gent"", mo = ""Escherichia coli""),  tobr = random_mic(10, ab = ""tobr"", mo = ""Escherichia coli""))ymean_amr_distance(y)y$amr_distance <- mean_amr_distance(y, where(is.mic))y[order(y$amr_distance), ]if (require(""dplyr"")) {  y %>%    mutate(      amr_distance = mean_amr_distance(y),      check_id_C = amr_distance_from_row(amr_distance, id == ""C"")    ) %>%    arrange(check_id_C)}if (require(""dplyr"")) {   support for groups  example_isolates %>%    filter(mo_genus() == ""Enterococcus"" & mo_species() != """") %>%    select(mo, TCY, carbapenems()) %>%    group_by(mo) %>%    mutate(dist = mean_amr_distance(.))']",1," Calculate the Mean AMR Distance```rmean_amr_distance(x, ...) S3 method for class 'sir'mean_amr_distance(x, ..., combine_SI = TRUE) S3 method for class 'data.frame'mean_amr_distance(x, ..., combine_SI = TRUE)amr_distance_from_row(amr_distance, row)``` Arguments- `x`: a vector of class sir , mic or disk , or a data.frame containing columns of any of these classes- `...`: variables to select (supports tidyselect language such as `column1:column4` and `where(is.mic)`, and can thus also be antibiotic selectors- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the input only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`- `amr_distance`: the outcome of `mean_amr_distance()`- `row`: an index, such as a row number DescriptionCalculates a normalised mean for antimicrobial resistance between multiple observations, to help to identify similar isolates without comparing antibiograms by hand. DetailsThe mean AMR distance is effectively [the Z-score](https://en.wikipedia.org/wiki/Standard_score); a normalised numeric value to compare AMR test results which can help to identify similar isolates, without comparing antibiograms by hand.MIC values (see `as.mic()`) are transformed with `log2()` first; their distance is thus calculated as `(log2(x) - mean(log2(x))) / sd(log2(x))`.SIR values (see `as.sir()`) are transformed using `""S""` = 1, `""I""` = 2, and `""R""` = 3. If `combine_SI` is `TRUE` (default), the `""I""` will be considered to be 1.For data sets, the mean AMR distance will be calculated per column, after which the mean per row will be returned, see Examples.Use `amr_distance_from_row()` to subtract distances from the distance of one row, see Examples. Interpretation Isolates with distances less than 0.01 difference from each other should be considered similar. Differences lower than 0.025 should be considered suspicious. Examples```rsir <- random_sir(10)sirmean_amr_distance(sir)mic <- random_mic(10)micmean_amr_distance(mic) equal to the Z-score of their log2:(log2(mic) - mean(log2(mic))) / sd(log2(mic))disk <- random_disk(10)diskmean_amr_distance(disk)y <- data.frame(  id = LETTERS[1:10],  amox = random_sir(10, ab = ""amox"", mo = ""Escherichia coli""),  cipr = random_disk(10, ab = ""cipr"", mo = ""Escherichia coli""),  gent = random_mic(10, ab = ""gent"", mo = ""Escherichia coli""),  tobr = random_mic(10, ab = ""tobr"", mo = ""Escherichia coli""))ymean_amr_distance(y)y$amr_distance <- mean_amr_distance(y, where(is.mic))y[order(y$amr_distance), ]if (require(""dplyr"")) {  y %>%    mutate(      amr_distance = mean_amr_distance(y),      check_id_C = amr_distance_from_row(amr_distance, id == ""C"")    ) %>%    arrange(check_id_C)}if (require(""dplyr"")) {   support for groups  example_isolates %>%    filter(mo_genus() == ""Enterococcus"" & mo_species() != """") %>%    select(mo, TCY, carbapenems()) %>%    group_by(mo) %>%    mutate(dist = mean_amr_distance(.)) %>%    arrange(mo, dist)}```",0
AMR,pca.md,"# Principal Component Analysis (for AMR)

```r
pca(
  x,
  ...,
  retx = TRUE,
  center = TRUE,
  scale. = TRUE,
  tol = NULL,
  rank. = NULL
)
```

## Arguments

- `x`: a data.frame containing numeric columns
- `...`: columns of `x` to be selected for PCA, can be unquoted since it supports quasiquotation.
- `retx`: a logical value indicating whether the rotated variables should be returned.
- `center`: a logical value indicating whether the variables should be shifted to be zero centered. Alternately, a vector of length equal the number of columns of `x` can be supplied. The value is passed to `scale`.
- `scale.`: a logical value indicating whether the variables should be scaled to have unit variance before the analysis takes place. The default is `FALSE` for consistency with S, but in general scaling is advisable. Alternatively, a vector of length equal the number of columns of `x` can be supplied. The value is passed to `scale`.
- `tol`: a value indicating the magnitude below which components should be omitted. (Components are omitted if their standard deviations are less than or equal to `tol` times the standard deviation of the first component.) With the default null setting, no components are omitted (unless `rank.` is specified less than `min(dim(x))`.). Other settings for tol could be `tol = 0` or `tol = sqrt(.Machine$double.eps)`, which would omit essentially constant components.
- `rank.`: optionally, a number specifying the maximal rank, i.e., maximal number of principal components to be used. Can be set as alternative or in addition to `tol`, useful notably when the desired rank is considerably smaller than the dimensions of the matrix.

## Returns

An object of classes pca and prcomp

## Description

Performs a principal component analysis (PCA) based on a data set with automatic determination for afterwards plotting the groups and labels, and automatic filtering on only suitable (i.e. non-empty and numeric) variables.

## Details

The `pca()` function takes a data.frame as input and performs the actual PCA with the function `prcomp()`.

The result of the `pca()` function is a prcomp object, with an additional attribute `non_numeric_cols` which is a vector with the column names of all columns that do not contain numeric values. These are probably the groups and labels, and will be used by `ggplot_pca()`.

## Examples

```r
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.


if (require(""dplyr"")) {
  # calculate the resistance per group first
  resistance_data <- example_isolates %>%
    group_by(
      order = mo_order(mo), # group on anything, like order
      genus = mo_genus(mo)
    ) %>% #   and genus as we do here;
    filter(n() >= 30) %>% # filter on only 30 results per group
    summarise_if(is.sir, resistance) # then get resistance of all drugs

  # now conduct PCA for certain antimicrobial drugs
  pca_result <- resistance_data %>%
    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)

  pca_result
  summary(pca_result)

  # old base R plotting method:
  biplot(pca_result)
  # new ggplot2 plotting method using this package:
  if (require(""ggplot2"")) {
    ggplot_pca(pca_result)

    ggplot_pca(pca_result) +
      scale_colour_viridis_d() +
      labs(title = ""Title here"")
  }
}
```



","['Principal Component Analysis (for AMR)```rpca(  x,  ...,  retx = TRUE,  center = TRUE,  scale.', '= TRUE,  tol = NULL,  rank.', '= NULL)``` Arguments- `x`: a data.frame containing numeric columns- `...`: columns of `x` to be selected for PCA, can be unquoted since it supports quasiquotation.- `retx`: a logical value indicating whether the rotated variables should be returned.- `center`: a logical value indicating whether the variables should be shifted to be zero centered.', 'Alternately, a vector of length equal the number of columns of `x` can be supplied.', 'The value is passed to `scale`.- `scale.`: a logical value indicating whether the variables should be scaled to have unit variance before the analysis takes place.', 'The default is `FALSE` for consistency with S, but in general scaling is advisable.', 'Alternatively, a vector of length equal the number of columns of `x` can be supplied.', 'The value is passed to `scale`.- `tol`: a value indicating the magnitude below which components should be omitted.', '(Components are omitted if their standard deviations are less than or equal to `tol` times the standard deviation of the first component.)', 'With the default null setting, no components are omitted (unless `rank.` is specified less than `min(dim(x))`.).', 'Other settings for tol could be `tol = 0` or `tol = sqrt(.Machine$double.eps)`, which would omit essentially constant components.- `rank.`: optionally, a number specifying the maximal rank, i.e., maximal number of principal components to be used.', 'Can be set as alternative or in addition to `tol`, useful notably when the desired rank is considerably smaller than the dimensions of the matrix.', 'ReturnsAn object of classes pca and prcomp DescriptionPerforms a principal component analysis (PCA) based on a data set with automatic determination for afterwards plotting the groups and labels, and automatic filtering on only suitable (i.e.', 'DetailsThe `pca()` function takes a data.frame as input and performs the actual PCA with the function `prcomp()`.The result of the `pca()` function is a prcomp object, with an additional attribute `non_numeric_cols` which is a vector with the column names of all columns that do not contain numeric values.', 'These are probably the groups and labels, and will be used by `ggplot_pca()`.', 'Examples```r `example_isolates` is a data set available in the AMR package.', 'See ?example_isolates.if (require(""dplyr"")) {   calculate the resistance per group first  resistance_data <- example_isolates %>%    group_by(      order = mo_order(mo),  group on anything, like order      genus = mo_genus(mo)    ) %>%    and genus as we do here;    filter(n() >= 30) %>%  filter on only 30 results per group    summarise_if(is.sir, resistance)  then get resistance of all drugs   now conduct PCA for certain antimicrobial drugs  pca_result <- resistance_data %>%    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)  pca_result  summary(pca_result)   old base R plotting method:  biplot(pca_result)   new ggplot2 plotting method using this package:  if (require(""ggplot2"")) {    ggplot_pca(pca_result)    ggplot_pca(pca_result) +      scale_colour_viridis_d() +      labs(title = ""Title here"")  }}```']",1," Principal Component Analysis (for AMR)```rpca(  x,  ...,  retx = TRUE,  center = TRUE,  scale. = TRUE,  tol = NULL,  rank. = NULL)``` Arguments- `x`: a data.frame containing numeric columns- `...`: columns of `x` to be selected for PCA, can be unquoted since it supports quasiquotation.- `retx`: a logical value indicating whether the rotated variables should be returned.- `center`: a logical value indicating whether the variables should be shifted to be zero centered. Alternately, a vector of length equal the number of columns of `x` can be supplied. The value is passed to `scale`.- `scale.`: a logical value indicating whether the variables should be scaled to have unit variance before the analysis takes place. The default is `FALSE` for consistency with S, but in general scaling is advisable. Alternatively, a vector of length equal the number of columns of `x` can be supplied. The value is passed to `scale`.- `tol`: a value indicating the magnitude below which components should be omitted. (Components are omitted if their standard deviations are less than or equal to `tol` times the standard deviation of the first component.) With the default null setting, no components are omitted (unless `rank.` is specified less than `min(dim(x))`.). Other settings for tol could be `tol = 0` or `tol = sqrt(.Machine$double.eps)`, which would omit essentially constant components.- `rank.`: optionally, a number specifying the maximal rank, i.e., maximal number of principal components to be used. Can be set as alternative or in addition to `tol`, useful notably when the desired rank is considerably smaller than the dimensions of the matrix. ReturnsAn object of classes pca and prcomp DescriptionPerforms a principal component analysis (PCA) based on a data set with automatic determination for afterwards plotting the groups and labels, and automatic filtering on only suitable (i.e. non-empty and numeric) variables. DetailsThe `pca()` function takes a data.frame as input and performs the actual PCA with the function `prcomp()`.The result of the `pca()` function is a prcomp object, with an additional attribute `non_numeric_cols` which is a vector with the column names of all columns that do not contain numeric values. These are probably the groups and labels, and will be used by `ggplot_pca()`. Examples```r `example_isolates` is a data set available in the AMR package. See ?example_isolates.if (require(""dplyr"")) {   calculate the resistance per group first  resistance_data <- example_isolates %>%    group_by(      order = mo_order(mo),  group on anything, like order      genus = mo_genus(mo)    ) %>%    and genus as we do here;    filter(n() >= 30) %>%  filter on only 30 results per group    summarise_if(is.sir, resistance)  then get resistance of all drugs   now conduct PCA for certain antimicrobial drugs  pca_result <- resistance_data %>%    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)  pca_result  summary(pca_result)   old base R plotting method:  biplot(pca_result)   new ggplot2 plotting method using this package:  if (require(""ggplot2"")) {    ggplot_pca(pca_result)    ggplot_pca(pca_result) +      scale_colour_viridis_d() +      labs(title = ""Title here"")  }}```",0
AMR,WHONET.md," data

# Data Set with 500 Isolates - WHONET Example

## Format

A tibble with 500 observations and 53 variables:

 * `Identification number`
   
   ID of the sample
 * `Specimen number`
   
   ID of the specimen
 * `Organism`
   
   Name of the microorganism. Before analysis, you should transform this to a valid microbial class, using `as.mo()`.
 * `Country`
   
   Country of origin
 * `Laboratory`
   
   Name of laboratory
 * `Last name`
   
   Fictitious last name of patient
 * `First name`
   
   Fictitious initial of patient
 * `Sex`
   
   Fictitious gender of patient
 * `Age`
   
   Fictitious age of patient
 * `Age category`
   
   Age group, can also be looked up using `age_groups()`
 * `Date of admission`
   
    Date of hospital admission
 * `Specimen date`
   
    Date when specimen was received at laboratory
 * `Specimen type`
   
   Specimen type or group
 * `Specimen type (Numeric)`
   
   Translation of `""Specimen type""`
 * `Reason`
   
   Reason of request with Differential Diagnosis
 * `Isolate number`
   
   ID of isolate
 * `Organism type`
   
   Type of microorganism, can also be looked up using `mo_type()`
 * `Serotype`
   
   Serotype of microorganism
 * `Beta-lactamase`
   
   Microorganism produces beta-lactamase?
 * `ESBL`
   
   Microorganism produces extended spectrum beta-lactamase?
 * `Carbapenemase`
   
   Microorganism produces carbapenemase?
 * `MRSA screening test`
   
   Microorganism is possible MRSA?
 * `Inducible clindamycin resistance`
   
   Clindamycin can be induced?
 * `Comment`
   
   Other comments
 * `Date of data entry`
   
    Date this data was entered in WHONET
 * `AMP_ND10:CIP_EE`
   
   28 different antibiotics. You can lookup the abbreviations in the antibiotics data set, or use e.g. `ab_name(""AMP"")` to get the official name immediately. Before analysis, you should transform this to a valid antibiotic class, using `as.sir()`.

```r
WHONET
```

## Description

This example data set has the exact same structure as an export file from WHONET. Such files can be used with this package, as this example data set shows. The antibiotic results are from our example_isolates data set. All patient names were created using online surname generators and are only in place for practice purposes.

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
WHONET
```



","['data Data Set with 500 Isolates - WHONET Example FormatA tibble with 500 observations and 53 variables:  `Identification number`      ID of the sample  `Specimen number`      ID of the specimen  `Organism`      Name of the microorganism.', 'Before analysis, you should transform this to a valid microbial class, using `as.mo()`.', '`Country`      Country of origin  `Laboratory`      Name of laboratory  `Last name`      Fictitious last name of patient  `First name`      Fictitious initial of patient  `Sex`      Fictitious gender of patient  `Age`      Fictitious age of patient  `Age category`      Age group, can also be looked up using `age_groups()`  `Date of admission`       Date of hospital admission  `Specimen date`       Date when specimen was received at laboratory  `Specimen type`      Specimen type or group  `Specimen type (Numeric)`      Translation of `""Specimen type""`  `Reason`      Reason of request with Differential Diagnosis  `Isolate number`      ID of isolate  `Organism type`      Type of microorganism, can also be looked up using `mo_type()`  `Serotype`      Serotype of microorganism  `Beta-lactamase`      Microorganism produces beta-lactamase?', '`ESBL`      Microorganism produces extended spectrum beta-lactamase?', '`MRSA screening test`      Microorganism is possible MRSA?', '`Inducible clindamycin resistance`      Clindamycin can be induced?', '`Comment`      Other comments  `Date of data entry`       Date this data was entered in WHONET  `AMP_ND10:CIP_EE`      28 different antibiotics.', 'You can lookup the abbreviations in the antibiotics data set, or use e.g.', '`ab_name(""AMP"")` to get the official name immediately.', 'Before analysis, you should transform this to a valid antibiotic class, using `as.sir()`.```rWHONET``` DescriptionThis example data set has the exact same structure as an export file from WHONET.', 'Such files can be used with this package, as this example data set shows.', 'The antibiotic results are from our example_isolates data set.', 'All patient names were created using online surname generators and are only in place for practice purposes.', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).']",1," data Data Set with 500 Isolates - WHONET Example FormatA tibble with 500 observations and 53 variables:  `Identification number`      ID of the sample  `Specimen number`      ID of the specimen  `Organism`      Name of the microorganism. Before analysis, you should transform this to a valid microbial class, using `as.mo()`.  `Country`      Country of origin  `Laboratory`      Name of laboratory  `Last name`      Fictitious last name of patient  `First name`      Fictitious initial of patient  `Sex`      Fictitious gender of patient  `Age`      Fictitious age of patient  `Age category`      Age group, can also be looked up using `age_groups()`  `Date of admission`       Date of hospital admission  `Specimen date`       Date when specimen was received at laboratory  `Specimen type`      Specimen type or group  `Specimen type (Numeric)`      Translation of `""Specimen type""`  `Reason`      Reason of request with Differential Diagnosis  `Isolate number`      ID of isolate  `Organism type`      Type of microorganism, can also be looked up using `mo_type()`  `Serotype`      Serotype of microorganism  `Beta-lactamase`      Microorganism produces beta-lactamase?  `ESBL`      Microorganism produces extended spectrum beta-lactamase?  `Carbapenemase`      Microorganism produces carbapenemase?  `MRSA screening test`      Microorganism is possible MRSA?  `Inducible clindamycin resistance`      Clindamycin can be induced?  `Comment`      Other comments  `Date of data entry`       Date this data was entered in WHONET  `AMP_ND10:CIP_EE`      28 different antibiotics. You can lookup the abbreviations in the antibiotics data set, or use e.g. `ab_name(""AMP"")` to get the official name immediately. Before analysis, you should transform this to a valid antibiotic class, using `as.sir()`.```rWHONET``` DescriptionThis example data set has the exact same structure as an export file from WHONET. Such files can be used with this package, as this example data set shows. The antibiotic results are from our example_isolates data set. All patient names were created using online surname generators and are only in place for practice purposes. DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rWHONET```",1
AMR,clinical_breakpoints.md," data

# Data Set with Clinical Breakpoints for SIR Interpretation

## Format

A tibble with 29 747 observations and 12 variables:

 * `guideline`
   
   Name of the guideline
 * `type`
   
   Breakpoint type, either ""ECOFF"", ""animal"", or ""human""
 * `method`
   
   Testing method, either ""DISK"" or ""MIC""
 * `site`
   
   Body site for which the breakpoint must be applied, e.g. ""Oral"" or ""Respiratory""
 * `mo`
   
   Microbial ID, see `as.mo()`
 * `rank_index`
   
   Taxonomic rank index of `mo` from 1 (subspecies/infraspecies) to 5 (unknown microorganism)
 * `ab`
   
   Antibiotic code as used by this package, EARS-Net and WHONET, see `as.ab()`
 * `ref_tbl`
   
   Info about where the guideline rule can be found
 * `disk_dose`
   
   Dose of the used disk diffusion method
 * `breakpoint_S`
   
   Lowest MIC value or highest number of millimetres that leads to ""S""
 * `breakpoint_R`
   
   Highest MIC value or lowest number of millimetres that leads to ""R""
 * `uti`
   
   A logical value (`TRUE`/`FALSE`) to indicate whether the rule applies to a urinary tract infection (UTI)

```r
clinical_breakpoints
```

## Description

Data set containing clinical breakpoints to interpret MIC and disk diffusion to SIR values, according to international guidelines. Currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023). Use `as.sir()` to transform MICs or disks measurements to SIR values.

## Details

### Different types of breakpoints

 Supported types of breakpoints are ECOFF, animal, and human. ECOFF (Epidemiological cut-off) values are used in antimicrobial susceptibility testing to differentiate between wild-type and non-wild-type strains of bacteria or fungi.

The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`. Use `as.sir(..., breakpoint_type = ...)` to interpret raw data using a specific breakpoint type, e.g. `as.sir(..., breakpoint_type = ""ECOFF"")` to use ECOFFs.

### Imported from WHONET

 Clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org), a free desktop Windows application developed and supported by the WHO Collaborating Centre for Surveillance of Antimicrobial Resistance. More can be read on [their website](https://whonet.org). The developers of WHONET and this `AMR` package have been in contact about sharing their work. We highly appreciate their development on the WHONET software.

### Response from CLSI and EUCAST

 The CEO of CLSI and the chairman of EUCAST have endorsed the work and public use of this `AMR` package (and consequently the use of their breakpoints) in June 2023, when future development of distributing clinical breakpoints was discussed in a meeting between CLSI, EUCAST, the WHO, and developers of WHONET and the `AMR` package.

### Download

 Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). They allow for machine reading EUCAST and CLSI guidelines, which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI, though initiatives have started to overcome these burdens.

NOTE: this `AMR` package (and the WHONET software as well) contains internal methods to apply the guidelines, which is rather complex. For example, some breakpoints must be applied on certain species groups (which are in case of this package available through the microorganisms.groups data set). It is important that this is considered when using the breakpoints for own use.

## Examples

```r
clinical_breakpoints
```

## See Also

intrinsic_resistant



","['data Data Set with Clinical Breakpoints for SIR Interpretation FormatA tibble with 29 747 observations and 12 variables:  `guideline`      Name of the guideline  `type`      Breakpoint type, either ""ECOFF"", ""animal"", or ""human""  `method`      Testing method, either ""DISK"" or ""MIC""  `site`      Body site for which the breakpoint must be applied, e.g.', '""Oral"" or ""Respiratory""  `mo`      Microbial ID, see `as.mo()`  `rank_index`      Taxonomic rank index of `mo` from 1 (subspecies/infraspecies) to 5 (unknown microorganism)  `ab`      Antibiotic code as used by this package, EARS-Net and WHONET, see `as.ab()`  `ref_tbl`      Info about where the guideline rule can be found  `disk_dose`      Dose of the used disk diffusion method  `breakpoint_S`      Lowest MIC value or highest number of millimetres that leads to ""S""  `breakpoint_R`      Highest MIC value or lowest number of millimetres that leads to ""R""  `uti`      A logical value (`TRUE`/`FALSE`) to indicate whether the rule applies to a urinary tract infection (UTI)```rclinical_breakpoints``` DescriptionData set containing clinical breakpoints to interpret MIC and disk diffusion to SIR values, according to international guidelines.', 'Currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023).', 'Use `as.sir()` to transform MICs or disks measurements to SIR values.', 'Details Different types of breakpoints Supported types of breakpoints are ECOFF, animal, and human.', 'ECOFF (Epidemiological cut-off) values are used in antimicrobial susceptibility testing to differentiate between wild-type and non-wild-type strains of bacteria or fungi.The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.', 'Use `as.sir(..., breakpoint_type = ...)` to interpret raw data using a specific breakpoint type, e.g.', '`as.sir(..., breakpoint_type = ""ECOFF"")` to use ECOFFs.', 'Imported from WHONET Clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org), a free desktop Windows application developed and supported by the WHO Collaborating Centre for Surveillance of Antimicrobial Resistance.', 'More can be read on [their website](https://whonet.org).', 'The developers of WHONET and this `AMR` package have been in contact about sharing their work.', 'We highly appreciate their development on the WHONET software.', 'Response from CLSI and EUCAST The CEO of CLSI and the chairman of EUCAST have endorsed the work and public use of this `AMR` package (and consequently the use of their breakpoints) in June 2023, when future development of distributing clinical breakpoints was discussed in a meeting between CLSI, EUCAST, the WHO, and developers of WHONET and the `AMR` package.', 'Download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'They allow for machine reading EUCAST and CLSI guidelines, which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI, though initiatives have started to overcome these burdens.NOTE: this `AMR` package (and the WHONET software as well) contains internal methods to apply the guidelines, which is rather complex.', 'For example, some breakpoints must be applied on certain species groups (which are in case of this package available through the microorganisms.groups data set).', 'It is important that this is considered when using the breakpoints for own use.']",1," data Data Set with Clinical Breakpoints for SIR Interpretation FormatA tibble with 29 747 observations and 12 variables:  `guideline`      Name of the guideline  `type`      Breakpoint type, either ""ECOFF"", ""animal"", or ""human""  `method`      Testing method, either ""DISK"" or ""MIC""  `site`      Body site for which the breakpoint must be applied, e.g. ""Oral"" or ""Respiratory""  `mo`      Microbial ID, see `as.mo()`  `rank_index`      Taxonomic rank index of `mo` from 1 (subspecies/infraspecies) to 5 (unknown microorganism)  `ab`      Antibiotic code as used by this package, EARS-Net and WHONET, see `as.ab()`  `ref_tbl`      Info about where the guideline rule can be found  `disk_dose`      Dose of the used disk diffusion method  `breakpoint_S`      Lowest MIC value or highest number of millimetres that leads to ""S""  `breakpoint_R`      Highest MIC value or lowest number of millimetres that leads to ""R""  `uti`      A logical value (`TRUE`/`FALSE`) to indicate whether the rule applies to a urinary tract infection (UTI)```rclinical_breakpoints``` DescriptionData set containing clinical breakpoints to interpret MIC and disk diffusion to SIR values, according to international guidelines. Currently implemented guidelines are EUCAST (2011-2023) and CLSI (2011-2023). Use `as.sir()` to transform MICs or disks measurements to SIR values. Details Different types of breakpoints Supported types of breakpoints are ECOFF, animal, and human. ECOFF (Epidemiological cut-off) values are used in antimicrobial susceptibility testing to differentiate between wild-type and non-wild-type strains of bacteria or fungi.The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`. Use `as.sir(..., breakpoint_type = ...)` to interpret raw data using a specific breakpoint type, e.g. `as.sir(..., breakpoint_type = ""ECOFF"")` to use ECOFFs. Imported from WHONET Clinical breakpoints in this package were validated through and imported from [WHONET](https://whonet.org), a free desktop Windows application developed and supported by the WHO Collaborating Centre for Surveillance of Antimicrobial Resistance. More can be read on [their website](https://whonet.org). The developers of WHONET and this `AMR` package have been in contact about sharing their work. We highly appreciate their development on the WHONET software. Response from CLSI and EUCAST The CEO of CLSI and the chairman of EUCAST have endorsed the work and public use of this `AMR` package (and consequently the use of their breakpoints) in June 2023, when future development of distributing clinical breakpoints was discussed in a meeting between CLSI, EUCAST, the WHO, and developers of WHONET and the `AMR` package. Download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). They allow for machine reading EUCAST and CLSI guidelines, which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI, though initiatives have started to overcome these burdens.NOTE: this `AMR` package (and the WHONET software as well) contains internal methods to apply the guidelines, which is rather complex. For example, some breakpoints must be applied on certain species groups (which are in case of this package available through the microorganisms.groups data set). It is important that this is considered when using the breakpoints for own use. Examples```rclinical_breakpoints``` See Alsointrinsic_resistant",1
AMR,add_custom_microorganisms.md,"# Add Custom Microorganisms

```r
add_custom_microorganisms(x)

clear_custom_microorganisms()
```

## Arguments

- `x`: a data.frame resembling the microorganisms data set, at least containing column ""genus"" (case-insensitive)

## Description

With `add_custom_microorganisms()` you can add your own custom microorganisms, such the non-taxonomic outcome of laboratory analysis.

## Details

This function will fill in missing taxonomy for you, if specific taxonomic columns are missing, see **Examples**.

Important: Due to how works, the `add_custom_microorganisms()` function has to be run in every session - added microorganisms are not stored between sessions and are thus lost when is exited.

There are two ways to circumvent this and automate the process of adding microorganisms:

Method 1: Using the package option `AMR_custom_mo`, which is the preferred method. To use this method:

1. Create a data set in the structure of the microorganisms data set (containing at the very least column ""genus"") and save it with `saveRDS()` to a location of choice, e.g. `""~/my_custom_mo.rds""`, or any remote location.
2. Set the file location to the package option `AMR_custom_mo`: `options(AMR_custom_mo = ""~/my_custom_mo.rds"")`. This can even be a remote file location, such as an https URL. Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of . To do this, open the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`, add this text and save the file:
   
    
   
   ```
   # Add custom microorganism codes:
   options(AMR_custom_mo = ""~/my_custom_mo.rds"")
   ```
   
    
   
   Upon package load, this file will be loaded and run through the `add_custom_microorganisms()` function.

Method 2: Loading the microorganism directly from your `.Rprofile` file. Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow. To use this method:

1. Edit the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`.
2. Add a text like below and save the file:
   
    
   
   ```
   # Add custom antibiotic drug codes:
    AMR::add_custom_microorganisms(
      data.frame(genus = ""Enterobacter"",
            species = ""asburiae/cloacae"")
    )
   ```

Use `clear_custom_microorganisms()` to clear the previously added microorganisms.

## Examples

```r
# a combination of species is not formal taxonomy, so
# this will result in ""Enterobacter cloacae cloacae"",
# since it resembles the input best:
mo_name(""Enterobacter asburiae/cloacae"")

# now add a custom entry - it will be considered by as.mo() and
# all mo_*() functions
add_custom_microorganisms(
  data.frame(
    genus = ""Enterobacter"",
    species = ""asburiae/cloacae""
  )
)

# E. asburiae/cloacae is now a new microorganism:
mo_name(""Enterobacter asburiae/cloacae"")

# its code:
as.mo(""Enterobacter asburiae/cloacae"")

# all internal algorithms will work as well:
mo_name(""Ent asburia cloacae"")

# and even the taxonomy was added based on the genus!
mo_family(""E. asburiae/cloacae"")
mo_gramstain(""Enterobacter asburiae/cloacae"")

mo_info(""Enterobacter asburiae/cloacae"")


# the function tries to be forgiving:
add_custom_microorganisms(
  data.frame(
    GENUS = ""BACTEROIDES / PARABACTEROIDES SLASHLINE"",
    SPECIES = ""SPECIES""
  )
)
mo_name(""BACTEROIDES / PARABACTEROIDES"")
mo_rank(""BACTEROIDES / PARABACTEROIDES"")

# taxonomy still works, even though a slashline genus was given as input:
mo_family(""Bacteroides/Parabacteroides"")


# for groups and complexes, set them as species or subspecies:
add_custom_microorganisms(
  data.frame(
    genus = ""Citrobacter"",
    species = c(""freundii"", ""braakii complex""),
    subspecies = c(""complex"", """")
  )
)
mo_name(c(""C. freundii complex"", ""C. braakii complex""))
mo_species(c(""C. freundii complex"", ""C. braakii complex""))
mo_gramstain(c(""C. freundii complex"", ""C. braakii complex""))
```

## See Also

`add_custom_antimicrobials()` to add custom antimicrobials.



","['Add Custom Microorganisms```radd_custom_microorganisms(x)clear_custom_microorganisms()``` Arguments- `x`: a data.frame resembling the microorganisms data set, at least containing column ""genus"" (case-insensitive) DescriptionWith `add_custom_microorganisms()` you can add your own custom microorganisms, such the non-taxonomic outcome of laboratory analysis.', 'DetailsThis function will fill in missing taxonomy for you, if specific taxonomic columns are missing, see Examples.Important: Due to how works, the `add_custom_microorganisms()` function has to be run in every session - added microorganisms are not stored between sessions and are thus lost when is exited.There are two ways to circumvent this and automate the process of adding microorganisms:Method 1: Using the package option `AMR_custom_mo`, which is the preferred method.', 'Create a data set in the structure of the microorganisms data set (containing at the very least column ""genus"") and save it with `saveRDS()` to a location of choice, e.g.', '`""~/my_custom_mo.rds""`, or any remote location.2.', 'Set the file location to the package option `AMR_custom_mo`: `options(AMR_custom_mo = ""~/my_custom_mo.rds"")`.', 'This can even be a remote file location, such as an https URL.', 'Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of .', 'To do this, open the `.Rprofile` file using e.g.', '`utils::file.edit(""~/.Rprofile"")`, add this text and save the file:             ```    Add custom microorganism codes:   options(AMR_custom_mo = ""~/my_custom_mo.rds"")   ```             Upon package load, this file will be loaded and run through the `add_custom_microorganisms()` function.Method 2: Loading the microorganism directly from your `.Rprofile` file.', 'Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow.', 'Edit the `.Rprofile` file using e.g.', 'Add a text like below and save the file:             ```    Add custom antibiotic drug codes:    AMR::add_custom_microorganisms(      data.frame(genus = ""Enterobacter"",            species = ""asburiae/cloacae"")    )   ```Use `clear_custom_microorganisms()` to clear the previously added microorganisms.', 'Examples```r a combination of species is not formal taxonomy, so this will result in ""Enterobacter cloacae cloacae"", since it resembles the input best:mo_name(""Enterobacter asburiae/cloacae"") now add a custom entry - it will be considered by as.mo() and all mo_() functionsadd_custom_microorganisms(  data.frame(    genus = ""Enterobacter"",    species = ""asburiae/cloacae""  )) E. asburiae/cloacae is now a new microorganism:mo_name(""Enterobacter asburiae/cloacae"") its code:as.mo(""Enterobacter asburiae/cloacae"") all internal algorithms will work as well:mo_name(""Ent asburia cloacae"") and even the taxonomy was added based on the genus!mo_family(""E. asburiae/cloacae"")mo_gramstain(""Enterobacter asburiae/cloacae"")mo_info(""Enterobacter asburiae/cloacae"") the function tries to be forgiving:add_custom_microorganisms(  data.frame(    GENUS = ""BACTEROIDES / PARABACTEROIDES SLASHLINE"",    SPECIES = ""SPECIES""  ))mo_name(""BACTEROIDES / PARABACTEROIDES"")mo_rank(""BACTEROIDES / PARABACTEROIDES"") taxonomy still works, even though a slashline genus was given as input:mo_family(""Bacteroides/Parabacteroides"") for groups and complexes, set them as species or subspecies:add_custom_microorganisms(  data.frame(    genus = ""Citrobacter"",    species = c(""freundii"", ""braakii complex""),    subspecies = c(""complex"", """")  ))mo_name(c(""C. freundii complex"", ""C. braakii complex""))mo_species(c(""C. freundii complex"", ""C. braakii complex""))mo_gramstain(c(""C. freundii complex"", ""C. braakii complex""))``` See Also`add_custom_antimicrobials()` to add custom antimicrobials.']",1," Add Custom Microorganisms```radd_custom_microorganisms(x)clear_custom_microorganisms()``` Arguments- `x`: a data.frame resembling the microorganisms data set, at least containing column ""genus"" (case-insensitive) DescriptionWith `add_custom_microorganisms()` you can add your own custom microorganisms, such the non-taxonomic outcome of laboratory analysis. DetailsThis function will fill in missing taxonomy for you, if specific taxonomic columns are missing, see Examples.Important: Due to how works, the `add_custom_microorganisms()` function has to be run in every session - added microorganisms are not stored between sessions and are thus lost when is exited.There are two ways to circumvent this and automate the process of adding microorganisms:Method 1: Using the package option `AMR_custom_mo`, which is the preferred method. To use this method:1. Create a data set in the structure of the microorganisms data set (containing at the very least column ""genus"") and save it with `saveRDS()` to a location of choice, e.g. `""~/my_custom_mo.rds""`, or any remote location.2. Set the file location to the package option `AMR_custom_mo`: `options(AMR_custom_mo = ""~/my_custom_mo.rds"")`. This can even be a remote file location, such as an https URL. Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of . To do this, open the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`, add this text and save the file:             ```    Add custom microorganism codes:   options(AMR_custom_mo = ""~/my_custom_mo.rds"")   ```             Upon package load, this file will be loaded and run through the `add_custom_microorganisms()` function.Method 2: Loading the microorganism directly from your `.Rprofile` file. Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow. To use this method:1. Edit the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`.2. Add a text like below and save the file:             ```    Add custom antibiotic drug codes:    AMR::add_custom_microorganisms(      data.frame(genus = ""Enterobacter"",            species = ""asburiae/cloacae"")    )   ```Use `clear_custom_microorganisms()` to clear the previously added microorganisms. Examples```r a combination of species is not formal taxonomy, so this will result in ""Enterobacter cloacae cloacae"", since it resembles the input best:mo_name(""Enterobacter asburiae/cloacae"") now add a custom entry - it will be considered by as.mo() and all mo_() functionsadd_custom_microorganisms(  data.frame(    genus = ""Enterobacter"",    species = ""asburiae/cloacae""  )) E. asburiae/cloacae is now a new microorganism:mo_name(""Enterobacter asburiae/cloacae"") its code:as.mo(""Enterobacter asburiae/cloacae"") all internal algorithms will work as well:mo_name(""Ent asburia cloacae"") and even the taxonomy was added based on the genus!mo_family(""E. asburiae/cloacae"")mo_gramstain(""Enterobacter asburiae/cloacae"")mo_info(""Enterobacter asburiae/cloacae"") the function tries to be forgiving:add_custom_microorganisms(  data.frame(    GENUS = ""BACTEROIDES / PARABACTEROIDES SLASHLINE"",    SPECIES = ""SPECIES""  ))mo_name(""BACTEROIDES / PARABACTEROIDES"")mo_rank(""BACTEROIDES / PARABACTEROIDES"") taxonomy still works, even though a slashline genus was given as input:mo_family(""Bacteroides/Parabacteroides"") for groups and complexes, set them as species or subspecies:add_custom_microorganisms(  data.frame(    genus = ""Citrobacter"",    species = c(""freundii"", ""braakii complex""),    subspecies = c(""complex"", """")  ))mo_name(c(""C. freundii complex"", ""C. braakii complex""))mo_species(c(""C. freundii complex"", ""C. braakii complex""))mo_gramstain(c(""C. freundii complex"", ""C. braakii complex""))``` See Also`add_custom_antimicrobials()` to add custom antimicrobials.",1
AMR,as.av.md,"# Transform Input to an Antiviral Drug ID

```r
as.av(x, flag_multiple_results = TRUE, info = interactive(), ...)

is.av(x)
```

## Arguments

- `x`: a character vector to determine to antiviral drug ID
- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antiviral drug code or name can be retrieved from a single input value.
- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode
- `...`: arguments passed on to internal functions

## Returns

A character vector with additional class `ab`

## Description

Use this function to determine the antiviral drug code of one or more antiviral drugs. The data set antivirals will be searched for abbreviations, official names and synonyms (brand names).

## Details

All entries in the antivirals data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem). The data set contains more than 5,000 official brand names from many different countries, as found in PubChem. Not that some drugs contain multiple ATC codes.

All these properties will be searched for the user input. The `as.av()` can correct for different forms of misspelling:

 * Wrong spelling of drug names (such as ""acyclovir""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.
 * Too few or too many vowels or consonants
 * Switching two characters (such as ""aycclovir"", often the case in clinical data, when doctors typed too fast)
 * Digitalised paper records, leaving artefacts like 0/o/O (zero and O's), B/8, n/r, etc.

Use the `av_*` functions to get properties based on the returned antiviral drug ID, see **Examples**.

Note: the `as.av()` and `av_*` functions may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems.

## Source

 World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)

European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)

## WHOCC

 This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).

These have become the gold standard for international drug utilisation monitoring and research.

The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.

NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.)

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# these examples all return ""ACI"", the ID of aciclovir:
as.av(""J05AB01"")
as.av(""J 05 AB 01"")
as.av(""Aciclovir"")
as.av(""aciclo"")
as.av(""   aciclo 123"")
as.av(""ACICL"")
as.av(""ACI"")
as.av(""Virorax"") # trade name
as.av(""Zovirax"") # trade name

as.av(""acyklofir"") # severe spelling error, yet works

# use av_* functions to get a specific properties (see ?av_property);
# they use as.av() internally:
av_name(""J05AB01"")
av_name(""acicl"")
```

## See Also

 * antivirals for the data.frame that is being used to determine ATCs
 * `av_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)



","['Transform Input to an Antiviral Drug ID```ras.av(x, flag_multiple_results = TRUE, info = interactive(), ...)is.av(x)``` Arguments- `x`: a character vector to determine to antiviral drug ID- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antiviral drug code or name can be retrieved from a single input value.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to internal functions ReturnsA character vector with additional class `ab` DescriptionUse this function to determine the antiviral drug code of one or more antiviral drugs.', 'The data set antivirals will be searched for abbreviations, official names and synonyms (brand names).', 'DetailsAll entries in the antivirals data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem).', 'The data set contains more than 5,000 official brand names from many different countries, as found in PubChem.', 'Not that some drugs contain multiple ATC codes.All these properties will be searched for the user input.', 'The `as.av()` can correct for different forms of misspelling:  Wrong spelling of drug names (such as ""acyclovir""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.', 'Too few or too many vowels or consonants  Switching two characters (such as ""aycclovir"", often the case in clinical data, when doctors typed too fast)  Digitalised paper records, leaving artefacts like 0/o/O (zero and O\'s), B/8, n/r, etc.Use the `av_` functions to get properties based on the returned antiviral drug ID, see Examples.Note: the `as.av()` and `av_` functions may use very long regular expression to match brand names of antimicrobial drugs.', 'This may fail on some systems.', 'Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government.', 'The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r these examples all return ""ACI"", the ID of aciclovir:as.av(""J05AB01"")as.av(""J 05 AB 01"")as.av(""Aciclovir"")as.av(""aciclo"")as.av(""   aciclo 123"")as.av(""ACICL"")as.av(""ACI"")as.av(""Virorax"")  trade nameas.av(""Zovirax"")  trade nameas.av(""acyklofir"")  severe spelling error, yet works use av_ functions to get a specific properties (see ?av_property); they use as.av() internally:av_name(""J05AB01"")av_name(""acicl"")``` See Also  antivirals for the data.frame that is being used to determine ATCs  `av_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)']",1," Transform Input to an Antiviral Drug ID```ras.av(x, flag_multiple_results = TRUE, info = interactive(), ...)is.av(x)``` Arguments- `x`: a character vector to determine to antiviral drug ID- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antiviral drug code or name can be retrieved from a single input value.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to internal functions ReturnsA character vector with additional class `ab` DescriptionUse this function to determine the antiviral drug code of one or more antiviral drugs. The data set antivirals will be searched for abbreviations, official names and synonyms (brand names). DetailsAll entries in the antivirals data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem). The data set contains more than 5,000 official brand names from many different countries, as found in PubChem. Not that some drugs contain multiple ATC codes.All these properties will be searched for the user input. The `as.av()` can correct for different forms of misspelling:  Wrong spelling of drug names (such as ""acyclovir""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.  Too few or too many vowels or consonants  Switching two characters (such as ""aycclovir"", often the case in clinical data, when doctors typed too fast)  Digitalised paper records, leaving artefacts like 0/o/O (zero and O's), B/8, n/r, etc.Use the `av_` functions to get properties based on the returned antiviral drug ID, see Examples.Note: the `as.av()` and `av_` functions may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems. Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r these examples all return ""ACI"", the ID of aciclovir:as.av(""J05AB01"")as.av(""J 05 AB 01"")as.av(""Aciclovir"")as.av(""aciclo"")as.av(""   aciclo 123"")as.av(""ACICL"")as.av(""ACI"")as.av(""Virorax"")  trade nameas.av(""Zovirax"")  trade nameas.av(""acyklofir"")  severe spelling error, yet works use av_ functions to get a specific properties (see ?av_property); they use as.av() internally:av_name(""J05AB01"")av_name(""acicl"")``` See Also  antivirals for the data.frame that is being used to determine ATCs  `av_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)",1
AMR,av_from_text.md,"# Retrieve Antiviral Drug Names and Doses from Clinical Text

```r
av_from_text(
  text,
  type = c(""drug"", ""dose"", ""administration""),
  collapse = NULL,
  translate_av = FALSE,
  thorough_search = NULL,
  info = interactive(),
  ...
)
```

## Arguments

- `text`: text to analyse
- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see **Examples**
- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see **Examples**
- `translate_av`: if `type = ""drug""`: a column name of the antivirals data set to translate the antibiotic abbreviations to, using `av_property()`. The default is `FALSE`. Using `TRUE` is equal to using ""name"".
- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values. Setting this to `TRUE` will take considerably more time than when using `FALSE`. At default, it will turn `TRUE` when all input elements contain a maximum of three words.
- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode
- `...`: arguments passed on to `as.av()`

## Returns

A list , or a character if `collapse` is not `NULL`

## Description

Use this function on e.g. clinical texts from health care records. It returns a list with all antiviral drugs, doses and forms of administration found in the texts.

## Details

This function is also internally used by `as.av()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned. Note: the `as.av()` function may use very long regular expression to match brand names of antiviral drugs. This may fail on some systems.

### Argument `type`

 At default, the function will search for antiviral drug names. All text elements will be searched for official names, ATC codes and brand names. As it uses `as.av()` internally, it will correct for misspelling.

With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years. The output will be numeric . It supports any unit (g, mg, IE, etc.) and multiple values in one clinical text, see **Examples**.

With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration. It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal. Abbreviations for oral (such as 'po', 'per os') will become ""oral"", all values for intravenous (such as 'iv', 'intraven') will become ""iv"". It supports multiple values in one clinical text, see **Examples**.

### Argument `collapse`

 Without using `collapse`, this function will return a list . This can be convenient to use e.g. inside a `mutate()`):


`df %>% mutate(avx = av_from_text(clinical_text))`

The returned AV codes can be transformed to official names, groups, etc. with all `av_*` functions such as `av_name()` and `av_group()`, or by using the `translate_av` argument.

With using `collapse`, this function will return a character :


`df %>% mutate(avx = av_from_text(clinical_text, collapse = ""|""))`

## Examples

```r
av_from_text(""28/03/2020 valaciclovir po tid"")
av_from_text(""28/03/2020 valaciclovir po tid"", type = ""admin"")
```



","['Retrieve Antiviral Drug Names and Doses from Clinical Text```rav_from_text(  text,  type = c(""drug"", ""dose"", ""administration""),  collapse = NULL,  translate_av = FALSE,  thorough_search = NULL,  info = interactive(),  ...)``` Arguments- `text`: text to analyse- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see Examples- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see Examples- `translate_av`: if `type = ""drug""`: a column name of the antivirals data set to translate the antibiotic abbreviations to, using `av_property()`.', 'Using `TRUE` is equal to using ""name"".- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values.', 'Setting this to `TRUE` will take considerably more time than when using `FALSE`.', 'At default, it will turn `TRUE` when all input elements contain a maximum of three words.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to `as.av()` ReturnsA list , or a character if `collapse` is not `NULL` DescriptionUse this function on e.g.', 'clinical texts from health care records.', 'It returns a list with all antiviral drugs, doses and forms of administration found in the texts.', 'DetailsThis function is also internally used by `as.av()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned.', 'Note: the `as.av()` function may use very long regular expression to match brand names of antiviral drugs.', 'This may fail on some systems.', 'Argument `type` At default, the function will search for antiviral drug names.', 'All text elements will be searched for official names, ATC codes and brand names.', 'As it uses `as.av()` internally, it will correct for misspelling.With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years.', 'The output will be numeric .', 'It supports any unit (g, mg, IE, etc.)', 'and multiple values in one clinical text, see Examples.With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration.', 'It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal.', 'Abbreviations for oral (such as \'po\', \'per os\') will become ""oral"", all values for intravenous (such as \'iv\', \'intraven\') will become ""iv"".', 'It supports multiple values in one clinical text, see Examples.', 'Argument `collapse` Without using `collapse`, this function will return a list .', 'This can be convenient to use e.g.', 'inside a `mutate()`):`df %>% mutate(avx = av_from_text(clinical_text))`The returned AV codes can be transformed to official names, groups, etc.', 'with all `av_` functions such as `av_name()` and `av_group()`, or by using the `translate_av` argument.With using `collapse`, this function will return a character :`df %>% mutate(avx = av_from_text(clinical_text, collapse = ""|""))` Examples```rav_from_text(""28/03/2020 valaciclovir po tid"")av_from_text(""28/03/2020 valaciclovir po tid"", type = ""admin"")```']",1," Retrieve Antiviral Drug Names and Doses from Clinical Text```rav_from_text(  text,  type = c(""drug"", ""dose"", ""administration""),  collapse = NULL,  translate_av = FALSE,  thorough_search = NULL,  info = interactive(),  ...)``` Arguments- `text`: text to analyse- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see Examples- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see Examples- `translate_av`: if `type = ""drug""`: a column name of the antivirals data set to translate the antibiotic abbreviations to, using `av_property()`. The default is `FALSE`. Using `TRUE` is equal to using ""name"".- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values. Setting this to `TRUE` will take considerably more time than when using `FALSE`. At default, it will turn `TRUE` when all input elements contain a maximum of three words.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to `as.av()` ReturnsA list , or a character if `collapse` is not `NULL` DescriptionUse this function on e.g. clinical texts from health care records. It returns a list with all antiviral drugs, doses and forms of administration found in the texts. DetailsThis function is also internally used by `as.av()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned. Note: the `as.av()` function may use very long regular expression to match brand names of antiviral drugs. This may fail on some systems. Argument `type` At default, the function will search for antiviral drug names. All text elements will be searched for official names, ATC codes and brand names. As it uses `as.av()` internally, it will correct for misspelling.With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years. The output will be numeric . It supports any unit (g, mg, IE, etc.) and multiple values in one clinical text, see Examples.With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration. It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal. Abbreviations for oral (such as 'po', 'per os') will become ""oral"", all values for intravenous (such as 'iv', 'intraven') will become ""iv"". It supports multiple values in one clinical text, see Examples. Argument `collapse` Without using `collapse`, this function will return a list . This can be convenient to use e.g. inside a `mutate()`):`df %>% mutate(avx = av_from_text(clinical_text))`The returned AV codes can be transformed to official names, groups, etc. with all `av_` functions such as `av_name()` and `av_group()`, or by using the `translate_av` argument.With using `collapse`, this function will return a character :`df %>% mutate(avx = av_from_text(clinical_text, collapse = ""|""))` Examples```rav_from_text(""28/03/2020 valaciclovir po tid"")av_from_text(""28/03/2020 valaciclovir po tid"", type = ""admin"")```",1
AMR,proportion.md,"# Calculate Antimicrobial Resistance

## Source

M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, **Clinical and Laboratory Standards Institute (CLSI)**. [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).

```r
resistance(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

susceptibility(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

sir_confidence_interval(
  ...,
  ab_result = ""R"",
  minimum = 30,
  as_percent = FALSE,
  only_all_tested = FALSE,
  confidence_level = 0.95,
  side = ""both"",
  collapse = FALSE
)

proportion_R(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

proportion_IR(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

proportion_I(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

proportion_SI(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

proportion_S(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)

proportion_df(
  data,
  translate_ab = ""name"",
  language = get_AMR_locale(),
  minimum = 30,
  as_percent = FALSE,
  combine_SI = TRUE,
  confidence_level = 0.95
)

sir_df(
  data,
  translate_ab = ""name"",
  language = get_AMR_locale(),
  minimum = 30,
  as_percent = FALSE,
  combine_SI = TRUE,
  confidence_level = 0.95
)
```

## Arguments

- `...`: one or more vectors (or columns) with antibiotic interpretations. They will be transformed internally with `as.sir()` if needed. Use multiple columns to calculate (the lack of) co-resistance: the probability where one of two drugs have a resistant or susceptible result. See **Examples**.
- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see **Source**.
- `as_percent`: a logical to indicate whether the output must be returned as a hundred fold with % sign (a character). A value of `0.123456` will then be returned as `""12.3%""`.
- `only_all_tested`: (for combination therapies, i.e. using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section **Combination Therapy** below
- `ab_result`: antibiotic results to test against, must be one or more values of ""S"", ""I"", or ""R""
- `confidence_level`: the confidence level for the returned confidence interval. For the calculation, the number of S or SI isolates, and R isolates are compared with the total number of available isolates with R, S, or I by using `binom.test()`, i.e., the Clopper-Pearson method.
- `side`: the side of the confidence interval to return. The default is `""both""` for a length 2 vector, but can also be (abbreviated as) `""min""`/`""left""`/`""lower""`/`""less""` or `""max""`/`""right""`/`""higher""`/`""greater""`.
- `collapse`: a logical to indicate whether the output values should be 'collapsed', i.e. be merged together into one value, or a character value to use for collapsing
- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)
- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`
- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`

## Returns

A double or, when `as_percent = TRUE`, a character .

## Description

These functions can be used to calculate the (co-)resistance or susceptibility of microbial isolates (i.e. percentage of S, SI, I, IR or R). All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see **Examples**. `resistance()` should be used to calculate resistance, `susceptibility()` should be used to calculate susceptibility.

## Details

Remember that you should filter your data to let it contain only firstisolates! This is needed to exclude duplicates and to reduce selection bias. Use `first_isolate()` to determine them in your data set with one of the four available algorithms.

The function `resistance()` is equal to the function `proportion_R()`. The function `susceptibility()` is equal to the function `proportion_SI()`.

Use `sir_confidence_interval()` to calculate the confidence interval, which relies on `binom.test()`, i.e., the Clopper-Pearson method. This function returns a vector of length 2 at default for antimicrobial **resistance**. Change the `side` argument to ""left""/""min"" or ""right""/""max"" to return a single value, and change the `ab_result` argument to e.g. `c(""S"", ""I"")` to test for antimicrobial **susceptibility**, see Examples.

These functions are not meant to count isolates, but to calculate the proportion of resistance/susceptibility. Use the `count_*()` functions to count isolates. The function `susceptibility()` is essentially equal to `count_susceptible()``/``count_all()`. **Low counts can influence the outcome - the `proportion_*()` functions may camouflage this, since they only return the proportion (albeit dependent on the `minimum` argument).**

The function `proportion_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and calculates the proportions S, I, and R. It also supports grouped variables. The function `sir_df()` works exactly like `proportion_df()`, but adds the number of isolates.

## Combination Therapy

 When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for. See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI:

 

```
--------------------------------------------------------------------
               only_all_tested = FALSE  only_all_tested = TRUE
               -----------------------  -----------------------
 Drug A    Drug B   include as  include as   include as  include as
               numerator   denominator  numerator   denominator
--------  --------  ----------  -----------  ----------  -----------
 S or I    S or I       X            X            X            X
   R       S or I       X            X            X            X
  <NA>     S or I       X            X            -            -
 S or I      R          X            X            X            X
   R         R          -            X            -            X
  <NA>       R          -            -            -            -
 S or I     <NA>        X            X            -            -
   R        <NA>        -            -            -            -
  <NA>      <NA>        -            -            -            -
--------------------------------------------------------------------
```

 

Please note that, in combination therapies, for `only_all_tested = TRUE` applies that:

 

```
count_S()    +   count_I()    +   count_R()    = count_all()
  proportion_S() + proportion_I() + proportion_R() = 1
```

 

and that, in combination therapies, for `only_all_tested = FALSE` applies that:


 

```
count_S()    +   count_I()    +   count_R()    >= count_all()
  proportion_S() + proportion_I() + proportion_R() >= 1
```

 

Using `only_all_tested` has no impact when only using one antibiotic as input.

## Interpretation of SIR

 In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):

 * S - Susceptible, standard dosing regimen
   
   A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.
 * I - Susceptible, increased exposure **A microorganism is categorised as ""Susceptible, Increased exposure**"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.
 * R = Resistant
   
   A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.
   
    * **Exposure** is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.

This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.

## Examples

```r
# example_isolates is a data set available in the AMR package.
# run ?example_isolates for more info.
example_isolates


# base R ------------------------------------------------------------
# determines %R
resistance(example_isolates$AMX)
sir_confidence_interval(example_isolates$AMX)
sir_confidence_interval(example_isolates$AMX,
  confidence_level = 0.975
)
sir_confidence_interval(example_isolates$AMX,
  confidence_level = 0.975,
  collapse = "", ""
)

# determines %S+I:
susceptibility(example_isolates$AMX)
sir_confidence_interval(example_isolates$AMX,
  ab_result = c(""S"", ""I"")
)

# be more specific
proportion_S(example_isolates$AMX)
proportion_SI(example_isolates$AMX)
proportion_I(example_isolates$AMX)
proportion_IR(example_isolates$AMX)
proportion_R(example_isolates$AMX)

# dplyr -------------------------------------------------------------

if (require(""dplyr"")) {
  example_isolates %>%
    group_by(ward) %>%
    summarise(
      r = resistance(CIP),
      n = n_sir(CIP)
    ) # n_sir works like n_distinct in dplyr, see ?n_sir
}
if (require(""dplyr"")) {
  example_isolates %>%
    group_by(ward) %>%
    summarise(
      cipro_R = resistance(CIP),
      ci_min = sir_confidence_interval(CIP, side = ""min""),
      ci_max = sir_confidence_interval(CIP, side = ""max""),
    )
}
if (require(""dplyr"")) {
  # scoped dplyr verbs with antibiotic selectors
  # (you could also use across() of course)
  example_isolates %>%
    group_by(ward) %>%
    summarise_at(
      c(aminoglycosides(), carbapenems()),
      resistance
    )
}
if (require(""dplyr"")) {
  example_isolates %>%
    group_by(ward) %>%
    summarise(
      R = resistance(CIP, as_percent = TRUE),
      SI = susceptibility(CIP, as_percent = TRUE),
      n1 = count_all(CIP), # the actual total; sum of all three
      n2 = n_sir(CIP), # same - analogous to n_distinct
      total = n()
    ) # NOT the number of tested isolates!

  # Calculate co-resistance between amoxicillin/clav acid and gentamicin,
  # so we can see that combination therapy does a lot more than mono therapy:
  example_isolates %>% susceptibility(AMC) # %SI = 76.3%
  example_isolates %>% count_all(AMC) #   n = 1879

  example_isolates %>% susceptibility(GEN) # %SI = 75.4%
  example_isolates %>% count_all(GEN) #   n = 1855

  example_isolates %>% susceptibility(AMC, GEN) # %SI = 94.1%
  example_isolates %>% count_all(AMC, GEN) #   n = 1939


  # See Details on how `only_all_tested` works. Example:
  example_isolates %>%
    summarise(
      numerator = count_susceptible(AMC, GEN),
      denominator = count_all(AMC, GEN),
      proportion = susceptibility(AMC, GEN)
    )

  example_isolates %>%
    summarise(
      numerator = count_susceptible(AMC, GEN, only_all_tested = TRUE),
      denominator = count_all(AMC, GEN, only_all_tested = TRUE),
      proportion = susceptibility(AMC, GEN, only_all_tested = TRUE)
    )


  example_isolates %>%
    group_by(ward) %>%
    summarise(
      cipro_p = susceptibility(CIP, as_percent = TRUE),
      cipro_n = count_all(CIP),
      genta_p = susceptibility(GEN, as_percent = TRUE),
      genta_n = count_all(GEN),
      combination_p = susceptibility(CIP, GEN, as_percent = TRUE),
      combination_n = count_all(CIP, GEN)
    )

  # Get proportions S/I/R immediately of all sir columns
  example_isolates %>%
    select(AMX, CIP) %>%
    proportion_df(translate = FALSE)

  # It also supports grouping variables
  # (use sir_df to also include the count)
  example_isolates %>%
    select(ward, AMX, CIP) %>%
    group_by(ward) %>%
    sir_df(translate = FALSE)
}
```

## See Also

`count()` to count resistant and susceptible isolates.



","['Calculate Antimicrobial Resistance SourceM39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI).', '[https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).```rresistance(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)susceptibility(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)sir_confidence_interval(  ...,  ab_result = ""R"",  minimum = 30,  as_percent = FALSE,  only_all_tested = FALSE,  confidence_level = 0.95,  side = ""both"",  collapse = FALSE)proportion_R(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_IR(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_I(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_SI(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_S(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  minimum = 30,  as_percent = FALSE,  combine_SI = TRUE,  confidence_level = 0.95)sir_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  minimum = 30,  as_percent = FALSE,  combine_SI = TRUE,  confidence_level = 0.95)``` Arguments- `...`: one or more vectors (or columns) with antibiotic interpretations.', 'They will be transformed internally with `as.sir()` if needed.', 'Use multiple columns to calculate (the lack of) co-resistance: the probability where one of two drugs have a resistant or susceptible result.', 'See Examples.- `minimum`: the minimum allowed number of available (tested) isolates.', 'Any isolate count lower than `minimum` will return `NA` with a warning.', 'The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `as_percent`: a logical to indicate whether the output must be returned as a hundred fold with % sign (a character).', 'A value of `0.123456` will then be returned as `""12.3%""`.- `only_all_tested`: (for combination therapies, i.e.', 'using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section Combination Therapy below- `ab_result`: antibiotic results to test against, must be one or more values of ""S"", ""I"", or ""R""- `confidence_level`: the confidence level for the returned confidence interval.', 'For the calculation, the number of S or SI isolates, and R isolates are compared with the total number of available isolates with R, S, or I by using `binom.test()`, i.e., the Clopper-Pearson method.- `side`: the side of the confidence interval to return.', 'The default is `""both""` for a length 2 vector, but can also be (abbreviated as) `""min""`/`""left""`/`""lower""`/`""less""` or `""max""`/`""right""`/`""higher""`/`""greater""`.- `collapse`: a logical to indicate whether the output values should be \'collapsed\', i.e.', 'be merged together into one value, or a character value to use for collapsing- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE` ReturnsA double or, when `as_percent = TRUE`, a character .', 'DescriptionThese functions can be used to calculate the (co-)resistance or susceptibility of microbial isolates (i.e.', 'percentage of S, SI, I, IR or R).', 'All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see Examples.', '`resistance()` should be used to calculate resistance, `susceptibility()` should be used to calculate susceptibility.', 'DetailsRemember that you should filter your data to let it contain only firstisolates!', 'This is needed to exclude duplicates and to reduce selection bias.', 'Use `first_isolate()` to determine them in your data set with one of the four available algorithms.The function `resistance()` is equal to the function `proportion_R()`.', 'The function `susceptibility()` is equal to the function `proportion_SI()`.Use `sir_confidence_interval()` to calculate the confidence interval, which relies on `binom.test()`, i.e., the Clopper-Pearson method.', 'This function returns a vector of length 2 at default for antimicrobial resistance.', 'Change the `side` argument to ""left""/""min"" or ""right""/""max"" to return a single value, and change the `ab_result` argument to e.g.', '`c(""S"", ""I"")` to test for antimicrobial susceptibility, see Examples.These functions are not meant to count isolates, but to calculate the proportion of resistance/susceptibility.', 'Use the `count_()` functions to count isolates.', 'The function `susceptibility()` is essentially equal to `count_susceptible()``/``count_all()`.', 'Low counts can influence the outcome - the `proportion_()` functions may camouflage this, since they only return the proportion (albeit dependent on the `minimum` argument).The function `proportion_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and calculates the proportions S, I, and R. It also supports grouped variables.', 'The function `sir_df()` works exactly like `proportion_df()`, but adds the number of isolates.', 'Combination Therapy When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for.', 'See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------``` Please note that, in combination therapies, for `only_all_tested = TRUE` applies that: ```count_S()    +   count_I()    +   count_R()    = count_all()  proportion_S() + proportion_I() + proportion_R() = 1``` and that, in combination therapies, for `only_all_tested = FALSE` applies that: ```count_S()    +   count_I()    +   count_R()    >= count_all()  proportion_S() + proportion_I() + proportion_R() >= 1``` Using `only_all_tested` has no impact when only using one antibiotic as input.', 'Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.', 'I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.', 'R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.', 'Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight.', 'Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.', 'Examples```r example_isolates is a data set available in the AMR package.', 'run ?example_isolates for more info.example_isolates base R ------------------------------------------------------------ determines %Rresistance(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX,  confidence_level = 0.975)sir_confidence_interval(example_isolates$AMX,  confidence_level = 0.975,  collapse = "", "") determines %S+I:susceptibility(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX,  ab_result = c(""S"", ""I"")) be more specificproportion_S(example_isolates$AMX)proportion_SI(example_isolates$AMX)proportion_I(example_isolates$AMX)proportion_IR(example_isolates$AMX)proportion_R(example_isolates$AMX) dplyr -------------------------------------------------------------if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      r = resistance(CIP),      n = n_sir(CIP)    )  n_sir works like n_distinct in dplyr, see ?n_sir}if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      cipro_R = resistance(CIP),      ci_min = sir_confidence_interval(CIP, side = ""min""),      ci_max = sir_confidence_interval(CIP, side = ""max""),    )}if (require(""dplyr"")) {   scoped dplyr verbs with antibiotic selectors   (you could also use across() of course)  example_isolates %>%    group_by(ward) %>%    summarise_at(      c(aminoglycosides(), carbapenems()),      resistance    )}if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      R = resistance(CIP, as_percent = TRUE),      SI = susceptibility(CIP, as_percent = TRUE),      n1 = count_all(CIP),  the actual total; sum of all three      n2 = n_sir(CIP),  same - analogous to n_distinct      total = n()    )  NOT the number of tested isolates!', 'Calculate co-resistance between amoxicillin/clav acid and gentamicin,   so we can see that combination therapy does a lot more than mono therapy:  example_isolates %>% susceptibility(AMC)  %SI = 76.3%  example_isolates %>% count_all(AMC)    n = 1879  example_isolates %>% susceptibility(GEN)  %SI = 75.4%  example_isolates %>% count_all(GEN)    n = 1855  example_isolates %>% susceptibility(AMC, GEN)  %SI = 94.1%  example_isolates %>% count_all(AMC, GEN)    n = 1939   See Details on how `only_all_tested` works.', 'Example:  example_isolates %>%    summarise(      numerator = count_susceptible(AMC, GEN),      denominator = count_all(AMC, GEN),      proportion = susceptibility(AMC, GEN)    )  example_isolates %>%    summarise(      numerator = count_susceptible(AMC, GEN, only_all_tested = TRUE),      denominator = count_all(AMC, GEN, only_all_tested = TRUE),      proportion = susceptibility(AMC, GEN, only_all_tested = TRUE)    )  example_isolates %>%    group_by(ward) %>%    summarise(      cipro_p = susceptibility(CIP, as_percent = TRUE),      cipro_n = count_all(CIP),      genta_p = susceptibility(GEN, as_percent = TRUE),      genta_n = count_all(GEN),      combination_p = susceptibility(CIP, GEN, as_percent = TRUE),      combination_n = count_all(CIP, GEN)    )   Get proportions S/I/R immediately of all sir columns  example_isolates %>%    select(AMX, CIP) %>%    proportion_df(translate = FALSE)   It also supports grouping variables   (use sir_df to also include the count)  example_isolates %>%    select(ward, AMX, CIP) %>%    group_by(ward) %>%    sir_df(translate = FALSE)}``` See Also`count()` to count resistant and susceptible isolates.']",1," Calculate Antimicrobial Resistance SourceM39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI). [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).```rresistance(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)susceptibility(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)sir_confidence_interval(  ...,  ab_result = ""R"",  minimum = 30,  as_percent = FALSE,  only_all_tested = FALSE,  confidence_level = 0.95,  side = ""both"",  collapse = FALSE)proportion_R(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_IR(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_I(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_SI(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_S(..., minimum = 30, as_percent = FALSE, only_all_tested = FALSE)proportion_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  minimum = 30,  as_percent = FALSE,  combine_SI = TRUE,  confidence_level = 0.95)sir_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  minimum = 30,  as_percent = FALSE,  combine_SI = TRUE,  confidence_level = 0.95)``` Arguments- `...`: one or more vectors (or columns) with antibiotic interpretations. They will be transformed internally with `as.sir()` if needed. Use multiple columns to calculate (the lack of) co-resistance: the probability where one of two drugs have a resistant or susceptible result. See Examples.- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `as_percent`: a logical to indicate whether the output must be returned as a hundred fold with % sign (a character). A value of `0.123456` will then be returned as `""12.3%""`.- `only_all_tested`: (for combination therapies, i.e. using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section Combination Therapy below- `ab_result`: antibiotic results to test against, must be one or more values of ""S"", ""I"", or ""R""- `confidence_level`: the confidence level for the returned confidence interval. For the calculation, the number of S or SI isolates, and R isolates are compared with the total number of available isolates with R, S, or I by using `binom.test()`, i.e., the Clopper-Pearson method.- `side`: the side of the confidence interval to return. The default is `""both""` for a length 2 vector, but can also be (abbreviated as) `""min""`/`""left""`/`""lower""`/`""less""` or `""max""`/`""right""`/`""higher""`/`""greater""`.- `collapse`: a logical to indicate whether the output values should be 'collapsed', i.e. be merged together into one value, or a character value to use for collapsing- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE` ReturnsA double or, when `as_percent = TRUE`, a character . DescriptionThese functions can be used to calculate the (co-)resistance or susceptibility of microbial isolates (i.e. percentage of S, SI, I, IR or R). All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see Examples. `resistance()` should be used to calculate resistance, `susceptibility()` should be used to calculate susceptibility. DetailsRemember that you should filter your data to let it contain only firstisolates! This is needed to exclude duplicates and to reduce selection bias. Use `first_isolate()` to determine them in your data set with one of the four available algorithms.The function `resistance()` is equal to the function `proportion_R()`. The function `susceptibility()` is equal to the function `proportion_SI()`.Use `sir_confidence_interval()` to calculate the confidence interval, which relies on `binom.test()`, i.e., the Clopper-Pearson method. This function returns a vector of length 2 at default for antimicrobial resistance. Change the `side` argument to ""left""/""min"" or ""right""/""max"" to return a single value, and change the `ab_result` argument to e.g. `c(""S"", ""I"")` to test for antimicrobial susceptibility, see Examples.These functions are not meant to count isolates, but to calculate the proportion of resistance/susceptibility. Use the `count_()` functions to count isolates. The function `susceptibility()` is essentially equal to `count_susceptible()``/``count_all()`. Low counts can influence the outcome - the `proportion_()` functions may camouflage this, since they only return the proportion (albeit dependent on the `minimum` argument).The function `proportion_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and calculates the proportions S, I, and R. It also supports grouped variables. The function `sir_df()` works exactly like `proportion_df()`, but adds the number of isolates. Combination Therapy When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for. See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------``` Please note that, in combination therapies, for `only_all_tested = TRUE` applies that: ```count_S()    +   count_I()    +   count_R()    = count_all()  proportion_S() + proportion_I() + proportion_R() = 1``` and that, in combination therapies, for `only_all_tested = FALSE` applies that: ```count_S()    +   count_I()    +   count_R()    >= count_all()  proportion_S() + proportion_I() + proportion_R() >= 1``` Using `only_all_tested` has no impact when only using one antibiotic as input. Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.  I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.  R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.        Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates. Examples```r example_isolates is a data set available in the AMR package. run ?example_isolates for more info.example_isolates base R ------------------------------------------------------------ determines %Rresistance(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX,  confidence_level = 0.975)sir_confidence_interval(example_isolates$AMX,  confidence_level = 0.975,  collapse = "", "") determines %S+I:susceptibility(example_isolates$AMX)sir_confidence_interval(example_isolates$AMX,  ab_result = c(""S"", ""I"")) be more specificproportion_S(example_isolates$AMX)proportion_SI(example_isolates$AMX)proportion_I(example_isolates$AMX)proportion_IR(example_isolates$AMX)proportion_R(example_isolates$AMX) dplyr -------------------------------------------------------------if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      r = resistance(CIP),      n = n_sir(CIP)    )  n_sir works like n_distinct in dplyr, see ?n_sir}if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      cipro_R = resistance(CIP),      ci_min = sir_confidence_interval(CIP, side = ""min""),      ci_max = sir_confidence_interval(CIP, side = ""max""),    )}if (require(""dplyr"")) {   scoped dplyr verbs with antibiotic selectors   (you could also use across() of course)  example_isolates %>%    group_by(ward) %>%    summarise_at(      c(aminoglycosides(), carbapenems()),      resistance    )}if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      R = resistance(CIP, as_percent = TRUE),      SI = susceptibility(CIP, as_percent = TRUE),      n1 = count_all(CIP),  the actual total; sum of all three      n2 = n_sir(CIP),  same - analogous to n_distinct      total = n()    )  NOT the number of tested isolates!   Calculate co-resistance between amoxicillin/clav acid and gentamicin,   so we can see that combination therapy does a lot more than mono therapy:  example_isolates %>% susceptibility(AMC)  %SI = 76.3%  example_isolates %>% count_all(AMC)    n = 1879  example_isolates %>% susceptibility(GEN)  %SI = 75.4%  example_isolates %>% count_all(GEN)    n = 1855  example_isolates %>% susceptibility(AMC, GEN)  %SI = 94.1%  example_isolates %>% count_all(AMC, GEN)    n = 1939   See Details on how `only_all_tested` works. Example:  example_isolates %>%    summarise(      numerator = count_susceptible(AMC, GEN),      denominator = count_all(AMC, GEN),      proportion = susceptibility(AMC, GEN)    )  example_isolates %>%    summarise(      numerator = count_susceptible(AMC, GEN, only_all_tested = TRUE),      denominator = count_all(AMC, GEN, only_all_tested = TRUE),      proportion = susceptibility(AMC, GEN, only_all_tested = TRUE)    )  example_isolates %>%    group_by(ward) %>%    summarise(      cipro_p = susceptibility(CIP, as_percent = TRUE),      cipro_n = count_all(CIP),      genta_p = susceptibility(GEN, as_percent = TRUE),      genta_n = count_all(GEN),      combination_p = susceptibility(CIP, GEN, as_percent = TRUE),      combination_n = count_all(CIP, GEN)    )   Get proportions S/I/R immediately of all sir columns  example_isolates %>%    select(AMX, CIP) %>%    proportion_df(translate = FALSE)   It also supports grouping variables   (use sir_df to also include the count)  example_isolates %>%    select(ward, AMX, CIP) %>%    group_by(ward) %>%    sir_df(translate = FALSE)}``` See Also`count()` to count resistant and susceptible isolates.",1
AMR,antibiotic_class_selectors.md,"# Antibiotic Selectors

```r
ab_class(ab_class, only_sir_columns = FALSE, only_treatable = TRUE, ...)

ab_selector(filter, only_sir_columns = FALSE, only_treatable = TRUE, ...)

aminoglycosides(only_sir_columns = FALSE, only_treatable = TRUE, ...)

aminopenicillins(only_sir_columns = FALSE, ...)

antifungals(only_sir_columns = FALSE, ...)

antimycobacterials(only_sir_columns = FALSE, ...)

betalactams(only_sir_columns = FALSE, only_treatable = TRUE, ...)

carbapenems(only_sir_columns = FALSE, only_treatable = TRUE, ...)

cephalosporins(only_sir_columns = FALSE, ...)

cephalosporins_1st(only_sir_columns = FALSE, ...)

cephalosporins_2nd(only_sir_columns = FALSE, ...)

cephalosporins_3rd(only_sir_columns = FALSE, ...)

cephalosporins_4th(only_sir_columns = FALSE, ...)

cephalosporins_5th(only_sir_columns = FALSE, ...)

fluoroquinolones(only_sir_columns = FALSE, ...)

glycopeptides(only_sir_columns = FALSE, ...)

lincosamides(only_sir_columns = FALSE, ...)

lipoglycopeptides(only_sir_columns = FALSE, ...)

macrolides(only_sir_columns = FALSE, ...)

oxazolidinones(only_sir_columns = FALSE, ...)

penicillins(only_sir_columns = FALSE, ...)

polymyxins(only_sir_columns = FALSE, only_treatable = TRUE, ...)

streptogramins(only_sir_columns = FALSE, ...)

quinolones(only_sir_columns = FALSE, ...)

tetracyclines(only_sir_columns = FALSE, ...)

trimethoprims(only_sir_columns = FALSE, ...)

ureidopenicillins(only_sir_columns = FALSE, ...)

administrable_per_os(only_sir_columns = FALSE, ...)

administrable_iv(only_sir_columns = FALSE, ...)

not_intrinsic_resistant(
  only_sir_columns = FALSE,
  col_mo = NULL,
  version_expertrules = 3.3,
  ...
)
```

## Arguments

- `ab_class`: an antimicrobial class or a part of it, such as `""carba""` and `""carbapenems""`. The columns `group`, `atc_group1` and `atc_group2` of the antibiotics data set will be searched (case-insensitive) for this value.
- `only_sir_columns`: a logical to indicate whether only columns of class `sir` must be selected (default is `FALSE`), see `as.sir()`
- `only_treatable`: a logical to indicate whether antimicrobial drugs should be excluded that are only for laboratory tests (default is `TRUE`), such as gentamicin-high (`GEH`) and imipenem/EDTA (`IPE`)
- `...`: ignored, only in place to allow future extensions
- `filter`: an expression to be evaluated in the antibiotics data set, such as `name %like% ""trim""`
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline. Can be ""3.3"", ""3.2"", or ""3.1"".

## Returns

(internally) a character vector of column names, with additional class `""ab_selector""`

## Description

These functions allow for filtering rows and selecting columns based on antibiotic test results that are of a specific antibiotic class or group (according to the antibiotics data set), without the need to define the columns or antibiotic abbreviations.

In short, if you have a column name that resembles an antimicrobial drug, it will be picked up by any of these functions that matches its pharmaceutical class: ""cefazolin"", ""kefzol"", ""CZO"" and ""J01DB04"" will all be picked up by `cephalosporins()`.

## Details

These functions can be used in data set calls for selecting columns and filtering rows. They work with base , the Tidyverse, and `data.table`. They are heavily inspired by the Tidyverse selection helpers such as `everything()`, but are not limited to `dplyr` verbs. Nonetheless, they are very convenient to use with `dplyr` functions such as `select()`, `filter()` and `summarise()`, see **Examples**.

All columns in the data in which these functions are called will be searched for known antibiotic names, abbreviations, brand names, and codes (ATC, EARS-Net, WHO, etc.) according to the antibiotics data set. This means that a selector such as `aminoglycosides()` will pick up column names like 'gen', 'genta', 'J01GB03', 'tobra', 'Tobracin', etc.

The `ab_class()` function can be used to filter/select on a manually defined antibiotic class. It searches for results in the antibiotics data set within the columns `group`, `atc_group1` and `atc_group2`.

The `ab_selector()` function can be used to internally filter the antibiotics data set on any results, see **Examples**. It allows for filtering on a (part of) a certain name, and/or a group name or even a minimum of DDDs for oral treatment. This function yields the highest flexibility, but is also the least user-friendly, since it requires a hard-coded filter to set.

The `administrable_per_os()` and `administrable_iv()` functions also rely on the antibiotics data set - antibiotic columns will be matched where a DDD (defined daily dose) for resp. oral and IV treatment is available in the antibiotics data set.

The `not_intrinsic_resistant()` function can be used to only select antibiotic columns that pose no intrinsic resistance for the microorganisms in the data set. For example, if a data set contains only microorganism codes or names of **E. coli** and **K. pneumoniae** and contains a column ""vancomycin"", this column will be removed (or rather, unselected) using this function. It currently applies ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021) to determine intrinsic resistance, using the `eucast_rules()` function internally. Because of this determination, this function is quite slow in terms of performance.

## Full list of supported (antibiotic) classes

 * `aminoglycosides()` can select:
   
   amikacin (AMK), amikacin/fosfomycin (AKF), amphotericin B-high (AMH), apramycin (APR), arbekacin (ARB), astromicin (AST), bekanamycin (BEK), dibekacin (DKB), framycetin (FRM), gentamicin (GEN), gentamicin-high (GEH), habekacin (HAB), hygromycin (HYG), isepamicin (ISE), kanamycin (KAN), kanamycin-high (KAH), kanamycin/cephalexin (KAC), micronomicin (MCR), neomycin (NEO), netilmicin (NET), pentisomicin (PIM), plazomicin (PLZ), propikacin (PKA), ribostamycin (RST), sisomicin (SIS), streptoduocin (STR), streptomycin (STR1), streptomycin-high (STH), tobramycin (TOB), and tobramycin-high (TOH)
 * `aminopenicillins()` can select:
   
   amoxicillin (AMX) and ampicillin (AMP)
 * `antifungals()` can select:
   
   amphotericin B (AMB), anidulafungin (ANI), butoconazole (BUT), caspofungin (CAS), ciclopirox (CIX), clotrimazole (CTR), econazole (ECO), fluconazole (FLU), flucytosine (FCT), fosfluconazole (FFL), griseofulvin (GRI), hachimycin (HCH), ibrexafungerp (IBX), isavuconazole (ISV), isoconazole (ISO), itraconazole (ITR), ketoconazole (KET), manogepix (MGX), micafungin (MIF), miconazole (MCZ), nystatin (NYS), oteseconazole (OTE), pimaricin (PMR), posaconazole (POS), rezafungin (RZF), ribociclib (RBC), sulconazole (SUC), terbinafine (TRB), terconazole (TRC), and voriconazole (VOR)
 * `antimycobacterials()` can select:
   
   4-aminosalicylic acid (AMA), calcium aminosalicylate (CLA), capreomycin (CAP), clofazimine (CLF), delamanid (DLM), enviomycin (ENV), ethambutol (ETH), ethambutol/isoniazid (ETI), ethionamide (ETI1), isoniazid (INH), isoniazid/sulfamethoxazole/trimethoprim/pyridoxine (IST), morinamide (MRN), p-aminosalicylic acid (PAS), pretomanid (PMD), protionamide (PTH), pyrazinamide (PZA), rifabutin (RIB), rifampicin (RIF), rifampicin/ethambutol/isoniazid (REI), rifampicin/isoniazid (RFI), rifampicin/pyrazinamide/ethambutol/isoniazid (RPEI), rifampicin/pyrazinamide/isoniazid (RPI), rifamycin (RFM), rifapentine (RFP), simvastatin/fenofibrate (SMF), sodium aminosalicylate (SDA), streptomycin/isoniazid (STI), terizidone (TRZ), thioacetazone (TAT), thioacetazone/isoniazid (THI1), tiocarlide (TCR), and viomycin (VIO)
 * `betalactams()` can select:
   
   amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), biapenem (BIA), carbenicillin (CRB), carindacillin (CRN), cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/nacubactam (FNC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), doripenem (DOR), epicillin (EPC), ertapenem (ETP), flucloxacillin (FLC), hetacillin (HET), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), latamoxef (LTM), lenampicillin (LEN), loracarbef (LOR), mecillinam (MEC), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), panipenem (PAN), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), tebipenem (TBP), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)
 * `carbapenems()` can select:
   
   biapenem (BIA), doripenem (DOR), ertapenem (ETP), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), panipenem (PAN), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), and tebipenem (TBP)
 * `cephalosporins()` can select:
   
   cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), latamoxef (LTM), and loracarbef (LOR)
 * `cephalosporins_1st()` can select:
   
   cefacetrile (CAC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefroxadine (CRD), ceftezole (CTL), and cephradine (CED)
 * `cephalosporins_2nd()` can select:
   
   cefaclor (CEC), cefamandole (MAN), cefmetazole (CMZ), cefonicid (CID), ceforanide (CND), cefotetan (CTT), cefotiam (CTF), cefoxitin (FOX), cefoxitin screening (FOX1), cefprozil (CPR), cefuroxime (CXM), cefuroxime axetil (CXA), and loracarbef (LOR)
 * `cephalosporins_3rd()` can select:
   
   cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefetamet (CAT), cefetamet pivoxil (CPI), cefixime (CFM), cefmenoxime (CMX), cefodizime (DIZ), cefoperazone (CFP), cefoperazone/sulbactam (CSL), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotiam hexetil (CHE), cefovecin (FOV), cefpimizole (CFZ), cefpiramide (CPM), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefsulodin (CFS), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), and latamoxef (LTM)
 * `cephalosporins_4th()` can select:
   
   cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetecol (CCL), cefoselis (CSE), cefozopran (ZOP), cefpirome (CPO), and cefquinome (CEQ)
 * `cephalosporins_5th()` can select:
   
   ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), and ceftolozane/tazobactam (CZT)
 * `fluoroquinolones()` can select:
   
   besifloxacin (BES), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nifuroquine (NIF), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), pazufloxacin (PAZ), pefloxacin (PEF), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)
 * `glycopeptides()` can select:
   
   avoparcin (AVO), dalbavancin (DAL), norvancomycin (NVA), oritavancin (ORI), ramoplanin (RAM), teicoplanin (TEC), teicoplanin-macromethod (TCM), telavancin (TLV), vancomycin (VAN), and vancomycin-macromethod (VAM)
 * `lincosamides()` can select:
   
   acetylmidecamycin (ACM), acetylspiramycin (ASP), clindamycin (CLI), gamithromycin (GAM), kitasamycin (KIT), lincomycin (LIN), meleumycin (MEL), nafithromycin (ZWK), pirlimycin (PRL), primycin (PRM), solithromycin (SOL), tildipirosin (TIP), tilmicosin (TIL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)
 * `lipoglycopeptides()` can select:
   
   dalbavancin (DAL), oritavancin (ORI), and telavancin (TLV)
 * `macrolides()` can select:
   
   acetylmidecamycin (ACM), acetylspiramycin (ASP), azithromycin (AZM), clarithromycin (CLR), dirithromycin (DIR), erythromycin (ERY), flurithromycin (FLR1), gamithromycin (GAM), josamycin (JOS), kitasamycin (KIT), meleumycin (MEL), midecamycin (MID), miocamycin (MCM), nafithromycin (ZWK), oleandomycin (OLE), pirlimycin (PRL), primycin (PRM), rokitamycin (ROK), roxithromycin (RXT), solithromycin (SOL), spiramycin (SPI), telithromycin (TLT), tildipirosin (TIP), tilmicosin (TIL), troleandomycin (TRL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)
 * `oxazolidinones()` can select:
   
   cadazolid (CDZ), cycloserine (CYC), linezolid (LNZ), tedizolid (TZD), and thiacetazone (THA)
 * `penicillins()` can select:
   
   amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), carbenicillin (CRB), carindacillin (CRN), cefepime/nacubactam (FNC), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), epicillin (EPC), flucloxacillin (FLC), hetacillin (HET), lenampicillin (LEN), mecillinam (MEC), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)
 * `polymyxins()` can select:
   
   colistin (COL), polymyxin B (PLB), and polymyxin B/polysorbate 80 (POP)
 * `quinolones()` can select:
   
   besifloxacin (BES), cinoxacin (CIN), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), flumequine (FLM), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nalidixic acid (NAL), nemonoxacin (NEM), nifuroquine (NIF), nitroxoline (NTR), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), oxolinic acid (OXO), pazufloxacin (PAZ), pefloxacin (PEF), pipemidic acid (PPA), piromidic acid (PIR), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rosoxacin (ROS), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)
 * `streptogramins()` can select:
   
   pristinamycin (PRI) and quinupristin/dalfopristin (QDA)
 * `tetracyclines()` can select:
   
   cetocycline (CTO), chlortetracycline (CTE), clomocycline (CLM1), demeclocycline (DEM), doxycycline (DOX), eravacycline (ERV), lymecycline (LYM), metacycline (MTC), minocycline (MNO), omadacycline (OMC), oxytetracycline (OXY), penimepicycline (PNM1), rolitetracycline (RLT), sarecycline (SRC), tetracycline (TCY), and tigecycline (TGC)
 * `trimethoprims()` can select:
   
   brodimoprim (BDP), sulfadiazine (SDI), sulfadiazine/tetroxoprim (SLT), sulfadiazine/trimethoprim (SLT1), sulfadimethoxine (SUD), sulfadimidine (SDM), sulfadimidine/trimethoprim (SLT2), sulfafurazole (SLF), sulfaisodimidine (SLF1), sulfalene (SLF2), sulfamazone (SZO), sulfamerazine (SLF3), sulfamerazine/trimethoprim (SLT3), sulfamethizole (SLF4), sulfamethoxazole (SMX), sulfamethoxypyridazine (SLF5), sulfametomidine (SLF6), sulfametoxydiazine (SLF7), sulfametrole/trimethoprim (SLT4), sulfamoxole (SLF8), sulfamoxole/trimethoprim (SLT5), sulfanilamide (SLF9), sulfaperin (SLF10), sulfaphenazole (SLF11), sulfapyridine (SLF12), sulfathiazole (SUT), sulfathiourea (SLF13), trimethoprim (TMP), and trimethoprim/sulfamethoxazole (SXT)
 * `ureidopenicillins()` can select:
   
   azlocillin (AZL), mezlocillin (MEZ), piperacillin (PIP), and piperacillin/tazobactam (TZP)

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.
example_isolates


# Examples sections below are split into 'base R', 'dplyr', and 'data.table':


# base R ------------------------------------------------------------------

# select columns 'IPM' (imipenem) and 'MEM' (meropenem)
example_isolates[, carbapenems()]

# select columns 'mo', 'AMK', 'GEN', 'KAN' and 'TOB'
example_isolates[, c(""mo"", aminoglycosides())]

# select only antibiotic columns with DDDs for oral treatment
example_isolates[, administrable_per_os()]

# filter using any() or all()
example_isolates[any(carbapenems() == ""R""), ]
subset(example_isolates, any(carbapenems() == ""R""))

# filter on any or all results in the carbapenem columns (i.e., IPM, MEM):
example_isolates[any(carbapenems()), ]
example_isolates[all(carbapenems()), ]

# filter with multiple antibiotic selectors using c()
example_isolates[all(c(carbapenems(), aminoglycosides()) == ""R""), ]

# filter + select in one go: get penicillins in carbapenem-resistant strains
example_isolates[any(carbapenems() == ""R""), penicillins()]

# You can combine selectors with '&' to be more specific. For example,
# penicillins() would select benzylpenicillin ('peni G') and
# administrable_per_os() would select erythromycin. Yet, when combined these
# drugs are both omitted since benzylpenicillin is not administrable per os
# and erythromycin is not a penicillin:
example_isolates[, penicillins() & administrable_per_os()]

# ab_selector() applies a filter in the `antibiotics` data set and is thus
# very flexible. For instance, to select antibiotic columns with an oral DDD
# of at least 1 gram:
example_isolates[, ab_selector(oral_ddd > 1 & oral_units == ""g"")]


# dplyr -------------------------------------------------------------------

if (require(""dplyr"")) {
  tibble(kefzol = random_sir(5)) %>%
    select(cephalosporins())
}

if (require(""dplyr"")) {
  # get AMR for all aminoglycosides e.g., per ward:
  example_isolates %>%
    group_by(ward) %>%
    summarise(across(aminoglycosides(), resistance))
}
if (require(""dplyr"")) {
  # You can combine selectors with '&' to be more specific:
  example_isolates %>%
    select(penicillins() & administrable_per_os())
}
if (require(""dplyr"")) {
  # get AMR for only drugs that matter - no intrinsic resistance:
  example_isolates %>%
    filter(mo_genus() %in% c(""Escherichia"", ""Klebsiella"")) %>%
    group_by(ward) %>%
    summarise(across(not_intrinsic_resistant(), resistance))
}
if (require(""dplyr"")) {
  # get susceptibility for antibiotics whose name contains ""trim"":
  example_isolates %>%
    filter(first_isolate()) %>%
    group_by(ward) %>%
    summarise(across(ab_selector(name %like% ""trim""), susceptibility))
}
if (require(""dplyr"")) {
  # this will select columns 'IPM' (imipenem) and 'MEM' (meropenem):
  example_isolates %>%
    select(carbapenems())
}
if (require(""dplyr"")) {
  # this will select columns 'mo', 'AMK', 'GEN', 'KAN' and 'TOB':
  example_isolates %>%
    select(mo, aminoglycosides())
}
if (require(""dplyr"")) {
  # any() and all() work in dplyr's filter() too:
  example_isolates %>%
    filter(
      any(aminoglycosides() == ""R""),
      all(cephalosporins_2nd() == ""R"")
    )
}
if (require(""dplyr"")) {
  # also works with c():
  example_isolates %>%
    filter(any(c(carbapenems(), aminoglycosides()) == ""R""))
}
if (require(""dplyr"")) {
  # not setting any/all will automatically apply all():
  example_isolates %>%
    filter(aminoglycosides() == ""R"")
}
if (require(""dplyr"")) {
  # this will select columns 'mo' and all antimycobacterial drugs ('RIF'):
  example_isolates %>%
    select(mo, ab_class(""mycobact""))
}
if (require(""dplyr"")) {
  # get bug/drug combinations for only glycopeptides in Gram-positives:
  example_isolates %>%
    filter(mo_is_gram_positive()) %>%
    select(mo, glycopeptides()) %>%
    bug_drug_combinations() %>%
    format()
}
if (require(""dplyr"")) {
  data.frame(
    some_column = ""some_value"",
    J01CA01 = ""S""
  ) %>% # ATC code of ampicillin
    select(penicillins()) # only the 'J01CA01' column will be selected
}
if (require(""dplyr"")) {
  # with recent versions of dplyr, this is all equal:
  x <- example_isolates[carbapenems() == ""R"", ]
  y <- example_isolates %>% filter(carbapenems() == ""R"")
  z <- example_isolates %>% filter(if_all(carbapenems(), ~ .x == ""R""))
  identical(x, y) && identical(y, z)
}


# data.table --------------------------------------------------------------

# data.table is supported as well, just use it in the same way as with
# base R, but add `with = FALSE` if using a single AB selector.

if (require(""data.table"")) {
  dt <- as.data.table(example_isolates)

  # this does not work, it returns column *names*
  dt[, carbapenems()]
}
if (require(""data.table"")) {
  # so `with = FALSE` is required
  dt[, carbapenems(), with = FALSE]
}

# for multiple selections or AB selectors, `with = FALSE` is not needed:
if (require(""data.table"")) {
  dt[, c(""mo"", aminoglycosides())]
}
if (require(""data.table"")) {
  dt[, c(carbapenems(), aminoglycosides())]
}

# row filters are also supported:
if (require(""data.table"")) {
  dt[any(carbapenems() == ""S""), ]
}
if (require(""data.table"")) {
  dt[any(carbapenems() == ""S""), penicillins(), with = FALSE]
}
```



","['Antibiotic Selectors```rab_class(ab_class, only_sir_columns = FALSE, only_treatable = TRUE, ...)ab_selector(filter, only_sir_columns = FALSE, only_treatable = TRUE, ...)aminoglycosides(only_sir_columns = FALSE, only_treatable = TRUE, ...)aminopenicillins(only_sir_columns = FALSE, ...)antifungals(only_sir_columns = FALSE, ...)antimycobacterials(only_sir_columns = FALSE, ...)betalactams(only_sir_columns = FALSE, only_treatable = TRUE, ...)carbapenems(only_sir_columns = FALSE, only_treatable = TRUE, ...)cephalosporins(only_sir_columns = FALSE, ...)cephalosporins_1st(only_sir_columns = FALSE, ...)cephalosporins_2nd(only_sir_columns = FALSE, ...)cephalosporins_3rd(only_sir_columns = FALSE, ...)cephalosporins_4th(only_sir_columns = FALSE, ...)cephalosporins_5th(only_sir_columns = FALSE, ...)fluoroquinolones(only_sir_columns = FALSE, ...)glycopeptides(only_sir_columns = FALSE, ...)lincosamides(only_sir_columns = FALSE, ...)lipoglycopeptides(only_sir_columns = FALSE, ...)macrolides(only_sir_columns = FALSE, ...)oxazolidinones(only_sir_columns = FALSE, ...)penicillins(only_sir_columns = FALSE, ...)polymyxins(only_sir_columns = FALSE, only_treatable = TRUE, ...)streptogramins(only_sir_columns = FALSE, ...)quinolones(only_sir_columns = FALSE, ...)tetracyclines(only_sir_columns = FALSE, ...)trimethoprims(only_sir_columns = FALSE, ...)ureidopenicillins(only_sir_columns = FALSE, ...)administrable_per_os(only_sir_columns = FALSE, ...)administrable_iv(only_sir_columns = FALSE, ...)not_intrinsic_resistant(  only_sir_columns = FALSE,  col_mo = NULL,  version_expertrules = 3.3,  ...)``` Arguments- `ab_class`: an antimicrobial class or a part of it, such as `""carba""` and `""carbapenems""`.', 'The columns `group`, `atc_group1` and `atc_group2` of the antibiotics data set will be searched (case-insensitive) for this value.- `only_sir_columns`: a logical to indicate whether only columns of class `sir` must be selected (default is `FALSE`), see `as.sir()`- `only_treatable`: a logical to indicate whether antimicrobial drugs should be excluded that are only for laboratory tests (default is `TRUE`), such as gentamicin-high (`GEH`) and imipenem/EDTA (`IPE`)- `...`: ignored, only in place to allow future extensions- `filter`: an expression to be evaluated in the antibiotics data set, such as `name %like% ""trim""`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline.', 'Can be ""3.3"", ""3.2"", or ""3.1"".', 'Returns(internally) a character vector of column names, with additional class `""ab_selector""` DescriptionThese functions allow for filtering rows and selecting columns based on antibiotic test results that are of a specific antibiotic class or group (according to the antibiotics data set), without the need to define the columns or antibiotic abbreviations.In short, if you have a column name that resembles an antimicrobial drug, it will be picked up by any of these functions that matches its pharmaceutical class: ""cefazolin"", ""kefzol"", ""CZO"" and ""J01DB04"" will all be picked up by `cephalosporins()`.', 'DetailsThese functions can be used in data set calls for selecting columns and filtering rows.', 'They work with base , the Tidyverse, and `data.table`.', 'They are heavily inspired by the Tidyverse selection helpers such as `everything()`, but are not limited to `dplyr` verbs.', 'Nonetheless, they are very convenient to use with `dplyr` functions such as `select()`, `filter()` and `summarise()`, see Examples.All columns in the data in which these functions are called will be searched for known antibiotic names, abbreviations, brand names, and codes (ATC, EARS-Net, WHO, etc.)', 'according to the antibiotics data set.', ""This means that a selector such as `aminoglycosides()` will pick up column names like 'gen', 'genta', 'J01GB03', 'tobra', 'Tobracin', etc.The `ab_class()` function can be used to filter/select on a manually defined antibiotic class."", 'It searches for results in the antibiotics data set within the columns `group`, `atc_group1` and `atc_group2`.The `ab_selector()` function can be used to internally filter the antibiotics data set on any results, see Examples.', 'It allows for filtering on a (part of) a certain name, and/or a group name or even a minimum of DDDs for oral treatment.', 'This function yields the highest flexibility, but is also the least user-friendly, since it requires a hard-coded filter to set.The `administrable_per_os()` and `administrable_iv()` functions also rely on the antibiotics data set - antibiotic columns will be matched where a DDD (defined daily dose) for resp.', 'oral and IV treatment is available in the antibiotics data set.The `not_intrinsic_resistant()` function can be used to only select antibiotic columns that pose no intrinsic resistance for the microorganisms in the data set.', 'For example, if a data set contains only microorganism codes or names of E. coli and K. pneumoniae and contains a column ""vancomycin"", this column will be removed (or rather, unselected) using this function.', ""It currently applies ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021) to determine intrinsic resistance, using the `eucast_rules()` function internally."", 'Because of this determination, this function is quite slow in terms of performance.', 'Full list of supported (antibiotic) classes  `aminoglycosides()` can select:      amikacin (AMK), amikacin/fosfomycin (AKF), amphotericin B-high (AMH), apramycin (APR), arbekacin (ARB), astromicin (AST), bekanamycin (BEK), dibekacin (DKB), framycetin (FRM), gentamicin (GEN), gentamicin-high (GEH), habekacin (HAB), hygromycin (HYG), isepamicin (ISE), kanamycin (KAN), kanamycin-high (KAH), kanamycin/cephalexin (KAC), micronomicin (MCR), neomycin (NEO), netilmicin (NET), pentisomicin (PIM), plazomicin (PLZ), propikacin (PKA), ribostamycin (RST), sisomicin (SIS), streptoduocin (STR), streptomycin (STR1), streptomycin-high (STH), tobramycin (TOB), and tobramycin-high (TOH)  `aminopenicillins()` can select:      amoxicillin (AMX) and ampicillin (AMP)  `antifungals()` can select:      amphotericin B (AMB), anidulafungin (ANI), butoconazole (BUT), caspofungin (CAS), ciclopirox (CIX), clotrimazole (CTR), econazole (ECO), fluconazole (FLU), flucytosine (FCT), fosfluconazole (FFL), griseofulvin (GRI), hachimycin (HCH), ibrexafungerp (IBX), isavuconazole (ISV), isoconazole (ISO), itraconazole (ITR), ketoconazole (KET), manogepix (MGX), micafungin (MIF), miconazole (MCZ), nystatin (NYS), oteseconazole (OTE), pimaricin (PMR), posaconazole (POS), rezafungin (RZF), ribociclib (RBC), sulconazole (SUC), terbinafine (TRB), terconazole (TRC), and voriconazole (VOR)  `antimycobacterials()` can select:      4-aminosalicylic acid (AMA), calcium aminosalicylate (CLA), capreomycin (CAP), clofazimine (CLF), delamanid (DLM), enviomycin (ENV), ethambutol (ETH), ethambutol/isoniazid (ETI), ethionamide (ETI1), isoniazid (INH), isoniazid/sulfamethoxazole/trimethoprim/pyridoxine (IST), morinamide (MRN), p-aminosalicylic acid (PAS), pretomanid (PMD), protionamide (PTH), pyrazinamide (PZA), rifabutin (RIB), rifampicin (RIF), rifampicin/ethambutol/isoniazid (REI), rifampicin/isoniazid (RFI), rifampicin/pyrazinamide/ethambutol/isoniazid (RPEI), rifampicin/pyrazinamide/isoniazid (RPI), rifamycin (RFM), rifapentine (RFP), simvastatin/fenofibrate (SMF), sodium aminosalicylate (SDA), streptomycin/isoniazid (STI), terizidone (TRZ), thioacetazone (TAT), thioacetazone/isoniazid (THI1), tiocarlide (TCR), and viomycin (VIO)  `betalactams()` can select:      amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), biapenem (BIA), carbenicillin (CRB), carindacillin (CRN), cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/nacubactam (FNC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), doripenem (DOR), epicillin (EPC), ertapenem (ETP), flucloxacillin (FLC), hetacillin (HET), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), latamoxef (LTM), lenampicillin (LEN), loracarbef (LOR), mecillinam (MEC), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), panipenem (PAN), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), tebipenem (TBP), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)  `carbapenems()` can select:      biapenem (BIA), doripenem (DOR), ertapenem (ETP), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), panipenem (PAN), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), and tebipenem (TBP)  `cephalosporins()` can select:      cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), latamoxef (LTM), and loracarbef (LOR)  `cephalosporins_1st()` can select:      cefacetrile (CAC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefroxadine (CRD), ceftezole (CTL), and cephradine (CED)  `cephalosporins_2nd()` can select:      cefaclor (CEC), cefamandole (MAN), cefmetazole (CMZ), cefonicid (CID), ceforanide (CND), cefotetan (CTT), cefotiam (CTF), cefoxitin (FOX), cefoxitin screening (FOX1), cefprozil (CPR), cefuroxime (CXM), cefuroxime axetil (CXA), and loracarbef (LOR)  `cephalosporins_3rd()` can select:      cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefetamet (CAT), cefetamet pivoxil (CPI), cefixime (CFM), cefmenoxime (CMX), cefodizime (DIZ), cefoperazone (CFP), cefoperazone/sulbactam (CSL), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotiam hexetil (CHE), cefovecin (FOV), cefpimizole (CFZ), cefpiramide (CPM), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefsulodin (CFS), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), and latamoxef (LTM)  `cephalosporins_4th()` can select:      cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetecol (CCL), cefoselis (CSE), cefozopran (ZOP), cefpirome (CPO), and cefquinome (CEQ)  `cephalosporins_5th()` can select:      ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), and ceftolozane/tazobactam (CZT)  `fluoroquinolones()` can select:      besifloxacin (BES), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nifuroquine (NIF), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), pazufloxacin (PAZ), pefloxacin (PEF), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)  `glycopeptides()` can select:      avoparcin (AVO), dalbavancin (DAL), norvancomycin (NVA), oritavancin (ORI), ramoplanin (RAM), teicoplanin (TEC), teicoplanin-macromethod (TCM), telavancin (TLV), vancomycin (VAN), and vancomycin-macromethod (VAM)  `lincosamides()` can select:      acetylmidecamycin (ACM), acetylspiramycin (ASP), clindamycin (CLI), gamithromycin (GAM), kitasamycin (KIT), lincomycin (LIN), meleumycin (MEL), nafithromycin (ZWK), pirlimycin (PRL), primycin (PRM), solithromycin (SOL), tildipirosin (TIP), tilmicosin (TIL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)  `lipoglycopeptides()` can select:      dalbavancin (DAL), oritavancin (ORI), and telavancin (TLV)  `macrolides()` can select:      acetylmidecamycin (ACM), acetylspiramycin (ASP), azithromycin (AZM), clarithromycin (CLR), dirithromycin (DIR), erythromycin (ERY), flurithromycin (FLR1), gamithromycin (GAM), josamycin (JOS), kitasamycin (KIT), meleumycin (MEL), midecamycin (MID), miocamycin (MCM), nafithromycin (ZWK), oleandomycin (OLE), pirlimycin (PRL), primycin (PRM), rokitamycin (ROK), roxithromycin (RXT), solithromycin (SOL), spiramycin (SPI), telithromycin (TLT), tildipirosin (TIP), tilmicosin (TIL), troleandomycin (TRL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)  `oxazolidinones()` can select:      cadazolid (CDZ), cycloserine (CYC), linezolid (LNZ), tedizolid (TZD), and thiacetazone (THA)  `penicillins()` can select:      amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), carbenicillin (CRB), carindacillin (CRN), cefepime/nacubactam (FNC), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), epicillin (EPC), flucloxacillin (FLC), hetacillin (HET), lenampicillin (LEN), mecillinam (MEC), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)  `polymyxins()` can select:      colistin (COL), polymyxin B (PLB), and polymyxin B/polysorbate 80 (POP)  `quinolones()` can select:      besifloxacin (BES), cinoxacin (CIN), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), flumequine (FLM), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nalidixic acid (NAL), nemonoxacin (NEM), nifuroquine (NIF), nitroxoline (NTR), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), oxolinic acid (OXO), pazufloxacin (PAZ), pefloxacin (PEF), pipemidic acid (PPA), piromidic acid (PIR), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rosoxacin (ROS), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)  `streptogramins()` can select:      pristinamycin (PRI) and quinupristin/dalfopristin (QDA)  `tetracyclines()` can select:      cetocycline (CTO), chlortetracycline (CTE), clomocycline (CLM1), demeclocycline (DEM), doxycycline (DOX), eravacycline (ERV), lymecycline (LYM), metacycline (MTC), minocycline (MNO), omadacycline (OMC), oxytetracycline (OXY), penimepicycline (PNM1), rolitetracycline (RLT), sarecycline (SRC), tetracycline (TCY), and tigecycline (TGC)  `trimethoprims()` can select:      brodimoprim (BDP), sulfadiazine (SDI), sulfadiazine/tetroxoprim (SLT), sulfadiazine/trimethoprim (SLT1), sulfadimethoxine (SUD), sulfadimidine (SDM), sulfadimidine/trimethoprim (SLT2), sulfafurazole (SLF), sulfaisodimidine (SLF1), sulfalene (SLF2), sulfamazone (SZO), sulfamerazine (SLF3), sulfamerazine/trimethoprim (SLT3), sulfamethizole (SLF4), sulfamethoxazole (SMX), sulfamethoxypyridazine (SLF5), sulfametomidine (SLF6), sulfametoxydiazine (SLF7), sulfametrole/trimethoprim (SLT4), sulfamoxole (SLF8), sulfamoxole/trimethoprim (SLT5), sulfanilamide (SLF9), sulfaperin (SLF10), sulfaphenazole (SLF11), sulfapyridine (SLF12), sulfathiazole (SUT), sulfathiourea (SLF13), trimethoprim (TMP), and trimethoprim/sulfamethoxazole (SXT)  `ureidopenicillins()` can select:      azlocillin (AZL), mezlocillin (MEZ), piperacillin (PIP), and piperacillin/tazobactam (TZP) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r `example_isolates` is a data set available in the AMR package.', 'See ?example_isolates.example_isolates Examples sections below are split into \'base R\', \'dplyr\', and \'data.table\': base R ------------------------------------------------------------------ select columns \'IPM\' (imipenem) and \'MEM\' (meropenem)example_isolates[, carbapenems()] select columns \'mo\', \'AMK\', \'GEN\', \'KAN\' and \'TOB\'example_isolates[, c(""mo"", aminoglycosides())] select only antibiotic columns with DDDs for oral treatmentexample_isolates[, administrable_per_os()] filter using any() or all()example_isolates[any(carbapenems() == ""R""), ]subset(example_isolates, any(carbapenems() == ""R"")) filter on any or all results in the carbapenem columns (i.e., IPM, MEM):example_isolates[any(carbapenems()), ]example_isolates[all(carbapenems()), ] filter with multiple antibiotic selectors using c()example_isolates[all(c(carbapenems(), aminoglycosides()) == ""R""), ] filter + select in one go: get penicillins in carbapenem-resistant strainsexample_isolates[any(carbapenems() == ""R""), penicillins()] You can combine selectors with \'&\' to be more specific.', ""For example, penicillins() would select benzylpenicillin ('peni G') and administrable_per_os() would select erythromycin."", 'Yet, when combined these drugs are both omitted since benzylpenicillin is not administrable per os and erythromycin is not a penicillin:example_isolates[, penicillins() & administrable_per_os()] ab_selector() applies a filter in the `antibiotics` data set and is thus very flexible.', 'For instance, to select antibiotic columns with an oral DDD of at least 1 gram:example_isolates[, ab_selector(oral_ddd > 1 & oral_units == ""g"")] dplyr -------------------------------------------------------------------if (require(""dplyr"")) {  tibble(kefzol = random_sir(5)) %>%    select(cephalosporins())}if (require(""dplyr"")) {   get AMR for all aminoglycosides e.g., per ward:  example_isolates %>%    group_by(ward) %>%    summarise(across(aminoglycosides(), resistance))}if (require(""dplyr"")) {   You can combine selectors with \'&\' to be more specific:  example_isolates %>%    select(penicillins() & administrable_per_os())}if (require(""dplyr"")) {   get AMR for only drugs that matter - no intrinsic resistance:  example_isolates %>%    filter(mo_genus() %in% c(""Escherichia"", ""Klebsiella"")) %>%    group_by(ward) %>%    summarise(across(not_intrinsic_resistant(), resistance))}if (require(""dplyr"")) {   get susceptibility for antibiotics whose name contains ""trim"":  example_isolates %>%    filter(first_isolate()) %>%    group_by(ward) %>%    summarise(across(ab_selector(name %like% ""trim""), susceptibility))}if (require(""dplyr"")) {   this will select columns \'IPM\' (imipenem) and \'MEM\' (meropenem):  example_isolates %>%    select(carbapenems())}if (require(""dplyr"")) {   this will select columns \'mo\', \'AMK\', \'GEN\', \'KAN\' and \'TOB\':  example_isolates %>%    select(mo, aminoglycosides())}if (require(""dplyr"")) {   any() and all() work in dplyr\'s filter() too:  example_isolates %>%    filter(      any(aminoglycosides() == ""R""),      all(cephalosporins_2nd() == ""R"")    )}if (require(""dplyr"")) {   also works with c():  example_isolates %>%    filter(any(c(carbapenems(), aminoglycosides()) == ""R""))}if (require(""dplyr"")) {   not setting any/all will automatically apply all():  example_isolates %>%    filter(aminoglycosides() == ""R"")}if (require(""dplyr"")) {   this will select columns \'mo\' and all antimycobacterial drugs (\'RIF\'):  example_isolates %>%    select(mo, ab_class(""mycobact""))}if (require(""dplyr"")) {   get bug/drug combinations for only glycopeptides in Gram-positives:  example_isolates %>%    filter(mo_is_gram_positive()) %>%    select(mo, glycopeptides()) %>%    bug_drug_combinations() %>%    format()}if (require(""dplyr"")) {  data.frame(    some_column = ""some_value"",    J01CA01 = ""S""  ) %>%  ATC code of ampicillin    select(penicillins())  only the \'J01CA01\' column will be selected}if (require(""dplyr"")) {   with recent versions of dplyr, this is all equal:  x <- example_isolates[carbapenems() == ""R"", ]  y <- example_isolates %>% filter(carbapenems() == ""R"")  z <- example_isolates %>% filter(if_all(carbapenems(), ~ .x == ""R""))  identical(x, y) && identical(y, z)} data.table -------------------------------------------------------------- data.table is supported as well, just use it in the same way as with base R, but add `with = FALSE` if using a single AB selector.if (require(""data.table"")) {  dt <- as.data.table(example_isolates)   this does not work, it returns column names  dt[, carbapenems()]}if (require(""data.table"")) {   so `with = FALSE` is required  dt[, carbapenems(), with = FALSE]} for multiple selections or AB selectors, `with = FALSE` is not needed:if (require(""data.table"")) {  dt[, c(""mo"", aminoglycosides())]}if (require(""data.table"")) {  dt[, c(carbapenems(), aminoglycosides())]} row filters are also supported:if (require(""data.table"")) {  dt[any(carbapenems() == ""S""), ]}if (require(""data.table"")) {  dt[any(carbapenems() == ""S""), penicillins(), with = FALSE]}```']",1," Antibiotic Selectors```rab_class(ab_class, only_sir_columns = FALSE, only_treatable = TRUE, ...)ab_selector(filter, only_sir_columns = FALSE, only_treatable = TRUE, ...)aminoglycosides(only_sir_columns = FALSE, only_treatable = TRUE, ...)aminopenicillins(only_sir_columns = FALSE, ...)antifungals(only_sir_columns = FALSE, ...)antimycobacterials(only_sir_columns = FALSE, ...)betalactams(only_sir_columns = FALSE, only_treatable = TRUE, ...)carbapenems(only_sir_columns = FALSE, only_treatable = TRUE, ...)cephalosporins(only_sir_columns = FALSE, ...)cephalosporins_1st(only_sir_columns = FALSE, ...)cephalosporins_2nd(only_sir_columns = FALSE, ...)cephalosporins_3rd(only_sir_columns = FALSE, ...)cephalosporins_4th(only_sir_columns = FALSE, ...)cephalosporins_5th(only_sir_columns = FALSE, ...)fluoroquinolones(only_sir_columns = FALSE, ...)glycopeptides(only_sir_columns = FALSE, ...)lincosamides(only_sir_columns = FALSE, ...)lipoglycopeptides(only_sir_columns = FALSE, ...)macrolides(only_sir_columns = FALSE, ...)oxazolidinones(only_sir_columns = FALSE, ...)penicillins(only_sir_columns = FALSE, ...)polymyxins(only_sir_columns = FALSE, only_treatable = TRUE, ...)streptogramins(only_sir_columns = FALSE, ...)quinolones(only_sir_columns = FALSE, ...)tetracyclines(only_sir_columns = FALSE, ...)trimethoprims(only_sir_columns = FALSE, ...)ureidopenicillins(only_sir_columns = FALSE, ...)administrable_per_os(only_sir_columns = FALSE, ...)administrable_iv(only_sir_columns = FALSE, ...)not_intrinsic_resistant(  only_sir_columns = FALSE,  col_mo = NULL,  version_expertrules = 3.3,  ...)``` Arguments- `ab_class`: an antimicrobial class or a part of it, such as `""carba""` and `""carbapenems""`. The columns `group`, `atc_group1` and `atc_group2` of the antibiotics data set will be searched (case-insensitive) for this value.- `only_sir_columns`: a logical to indicate whether only columns of class `sir` must be selected (default is `FALSE`), see `as.sir()`- `only_treatable`: a logical to indicate whether antimicrobial drugs should be excluded that are only for laboratory tests (default is `TRUE`), such as gentamicin-high (`GEH`) and imipenem/EDTA (`IPE`)- `...`: ignored, only in place to allow future extensions- `filter`: an expression to be evaluated in the antibiotics data set, such as `name %like% ""trim""`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline. Can be ""3.3"", ""3.2"", or ""3.1"". Returns(internally) a character vector of column names, with additional class `""ab_selector""` DescriptionThese functions allow for filtering rows and selecting columns based on antibiotic test results that are of a specific antibiotic class or group (according to the antibiotics data set), without the need to define the columns or antibiotic abbreviations.In short, if you have a column name that resembles an antimicrobial drug, it will be picked up by any of these functions that matches its pharmaceutical class: ""cefazolin"", ""kefzol"", ""CZO"" and ""J01DB04"" will all be picked up by `cephalosporins()`. DetailsThese functions can be used in data set calls for selecting columns and filtering rows. They work with base , the Tidyverse, and `data.table`. They are heavily inspired by the Tidyverse selection helpers such as `everything()`, but are not limited to `dplyr` verbs. Nonetheless, they are very convenient to use with `dplyr` functions such as `select()`, `filter()` and `summarise()`, see Examples.All columns in the data in which these functions are called will be searched for known antibiotic names, abbreviations, brand names, and codes (ATC, EARS-Net, WHO, etc.) according to the antibiotics data set. This means that a selector such as `aminoglycosides()` will pick up column names like 'gen', 'genta', 'J01GB03', 'tobra', 'Tobracin', etc.The `ab_class()` function can be used to filter/select on a manually defined antibiotic class. It searches for results in the antibiotics data set within the columns `group`, `atc_group1` and `atc_group2`.The `ab_selector()` function can be used to internally filter the antibiotics data set on any results, see Examples. It allows for filtering on a (part of) a certain name, and/or a group name or even a minimum of DDDs for oral treatment. This function yields the highest flexibility, but is also the least user-friendly, since it requires a hard-coded filter to set.The `administrable_per_os()` and `administrable_iv()` functions also rely on the antibiotics data set - antibiotic columns will be matched where a DDD (defined daily dose) for resp. oral and IV treatment is available in the antibiotics data set.The `not_intrinsic_resistant()` function can be used to only select antibiotic columns that pose no intrinsic resistance for the microorganisms in the data set. For example, if a data set contains only microorganism codes or names of E. coli and K. pneumoniae and contains a column ""vancomycin"", this column will be removed (or rather, unselected) using this function. It currently applies ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021) to determine intrinsic resistance, using the `eucast_rules()` function internally. Because of this determination, this function is quite slow in terms of performance. Full list of supported (antibiotic) classes  `aminoglycosides()` can select:      amikacin (AMK), amikacin/fosfomycin (AKF), amphotericin B-high (AMH), apramycin (APR), arbekacin (ARB), astromicin (AST), bekanamycin (BEK), dibekacin (DKB), framycetin (FRM), gentamicin (GEN), gentamicin-high (GEH), habekacin (HAB), hygromycin (HYG), isepamicin (ISE), kanamycin (KAN), kanamycin-high (KAH), kanamycin/cephalexin (KAC), micronomicin (MCR), neomycin (NEO), netilmicin (NET), pentisomicin (PIM), plazomicin (PLZ), propikacin (PKA), ribostamycin (RST), sisomicin (SIS), streptoduocin (STR), streptomycin (STR1), streptomycin-high (STH), tobramycin (TOB), and tobramycin-high (TOH)  `aminopenicillins()` can select:      amoxicillin (AMX) and ampicillin (AMP)  `antifungals()` can select:      amphotericin B (AMB), anidulafungin (ANI), butoconazole (BUT), caspofungin (CAS), ciclopirox (CIX), clotrimazole (CTR), econazole (ECO), fluconazole (FLU), flucytosine (FCT), fosfluconazole (FFL), griseofulvin (GRI), hachimycin (HCH), ibrexafungerp (IBX), isavuconazole (ISV), isoconazole (ISO), itraconazole (ITR), ketoconazole (KET), manogepix (MGX), micafungin (MIF), miconazole (MCZ), nystatin (NYS), oteseconazole (OTE), pimaricin (PMR), posaconazole (POS), rezafungin (RZF), ribociclib (RBC), sulconazole (SUC), terbinafine (TRB), terconazole (TRC), and voriconazole (VOR)  `antimycobacterials()` can select:      4-aminosalicylic acid (AMA), calcium aminosalicylate (CLA), capreomycin (CAP), clofazimine (CLF), delamanid (DLM), enviomycin (ENV), ethambutol (ETH), ethambutol/isoniazid (ETI), ethionamide (ETI1), isoniazid (INH), isoniazid/sulfamethoxazole/trimethoprim/pyridoxine (IST), morinamide (MRN), p-aminosalicylic acid (PAS), pretomanid (PMD), protionamide (PTH), pyrazinamide (PZA), rifabutin (RIB), rifampicin (RIF), rifampicin/ethambutol/isoniazid (REI), rifampicin/isoniazid (RFI), rifampicin/pyrazinamide/ethambutol/isoniazid (RPEI), rifampicin/pyrazinamide/isoniazid (RPI), rifamycin (RFM), rifapentine (RFP), simvastatin/fenofibrate (SMF), sodium aminosalicylate (SDA), streptomycin/isoniazid (STI), terizidone (TRZ), thioacetazone (TAT), thioacetazone/isoniazid (THI1), tiocarlide (TCR), and viomycin (VIO)  `betalactams()` can select:      amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), biapenem (BIA), carbenicillin (CRB), carindacillin (CRN), cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/nacubactam (FNC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), doripenem (DOR), epicillin (EPC), ertapenem (ETP), flucloxacillin (FLC), hetacillin (HET), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), latamoxef (LTM), lenampicillin (LEN), loracarbef (LOR), mecillinam (MEC), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), panipenem (PAN), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), tebipenem (TBP), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)  `carbapenems()` can select:      biapenem (BIA), doripenem (DOR), ertapenem (ETP), imipenem (IPM), imipenem/EDTA (IPE), imipenem/relebactam (IMR), meropenem (MEM), meropenem/nacubactam (MNC), meropenem/vaborbactam (MEV), panipenem (PAN), razupenem (RZM), ritipenem (RIT), ritipenem acoxil (RIA), and tebipenem (TBP)  `cephalosporins()` can select:      cefacetrile (CAC), cefaclor (CEC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefamandole (MAN), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetamet (CAT), cefetamet pivoxil (CPI), cefetecol (CCL), cefetrizole (CZL), cefixime (CFM), cefmenoxime (CMX), cefmetazole (CMZ), cefodizime (DIZ), cefonicid (CID), cefoperazone (CFP), cefoperazone/sulbactam (CSL), ceforanide (CND), cefoselis (CSE), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotetan (CTT), cefotiam (CTF), cefotiam hexetil (CHE), cefovecin (FOV), cefoxitin (FOX), cefoxitin screening (FOX1), cefozopran (ZOP), cefpimizole (CFZ), cefpiramide (CPM), cefpirome (CPO), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefprozil (CPR), cefquinome (CEQ), cefroxadine (CRD), cefsulodin (CFS), cefsumide (CSU), ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftezole (CTL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), ceftolozane/tazobactam (CZT), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), cefuroxime (CXM), cefuroxime axetil (CXA), cephradine (CED), latamoxef (LTM), and loracarbef (LOR)  `cephalosporins_1st()` can select:      cefacetrile (CAC), cefadroxil (CFR), cefalexin (LEX), cefaloridine (RID), cefalotin (CEP), cefapirin (HAP), cefatrizine (CTZ), cefazedone (CZD), cefazolin (CZO), cefroxadine (CRD), ceftezole (CTL), and cephradine (CED)  `cephalosporins_2nd()` can select:      cefaclor (CEC), cefamandole (MAN), cefmetazole (CMZ), cefonicid (CID), ceforanide (CND), cefotetan (CTT), cefotiam (CTF), cefoxitin (FOX), cefoxitin screening (FOX1), cefprozil (CPR), cefuroxime (CXM), cefuroxime axetil (CXA), and loracarbef (LOR)  `cephalosporins_3rd()` can select:      cefcapene (CCP), cefcapene pivoxil (CCX), cefdinir (CDR), cefditoren (DIT), cefditoren pivoxil (DIX), cefetamet (CAT), cefetamet pivoxil (CPI), cefixime (CFM), cefmenoxime (CMX), cefodizime (DIZ), cefoperazone (CFP), cefoperazone/sulbactam (CSL), cefotaxime (CTX), cefotaxime/clavulanic acid (CTC), cefotaxime/sulbactam (CTS), cefotiam hexetil (CHE), cefovecin (FOV), cefpimizole (CFZ), cefpiramide (CPM), cefpodoxime (CPD), cefpodoxime proxetil (CPX), cefpodoxime/clavulanic acid (CDC), cefsulodin (CFS), ceftazidime (CAZ), ceftazidime/avibactam (CZA), ceftazidime/clavulanic acid (CCV), cefteram (CEM), cefteram pivoxil (CPL), ceftibuten (CTB), ceftiofur (TIO), ceftizoxime (CZX), ceftizoxime alapivoxil (CZP), ceftriaxone (CRO), ceftriaxone/beta-lactamase inhibitor (CEB), and latamoxef (LTM)  `cephalosporins_4th()` can select:      cefepime (FEP), cefepime/clavulanic acid (CPC), cefepime/tazobactam (FPT), cefetecol (CCL), cefoselis (CSE), cefozopran (ZOP), cefpirome (CPO), and cefquinome (CEQ)  `cephalosporins_5th()` can select:      ceftaroline (CPT), ceftaroline/avibactam (CPA), ceftobiprole (BPR), ceftobiprole medocaril (CFM1), and ceftolozane/tazobactam (CZT)  `fluoroquinolones()` can select:      besifloxacin (BES), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nifuroquine (NIF), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), pazufloxacin (PAZ), pefloxacin (PEF), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)  `glycopeptides()` can select:      avoparcin (AVO), dalbavancin (DAL), norvancomycin (NVA), oritavancin (ORI), ramoplanin (RAM), teicoplanin (TEC), teicoplanin-macromethod (TCM), telavancin (TLV), vancomycin (VAN), and vancomycin-macromethod (VAM)  `lincosamides()` can select:      acetylmidecamycin (ACM), acetylspiramycin (ASP), clindamycin (CLI), gamithromycin (GAM), kitasamycin (KIT), lincomycin (LIN), meleumycin (MEL), nafithromycin (ZWK), pirlimycin (PRL), primycin (PRM), solithromycin (SOL), tildipirosin (TIP), tilmicosin (TIL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)  `lipoglycopeptides()` can select:      dalbavancin (DAL), oritavancin (ORI), and telavancin (TLV)  `macrolides()` can select:      acetylmidecamycin (ACM), acetylspiramycin (ASP), azithromycin (AZM), clarithromycin (CLR), dirithromycin (DIR), erythromycin (ERY), flurithromycin (FLR1), gamithromycin (GAM), josamycin (JOS), kitasamycin (KIT), meleumycin (MEL), midecamycin (MID), miocamycin (MCM), nafithromycin (ZWK), oleandomycin (OLE), pirlimycin (PRL), primycin (PRM), rokitamycin (ROK), roxithromycin (RXT), solithromycin (SOL), spiramycin (SPI), telithromycin (TLT), tildipirosin (TIP), tilmicosin (TIL), troleandomycin (TRL), tulathromycin (TUL), tylosin (TYL), and tylvalosin (TYL1)  `oxazolidinones()` can select:      cadazolid (CDZ), cycloserine (CYC), linezolid (LNZ), tedizolid (TZD), and thiacetazone (THA)  `penicillins()` can select:      amoxicillin (AMX), amoxicillin/clavulanic acid (AMC), amoxicillin/sulbactam (AXS), ampicillin (AMP), ampicillin/sulbactam (SAM), apalcillin (APL), aspoxicillin (APX), avibactam (AVB), azidocillin (AZD), azlocillin (AZL), aztreonam (ATM), aztreonam/avibactam (AZA), aztreonam/nacubactam (ANC), bacampicillin (BAM), benzathine benzylpenicillin (BNB), benzathine phenoxymethylpenicillin (BNP), benzylpenicillin (PEN), carbenicillin (CRB), carindacillin (CRN), cefepime/nacubactam (FNC), ciclacillin (CIC), clometocillin (CLM), cloxacillin (CLO), dicloxacillin (DIC), epicillin (EPC), flucloxacillin (FLC), hetacillin (HET), lenampicillin (LEN), mecillinam (MEC), metampicillin (MTM), meticillin (MET), mezlocillin (MEZ), mezlocillin/sulbactam (MSU), nacubactam (NAC), nafcillin (NAF), oxacillin (OXA), penamecillin (PNM), penicillin/novobiocin (PNO), penicillin/sulbactam (PSU), pheneticillin (PHE), phenoxymethylpenicillin (PHN), piperacillin (PIP), piperacillin/sulbactam (PIS), piperacillin/tazobactam (TZP), piridicillin (PRC), pivampicillin (PVM), pivmecillinam (PME), procaine benzylpenicillin (PRB), propicillin (PRP), sarmoxicillin (SRX), sulbactam (SUL), sulbenicillin (SBC), sultamicillin (SLT6), talampicillin (TAL), tazobactam (TAZ), temocillin (TEM), ticarcillin (TIC), and ticarcillin/clavulanic acid (TCC)  `polymyxins()` can select:      colistin (COL), polymyxin B (PLB), and polymyxin B/polysorbate 80 (POP)  `quinolones()` can select:      besifloxacin (BES), cinoxacin (CIN), ciprofloxacin (CIP), clinafloxacin (CLX), danofloxacin (DAN), delafloxacin (DFX), difloxacin (DIF), enoxacin (ENX), enrofloxacin (ENR), finafloxacin (FIN), fleroxacin (FLE), flumequine (FLM), garenoxacin (GRN), gatifloxacin (GAT), gemifloxacin (GEM), grepafloxacin (GRX), lascufloxacin (LSC), levofloxacin (LVX), levonadifloxacin (LND), lomefloxacin (LOM), marbofloxacin (MAR), metioxate (MXT), miloxacin (MIL), moxifloxacin (MFX), nadifloxacin (NAD), nalidixic acid (NAL), nemonoxacin (NEM), nifuroquine (NIF), nitroxoline (NTR), norfloxacin (NOR), ofloxacin (OFX), orbifloxacin (ORB), oxolinic acid (OXO), pazufloxacin (PAZ), pefloxacin (PEF), pipemidic acid (PPA), piromidic acid (PIR), pradofloxacin (PRA), premafloxacin (PRX), prulifloxacin (PRU), rosoxacin (ROS), rufloxacin (RFL), sarafloxacin (SAR), sitafloxacin (SIT), sparfloxacin (SPX), temafloxacin (TMX), tilbroquinol (TBQ), tioxacin (TXC), tosufloxacin (TFX), and trovafloxacin (TVA)  `streptogramins()` can select:      pristinamycin (PRI) and quinupristin/dalfopristin (QDA)  `tetracyclines()` can select:      cetocycline (CTO), chlortetracycline (CTE), clomocycline (CLM1), demeclocycline (DEM), doxycycline (DOX), eravacycline (ERV), lymecycline (LYM), metacycline (MTC), minocycline (MNO), omadacycline (OMC), oxytetracycline (OXY), penimepicycline (PNM1), rolitetracycline (RLT), sarecycline (SRC), tetracycline (TCY), and tigecycline (TGC)  `trimethoprims()` can select:      brodimoprim (BDP), sulfadiazine (SDI), sulfadiazine/tetroxoprim (SLT), sulfadiazine/trimethoprim (SLT1), sulfadimethoxine (SUD), sulfadimidine (SDM), sulfadimidine/trimethoprim (SLT2), sulfafurazole (SLF), sulfaisodimidine (SLF1), sulfalene (SLF2), sulfamazone (SZO), sulfamerazine (SLF3), sulfamerazine/trimethoprim (SLT3), sulfamethizole (SLF4), sulfamethoxazole (SMX), sulfamethoxypyridazine (SLF5), sulfametomidine (SLF6), sulfametoxydiazine (SLF7), sulfametrole/trimethoprim (SLT4), sulfamoxole (SLF8), sulfamoxole/trimethoprim (SLT5), sulfanilamide (SLF9), sulfaperin (SLF10), sulfaphenazole (SLF11), sulfapyridine (SLF12), sulfathiazole (SUT), sulfathiourea (SLF13), trimethoprim (TMP), and trimethoprim/sulfamethoxazole (SXT)  `ureidopenicillins()` can select:      azlocillin (AZL), mezlocillin (MEZ), piperacillin (PIP), and piperacillin/tazobactam (TZP) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r `example_isolates` is a data set available in the AMR package. See ?example_isolates.example_isolates Examples sections below are split into 'base R', 'dplyr', and 'data.table': base R ------------------------------------------------------------------ select columns 'IPM' (imipenem) and 'MEM' (meropenem)example_isolates[, carbapenems()] select columns 'mo', 'AMK', 'GEN', 'KAN' and 'TOB'example_isolates[, c(""mo"", aminoglycosides())] select only antibiotic columns with DDDs for oral treatmentexample_isolates[, administrable_per_os()] filter using any() or all()example_isolates[any(carbapenems() == ""R""), ]subset(example_isolates, any(carbapenems() == ""R"")) filter on any or all results in the carbapenem columns (i.e., IPM, MEM):example_isolates[any(carbapenems()), ]example_isolates[all(carbapenems()), ] filter with multiple antibiotic selectors using c()example_isolates[all(c(carbapenems(), aminoglycosides()) == ""R""), ] filter + select in one go: get penicillins in carbapenem-resistant strainsexample_isolates[any(carbapenems() == ""R""), penicillins()] You can combine selectors with '&' to be more specific. For example, penicillins() would select benzylpenicillin ('peni G') and administrable_per_os() would select erythromycin. Yet, when combined these drugs are both omitted since benzylpenicillin is not administrable per os and erythromycin is not a penicillin:example_isolates[, penicillins() & administrable_per_os()] ab_selector() applies a filter in the `antibiotics` data set and is thus very flexible. For instance, to select antibiotic columns with an oral DDD of at least 1 gram:example_isolates[, ab_selector(oral_ddd > 1 & oral_units == ""g"")] dplyr -------------------------------------------------------------------if (require(""dplyr"")) {  tibble(kefzol = random_sir(5)) %>%    select(cephalosporins())}if (require(""dplyr"")) {   get AMR for all aminoglycosides e.g., per ward:  example_isolates %>%    group_by(ward) %>%    summarise(across(aminoglycosides(), resistance))}if (require(""dplyr"")) {   You can combine selectors with '&' to be more specific:  example_isolates %>%    select(penicillins() & administrable_per_os())}if (require(""dplyr"")) {   get AMR for only drugs that matter - no intrinsic resistance:  example_isolates %>%    filter(mo_genus() %in% c(""Escherichia"", ""Klebsiella"")) %>%    group_by(ward) %>%    summarise(across(not_intrinsic_resistant(), resistance))}if (require(""dplyr"")) {   get susceptibility for antibiotics whose name contains ""trim"":  example_isolates %>%    filter(first_isolate()) %>%    group_by(ward) %>%    summarise(across(ab_selector(name %like% ""trim""), susceptibility))}if (require(""dplyr"")) {   this will select columns 'IPM' (imipenem) and 'MEM' (meropenem):  example_isolates %>%    select(carbapenems())}if (require(""dplyr"")) {   this will select columns 'mo', 'AMK', 'GEN', 'KAN' and 'TOB':  example_isolates %>%    select(mo, aminoglycosides())}if (require(""dplyr"")) {   any() and all() work in dplyr's filter() too:  example_isolates %>%    filter(      any(aminoglycosides() == ""R""),      all(cephalosporins_2nd() == ""R"")    )}if (require(""dplyr"")) {   also works with c():  example_isolates %>%    filter(any(c(carbapenems(), aminoglycosides()) == ""R""))}if (require(""dplyr"")) {   not setting any/all will automatically apply all():  example_isolates %>%    filter(aminoglycosides() == ""R"")}if (require(""dplyr"")) {   this will select columns 'mo' and all antimycobacterial drugs ('RIF'):  example_isolates %>%    select(mo, ab_class(""mycobact""))}if (require(""dplyr"")) {   get bug/drug combinations for only glycopeptides in Gram-positives:  example_isolates %>%    filter(mo_is_gram_positive()) %>%    select(mo, glycopeptides()) %>%    bug_drug_combinations() %>%    format()}if (require(""dplyr"")) {  data.frame(    some_column = ""some_value"",    J01CA01 = ""S""  ) %>%  ATC code of ampicillin    select(penicillins())  only the 'J01CA01' column will be selected}if (require(""dplyr"")) {   with recent versions of dplyr, this is all equal:  x <- example_isolates[carbapenems() == ""R"", ]  y <- example_isolates %>% filter(carbapenems() == ""R"")  z <- example_isolates %>% filter(if_all(carbapenems(), ~ .x == ""R""))  identical(x, y) && identical(y, z)} data.table -------------------------------------------------------------- data.table is supported as well, just use it in the same way as with base R, but add `with = FALSE` if using a single AB selector.if (require(""data.table"")) {  dt <- as.data.table(example_isolates)   this does not work, it returns column names  dt[, carbapenems()]}if (require(""data.table"")) {   so `with = FALSE` is required  dt[, carbapenems(), with = FALSE]} for multiple selections or AB selectors, `with = FALSE` is not needed:if (require(""data.table"")) {  dt[, c(""mo"", aminoglycosides())]}if (require(""data.table"")) {  dt[, c(carbapenems(), aminoglycosides())]} row filters are also supported:if (require(""data.table"")) {  dt[any(carbapenems() == ""S""), ]}if (require(""data.table"")) {  dt[any(carbapenems() == ""S""), penicillins(), with = FALSE]}```",1
AMR,AMR-deprecated.md," data

# Deprecated Functions

## Format

An object of class `rsi` (inherits from `ordered`, `factor`) of length 1.

```r
NA_rsi_

as.rsi(x, ...)

facet_rsi(...)

geom_rsi(...)

ggplot_rsi(...)

ggplot_rsi_predict(...)

is.rsi(...)

is.rsi.eligible(...)

labels_rsi_count(...)

n_rsi(...)

random_rsi(...)

rsi_df(...)

rsi_predict(...)

scale_rsi_colours(...)

theme_rsi(...)
```

## Description

These functions are so-called 'Deprecated '. They will be removed in a future release. Using the functions will give a warning with the name of the function it has been replaced by (if there is one).



","[""data Deprecated Functions FormatAn object of class `rsi` (inherits from `ordered`, `factor`) of length 1.```rNA_rsi_as.rsi(x, ...)facet_rsi(...)geom_rsi(...)ggplot_rsi(...)ggplot_rsi_predict(...)is.rsi(...)is.rsi.eligible(...)labels_rsi_count(...)n_rsi(...)random_rsi(...)rsi_df(...)rsi_predict(...)scale_rsi_colours(...)theme_rsi(...)``` DescriptionThese functions are so-called 'Deprecated '."", 'They will be removed in a future release.', 'Using the functions will give a warning with the name of the function it has been replaced by (if there is one).']",1," data Deprecated Functions FormatAn object of class `rsi` (inherits from `ordered`, `factor`) of length 1.```rNA_rsi_as.rsi(x, ...)facet_rsi(...)geom_rsi(...)ggplot_rsi(...)ggplot_rsi_predict(...)is.rsi(...)is.rsi.eligible(...)labels_rsi_count(...)n_rsi(...)random_rsi(...)rsi_df(...)rsi_predict(...)scale_rsi_colours(...)theme_rsi(...)``` DescriptionThese functions are so-called 'Deprecated '. They will be removed in a future release. Using the functions will give a warning with the name of the function it has been replaced by (if there is one).",2
AMR,get_episode.md,"# Determine Clinical or Epidemic Episodes

```r
get_episode(x, episode_days = NULL, case_free_days = NULL, ...)

is_new_episode(x, episode_days = NULL, case_free_days = NULL, ...)
```

## Arguments

- `x`: vector of dates (class `Date` or `POSIXt`), will be sorted internally to determine episodes
- `episode_days`: episode length in days to specify the time period after which a new episode begins, can also be less than a day or `Inf`, see **Details**
- `case_free_days`: (inter-epidemic) interval length in days after which a new episode will start, can also be less than a day or `Inf`, see **Details**
- `...`: ignored, only in place to allow future extensions

## Returns

 * `get_episode()`: an integer vector
 * `is_new_episode()`: a logical vector

## Description

These functions determine which items in a vector can be considered (the start of) a new episode. This can be used to determine clinical episodes for any epidemiological analysis. The `get_episode()` function returns the index number of the episode per group, while the `is_new_episode()` function returns `TRUE` for every new `get_episode()` index. Both absolute and relative episode determination are supported.

## Details

Episodes can be determined in two ways: absolute and relative.

1. Absolute
   
   This method uses `episode_days` to define an episode length in days, after which a new episode will start. A common use case in AMR data analysis is microbial epidemiology: episodes of **S. aureus** bacteraemia in ICU patients for example. The episode length could then be 30 days, so that new **S. aureus** isolates after an ICU episode of 30 days will be considered a different (or new) episode.
   
   Thus, this method counts since the start of the previous episode .
2. Relative
   
   This method uses `case_free_days` to quantify the duration of case-free days (the inter-epidemic interval), after which a new episode will start. A common use case is infectious disease epidemiology: episodes of norovirus outbreaks in a hospital for example. The case-free period could then be 14 days, so that new norovirus cases after that time will be considered a different (or new) episode.
   
   Thus, this methods counts since the last case in the previous episode .

In a table:

||||
|:-:|:-:|:-:|
|Date|Using  `episode_days = 7`|Using  `case_free_days = 7`|
|2023-01-01|1|1|
|2023-01-02|1|1|
|2023-01-05|1|1|
|2023-01-08|2**|1|
|2023-02-21|3|2***|
|2023-02-22|3|2|
|2023-02-23|3|2|
|2023-02-24|3|2|
|2023-03-01|4|2|

** This marks the start of a new episode, because 8 January 2023 is more than 7 days since the start of the previous episode (1 January 2023). 

*** This marks the start of a new episode, because 21 January 2023 is more than 7 days since the last case in the previous episode (8 January 2023).


Either `episode_days` or `case_free_days` must be provided in the function.

### Difference between `get_episode()` and `is_new_episode()`

 The `get_episode()` function returns the index number of the episode, so all cases/patients/isolates in the first episode will have the number 1, all cases/patients/isolates in the second episode will have the number 2, etc.

The `is_new_episode()` function on the other hand, returns `TRUE` for every new `get_episode()` index.

To specify, when setting `episode_days = 365` (using method 1 as explained above), this is how the two functions differ:

|||||
|:-:|:-:|:-:|:-:|
|patient|date|`get_episode()`|`is_new_episode()`|
|A|2019-01-01|1|TRUE|
|A|2019-03-01|1|FALSE|
|A|2021-01-01|2|TRUE|
|B|2008-01-01|1|TRUE|
|B|2008-01-01|1|FALSE|
|C|2020-01-01|1|TRUE|

### Other

 The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but is more efficient for data sets containing microorganism codes or names and allows for different isolate selection methods.

The `dplyr` package is not required for these functions to work, but these episode functions do support variable grouping and work conveniently inside `dplyr` verbs such as `filter()`, `mutate()` and `summarise()`.

## Examples

```r
# difference between absolute and relative determination of episodes:
x <- data.frame(dates = as.Date(c(
  ""2021-01-01"",
  ""2021-01-02"",
  ""2021-01-05"",
  ""2021-01-08"",
  ""2021-02-21"",
  ""2021-02-22"",
  ""2021-02-23"",
  ""2021-02-24"",
  ""2021-03-01"",
  ""2021-03-01""
)))
x$absolute <- get_episode(x$dates, episode_days = 7)
x$relative <- get_episode(x$dates, case_free_days = 7)
x


# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates
df <- example_isolates[sample(seq_len(2000), size = 100), ]

get_episode(df$date, episode_days = 60) # indices
is_new_episode(df$date, episode_days = 60) # TRUE/FALSE

# filter on results from the third 60-day episode only, using base R
df[which(get_episode(df$date, 60) == 3), ]

# the functions also work for less than a day, e.g. to include one per hour:
get_episode(
  c(
    Sys.time(),
    Sys.time() + 60 * 60
  ),
  episode_days = 1 / 24
)


if (require(""dplyr"")) {
  # is_new_episode() can also be used in dplyr verbs to determine patient
  # episodes based on any (combination of) grouping variables:
  df %>%
    mutate(condition = sample(
      x = c(""A"", ""B"", ""C""),
      size = 100,
      replace = TRUE
    )) %>%
    group_by(patient, condition) %>%
    mutate(new_episode = is_new_episode(date, 365)) %>%
    select(patient, date, condition, new_episode) %>%
    arrange(patient, condition, date)
}

if (require(""dplyr"")) {
  df %>%
    group_by(ward, patient) %>%
    transmute(date,
      patient,
      new_index = get_episode(date, 60),
      new_logical = is_new_episode(date, 60)
    ) %>%
    arrange(patient, ward, date)
}

if (require(""dplyr"")) {
  df %>%
    group_by(ward) %>%
    summarise(
      n_patients = n_distinct(patient),
      n_episodes_365 = sum(is_new_episode(date, episode_days = 365)),
      n_episodes_60 = sum(is_new_episode(date, episode_days = 60)),
      n_episodes_30 = sum(is_new_episode(date, episode_days = 30))
    )
}

# grouping on patients and microorganisms leads to the same
# results as first_isolate() when using 'episode-based':
if (require(""dplyr"")) {
  x <- df %>%
    filter_first_isolate(
      include_unknown = TRUE,
      method = ""episode-based""
    )

  y <- df %>%
    group_by(patient, mo) %>%
    filter(is_new_episode(date, 365)) %>%
    ungroup()

  identical(x, y)
}

# but is_new_episode() has a lot more flexibility than first_isolate(),
# since you can now group on anything that seems relevant:
if (require(""dplyr"")) {
  df %>%
    group_by(patient, mo, ward) %>%
    mutate(flag_episode = is_new_episode(date, 365)) %>%
    select(group_vars(.), flag_episode)
}
```

## See Also

`first_isolate()`



","['Determine Clinical or Epidemic Episodes```rget_episode(x, episode_days = NULL, case_free_days = NULL, ...)is_new_episode(x, episode_days = NULL, case_free_days = NULL, ...)``` Arguments- `x`: vector of dates (class `Date` or `POSIXt`), will be sorted internally to determine episodes- `episode_days`: episode length in days to specify the time period after which a new episode begins, can also be less than a day or `Inf`, see Details- `case_free_days`: (inter-epidemic) interval length in days after which a new episode will start, can also be less than a day or `Inf`, see Details- `...`: ignored, only in place to allow future extensions Returns  `get_episode()`: an integer vector  `is_new_episode()`: a logical vector DescriptionThese functions determine which items in a vector can be considered (the start of) a new episode.', 'This can be used to determine clinical episodes for any epidemiological analysis.', 'The `get_episode()` function returns the index number of the episode per group, while the `is_new_episode()` function returns `TRUE` for every new `get_episode()` index.', 'Both absolute and relative episode determination are supported.', 'DetailsEpisodes can be determined in two ways: absolute and relative.1.', 'Absolute      This method uses `episode_days` to define an episode length in days, after which a new episode will start.', 'A common use case in AMR data analysis is microbial epidemiology: episodes of S. aureus bacteraemia in ICU patients for example.', 'The episode length could then be 30 days, so that new S. aureus isolates after an ICU episode of 30 days will be considered a different (or new) episode.', 'Thus, this method counts since the start of the previous episode .2.', 'Relative      This method uses `case_free_days` to quantify the duration of case-free days (the inter-epidemic interval), after which a new episode will start.', 'A common use case is infectious disease epidemiology: episodes of norovirus outbreaks in a hospital for example.', 'The case-free period could then be 14 days, so that new norovirus cases after that time will be considered a different (or new) episode.', 'Thus, this methods counts since the last case in the previous episode .In a table:|||||:-:|:-:|:-:||Date|Using  `episode_days = 7`|Using  `case_free_days = 7`||2023-01-01|1|1||2023-01-02|1|1||2023-01-05|1|1||2023-01-08|2|1||2023-02-21|3|2||2023-02-22|3|2||2023-02-23|3|2||2023-02-24|3|2||2023-03-01|4|2| This marks the start of a new episode, because 8 January 2023 is more than 7 days since the start of the previous episode (1 January 2023).', 'This marks the start of a new episode, because 21 January 2023 is more than 7 days since the last case in the previous episode (8 January 2023).Either `episode_days` or `case_free_days` must be provided in the function.', 'Difference between `get_episode()` and `is_new_episode()` The `get_episode()` function returns the index number of the episode, so all cases/patients/isolates in the first episode will have the number 1, all cases/patients/isolates in the second episode will have the number 2, etc.The `is_new_episode()` function on the other hand, returns `TRUE` for every new `get_episode()` index.To specify, when setting `episode_days = 365` (using method 1 as explained above), this is how the two functions differ:||||||:-:|:-:|:-:|:-:||patient|date|`get_episode()`|`is_new_episode()`||A|2019-01-01|1|TRUE||A|2019-03-01|1|FALSE||A|2021-01-01|2|TRUE||B|2008-01-01|1|TRUE||B|2008-01-01|1|FALSE||C|2020-01-01|1|TRUE| Other The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but is more efficient for data sets containing microorganism codes or names and allows for different isolate selection methods.The `dplyr` package is not required for these functions to work, but these episode functions do support variable grouping and work conveniently inside `dplyr` verbs such as `filter()`, `mutate()` and `summarise()`.', 'Examples```r difference between absolute and relative determination of episodes:x <- data.frame(dates = as.Date(c(  ""2021-01-01"",  ""2021-01-02"",  ""2021-01-05"",  ""2021-01-08"",  ""2021-02-21"",  ""2021-02-22"",  ""2021-02-23"",  ""2021-02-24"",  ""2021-03-01"",  ""2021-03-01"")))x$absolute <- get_episode(x$dates, episode_days = 7)x$relative <- get_episode(x$dates, case_free_days = 7)x `example_isolates` is a data set available in the AMR package.', 'See ?example_isolatesdf <- example_isolates[sample(seq_len(2000), size = 100), ]get_episode(df$date, episode_days = 60)  indicesis_new_episode(df$date, episode_days = 60)  TRUE/FALSE filter on results from the third 60-day episode only, using base Rdf[which(get_episode(df$date, 60) == 3), ] the functions also work for less than a day, e.g.', 'to include one per hour:get_episode(  c(    Sys.time(),    Sys.time() + 60  60  ),  episode_days = 1 / 24)if (require(""dplyr"")) {   is_new_episode() can also be used in dplyr verbs to determine patient   episodes based on any (combination of) grouping variables:  df %>%    mutate(condition = sample(      x = c(""A"", ""B"", ""C""),      size = 100,      replace = TRUE    )) %>%    group_by(patient, condition) %>%    mutate(new_episode = is_new_episode(date, 365)) %>%    select(patient, date, condition, new_episode) %>%    arrange(patient, condition, date)}if (require(""dplyr"")) {  df %>%    group_by(ward, patient) %>%    transmute(date,      patient,      new_index = get_episode(date, 60),      new_logical = is_new_episode(date, 60)    ) %>%    arrange(patient, ward, date)}if (require(""dplyr"")) {  df %>%    group_by(ward) %>%    summarise(      n_patients = n_distinct(patient),      n_episodes_365 = sum(is_new_episode(date, episode_days = 365)),      n_episodes_60 = sum(is_new_episode(date, episode_days = 60)),      n_episodes_30 = sum(is_new_episode(date, episode_days = 30))    )} grouping on patients and microorganisms leads to the same results as first_isolate() when using \'episode-based\':if (require(""dplyr"")) {  x <- df %>%    filter_first_isolate(      include_unknown = TRUE,      method = ""episode-based""    )  y <- df %>%    group_by(patient, mo) %>%    filter(is_new_episode(date, 365)) %>%    ungroup()  identical(x, y)} but is_new_episode() has a lot more flexibility than first_isolate(), since you can now group on anything that seems relevant:if (require(""dplyr"")) {  df %>%    group_by(patient, mo, ward) %>%    mutate(flag_episode = is_new_episode(date, 365)) %>%    select(group_vars(.']",1," Determine Clinical or Epidemic Episodes```rget_episode(x, episode_days = NULL, case_free_days = NULL, ...)is_new_episode(x, episode_days = NULL, case_free_days = NULL, ...)``` Arguments- `x`: vector of dates (class `Date` or `POSIXt`), will be sorted internally to determine episodes- `episode_days`: episode length in days to specify the time period after which a new episode begins, can also be less than a day or `Inf`, see Details- `case_free_days`: (inter-epidemic) interval length in days after which a new episode will start, can also be less than a day or `Inf`, see Details- `...`: ignored, only in place to allow future extensions Returns  `get_episode()`: an integer vector  `is_new_episode()`: a logical vector DescriptionThese functions determine which items in a vector can be considered (the start of) a new episode. This can be used to determine clinical episodes for any epidemiological analysis. The `get_episode()` function returns the index number of the episode per group, while the `is_new_episode()` function returns `TRUE` for every new `get_episode()` index. Both absolute and relative episode determination are supported. DetailsEpisodes can be determined in two ways: absolute and relative.1. Absolute      This method uses `episode_days` to define an episode length in days, after which a new episode will start. A common use case in AMR data analysis is microbial epidemiology: episodes of S. aureus bacteraemia in ICU patients for example. The episode length could then be 30 days, so that new S. aureus isolates after an ICU episode of 30 days will be considered a different (or new) episode.      Thus, this method counts since the start of the previous episode .2. Relative      This method uses `case_free_days` to quantify the duration of case-free days (the inter-epidemic interval), after which a new episode will start. A common use case is infectious disease epidemiology: episodes of norovirus outbreaks in a hospital for example. The case-free period could then be 14 days, so that new norovirus cases after that time will be considered a different (or new) episode.      Thus, this methods counts since the last case in the previous episode .In a table:|||||:-:|:-:|:-:||Date|Using  `episode_days = 7`|Using  `case_free_days = 7`||2023-01-01|1|1||2023-01-02|1|1||2023-01-05|1|1||2023-01-08|2|1||2023-02-21|3|2||2023-02-22|3|2||2023-02-23|3|2||2023-02-24|3|2||2023-03-01|4|2| This marks the start of a new episode, because 8 January 2023 is more than 7 days since the start of the previous episode (1 January 2023).  This marks the start of a new episode, because 21 January 2023 is more than 7 days since the last case in the previous episode (8 January 2023).Either `episode_days` or `case_free_days` must be provided in the function. Difference between `get_episode()` and `is_new_episode()` The `get_episode()` function returns the index number of the episode, so all cases/patients/isolates in the first episode will have the number 1, all cases/patients/isolates in the second episode will have the number 2, etc.The `is_new_episode()` function on the other hand, returns `TRUE` for every new `get_episode()` index.To specify, when setting `episode_days = 365` (using method 1 as explained above), this is how the two functions differ:||||||:-:|:-:|:-:|:-:||patient|date|`get_episode()`|`is_new_episode()`||A|2019-01-01|1|TRUE||A|2019-03-01|1|FALSE||A|2021-01-01|2|TRUE||B|2008-01-01|1|TRUE||B|2008-01-01|1|FALSE||C|2020-01-01|1|TRUE| Other The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but is more efficient for data sets containing microorganism codes or names and allows for different isolate selection methods.The `dplyr` package is not required for these functions to work, but these episode functions do support variable grouping and work conveniently inside `dplyr` verbs such as `filter()`, `mutate()` and `summarise()`. Examples```r difference between absolute and relative determination of episodes:x <- data.frame(dates = as.Date(c(  ""2021-01-01"",  ""2021-01-02"",  ""2021-01-05"",  ""2021-01-08"",  ""2021-02-21"",  ""2021-02-22"",  ""2021-02-23"",  ""2021-02-24"",  ""2021-03-01"",  ""2021-03-01"")))x$absolute <- get_episode(x$dates, episode_days = 7)x$relative <- get_episode(x$dates, case_free_days = 7)x `example_isolates` is a data set available in the AMR package. See ?example_isolatesdf <- example_isolates[sample(seq_len(2000), size = 100), ]get_episode(df$date, episode_days = 60)  indicesis_new_episode(df$date, episode_days = 60)  TRUE/FALSE filter on results from the third 60-day episode only, using base Rdf[which(get_episode(df$date, 60) == 3), ] the functions also work for less than a day, e.g. to include one per hour:get_episode(  c(    Sys.time(),    Sys.time() + 60  60  ),  episode_days = 1 / 24)if (require(""dplyr"")) {   is_new_episode() can also be used in dplyr verbs to determine patient   episodes based on any (combination of) grouping variables:  df %>%    mutate(condition = sample(      x = c(""A"", ""B"", ""C""),      size = 100,      replace = TRUE    )) %>%    group_by(patient, condition) %>%    mutate(new_episode = is_new_episode(date, 365)) %>%    select(patient, date, condition, new_episode) %>%    arrange(patient, condition, date)}if (require(""dplyr"")) {  df %>%    group_by(ward, patient) %>%    transmute(date,      patient,      new_index = get_episode(date, 60),      new_logical = is_new_episode(date, 60)    ) %>%    arrange(patient, ward, date)}if (require(""dplyr"")) {  df %>%    group_by(ward) %>%    summarise(      n_patients = n_distinct(patient),      n_episodes_365 = sum(is_new_episode(date, episode_days = 365)),      n_episodes_60 = sum(is_new_episode(date, episode_days = 60)),      n_episodes_30 = sum(is_new_episode(date, episode_days = 30))    )} grouping on patients and microorganisms leads to the same results as first_isolate() when using 'episode-based':if (require(""dplyr"")) {  x <- df %>%    filter_first_isolate(      include_unknown = TRUE,      method = ""episode-based""    )  y <- df %>%    group_by(patient, mo) %>%    filter(is_new_episode(date, 365)) %>%    ungroup()  identical(x, y)} but is_new_episode() has a lot more flexibility than first_isolate(), since you can now group on anything that seems relevant:if (require(""dplyr"")) {  df %>%    group_by(patient, mo, ward) %>%    mutate(flag_episode = is_new_episode(date, 365)) %>%    select(group_vars(.), flag_episode)}``` See Also`first_isolate()`",2
AMR,guess_ab_col.md,"# Guess Antibiotic Column

```r
guess_ab_col(
  x = NULL,
  search_string = NULL,
  verbose = FALSE,
  only_sir_columns = FALSE
)
```

## Arguments

- `x`: a data.frame
- `search_string`: a text to search `x` for, will be checked with `as.ab()` if this value is not a column in `x`
- `verbose`: a logical to indicate whether additional info should be printed
- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)

## Returns

A column name of `x`, or `NULL` when no result is found.

## Description

This tries to find a column name in a data set based on information from the antibiotics data set. Also supports WHONET abbreviations.

## Details

You can look for an antibiotic (trade) name or abbreviation and it will search `x` and the antibiotics data set for any column containing a name or code of that antibiotic.

## Examples

```r
df <- data.frame(
  amox = ""S"",
  tetr = ""R""
)

guess_ab_col(df, ""amoxicillin"")
guess_ab_col(df, ""J01AA07"") # ATC code of tetracycline

guess_ab_col(df, ""J01AA07"", verbose = TRUE)
# NOTE: Using column 'tetr' as input for J01AA07 (tetracycline).

# WHONET codes
df <- data.frame(
  AMP_ND10 = ""R"",
  AMC_ED20 = ""S""
)
guess_ab_col(df, ""ampicillin"")
guess_ab_col(df, ""J01CR02"")
guess_ab_col(df, as.ab(""augmentin""))
```



","['Guess Antibiotic Column```rguess_ab_col(  x = NULL,  search_string = NULL,  verbose = FALSE,  only_sir_columns = FALSE)``` Arguments- `x`: a data.frame- `search_string`: a text to search `x` for, will be checked with `as.ab()` if this value is not a column in `x`- `verbose`: a logical to indicate whether additional info should be printed- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`) ReturnsA column name of `x`, or `NULL` when no result is found.', 'DescriptionThis tries to find a column name in a data set based on information from the antibiotics data set.', 'DetailsYou can look for an antibiotic (trade) name or abbreviation and it will search `x` and the antibiotics data set for any column containing a name or code of that antibiotic.', 'Examples```rdf <- data.frame(  amox = ""S"",  tetr = ""R"")guess_ab_col(df, ""amoxicillin"")guess_ab_col(df, ""J01AA07"")  ATC code of tetracyclineguess_ab_col(df, ""J01AA07"", verbose = TRUE) NOTE: Using column \'tetr\' as input for J01AA07 (tetracycline).', 'WHONET codesdf <- data.frame(  AMP_ND10 = ""R"",  AMC_ED20 = ""S"")guess_ab_col(df, ""ampicillin"")guess_ab_col(df, ""J01CR02"")guess_ab_col(df, as.ab(""augmentin""))```']",1," Guess Antibiotic Column```rguess_ab_col(  x = NULL,  search_string = NULL,  verbose = FALSE,  only_sir_columns = FALSE)``` Arguments- `x`: a data.frame- `search_string`: a text to search `x` for, will be checked with `as.ab()` if this value is not a column in `x`- `verbose`: a logical to indicate whether additional info should be printed- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`) ReturnsA column name of `x`, or `NULL` when no result is found. DescriptionThis tries to find a column name in a data set based on information from the antibiotics data set. Also supports WHONET abbreviations. DetailsYou can look for an antibiotic (trade) name or abbreviation and it will search `x` and the antibiotics data set for any column containing a name or code of that antibiotic. Examples```rdf <- data.frame(  amox = ""S"",  tetr = ""R"")guess_ab_col(df, ""amoxicillin"")guess_ab_col(df, ""J01AA07"")  ATC code of tetracyclineguess_ab_col(df, ""J01AA07"", verbose = TRUE) NOTE: Using column 'tetr' as input for J01AA07 (tetracycline). WHONET codesdf <- data.frame(  AMP_ND10 = ""R"",  AMC_ED20 = ""S"")guess_ab_col(df, ""ampicillin"")guess_ab_col(df, ""J01CR02"")guess_ab_col(df, as.ab(""augmentin""))```",2
AMR,first_isolate.md,"# Determine First Isolates

## Source

Methodology of this function is strictly based on:

 * M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, **Clinical and Laboratory Standards Institute (CLSI)**. [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).
 * Hindler JF and Stelling J (2007). Analysis and Presentation of Cumulative Antibiograms: A New ConsensusGuideline from the Clinical and Laboratory Standards Institute. Clinical Infectious Diseases, 44(6), 867-873. tools:::Rd_expr_doi(""10.1086/511864"")

```r
first_isolate(
  x = NULL,
  col_date = NULL,
  col_patient_id = NULL,
  col_mo = NULL,
  col_testcode = NULL,
  col_specimen = NULL,
  col_icu = NULL,
  col_keyantimicrobials = NULL,
  episode_days = 365,
  testcodes_exclude = NULL,
  icu_exclude = FALSE,
  specimen_group = NULL,
  type = ""points"",
  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),
  ignore_I = TRUE,
  points_threshold = 2,
  info = interactive(),
  include_unknown = FALSE,
  include_untested_sir = TRUE,
  ...
)

filter_first_isolate(
  x = NULL,
  col_date = NULL,
  col_patient_id = NULL,
  col_mo = NULL,
  episode_days = 365,
  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),
  ...
)
```

## Arguments

- `x`: a data.frame containing isolates. Can be left blank for automatic determination, see **Examples**.
- `col_date`: column name of the result date (or date that is was received on the lab) - the default is the first column with a date class
- `col_patient_id`: column name of the unique IDs of the patients - the default is the first column that starts with 'patient' or 'patid' (case insensitive)
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `col_testcode`: column name of the test codes. Use `col_testcode = NULL` to not exclude certain test codes (such as test codes for screening). In that case `testcodes_exclude` will be ignored.
- `col_specimen`: column name of the specimen type or group
- `col_icu`: column name of the logicals (`TRUE`/`FALSE`) whether a ward or department is an Intensive Care Unit (ICU). This can also be a logical vector with the same length as rows in `x`.
- `col_keyantimicrobials`: (only useful when `method = ""phenotype-based""`) column name of the key antimicrobials to determine first isolates, see `key_antimicrobials()`. The default is the first column that starts with 'key' followed by 'ab' or 'antibiotics' or 'antimicrobials' (case insensitive). Use `col_keyantimicrobials = FALSE` to prevent this. Can also be the output of `key_antimicrobials()`.
- `episode_days`: episode in days after which a genus/species combination will be determined as 'first isolate' again. The default of 365 days is based on the guideline by CLSI, see **Source**.
- `testcodes_exclude`: a character vector with test codes that should be excluded (case-insensitive)
- `icu_exclude`: a logical to indicate whether ICU isolates should be excluded (rows with value `TRUE` in the column set with `col_icu`)
- `specimen_group`: value in the column set with `col_specimen` to filter on
- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see **Details**
- `method`: the method to apply, either `""phenotype-based""`, `""episode-based""`, `""patient-based""` or `""isolate-based""` (can be abbreviated), see **Details**. The default is `""phenotype-based""` if antimicrobial test results are present in the data, and `""episode-based""` otherwise.
- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see **Details**
- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see **Details**
- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode
- `include_unknown`: a logical to indicate whether 'unknown' microorganisms should be included too, i.e. microbial code `""UNKNOWN""`, which defaults to `FALSE`. For WHONET users, this means that all records with organism code `""con""` (**contamination**) will be excluded at default. Isolates with a microbial ID of `NA` will always be excluded as first isolate.
- `include_untested_sir`: a logical to indicate whether also rows without antibiotic results are still eligible for becoming a first isolate. Use `include_untested_sir = FALSE` to always return `FALSE` for such rows. This checks the data set for columns of class `sir` and consequently requires transforming columns with antibiotic results using `as.sir()` first.
- `...`: arguments passed on to `first_isolate()` when using `filter_first_isolate()`, otherwise arguments passed on to `key_antimicrobials()` (such as `universal`, `gram_negative`, `gram_positive`)

## Returns

A logical vector

## Description

Determine first isolates of all microorganisms of every patient per episode and (if needed) per specimen type. These functions support all four methods as summarised by Hindler **et al.** in 2007 (tools:::Rd_expr_doi(""10.1086/511864"") ). To determine patient episodes not necessarily based on microorganisms, use `is_new_episode()` that also supports grouping with the `dplyr` package.

## Details

To conduct epidemiological analyses on antimicrobial resistance data, only so-called first isolates should be included to prevent overestimation and underestimation of antimicrobial resistance. Different methods can be used to do so, see below.

These functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see **Examples**.

The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but more efficient for data sets containing microorganism codes or names.

All isolates with a microbial ID of `NA` will be excluded as first isolate.

### Different methods

 According to Hindler **et al.** (2007, tools:::Rd_expr_doi(""10.1086/511864"") ), there are different methods (algorithms) to select first isolates with increasing reliability: isolate-based, patient-based, episode-based and phenotype-based. All methods select on a combination of the taxonomic genus and species (not subspecies).

All mentioned methods are covered in the `first_isolate()` function:

|||
|:--|:--|
|Method|Function to apply|
|Isolate-based|`first_isolate(x, method = ""isolate-based"")`|
|**(= all isolates)**||
|||
|||
|Patient-based|`first_isolate(x, method = ""patient-based"")`|
|**(= first isolate per patient)**||
|||
|||
|Episode-based|`first_isolate(x, method = ""episode-based"")` , or:|
|**(= first isolate per episode)**||
|- 7-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 7)`|
|- 30-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 30)`|
|||
|||
|Phenotype-based|`first_isolate(x, method = ""phenotype-based"")` , or:|
|**(= first isolate per phenotype)**||
|- Major difference in any antimicrobial result|-  `first_isolate(x, type = ""points"")`|
|- Any difference in key antimicrobial results|-  `first_isolate(x, type = ""keyantimicrobials"")`|

### Isolate-based

 This method does not require any selection, as all isolates should be included. It does, however, respect all arguments set in the `first_isolate()` function. For example, the default setting for `include_unknown` (`FALSE`) will omit selection of rows without a microbial ID.

### Patient-based

 To include every genus-species combination per patient once, set the `episode_days` to `Inf`. Although often inappropriate, this method makes sure that no duplicate isolates are selected from the same patient. In a large longitudinal data set, this could mean that isolates are **excluded** that were found years after the initial isolate.

### Episode-based

 To include every genus-species combination per patient episode once, set the `episode_days` to a sensible number of days. Depending on the type of analysis, this could be 14, 30, 60 or 365. Short episodes are common for analysing specific hospital or ward data, long episodes are common for analysing regional and national data.

This is the most common method to correct for duplicate isolates. Patients are categorised into episodes based on their ID and dates (e.g., the date of specimen receipt or laboratory result). While this is a common method, it does not take into account antimicrobial test results. This means that e.g. a methicillin-resistant **Staphylococcus aureus** (MRSA) isolate cannot be differentiated from a wildtype **Staphylococcus aureus** isolate.

### Phenotype-based

 This is a more reliable method, since it also **weighs** the antibiogram (antimicrobial test results) yielding so-called 'first weighted isolates'. There are two different methods to weigh the antibiogram:

1. Using `type = ""points""` and argument `points_threshold` (default)
   
   This method weighs **all** antimicrobial drugs available in the data set. Any difference from I to S or R (or vice versa) counts as `0.5` points, a difference from S to R (or vice versa) counts as `1` point. When the sum of points exceeds `points_threshold`, which defaults to `2`, an isolate will be selected as a first weighted isolate.
   
   All antimicrobials are internally selected using the `all_antimicrobials()` function. The output of this function does not need to be passed to the `first_isolate()` function.
2. Using `type = ""keyantimicrobials""` and argument `ignore_I`
   
   This method only weighs specific antimicrobial drugs, called **key antimicrobials**. Any difference from S to R (or vice versa) in these key antimicrobials will select an isolate as a first weighted isolate. With `ignore_I = FALSE`, also differences from I to S or R (or vice versa) will lead to this.
   
   Key antimicrobials are internally selected using the `key_antimicrobials()` function, but can also be added manually as a variable to the data and set in the `col_keyantimicrobials` argument. Another option is to pass the output of the `key_antimicrobials()` function directly to the `col_keyantimicrobials` argument.

The default method is phenotype-based (using `type = ""points""`) and episode-based (using `episode_days = 365`). This makes sure that every genus-species combination is selected per patient once per year, while taking into account all antimicrobial test results. If no antimicrobial test results are available in the data set, only the episode-based method is applied at default.

## Examples

```r
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.

example_isolates[first_isolate(info = TRUE), ]

# get all first Gram-negatives
example_isolates[which(first_isolate(info = FALSE) & mo_is_gram_negative()), ]

if (require(""dplyr"")) {
  # filter on first isolates using dplyr:
  example_isolates %>%
    filter(first_isolate(info = TRUE))
}
if (require(""dplyr"")) {
  # short-hand version:
  example_isolates %>%
    filter_first_isolate(info = FALSE)
}
if (require(""dplyr"")) {
  # flag the first isolates per group:
  example_isolates %>%
    group_by(ward) %>%
    mutate(first = first_isolate(info = TRUE)) %>%
    select(ward, date, patient, mo, first)
}
```

## See Also

`key_antimicrobials()`



","['Determine First Isolates SourceMethodology of this function is strictly based on:  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI).', 'Hindler JF and Stelling J (2007).', 'Analysis and Presentation of Cumulative Antibiograms: A New ConsensusGuideline from the Clinical and Laboratory Standards Institute.', 'Clinical Infectious Diseases, 44(6), 867-873. tools:::Rd_expr_doi(""10.1086/511864"")```rfirst_isolate(  x = NULL,  col_date = NULL,  col_patient_id = NULL,  col_mo = NULL,  col_testcode = NULL,  col_specimen = NULL,  col_icu = NULL,  col_keyantimicrobials = NULL,  episode_days = 365,  testcodes_exclude = NULL,  icu_exclude = FALSE,  specimen_group = NULL,  type = ""points"",  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),  ignore_I = TRUE,  points_threshold = 2,  info = interactive(),  include_unknown = FALSE,  include_untested_sir = TRUE,  ...)filter_first_isolate(  x = NULL,  col_date = NULL,  col_patient_id = NULL,  col_mo = NULL,  episode_days = 365,  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),  ...)``` Arguments- `x`: a data.frame containing isolates.', ""Can be left blank for automatic determination, see Examples.- `col_date`: column name of the result date (or date that is was received on the lab) - the default is the first column with a date class- `col_patient_id`: column name of the unique IDs of the patients - the default is the first column that starts with 'patient' or 'patid' (case insensitive)- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`."", 'Values will be coerced using `as.mo()`.- `col_testcode`: column name of the test codes.', 'Use `col_testcode = NULL` to not exclude certain test codes (such as test codes for screening).', 'In that case `testcodes_exclude` will be ignored.- `col_specimen`: column name of the specimen type or group- `col_icu`: column name of the logicals (`TRUE`/`FALSE`) whether a ward or department is an Intensive Care Unit (ICU).', 'This can also be a logical vector with the same length as rows in `x`.- `col_keyantimicrobials`: (only useful when `method = ""phenotype-based""`) column name of the key antimicrobials to determine first isolates, see `key_antimicrobials()`.', ""The default is the first column that starts with 'key' followed by 'ab' or 'antibiotics' or 'antimicrobials' (case insensitive)."", 'Use `col_keyantimicrobials = FALSE` to prevent this.', ""Can also be the output of `key_antimicrobials()`.- `episode_days`: episode in days after which a genus/species combination will be determined as 'first isolate' again."", 'The default of 365 days is based on the guideline by CLSI, see Source.- `testcodes_exclude`: a character vector with test codes that should be excluded (case-insensitive)- `icu_exclude`: a logical to indicate whether ICU isolates should be excluded (rows with value `TRUE` in the column set with `col_icu`)- `specimen_group`: value in the column set with `col_specimen` to filter on- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see Details- `method`: the method to apply, either `""phenotype-based""`, `""episode-based""`, `""patient-based""` or `""isolate-based""` (can be abbreviated), see Details.', 'The default is `""phenotype-based""` if antimicrobial test results are present in the data, and `""episode-based""` otherwise.- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see Details- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see Details- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode- `include_unknown`: a logical to indicate whether \'unknown\' microorganisms should be included too, i.e.', 'microbial code `""UNKNOWN""`, which defaults to `FALSE`.', 'For WHONET users, this means that all records with organism code `""con""` (contamination) will be excluded at default.', 'Isolates with a microbial ID of `NA` will always be excluded as first isolate.- `include_untested_sir`: a logical to indicate whether also rows without antibiotic results are still eligible for becoming a first isolate.', 'Use `include_untested_sir = FALSE` to always return `FALSE` for such rows.', 'This checks the data set for columns of class `sir` and consequently requires transforming columns with antibiotic results using `as.sir()` first.- `...`: arguments passed on to `first_isolate()` when using `filter_first_isolate()`, otherwise arguments passed on to `key_antimicrobials()` (such as `universal`, `gram_negative`, `gram_positive`) ReturnsA logical vector DescriptionDetermine first isolates of all microorganisms of every patient per episode and (if needed) per specimen type.', 'These functions support all four methods as summarised by Hindler et al.', 'To determine patient episodes not necessarily based on microorganisms, use `is_new_episode()` that also supports grouping with the `dplyr` package.', 'DetailsTo conduct epidemiological analyses on antimicrobial resistance data, only so-called first isolates should be included to prevent overestimation and underestimation of antimicrobial resistance.', 'Different methods can be used to do so, see below.These functions are context-aware.', 'This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but more efficient for data sets containing microorganism codes or names.All isolates with a microbial ID of `NA` will be excluded as first isolate.', 'Different methods According to Hindler et al.', '(2007, tools:::Rd_expr_doi(""10.1086/511864"") ), there are different methods (algorithms) to select first isolates with increasing reliability: isolate-based, patient-based, episode-based and phenotype-based.', 'All methods select on a combination of the taxonomic genus and species (not subspecies).All mentioned methods are covered in the `first_isolate()` function:||||:--|:--||Method|Function to apply||Isolate-based|`first_isolate(x, method = ""isolate-based"")`||(= all isolates)|||||||||Patient-based|`first_isolate(x, method = ""patient-based"")`||(= first isolate per patient)|||||||||Episode-based|`first_isolate(x, method = ""episode-based"")` , or:||(= first isolate per episode)|||- 7-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 7)`||- 30-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 30)`||||||||Phenotype-based|`first_isolate(x, method = ""phenotype-based"")` , or:||(= first isolate per phenotype)|||- Major difference in any antimicrobial result|-  `first_isolate(x, type = ""points"")`||- Any difference in key antimicrobial results|-  `first_isolate(x, type = ""keyantimicrobials"")`| Isolate-based This method does not require any selection, as all isolates should be included.', 'It does, however, respect all arguments set in the `first_isolate()` function.', 'For example, the default setting for `include_unknown` (`FALSE`) will omit selection of rows without a microbial ID.', 'Patient-based To include every genus-species combination per patient once, set the `episode_days` to `Inf`.', 'Although often inappropriate, this method makes sure that no duplicate isolates are selected from the same patient.', 'In a large longitudinal data set, this could mean that isolates are excluded that were found years after the initial isolate.', 'Episode-based To include every genus-species combination per patient episode once, set the `episode_days` to a sensible number of days.', 'Depending on the type of analysis, this could be 14, 30, 60 or 365.', 'Short episodes are common for analysing specific hospital or ward data, long episodes are common for analysing regional and national data.This is the most common method to correct for duplicate isolates.', 'Patients are categorised into episodes based on their ID and dates (e.g., the date of specimen receipt or laboratory result).', 'While this is a common method, it does not take into account antimicrobial test results.', 'a methicillin-resistant Staphylococcus aureus (MRSA) isolate cannot be differentiated from a wildtype Staphylococcus aureus isolate.', ""Phenotype-based This is a more reliable method, since it also weighs the antibiogram (antimicrobial test results) yielding so-called 'first weighted isolates'."", 'There are two different methods to weigh the antibiogram:1.', 'Using `type = ""points""` and argument `points_threshold` (default)      This method weighs all antimicrobial drugs available in the data set.', 'Any difference from I to S or R (or vice versa) counts as `0.5` points, a difference from S to R (or vice versa) counts as `1` point.', 'When the sum of points exceeds `points_threshold`, which defaults to `2`, an isolate will be selected as a first weighted isolate.', 'All antimicrobials are internally selected using the `all_antimicrobials()` function.', 'The output of this function does not need to be passed to the `first_isolate()` function.2.', 'Using `type = ""keyantimicrobials""` and argument `ignore_I`      This method only weighs specific antimicrobial drugs, called key antimicrobials.', 'Any difference from S to R (or vice versa) in these key antimicrobials will select an isolate as a first weighted isolate.', 'With `ignore_I = FALSE`, also differences from I to S or R (or vice versa) will lead to this.', 'Key antimicrobials are internally selected using the `key_antimicrobials()` function, but can also be added manually as a variable to the data and set in the `col_keyantimicrobials` argument.', 'Another option is to pass the output of the `key_antimicrobials()` function directly to the `col_keyantimicrobials` argument.The default method is phenotype-based (using `type = ""points""`) and episode-based (using `episode_days = 365`).', 'This makes sure that every genus-species combination is selected per patient once per year, while taking into account all antimicrobial test results.', 'If no antimicrobial test results are available in the data set, only the episode-based method is applied at default.', 'Examples```r `example_isolates` is a data set available in the AMR package.', 'See ?example_isolates.example_isolates[first_isolate(info = TRUE), ] get all first Gram-negativesexample_isolates[which(first_isolate(info = FALSE) & mo_is_gram_negative()), ]if (require(""dplyr"")) {   filter on first isolates using dplyr:  example_isolates %>%    filter(first_isolate(info = TRUE))}if (require(""dplyr"")) {   short-hand version:  example_isolates %>%    filter_first_isolate(info = FALSE)}if (require(""dplyr"")) {   flag the first isolates per group:  example_isolates %>%    group_by(ward) %>%    mutate(first = first_isolate(info = TRUE)) %>%    select(ward, date, patient, mo, first)}``` See Also`key_antimicrobials()`']",1," Determine First Isolates SourceMethodology of this function is strictly based on:  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI). [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).  Hindler JF and Stelling J (2007). Analysis and Presentation of Cumulative Antibiograms: A New ConsensusGuideline from the Clinical and Laboratory Standards Institute. Clinical Infectious Diseases, 44(6), 867-873. tools:::Rd_expr_doi(""10.1086/511864"")```rfirst_isolate(  x = NULL,  col_date = NULL,  col_patient_id = NULL,  col_mo = NULL,  col_testcode = NULL,  col_specimen = NULL,  col_icu = NULL,  col_keyantimicrobials = NULL,  episode_days = 365,  testcodes_exclude = NULL,  icu_exclude = FALSE,  specimen_group = NULL,  type = ""points"",  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),  ignore_I = TRUE,  points_threshold = 2,  info = interactive(),  include_unknown = FALSE,  include_untested_sir = TRUE,  ...)filter_first_isolate(  x = NULL,  col_date = NULL,  col_patient_id = NULL,  col_mo = NULL,  episode_days = 365,  method = c(""phenotype-based"", ""episode-based"", ""patient-based"", ""isolate-based""),  ...)``` Arguments- `x`: a data.frame containing isolates. Can be left blank for automatic determination, see Examples.- `col_date`: column name of the result date (or date that is was received on the lab) - the default is the first column with a date class- `col_patient_id`: column name of the unique IDs of the patients - the default is the first column that starts with 'patient' or 'patid' (case insensitive)- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `col_testcode`: column name of the test codes. Use `col_testcode = NULL` to not exclude certain test codes (such as test codes for screening). In that case `testcodes_exclude` will be ignored.- `col_specimen`: column name of the specimen type or group- `col_icu`: column name of the logicals (`TRUE`/`FALSE`) whether a ward or department is an Intensive Care Unit (ICU). This can also be a logical vector with the same length as rows in `x`.- `col_keyantimicrobials`: (only useful when `method = ""phenotype-based""`) column name of the key antimicrobials to determine first isolates, see `key_antimicrobials()`. The default is the first column that starts with 'key' followed by 'ab' or 'antibiotics' or 'antimicrobials' (case insensitive). Use `col_keyantimicrobials = FALSE` to prevent this. Can also be the output of `key_antimicrobials()`.- `episode_days`: episode in days after which a genus/species combination will be determined as 'first isolate' again. The default of 365 days is based on the guideline by CLSI, see Source.- `testcodes_exclude`: a character vector with test codes that should be excluded (case-insensitive)- `icu_exclude`: a logical to indicate whether ICU isolates should be excluded (rows with value `TRUE` in the column set with `col_icu`)- `specimen_group`: value in the column set with `col_specimen` to filter on- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see Details- `method`: the method to apply, either `""phenotype-based""`, `""episode-based""`, `""patient-based""` or `""isolate-based""` (can be abbreviated), see Details. The default is `""phenotype-based""` if antimicrobial test results are present in the data, and `""episode-based""` otherwise.- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see Details- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see Details- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode- `include_unknown`: a logical to indicate whether 'unknown' microorganisms should be included too, i.e. microbial code `""UNKNOWN""`, which defaults to `FALSE`. For WHONET users, this means that all records with organism code `""con""` (contamination) will be excluded at default. Isolates with a microbial ID of `NA` will always be excluded as first isolate.- `include_untested_sir`: a logical to indicate whether also rows without antibiotic results are still eligible for becoming a first isolate. Use `include_untested_sir = FALSE` to always return `FALSE` for such rows. This checks the data set for columns of class `sir` and consequently requires transforming columns with antibiotic results using `as.sir()` first.- `...`: arguments passed on to `first_isolate()` when using `filter_first_isolate()`, otherwise arguments passed on to `key_antimicrobials()` (such as `universal`, `gram_negative`, `gram_positive`) ReturnsA logical vector DescriptionDetermine first isolates of all microorganisms of every patient per episode and (if needed) per specimen type. These functions support all four methods as summarised by Hindler et al. in 2007 (tools:::Rd_expr_doi(""10.1086/511864"") ). To determine patient episodes not necessarily based on microorganisms, use `is_new_episode()` that also supports grouping with the `dplyr` package. DetailsTo conduct epidemiological analyses on antimicrobial resistance data, only so-called first isolates should be included to prevent overestimation and underestimation of antimicrobial resistance. Different methods can be used to do so, see below.These functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.The `first_isolate()` function is a wrapper around the `is_new_episode()` function, but more efficient for data sets containing microorganism codes or names.All isolates with a microbial ID of `NA` will be excluded as first isolate. Different methods According to Hindler et al. (2007, tools:::Rd_expr_doi(""10.1086/511864"") ), there are different methods (algorithms) to select first isolates with increasing reliability: isolate-based, patient-based, episode-based and phenotype-based. All methods select on a combination of the taxonomic genus and species (not subspecies).All mentioned methods are covered in the `first_isolate()` function:||||:--|:--||Method|Function to apply||Isolate-based|`first_isolate(x, method = ""isolate-based"")`||(= all isolates)|||||||||Patient-based|`first_isolate(x, method = ""patient-based"")`||(= first isolate per patient)|||||||||Episode-based|`first_isolate(x, method = ""episode-based"")` , or:||(= first isolate per episode)|||- 7-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 7)`||- 30-Day interval from initial isolate|-  `first_isolate(x, method = ""e"", episode_days = 30)`||||||||Phenotype-based|`first_isolate(x, method = ""phenotype-based"")` , or:||(= first isolate per phenotype)|||- Major difference in any antimicrobial result|-  `first_isolate(x, type = ""points"")`||- Any difference in key antimicrobial results|-  `first_isolate(x, type = ""keyantimicrobials"")`| Isolate-based This method does not require any selection, as all isolates should be included. It does, however, respect all arguments set in the `first_isolate()` function. For example, the default setting for `include_unknown` (`FALSE`) will omit selection of rows without a microbial ID. Patient-based To include every genus-species combination per patient once, set the `episode_days` to `Inf`. Although often inappropriate, this method makes sure that no duplicate isolates are selected from the same patient. In a large longitudinal data set, this could mean that isolates are excluded that were found years after the initial isolate. Episode-based To include every genus-species combination per patient episode once, set the `episode_days` to a sensible number of days. Depending on the type of analysis, this could be 14, 30, 60 or 365. Short episodes are common for analysing specific hospital or ward data, long episodes are common for analysing regional and national data.This is the most common method to correct for duplicate isolates. Patients are categorised into episodes based on their ID and dates (e.g., the date of specimen receipt or laboratory result). While this is a common method, it does not take into account antimicrobial test results. This means that e.g. a methicillin-resistant Staphylococcus aureus (MRSA) isolate cannot be differentiated from a wildtype Staphylococcus aureus isolate. Phenotype-based This is a more reliable method, since it also weighs the antibiogram (antimicrobial test results) yielding so-called 'first weighted isolates'. There are two different methods to weigh the antibiogram:1. Using `type = ""points""` and argument `points_threshold` (default)      This method weighs all antimicrobial drugs available in the data set. Any difference from I to S or R (or vice versa) counts as `0.5` points, a difference from S to R (or vice versa) counts as `1` point. When the sum of points exceeds `points_threshold`, which defaults to `2`, an isolate will be selected as a first weighted isolate.      All antimicrobials are internally selected using the `all_antimicrobials()` function. The output of this function does not need to be passed to the `first_isolate()` function.2. Using `type = ""keyantimicrobials""` and argument `ignore_I`      This method only weighs specific antimicrobial drugs, called key antimicrobials. Any difference from S to R (or vice versa) in these key antimicrobials will select an isolate as a first weighted isolate. With `ignore_I = FALSE`, also differences from I to S or R (or vice versa) will lead to this.      Key antimicrobials are internally selected using the `key_antimicrobials()` function, but can also be added manually as a variable to the data and set in the `col_keyantimicrobials` argument. Another option is to pass the output of the `key_antimicrobials()` function directly to the `col_keyantimicrobials` argument.The default method is phenotype-based (using `type = ""points""`) and episode-based (using `episode_days = 365`). This makes sure that every genus-species combination is selected per patient once per year, while taking into account all antimicrobial test results. If no antimicrobial test results are available in the data set, only the episode-based method is applied at default. Examples```r `example_isolates` is a data set available in the AMR package. See ?example_isolates.example_isolates[first_isolate(info = TRUE), ] get all first Gram-negativesexample_isolates[which(first_isolate(info = FALSE) & mo_is_gram_negative()), ]if (require(""dplyr"")) {   filter on first isolates using dplyr:  example_isolates %>%    filter(first_isolate(info = TRUE))}if (require(""dplyr"")) {   short-hand version:  example_isolates %>%    filter_first_isolate(info = FALSE)}if (require(""dplyr"")) {   flag the first isolates per group:  example_isolates %>%    group_by(ward) %>%    mutate(first = first_isolate(info = TRUE)) %>%    select(ward, date, patient, mo, first)}``` See Also`key_antimicrobials()`",2
AMR,resistance_predict.md,"# Predict Antimicrobial Resistance

```r
resistance_predict(
  x,
  col_ab,
  col_date = NULL,
  year_min = NULL,
  year_max = NULL,
  year_every = 1,
  minimum = 30,
  model = NULL,
  I_as_S = TRUE,
  preserve_measurements = TRUE,
  info = interactive(),
  ...
)

sir_predict(
  x,
  col_ab,
  col_date = NULL,
  year_min = NULL,
  year_max = NULL,
  year_every = 1,
  minimum = 30,
  model = NULL,
  I_as_S = TRUE,
  preserve_measurements = TRUE,
  info = interactive(),
  ...
)

## S3 method for class 'resistance_predict'
plot(x, main = paste(""Resistance Prediction of"", x_name), ...)

ggplot_sir_predict(
  x,
  main = paste(""Resistance Prediction of"", x_name),
  ribbon = TRUE,
  ...
)

## S3 method for class 'resistance_predict'
autoplot(
  object,
  main = paste(""Resistance Prediction of"", x_name),
  ribbon = TRUE,
  ...
)
```

## Arguments

- `x`: a data.frame containing isolates. Can be left blank for automatic determination, see **Examples**.
- `col_ab`: column name of `x` containing antimicrobial interpretations (`""R""`, `""I""` and `""S""`)
- `col_date`: column name of the date, will be used to calculate years if this column doesn't consist of years already - the default is the first column of with a date class
- `year_min`: lowest year to use in the prediction model, dafaults to the lowest year in `col_date`
- `year_max`: highest year to use in the prediction model - the default is 10 years after today
- `year_every`: unit of sequence between lowest year found in the data and `year_max`
- `minimum`: minimal amount of available isolates per year to include. Years containing less observations will be estimated by the model.
- `model`: the statistical model of choice. This could be a generalised linear regression model with binomial distribution (i.e. using `glm(..., family = binomial)`, assuming that a period of zero resistance was followed by a period of increasing resistance leading slowly to more and more resistance. See **Details** for all valid options.
- `I_as_S`: a logical to indicate whether values `""I""` should be treated as `""S""` (will otherwise be treated as `""R""`). The default, `TRUE`, follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section **Interpretation of S, I and R** below.
- `preserve_measurements`: a logical to indicate whether predictions of years that are actually available in the data should be overwritten by the original data. The standard errors of those years will be `NA`.
- `info`: a logical to indicate whether textual analysis should be printed with the name and `summary()` of the statistical model.
- `...`: arguments passed on to functions
- `main`: title of the plot
- `ribbon`: a logical to indicate whether a ribbon should be shown (default) or error bars
- `object`: model data to be plotted

## Returns

A data.frame with extra class `resistance_predict` with columns:

 * `year`
 * `value`, the same as `estimated` when `preserve_measurements = FALSE`, and a combination of `observed` and `estimated` otherwise
 * `se_min`, the lower bound of the standard error with a minimum of `0` (so the standard error will never go below 0%)
 * `se_max` the upper bound of the standard error with a maximum of `1` (so the standard error will never go above 100%)
 * `observations`, the total number of available observations in that year, i.e. `S + I + R`
 * `observed`, the original observed resistant percentages
 * `estimated`, the estimated resistant percentages, calculated by the model

Furthermore, the model itself is available as an attribute: `attributes(x)$model`, see **Examples**.

## Description

Create a prediction model to predict antimicrobial resistance for the next years on statistical solid ground. Standard errors (SE) will be returned as columns `se_min` and `se_max`. See **Examples** for a real live example.

## Details

Valid options for the statistical model (argument `model`) are:

 * `""binomial""` or `""binom""` or `""logit""`: a generalised linear regression model with binomial distribution
 * `""loglin""` or `""poisson""`: a generalised log-linear regression model with poisson distribution
 * `""lin""` or `""linear""`: a linear regression model

## Interpretation of SIR

 In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):

 * S - Susceptible, standard dosing regimen
   
   A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.
 * I - Susceptible, increased exposure **A microorganism is categorised as ""Susceptible, Increased exposure**"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.
 * R = Resistant
   
   A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.
   
    * **Exposure** is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.

This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.

## Examples

```r
x <- resistance_predict(example_isolates,
  col_ab = ""AMX"",
  year_min = 2010,
  model = ""binomial""
)
plot(x)

if (require(""ggplot2"")) {
  ggplot_sir_predict(x)
}

# using dplyr:
if (require(""dplyr"")) {
  x <- example_isolates %>%
    filter_first_isolate() %>%
    filter(mo_genus(mo) == ""Staphylococcus"") %>%
    resistance_predict(""PEN"", model = ""binomial"")
  print(plot(x))

  # get the model from the object
  mymodel <- attributes(x)$model
  summary(mymodel)
}

# create nice plots with ggplot2 yourself
if (require(""dplyr"") && require(""ggplot2"")) {
  data <- example_isolates %>%
    filter(mo == as.mo(""E. coli"")) %>%
    resistance_predict(
      col_ab = ""AMX"",
      col_date = ""date"",
      model = ""binomial"",
      info = FALSE,
      minimum = 15
    )
  head(data)
  autoplot(data)
}
```

## See Also

The `proportion()` functions to calculate resistance

Models: `lm()` `glm()`



","['Predict Antimicrobial Resistance```rresistance_predict(  x,  col_ab,  col_date = NULL,  year_min = NULL,  year_max = NULL,  year_every = 1,  minimum = 30,  model = NULL,  I_as_S = TRUE,  preserve_measurements = TRUE,  info = interactive(),  ...)sir_predict(  x,  col_ab,  col_date = NULL,  year_min = NULL,  year_max = NULL,  year_every = 1,  minimum = 30,  model = NULL,  I_as_S = TRUE,  preserve_measurements = TRUE,  info = interactive(),  ...) S3 method for class \'resistance_predict\'plot(x, main = paste(""Resistance Prediction of"", x_name), ...)ggplot_sir_predict(  x,  main = paste(""Resistance Prediction of"", x_name),  ribbon = TRUE,  ...) S3 method for class \'resistance_predict\'autoplot(  object,  main = paste(""Resistance Prediction of"", x_name),  ribbon = TRUE,  ...)``` Arguments- `x`: a data.frame containing isolates.', 'Can be left blank for automatic determination, see Examples.- `col_ab`: column name of `x` containing antimicrobial interpretations (`""R""`, `""I""` and `""S""`)- `col_date`: column name of the date, will be used to calculate years if this column doesn\'t consist of years already - the default is the first column of with a date class- `year_min`: lowest year to use in the prediction model, dafaults to the lowest year in `col_date`- `year_max`: highest year to use in the prediction model - the default is 10 years after today- `year_every`: unit of sequence between lowest year found in the data and `year_max`- `minimum`: minimal amount of available isolates per year to include.', 'Years containing less observations will be estimated by the model.- `model`: the statistical model of choice.', 'This could be a generalised linear regression model with binomial distribution (i.e.', 'using `glm(..., family = binomial)`, assuming that a period of zero resistance was followed by a period of increasing resistance leading slowly to more and more resistance.', 'See Details for all valid options.- `I_as_S`: a logical to indicate whether values `""I""` should be treated as `""S""` (will otherwise be treated as `""R""`).', 'The default, `TRUE`, follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section Interpretation of S, I and R below.- `preserve_measurements`: a logical to indicate whether predictions of years that are actually available in the data should be overwritten by the original data.', 'The standard errors of those years will be `NA`.- `info`: a logical to indicate whether textual analysis should be printed with the name and `summary()` of the statistical model.- `...`: arguments passed on to functions- `main`: title of the plot- `ribbon`: a logical to indicate whether a ribbon should be shown (default) or error bars- `object`: model data to be plotted ReturnsA data.frame with extra class `resistance_predict` with columns:  `year`  `value`, the same as `estimated` when `preserve_measurements = FALSE`, and a combination of `observed` and `estimated` otherwise  `se_min`, the lower bound of the standard error with a minimum of `0` (so the standard error will never go below 0%)  `se_max` the upper bound of the standard error with a maximum of `1` (so the standard error will never go above 100%)  `observations`, the total number of available observations in that year, i.e.', '`S + I + R`  `observed`, the original observed resistant percentages  `estimated`, the estimated resistant percentages, calculated by the modelFurthermore, the model itself is available as an attribute: `attributes(x)$model`, see Examples.', 'DescriptionCreate a prediction model to predict antimicrobial resistance for the next years on statistical solid ground.', 'Standard errors (SE) will be returned as columns `se_min` and `se_max`.', 'See Examples for a real live example.', 'DetailsValid options for the statistical model (argument `model`) are:  `""binomial""` or `""binom""` or `""logit""`: a generalised linear regression model with binomial distribution  `""loglin""` or `""poisson""`: a generalised log-linear regression model with poisson distribution  `""lin""` or `""linear""`: a linear regression model Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.', 'I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.', 'R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.', 'Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight.', 'Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.', 'Examples```rx <- resistance_predict(example_isolates,  col_ab = ""AMX"",  year_min = 2010,  model = ""binomial"")plot(x)if (require(""ggplot2"")) {  ggplot_sir_predict(x)} using dplyr:if (require(""dplyr"")) {  x <- example_isolates %>%    filter_first_isolate() %>%    filter(mo_genus(mo) == ""Staphylococcus"") %>%    resistance_predict(""PEN"", model = ""binomial"")  print(plot(x))   get the model from the object  mymodel <- attributes(x)$model  summary(mymodel)} create nice plots with ggplot2 yourselfif (require(""dplyr"") && require(""ggplot2"")) {  data <- example_isolates %>%    filter(mo == as.mo(""E. coli"")) %>%    resistance_predict(      col_ab = ""AMX"",      col_date = ""date"",      model = ""binomial"",      info = FALSE,      minimum = 15    )  head(data)  autoplot(data)}``` See AlsoThe `proportion()` functions to calculate resistanceModels: `lm()` `glm()`']",1," Predict Antimicrobial Resistance```rresistance_predict(  x,  col_ab,  col_date = NULL,  year_min = NULL,  year_max = NULL,  year_every = 1,  minimum = 30,  model = NULL,  I_as_S = TRUE,  preserve_measurements = TRUE,  info = interactive(),  ...)sir_predict(  x,  col_ab,  col_date = NULL,  year_min = NULL,  year_max = NULL,  year_every = 1,  minimum = 30,  model = NULL,  I_as_S = TRUE,  preserve_measurements = TRUE,  info = interactive(),  ...) S3 method for class 'resistance_predict'plot(x, main = paste(""Resistance Prediction of"", x_name), ...)ggplot_sir_predict(  x,  main = paste(""Resistance Prediction of"", x_name),  ribbon = TRUE,  ...) S3 method for class 'resistance_predict'autoplot(  object,  main = paste(""Resistance Prediction of"", x_name),  ribbon = TRUE,  ...)``` Arguments- `x`: a data.frame containing isolates. Can be left blank for automatic determination, see Examples.- `col_ab`: column name of `x` containing antimicrobial interpretations (`""R""`, `""I""` and `""S""`)- `col_date`: column name of the date, will be used to calculate years if this column doesn't consist of years already - the default is the first column of with a date class- `year_min`: lowest year to use in the prediction model, dafaults to the lowest year in `col_date`- `year_max`: highest year to use in the prediction model - the default is 10 years after today- `year_every`: unit of sequence between lowest year found in the data and `year_max`- `minimum`: minimal amount of available isolates per year to include. Years containing less observations will be estimated by the model.- `model`: the statistical model of choice. This could be a generalised linear regression model with binomial distribution (i.e. using `glm(..., family = binomial)`, assuming that a period of zero resistance was followed by a period of increasing resistance leading slowly to more and more resistance. See Details for all valid options.- `I_as_S`: a logical to indicate whether values `""I""` should be treated as `""S""` (will otherwise be treated as `""R""`). The default, `TRUE`, follows the redefinition by EUCAST about the interpretation of I (increased exposure) in 2019, see section Interpretation of S, I and R below.- `preserve_measurements`: a logical to indicate whether predictions of years that are actually available in the data should be overwritten by the original data. The standard errors of those years will be `NA`.- `info`: a logical to indicate whether textual analysis should be printed with the name and `summary()` of the statistical model.- `...`: arguments passed on to functions- `main`: title of the plot- `ribbon`: a logical to indicate whether a ribbon should be shown (default) or error bars- `object`: model data to be plotted ReturnsA data.frame with extra class `resistance_predict` with columns:  `year`  `value`, the same as `estimated` when `preserve_measurements = FALSE`, and a combination of `observed` and `estimated` otherwise  `se_min`, the lower bound of the standard error with a minimum of `0` (so the standard error will never go below 0%)  `se_max` the upper bound of the standard error with a maximum of `1` (so the standard error will never go above 100%)  `observations`, the total number of available observations in that year, i.e. `S + I + R`  `observed`, the original observed resistant percentages  `estimated`, the estimated resistant percentages, calculated by the modelFurthermore, the model itself is available as an attribute: `attributes(x)$model`, see Examples. DescriptionCreate a prediction model to predict antimicrobial resistance for the next years on statistical solid ground. Standard errors (SE) will be returned as columns `se_min` and `se_max`. See Examples for a real live example. DetailsValid options for the statistical model (argument `model`) are:  `""binomial""` or `""binom""` or `""logit""`: a generalised linear regression model with binomial distribution  `""loglin""` or `""poisson""`: a generalised log-linear regression model with poisson distribution  `""lin""` or `""linear""`: a linear regression model Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.  I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.  R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.        Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates. Examples```rx <- resistance_predict(example_isolates,  col_ab = ""AMX"",  year_min = 2010,  model = ""binomial"")plot(x)if (require(""ggplot2"")) {  ggplot_sir_predict(x)} using dplyr:if (require(""dplyr"")) {  x <- example_isolates %>%    filter_first_isolate() %>%    filter(mo_genus(mo) == ""Staphylococcus"") %>%    resistance_predict(""PEN"", model = ""binomial"")  print(plot(x))   get the model from the object  mymodel <- attributes(x)$model  summary(mymodel)} create nice plots with ggplot2 yourselfif (require(""dplyr"") && require(""ggplot2"")) {  data <- example_isolates %>%    filter(mo == as.mo(""E. coli"")) %>%    resistance_predict(      col_ab = ""AMX"",      col_date = ""date"",      model = ""binomial"",      info = FALSE,      minimum = 15    )  head(data)  autoplot(data)}``` See AlsoThe `proportion()` functions to calculate resistanceModels: `lm()` `glm()`",2
AMR,mo_source.md,"# User-Defined Reference Data Set for Microorganisms

```r
set_mo_source(
  path,
  destination = getOption(""AMR_mo_source"", ""~/mo_source.rds"")
)

get_mo_source(destination = getOption(""AMR_mo_source"", ""~/mo_source.rds""))
```

## Arguments

- `path`: location of your reference file, this can be any text file (comma-, tab- or pipe-separated) or an Excel file (see **Details**). Can also be `""""`, `NULL` or `FALSE` to delete the reference file.
- `destination`: destination of the compressed data file - the default is the user's home directory.

## Description

These functions can be used to predefine your own reference to be used in `as.mo()` and consequently all `mo_*` functions (such as `mo_genus()` and `mo_gramstain()`).

This is the fastest way to have your organisation (or analysis) specific codes picked up and translated by this package, since you don't have to bother about it again after setting it up once.

## Details

The reference file can be a text file separated with commas (CSV) or tabs or pipes, an Excel file (either 'xls' or 'xlsx' format) or an object file (extension '.rds'). To use an Excel file, you will need to have the `readxl` package installed. `set_mo_source()` will check the file for validity: it must be a data.frame , must have a column named `""mo""` which contains values from `microorganisms$mo` or `microorganisms$fullname` and must have a reference column with your own defined values. If all tests pass, `set_mo_source()` will read the file into and will ask to export it to `""~/mo_source.rds""`. The CRAN policy disallows packages to write to the file system, although '**exceptions may be allowed in interactive sessions if the package obtains confirmation from the user**'. For this reason, this function only works in interactive sessions so that the user can specifically confirm and allow that this file will be created. The destination of this file can be set with the `destination` argument and defaults to the user's home directory. It can also be set with the package option `AMR_mo_source`, e.g. `options(AMR_mo_source = ""my/location/file.rds"")`.

The created compressed data file `""mo_source.rds""` will be used at default for MO determination (function `as.mo()` and consequently all `mo_*` functions like `mo_genus()` and `mo_gramstain()`). The location and timestamp of the original file will be saved as an attribute to the compressed data file.

The function `get_mo_source()` will return the data set by reading `""mo_source.rds""` with `readRDS()`. If the original file has changed (by checking the location and timestamp of the original file), it will call `set_mo_source()` to update the data file automatically if used in an interactive session.

Reading an Excel file (`.xlsx`) with only one row has a size of 8-9 kB. The compressed file created with `set_mo_source()` will then have a size of 0.1 kB and can be read by `get_mo_source()` in only a couple of microseconds (millionths of a second).

## How to Setup

 Imagine this data on a sheet of an Excel file. The first column contains the organisation specific codes, the second column contains valid taxonomic names:

 

```
|         A          |            B          |
--|--------------------|-----------------------|
1 | Organisation XYZ   | mo                    |
2 | lab_mo_ecoli       | Escherichia coli      |
3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |
4 |                    |                       |
```

 

We save it as `""home/me/ourcodes.xlsx""`. Now we have to set it as a source:

 

```
set_mo_source(""home/me/ourcodes.xlsx"")
#> NOTE: Created mo_source file '/Users/me/mo_source.rds' (0.3 kB) from
#>       '/Users/me/Documents/ourcodes.xlsx' (9 kB), columns
#>       ""Organisation XYZ"" and ""mo""
```

 

It has now created a file `""~/mo_source.rds""` with the contents of our Excel file. Only the first column with foreign values and the 'mo' column will be kept when creating the RDS file.


And now we can use it in our functions:

 

```
as.mo(""lab_mo_ecoli"")
#> Class 'mo'
#> [1] B_ESCHR_COLI

mo_genus(""lab_mo_kpneumoniae"")
#> [1] ""Klebsiella""

# other input values still work too
as.mo(c(""Escherichia coli"", ""E. coli"", ""lab_mo_ecoli""))
#> NOTE: Translation to one microorganism was guessed with uncertainty.
#>       Use mo_uncertainties() to review it.
#> Class 'mo'
#> [1] B_ESCHR_COLI B_ESCHR_COLI B_ESCHR_COLI
```

 

If we edit the Excel file by, let's say, adding row 4 like this:


 

```
|         A          |            B          |
--|--------------------|-----------------------|
1 | Organisation XYZ   | mo                    |
2 | lab_mo_ecoli       | Escherichia coli      |
3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |
4 | lab_Staph_aureus   | Staphylococcus aureus |
5 |                    |                       |
```

 

...any new usage of an MO function in this package will update your data file:


 

```
as.mo(""lab_mo_ecoli"")
#> NOTE: Updated mo_source file '/Users/me/mo_source.rds' (0.3 kB) from
#>       '/Users/me/Documents/ourcodes.xlsx' (9 kB), columns
#>        ""Organisation XYZ"" and ""mo""
#> Class 'mo'
#> [1] B_ESCHR_COLI

mo_genus(""lab_Staph_aureus"")
#> [1] ""Staphylococcus""
```

 

To delete the reference data file, just use `""""`, `NULL` or `FALSE` as input for `set_mo_source()`:


 

```
set_mo_source(NULL)
#> Removed mo_source file '/Users/me/mo_source.rds'
```

 

If the original file (in the previous case an Excel file) is moved or deleted, the `mo_source.rds` file will be removed upon the next use of `as.mo()` or any `mo_*` function.



","['User-Defined Reference Data Set for Microorganisms```rset_mo_source(  path,  destination = getOption(""AMR_mo_source"", ""~/mo_source.rds""))get_mo_source(destination = getOption(""AMR_mo_source"", ""~/mo_source.rds""))``` Arguments- `path`: location of your reference file, this can be any text file (comma-, tab- or pipe-separated) or an Excel file (see Details).', 'Can also be `""""`, `NULL` or `FALSE` to delete the reference file.- `destination`: destination of the compressed data file - the default is the user\'s home directory.', ""DescriptionThese functions can be used to predefine your own reference to be used in `as.mo()` and consequently all `mo_` functions (such as `mo_genus()` and `mo_gramstain()`).This is the fastest way to have your organisation (or analysis) specific codes picked up and translated by this package, since you don't have to bother about it again after setting it up once."", ""DetailsThe reference file can be a text file separated with commas (CSV) or tabs or pipes, an Excel file (either 'xls' or 'xlsx' format) or an object file (extension '.rds')."", 'To use an Excel file, you will need to have the `readxl` package installed.', '`set_mo_source()` will check the file for validity: it must be a data.frame , must have a column named `""mo""` which contains values from `microorganisms$mo` or `microorganisms$fullname` and must have a reference column with your own defined values.', 'If all tests pass, `set_mo_source()` will read the file into and will ask to export it to `""~/mo_source.rds""`.', ""The CRAN policy disallows packages to write to the file system, although 'exceptions may be allowed in interactive sessions if the package obtains confirmation from the user'."", 'For this reason, this function only works in interactive sessions so that the user can specifically confirm and allow that this file will be created.', ""The destination of this file can be set with the `destination` argument and defaults to the user's home directory."", 'It can also be set with the package option `AMR_mo_source`, e.g.', '`options(AMR_mo_source = ""my/location/file.rds"")`.The created compressed data file `""mo_source.rds""` will be used at default for MO determination (function `as.mo()` and consequently all `mo_` functions like `mo_genus()` and `mo_gramstain()`).', 'The location and timestamp of the original file will be saved as an attribute to the compressed data file.The function `get_mo_source()` will return the data set by reading `""mo_source.rds""` with `readRDS()`.', 'If the original file has changed (by checking the location and timestamp of the original file), it will call `set_mo_source()` to update the data file automatically if used in an interactive session.Reading an Excel file (`.xlsx`) with only one row has a size of 8-9 kB.', 'The compressed file created with `set_mo_source()` will then have a size of 0.1 kB and can be read by `get_mo_source()` in only a couple of microseconds (millionths of a second).', 'How to Setup Imagine this data on a sheet of an Excel file.', 'The first column contains the organisation specific codes, the second column contains valid taxonomic names: ```|         A          |            B          |--|--------------------|-----------------------|1 | Organisation XYZ   | mo                    |2 | lab_mo_ecoli       | Escherichia coli      |3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |4 |                    |                       |``` We save it as `""home/me/ourcodes.xlsx""`.', 'Now we have to set it as a source: ```set_mo_source(""home/me/ourcodes.xlsx"")> NOTE: Created mo_source file \'/Users/me/mo_source.rds\' (0.3 kB) from>       \'/Users/me/Documents/ourcodes.xlsx\' (9 kB), columns>       ""Organisation XYZ"" and ""mo""``` It has now created a file `""~/mo_source.rds""` with the contents of our Excel file.', 'Only the first column with foreign values and the \'mo\' column will be kept when creating the RDS file.And now we can use it in our functions: ```as.mo(""lab_mo_ecoli"")> Class \'mo\'> [1] B_ESCHR_COLImo_genus(""lab_mo_kpneumoniae"")> [1] ""Klebsiella"" other input values still work tooas.mo(c(""Escherichia coli"", ""E. coli"", ""lab_mo_ecoli""))> NOTE: Translation to one microorganism was guessed with uncertainty.>       Use mo_uncertainties() to review it.> Class \'mo\'> [1] B_ESCHR_COLI B_ESCHR_COLI B_ESCHR_COLI``` If we edit the Excel file by, let\'s say, adding row 4 like this: ```|         A          |            B          |--|--------------------|-----------------------|1 | Organisation XYZ   | mo                    |2 | lab_mo_ecoli       | Escherichia coli      |3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |4 | lab_Staph_aureus   | Staphylococcus aureus |5 |                    |                       |``` ...any new usage of an MO function in this package will update your data file: ```as.mo(""lab_mo_ecoli"")> NOTE: Updated mo_source file \'/Users/me/mo_source.rds\' (0.3 kB) from>       \'/Users/me/Documents/ourcodes.xlsx\' (9 kB), columns>        ""Organisation XYZ"" and ""mo""> Class \'mo\'> [1] B_ESCHR_COLImo_genus(""lab_Staph_aureus"")> [1] ""Staphylococcus""``` To delete the reference data file, just use `""""`, `NULL` or `FALSE` as input for `set_mo_source()`: ```set_mo_source(NULL)> Removed mo_source file \'/Users/me/mo_source.rds\'``` If the original file (in the previous case an Excel file) is moved or deleted, the `mo_source.rds` file will be removed upon the next use of `as.mo()` or any `mo_` function.']",1," User-Defined Reference Data Set for Microorganisms```rset_mo_source(  path,  destination = getOption(""AMR_mo_source"", ""~/mo_source.rds""))get_mo_source(destination = getOption(""AMR_mo_source"", ""~/mo_source.rds""))``` Arguments- `path`: location of your reference file, this can be any text file (comma-, tab- or pipe-separated) or an Excel file (see Details). Can also be `""""`, `NULL` or `FALSE` to delete the reference file.- `destination`: destination of the compressed data file - the default is the user's home directory. DescriptionThese functions can be used to predefine your own reference to be used in `as.mo()` and consequently all `mo_` functions (such as `mo_genus()` and `mo_gramstain()`).This is the fastest way to have your organisation (or analysis) specific codes picked up and translated by this package, since you don't have to bother about it again after setting it up once. DetailsThe reference file can be a text file separated with commas (CSV) or tabs or pipes, an Excel file (either 'xls' or 'xlsx' format) or an object file (extension '.rds'). To use an Excel file, you will need to have the `readxl` package installed. `set_mo_source()` will check the file for validity: it must be a data.frame , must have a column named `""mo""` which contains values from `microorganisms$mo` or `microorganisms$fullname` and must have a reference column with your own defined values. If all tests pass, `set_mo_source()` will read the file into and will ask to export it to `""~/mo_source.rds""`. The CRAN policy disallows packages to write to the file system, although 'exceptions may be allowed in interactive sessions if the package obtains confirmation from the user'. For this reason, this function only works in interactive sessions so that the user can specifically confirm and allow that this file will be created. The destination of this file can be set with the `destination` argument and defaults to the user's home directory. It can also be set with the package option `AMR_mo_source`, e.g. `options(AMR_mo_source = ""my/location/file.rds"")`.The created compressed data file `""mo_source.rds""` will be used at default for MO determination (function `as.mo()` and consequently all `mo_` functions like `mo_genus()` and `mo_gramstain()`). The location and timestamp of the original file will be saved as an attribute to the compressed data file.The function `get_mo_source()` will return the data set by reading `""mo_source.rds""` with `readRDS()`. If the original file has changed (by checking the location and timestamp of the original file), it will call `set_mo_source()` to update the data file automatically if used in an interactive session.Reading an Excel file (`.xlsx`) with only one row has a size of 8-9 kB. The compressed file created with `set_mo_source()` will then have a size of 0.1 kB and can be read by `get_mo_source()` in only a couple of microseconds (millionths of a second). How to Setup Imagine this data on a sheet of an Excel file. The first column contains the organisation specific codes, the second column contains valid taxonomic names: ```|         A          |            B          |--|--------------------|-----------------------|1 | Organisation XYZ   | mo                    |2 | lab_mo_ecoli       | Escherichia coli      |3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |4 |                    |                       |``` We save it as `""home/me/ourcodes.xlsx""`. Now we have to set it as a source: ```set_mo_source(""home/me/ourcodes.xlsx"")> NOTE: Created mo_source file '/Users/me/mo_source.rds' (0.3 kB) from>       '/Users/me/Documents/ourcodes.xlsx' (9 kB), columns>       ""Organisation XYZ"" and ""mo""``` It has now created a file `""~/mo_source.rds""` with the contents of our Excel file. Only the first column with foreign values and the 'mo' column will be kept when creating the RDS file.And now we can use it in our functions: ```as.mo(""lab_mo_ecoli"")> Class 'mo'> [1] B_ESCHR_COLImo_genus(""lab_mo_kpneumoniae"")> [1] ""Klebsiella"" other input values still work tooas.mo(c(""Escherichia coli"", ""E. coli"", ""lab_mo_ecoli""))> NOTE: Translation to one microorganism was guessed with uncertainty.>       Use mo_uncertainties() to review it.> Class 'mo'> [1] B_ESCHR_COLI B_ESCHR_COLI B_ESCHR_COLI``` If we edit the Excel file by, let's say, adding row 4 like this: ```|         A          |            B          |--|--------------------|-----------------------|1 | Organisation XYZ   | mo                    |2 | lab_mo_ecoli       | Escherichia coli      |3 | lab_mo_kpneumoniae | Klebsiella pneumoniae |4 | lab_Staph_aureus   | Staphylococcus aureus |5 |                    |                       |``` ...any new usage of an MO function in this package will update your data file: ```as.mo(""lab_mo_ecoli"")> NOTE: Updated mo_source file '/Users/me/mo_source.rds' (0.3 kB) from>       '/Users/me/Documents/ourcodes.xlsx' (9 kB), columns>        ""Organisation XYZ"" and ""mo""> Class 'mo'> [1] B_ESCHR_COLImo_genus(""lab_Staph_aureus"")> [1] ""Staphylococcus""``` To delete the reference data file, just use `""""`, `NULL` or `FALSE` as input for `set_mo_source()`: ```set_mo_source(NULL)> Removed mo_source file '/Users/me/mo_source.rds'``` If the original file (in the previous case an Excel file) is moved or deleted, the `mo_source.rds` file will be removed upon the next use of `as.mo()` or any `mo_` function.",2
AMR,italicise_taxonomy.md,"# Italicise Taxonomic Families, Genera, Species, Subspecies

```r
italicise_taxonomy(string, type = c(""markdown"", ""ansi""))

italicize_taxonomy(string, type = c(""markdown"", ""ansi""))
```

## Arguments

- `string`: a character (vector)
- `type`: type of conversion of the taxonomic names, either ""markdown"" or ""ansi"", see **Details**

## Description

According to the binomial nomenclature, the lowest four taxonomic levels (family, genus, species, subspecies) should be printed in italics. This function finds taxonomic names within strings and makes them italic.

## Details

This function finds the taxonomic names and makes them italic based on the microorganisms data set.

The taxonomic names can be italicised using markdown (the default) by adding `*` before and after the taxonomic names, or using ANSI colours by adding `\033[3m` before and `\033[23m` after the taxonomic names. If multiple ANSI colours are not available, no conversion will occur.

This function also supports abbreviation of the genus if it is followed by a species, such as ""E. coli"" and ""K. pneumoniae ozaenae"".

## Examples

```r
italicise_taxonomy(""An overview of Staphylococcus aureus isolates"")
italicise_taxonomy(""An overview of S. aureus isolates"")

cat(italicise_taxonomy(""An overview of S. aureus isolates"", type = ""ansi""))
```



","['Italicise Taxonomic Families, Genera, Species, Subspecies```ritalicise_taxonomy(string, type = c(""markdown"", ""ansi""))italicize_taxonomy(string, type = c(""markdown"", ""ansi""))``` Arguments- `string`: a character (vector)- `type`: type of conversion of the taxonomic names, either ""markdown"" or ""ansi"", see Details DescriptionAccording to the binomial nomenclature, the lowest four taxonomic levels (family, genus, species, subspecies) should be printed in italics.', 'This function finds taxonomic names within strings and makes them italic.', 'DetailsThis function finds the taxonomic names and makes them italic based on the microorganisms data set.The taxonomic names can be italicised using markdown (the default) by adding `` before and after the taxonomic names, or using ANSI colours by adding `\\033[3m` before and `\\033[23m` after the taxonomic names.', 'If multiple ANSI colours are not available, no conversion will occur.This function also supports abbreviation of the genus if it is followed by a species, such as ""E. coli"" and ""K. pneumoniae ozaenae"".', 'Examples```ritalicise_taxonomy(""An overview of Staphylococcus aureus isolates"")italicise_taxonomy(""An overview of S. aureus isolates"")cat(italicise_taxonomy(""An overview of S. aureus isolates"", type = ""ansi""))```']",1," Italicise Taxonomic Families, Genera, Species, Subspecies```ritalicise_taxonomy(string, type = c(""markdown"", ""ansi""))italicize_taxonomy(string, type = c(""markdown"", ""ansi""))``` Arguments- `string`: a character (vector)- `type`: type of conversion of the taxonomic names, either ""markdown"" or ""ansi"", see Details DescriptionAccording to the binomial nomenclature, the lowest four taxonomic levels (family, genus, species, subspecies) should be printed in italics. This function finds taxonomic names within strings and makes them italic. DetailsThis function finds the taxonomic names and makes them italic based on the microorganisms data set.The taxonomic names can be italicised using markdown (the default) by adding `` before and after the taxonomic names, or using ANSI colours by adding `\033[3m` before and `\033[23m` after the taxonomic names. If multiple ANSI colours are not available, no conversion will occur.This function also supports abbreviation of the genus if it is followed by a species, such as ""E. coli"" and ""K. pneumoniae ozaenae"". Examples```ritalicise_taxonomy(""An overview of Staphylococcus aureus isolates"")italicise_taxonomy(""An overview of S. aureus isolates"")cat(italicise_taxonomy(""An overview of S. aureus isolates"", type = ""ansi""))```",2
AMR,AMR-options.md,"# Options for the AMR package

## Description

This is an overview of all the package-specific `options()` you can set in the `AMR` package.

## Options

 * `AMR_custom_ab`
   
   Allows to use custom antimicrobial drugs with this package. This is explained in `add_custom_antimicrobials()`.
 * `AMR_custom_mo`
   
   Allows to use custom microorganisms with this package. This is explained in `add_custom_microorganisms()`.
 * `AMR_eucastrules`
   
   Used for setting the default types of rules for `eucast_rules()` function, must be one or more of: `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`.
 * `AMR_guideline`
   
   Used for setting the default guideline for interpreting MIC values and disk diffusion diameters with `as.sir()`. Can be only the guideline name (e.g., `""CLSI""`) or the name with a year (e.g. `""CLSI 2019""`). The default to the latest implemented EUCAST guideline, currently `""EUCAST 2023""`. Supported guideline are currently EUCAST (2011-2023) and CLSI (2011-2023).
 * `AMR_ignore_pattern`
   
   A regular expression to ignore (i.e., make `NA`) any match given in `as.mo()` and all `mo_*` functions.
 * `AMR_include_PKPD`
   
   A logical to use in `as.sir()`, to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`.
 * `AMR_ecoff`
   
   A logical use in `as.sir()`, to indicate that ECOFF (Epidemiological Cut-Off) values must be used - the default is `FALSE`.
 * `AMR_include_screening`
   
   A logical to use in `as.sir()`, to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`.
 * `AMR_keep_synonyms`
   
   A logical to use in `as.mo()` and all `mo_*` functions, to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`.
 * `AMR_cleaning_regex`
   
   A regular expression (case-insensitive) to use in `as.mo()` and all `mo_*` functions, to clean the user input. The default is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"".
 * `AMR_locale`
   
   A language to use for the `AMR` package, can be one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk). The default is the current system language (if supported).
 * `AMR_mo_source`
   
   A file location for a manual code list to be used in `as.mo()` and all `mo_*` functions. This is explained in `set_mo_source()`.

## Saving Settings Between Sessions

 Settings in are not saved globally and are thus lost when is exited. You can save your options to your own `.Rprofile` file, which is a user-specific file. You can edit it using:

 

```
utils::file.edit(""~/.Rprofile"")
```

 

In this file, you can set options such as:

 

```
options(AMR_locale = ""pt"")
 options(AMR_include_PKPD = TRUE)
```

 

to add Portuguese language support of antibiotics, and allow PK/PD rules when interpreting MIC values with `as.sir()`.


### Share Options Within Team

 For a more global approach, e.g. within a data team, save an options file to a remote file location, such as a shared network drive. This would work in this way:

1. Save a plain text file to e.g. ""X:/team_folder/R_options.R"" and fill it with preferred settings.
2. For each user, open the `.Rprofile` file using `utils::file.edit(""~/.Rprofile"")` and put in there:
   
    
   
   ```
   source(""X:/team_folder/R_options.R"")
   ```
3. Reload R/RStudio and check the settings with `getOption()`, e.g. `getOption(""AMR_locale"")` if you have set that value.

Now the team settings are configured in only one place, and can be maintained there.



","['Options for the AMR package DescriptionThis is an overview of all the package-specific `options()` you can set in the `AMR` package.', 'Options  `AMR_custom_ab`      Allows to use custom antimicrobial drugs with this package.', 'This is explained in `add_custom_antimicrobials()`.', '`AMR_custom_mo`      Allows to use custom microorganisms with this package.', 'This is explained in `add_custom_microorganisms()`.', '`AMR_eucastrules`      Used for setting the default types of rules for `eucast_rules()` function, must be one or more of: `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`.', '`AMR_guideline`      Used for setting the default guideline for interpreting MIC values and disk diffusion diameters with `as.sir()`.', 'Can be only the guideline name (e.g., `""CLSI""`) or the name with a year (e.g.', 'The default to the latest implemented EUCAST guideline, currently `""EUCAST 2023""`.', 'Supported guideline are currently EUCAST (2011-2023) and CLSI (2011-2023).', '`AMR_ignore_pattern`      A regular expression to ignore (i.e., make `NA`) any match given in `as.mo()` and all `mo_` functions.', '`AMR_include_PKPD`      A logical to use in `as.sir()`, to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`.', '`AMR_ecoff`      A logical use in `as.sir()`, to indicate that ECOFF (Epidemiological Cut-Off) values must be used - the default is `FALSE`.', '`AMR_include_screening`      A logical to use in `as.sir()`, to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`.', '`AMR_keep_synonyms`      A logical to use in `as.mo()` and all `mo_` functions, to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names.', '`AMR_cleaning_regex`      A regular expression (case-insensitive) to use in `as.mo()` and all `mo_` functions, to clean the user input.', 'The default is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"".', '`AMR_locale`      A language to use for the `AMR` package, can be one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk).', 'The default is the current system language (if supported).', '`AMR_mo_source`      A file location for a manual code list to be used in `as.mo()` and all `mo_` functions.', 'This is explained in `set_mo_source()`.', 'Saving Settings Between Sessions Settings in are not saved globally and are thus lost when is exited.', 'You can save your options to your own `.Rprofile` file, which is a user-specific file.', 'You can edit it using: ```utils::file.edit(""~/.Rprofile"")``` In this file, you can set options such as: ```options(AMR_locale = ""pt"") options(AMR_include_PKPD = TRUE)``` to add Portuguese language support of antibiotics, and allow PK/PD rules when interpreting MIC values with `as.sir()`.', 'Share Options Within Team For a more global approach, e.g.', 'within a data team, save an options file to a remote file location, such as a shared network drive.', 'This would work in this way:1.', 'Save a plain text file to e.g.', '""X:/team_folder/R_options.R"" and fill it with preferred settings.2.', 'For each user, open the `.Rprofile` file using `utils::file.edit(""~/.Rprofile"")` and put in there:             ```   source(""X:/team_folder/R_options.R"")   ```3.', 'Reload R/RStudio and check the settings with `getOption()`, e.g.', '`getOption(""AMR_locale"")` if you have set that value.Now the team settings are configured in only one place, and can be maintained there.']",1," Options for the AMR package DescriptionThis is an overview of all the package-specific `options()` you can set in the `AMR` package. Options  `AMR_custom_ab`      Allows to use custom antimicrobial drugs with this package. This is explained in `add_custom_antimicrobials()`.  `AMR_custom_mo`      Allows to use custom microorganisms with this package. This is explained in `add_custom_microorganisms()`.  `AMR_eucastrules`      Used for setting the default types of rules for `eucast_rules()` function, must be one or more of: `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`.  `AMR_guideline`      Used for setting the default guideline for interpreting MIC values and disk diffusion diameters with `as.sir()`. Can be only the guideline name (e.g., `""CLSI""`) or the name with a year (e.g. `""CLSI 2019""`). The default to the latest implemented EUCAST guideline, currently `""EUCAST 2023""`. Supported guideline are currently EUCAST (2011-2023) and CLSI (2011-2023).  `AMR_ignore_pattern`      A regular expression to ignore (i.e., make `NA`) any match given in `as.mo()` and all `mo_` functions.  `AMR_include_PKPD`      A logical to use in `as.sir()`, to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`.  `AMR_ecoff`      A logical use in `as.sir()`, to indicate that ECOFF (Epidemiological Cut-Off) values must be used - the default is `FALSE`.  `AMR_include_screening`      A logical to use in `as.sir()`, to indicate that clinical breakpoints for screening are allowed - the default is `FALSE`.  `AMR_keep_synonyms`      A logical to use in `as.mo()` and all `mo_` functions, to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`.  `AMR_cleaning_regex`      A regular expression (case-insensitive) to use in `as.mo()` and all `mo_` functions, to clean the user input. The default is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"".  `AMR_locale`      A language to use for the `AMR` package, can be one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk). The default is the current system language (if supported).  `AMR_mo_source`      A file location for a manual code list to be used in `as.mo()` and all `mo_` functions. This is explained in `set_mo_source()`. Saving Settings Between Sessions Settings in are not saved globally and are thus lost when is exited. You can save your options to your own `.Rprofile` file, which is a user-specific file. You can edit it using: ```utils::file.edit(""~/.Rprofile"")``` In this file, you can set options such as: ```options(AMR_locale = ""pt"") options(AMR_include_PKPD = TRUE)``` to add Portuguese language support of antibiotics, and allow PK/PD rules when interpreting MIC values with `as.sir()`. Share Options Within Team For a more global approach, e.g. within a data team, save an options file to a remote file location, such as a shared network drive. This would work in this way:1. Save a plain text file to e.g. ""X:/team_folder/R_options.R"" and fill it with preferred settings.2. For each user, open the `.Rprofile` file using `utils::file.edit(""~/.Rprofile"")` and put in there:             ```   source(""X:/team_folder/R_options.R"")   ```3. Reload R/RStudio and check the settings with `getOption()`, e.g. `getOption(""AMR_locale"")` if you have set that value.Now the team settings are configured in only one place, and can be maintained there.",3
AMR,antibiotics.md," data

# Data Sets with 603 Antimicrobial Drugs

## Format

### For the antibiotics data set: a tibble with 483 observations and 14 variables:

 * `ab`
   
   Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available. **This is a unique identifier.**
 * `cid`
   
   Compound ID as found in PubChem. **This is a unique identifier.**
 * `name`
   
   Official name as used by WHONET/EARS-Net or the WHO. **This is a unique identifier.**
 * `group`
   
   A short and concise group name, based on WHONET and WHOCC definitions
 * `atc`
   
   ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC, like `J01CR02`
 * `atc_group1`
   
   Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC, like `""Macrolides, lincosamides and streptogramins""`
 * `atc_group2`
   
   Official chemical subgroup (4th level ATC code) as defined by the WHOCC, like `""Macrolides""`
 * `abbr`
   
   List of abbreviations as used in many countries, also for antibiotic susceptibility testing (AST)
 * `synonyms`
   
   Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID
 * `oral_ddd`
   
   Defined Daily Dose (DDD), oral treatment, currently available for 174 drugs
 * `oral_units`
   
   Units of `oral_ddd`
 * `iv_ddd`
   
   Defined Daily Dose (DDD), parenteral (intravenous) treatment, currently available for 146 drugs
 * `iv_units`
   
   Units of `iv_ddd`
 * `loinc`
   
   All codes associated with the name of the antimicrobial drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Use `ab_loinc()` to retrieve them quickly, see `ab_property()`.

### For the antivirals data set: a tibble with 120 observations and 11 variables:

 * `av`
   
   Antiviral ID as used in this package (such as `ACI`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available. **This is a unique identifier.** Combinations are codes that contain a `+` to indicate this, such as `ATA+COBI` for atazanavir/cobicistat.
 * `name`
   
   Official name as used by WHONET/EARS-Net or the WHO. **This is a unique identifier.**
 * `atc`
   
   ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC
 * `cid`
   
   Compound ID as found in PubChem. **This is a unique identifier.**
 * `atc_group`
   
   Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC
 * `synonyms`
   
   Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID
 * `oral_ddd`
   
   Defined Daily Dose (DDD), oral treatment
 * `oral_units`
   
   Units of `oral_ddd`
 * `iv_ddd`
   
   Defined Daily Dose (DDD), parenteral treatment
 * `iv_units`
   
   Units of `iv_ddd`
 * `loinc`
   
   All codes associated with the name of the antiviral drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Use `av_loinc()` to retrieve them quickly, see `av_property()`.

An object of class `tbl_df`(inherits from `tbl`, `data.frame`) with 120 rows and 11 columns.

## Source

 * World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology (WHOCC): [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)
 * Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Accessed from [https://loinc.org](https://loinc.org) on October 19th, 2023.
 * European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)

```r
antibiotics

antivirals
```

## Description

Two data sets containing all antibiotics/antimycotics and antivirals. Use `as.ab()` or one of the `ab_*` functions to retrieve values from the antibiotics data set. Three identifiers are included in this data set: an antibiotic ID (`ab`, primarily used in this package) as defined by WHONET/EARS-Net, an ATC code (`atc`) as defined by the WHO, and a Compound ID (`cid`) as found in PubChem. Other properties in this data set are derived from one or more of these codes. Note that some drugs have multiple ATC codes.

## Details

Properties that are based on an ATC code are only available when an ATC is available. These properties are: `atc_group1`, `atc_group2`, `oral_ddd`, `oral_units`, `iv_ddd` and `iv_units`.

Synonyms (i.e. trade names) were derived from the PubChem Compound ID (column `cid`) and consequently only available where a CID is available.

### Direct download

 Like all data sets in this package, these data sets are publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## WHOCC

 This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).

These have become the gold standard for international drug utilisation monitoring and research.

The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.

NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.)

## Examples

```r
antibiotics
antivirals
```

## See Also

microorganisms , intrinsic_resistant



","['data Data Sets with 603 Antimicrobial Drugs Format For the antibiotics data set: a tibble with 483 observations and 14 variables:  `ab`      Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available.', 'This is a unique identifier.', '`cid`      Compound ID as found in PubChem.', 'This is a unique identifier.', '`name`      Official name as used by WHONET/EARS-Net or the WHO.', 'This is a unique identifier.', '`group`      A short and concise group name, based on WHONET and WHOCC definitions  `atc`      ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC, like `J01CR02`  `atc_group1`      Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC, like `""Macrolides, lincosamides and streptogramins""`  `atc_group2`      Official chemical subgroup (4th level ATC code) as defined by the WHOCC, like `""Macrolides""`  `abbr`      List of abbreviations as used in many countries, also for antibiotic susceptibility testing (AST)  `synonyms`      Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID  `oral_ddd`      Defined Daily Dose (DDD), oral treatment, currently available for 174 drugs  `oral_units`      Units of `oral_ddd`  `iv_ddd`      Defined Daily Dose (DDD), parenteral (intravenous) treatment, currently available for 146 drugs  `iv_units`      Units of `iv_ddd`  `loinc`      All codes associated with the name of the antimicrobial drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023).', 'Use `ab_loinc()` to retrieve them quickly, see `ab_property()`.', 'For the antivirals data set: a tibble with 120 observations and 11 variables:  `av`      Antiviral ID as used in this package (such as `ACI`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available.', 'This is a unique identifier.', 'Combinations are codes that contain a `+` to indicate this, such as `ATA+COBI` for atazanavir/cobicistat.', '`name`      Official name as used by WHONET/EARS-Net or the WHO.', 'This is a unique identifier.', '`atc`      ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC  `cid`      Compound ID as found in PubChem.', 'This is a unique identifier.', '`atc_group`      Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC  `synonyms`      Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID  `oral_ddd`      Defined Daily Dose (DDD), oral treatment  `oral_units`      Units of `oral_ddd`  `iv_ddd`      Defined Daily Dose (DDD), parenteral treatment  `iv_units`      Units of `iv_ddd`  `loinc`      All codes associated with the name of the antiviral drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023).', 'Use `av_loinc()` to retrieve them quickly, see `av_property()`.An object of class `tbl_df`(inherits from `tbl`, `data.frame`) with 120 rows and 11 columns.', 'Source  World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology (WHOCC): [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)  Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023).', 'Accessed from [https://loinc.org](https://loinc.org) on October 19th, 2023.', 'European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)```rantibioticsantivirals``` DescriptionTwo data sets containing all antibiotics/antimycotics and antivirals.', 'Use `as.ab()` or one of the `ab_` functions to retrieve values from the antibiotics data set.', 'Three identifiers are included in this data set: an antibiotic ID (`ab`, primarily used in this package) as defined by WHONET/EARS-Net, an ATC code (`atc`) as defined by the WHO, and a Compound ID (`cid`) as found in PubChem.', 'Other properties in this data set are derived from one or more of these codes.', 'Note that some drugs have multiple ATC codes.', 'DetailsProperties that are based on an ATC code are only available when an ATC is available.', 'These properties are: `atc_group1`, `atc_group2`, `oral_ddd`, `oral_units`, `iv_ddd` and `iv_units`.Synonyms (i.e.', 'trade names) were derived from the PubChem Compound ID (column `cid`) and consequently only available where a CID is available.', 'Direct download Like all data sets in this package, these data sets are publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government.', 'The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package.', 'Examples```rantibioticsantivirals``` See Alsomicroorganisms , intrinsic_resistant']",1," data Data Sets with 603 Antimicrobial Drugs Format For the antibiotics data set: a tibble with 483 observations and 14 variables:  `ab`      Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available. This is a unique identifier.  `cid`      Compound ID as found in PubChem. This is a unique identifier.  `name`      Official name as used by WHONET/EARS-Net or the WHO. This is a unique identifier.  `group`      A short and concise group name, based on WHONET and WHOCC definitions  `atc`      ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC, like `J01CR02`  `atc_group1`      Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC, like `""Macrolides, lincosamides and streptogramins""`  `atc_group2`      Official chemical subgroup (4th level ATC code) as defined by the WHOCC, like `""Macrolides""`  `abbr`      List of abbreviations as used in many countries, also for antibiotic susceptibility testing (AST)  `synonyms`      Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID  `oral_ddd`      Defined Daily Dose (DDD), oral treatment, currently available for 174 drugs  `oral_units`      Units of `oral_ddd`  `iv_ddd`      Defined Daily Dose (DDD), parenteral (intravenous) treatment, currently available for 146 drugs  `iv_units`      Units of `iv_ddd`  `loinc`      All codes associated with the name of the antimicrobial drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Use `ab_loinc()` to retrieve them quickly, see `ab_property()`. For the antivirals data set: a tibble with 120 observations and 11 variables:  `av`      Antiviral ID as used in this package (such as `ACI`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available. This is a unique identifier. Combinations are codes that contain a `+` to indicate this, such as `ATA+COBI` for atazanavir/cobicistat.  `name`      Official name as used by WHONET/EARS-Net or the WHO. This is a unique identifier.  `atc`      ATC codes (Anatomical Therapeutic Chemical) as defined by the WHOCC  `cid`      Compound ID as found in PubChem. This is a unique identifier.  `atc_group`      Official pharmacological subgroup (3rd level ATC code) as defined by the WHOCC  `synonyms`      Synonyms (often trade names) of a drug, as found in PubChem based on their compound ID  `oral_ddd`      Defined Daily Dose (DDD), oral treatment  `oral_units`      Units of `oral_ddd`  `iv_ddd`      Defined Daily Dose (DDD), parenteral treatment  `iv_units`      Units of `iv_ddd`  `loinc`      All codes associated with the name of the antiviral drug from Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Use `av_loinc()` to retrieve them quickly, see `av_property()`.An object of class `tbl_df`(inherits from `tbl`, `data.frame`) with 120 rows and 11 columns. Source  World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology (WHOCC): [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)  Logical Observation Identifiers Names and Codes (LOINC), Version 2.76 (18 September, 2023). Accessed from [https://loinc.org](https://loinc.org) on October 19th, 2023.  European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)```rantibioticsantivirals``` DescriptionTwo data sets containing all antibiotics/antimycotics and antivirals. Use `as.ab()` or one of the `ab_` functions to retrieve values from the antibiotics data set. Three identifiers are included in this data set: an antibiotic ID (`ab`, primarily used in this package) as defined by WHONET/EARS-Net, an ATC code (`atc`) as defined by the WHO, and a Compound ID (`cid`) as found in PubChem. Other properties in this data set are derived from one or more of these codes. Note that some drugs have multiple ATC codes. DetailsProperties that are based on an ATC code are only available when an ATC is available. These properties are: `atc_group1`, `atc_group2`, `oral_ddd`, `oral_units`, `iv_ddd` and `iv_units`.Synonyms (i.e. trade names) were derived from the PubChem Compound ID (column `cid`) and consequently only available where a CID is available. Direct download Like all data sets in this package, these data sets are publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.) Examples```rantibioticsantivirals``` See Alsomicroorganisms , intrinsic_resistant",3
AMR,example_isolates.md," data

# Data Set with 2 000 Example Isolates

## Format

A tibble with 2 000 observations and 46 variables:

 * `date`
   
   Date of receipt at the laboratory
 * `patient`
   
   ID of the patient
 * `age`
   
   Age of the patient
 * `gender`
   
   Gender of the patient, either ""F"" or ""M""
 * `ward`
   
   Ward type where the patient was admitted, either ""Clinical"", ""ICU"", or ""Outpatient""
 * `mo`
   
   ID of microorganism created with `as.mo()`, see also the microorganisms data set
 * `PEN:RIF`
   
   40 different antibiotics with class `sir` (see `as.sir()`); these column names occur in the antibiotics data set and can be translated with `set_ab_names()` or `ab_name()`

```r
example_isolates
```

## Description

A data set containing 2 000 microbial isolates with their full antibiograms. This data set contains randomised fictitious data, but reflects reality and can be used to practise AMR data analysis. For examples, please read [the tutorial on our website](https://msberends.github.io/AMR/articles/AMR.html).

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
example_isolates
```



","['data Data Set with 2 000 Example Isolates FormatA tibble with 2 000 observations and 46 variables:  `date`      Date of receipt at the laboratory  `patient`      ID of the patient  `age`      Age of the patient  `gender`      Gender of the patient, either ""F"" or ""M""  `ward`      Ward type where the patient was admitted, either ""Clinical"", ""ICU"", or ""Outpatient""  `mo`      ID of microorganism created with `as.mo()`, see also the microorganisms data set  `PEN:RIF`      40 different antibiotics with class `sir` (see `as.sir()`); these column names occur in the antibiotics data set and can be translated with `set_ab_names()` or `ab_name()````rexample_isolates``` DescriptionA data set containing 2 000 microbial isolates with their full antibiograms.', 'This data set contains randomised fictitious data, but reflects reality and can be used to practise AMR data analysis.', 'For examples, please read [the tutorial on our website](https://msberends.github.io/AMR/articles/AMR.html).', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).']",1," data Data Set with 2 000 Example Isolates FormatA tibble with 2 000 observations and 46 variables:  `date`      Date of receipt at the laboratory  `patient`      ID of the patient  `age`      Age of the patient  `gender`      Gender of the patient, either ""F"" or ""M""  `ward`      Ward type where the patient was admitted, either ""Clinical"", ""ICU"", or ""Outpatient""  `mo`      ID of microorganism created with `as.mo()`, see also the microorganisms data set  `PEN:RIF`      40 different antibiotics with class `sir` (see `as.sir()`); these column names occur in the antibiotics data set and can be translated with `set_ab_names()` or `ab_name()````rexample_isolates``` DescriptionA data set containing 2 000 microbial isolates with their full antibiograms. This data set contains randomised fictitious data, but reflects reality and can be used to practise AMR data analysis. For examples, please read [the tutorial on our website](https://msberends.github.io/AMR/articles/AMR.html). DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rexample_isolates```",3
AMR,custom_eucast_rules.md,"# Define Custom EUCAST Rules

```r
custom_eucast_rules(...)
```

## Arguments

- `...`: rules in formula notation, see **Examples**

## Returns

A list containing the custom rules

## Description

Define custom EUCAST rules for your organisation or specific analysis and use the output of this function in `eucast_rules()`.

## Details

Some organisations have their own adoption of EUCAST rules. This function can be used to define custom EUCAST rules to be used in the `eucast_rules()` function.

## How it works

### Basics

 If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules. Rules must be set using what considers to be the 'formula notation'. The rule itself is written **before** the tilde (`~`) and the consequence of the rule is written **after** the tilde:

 

```
x <- custom_eucast_rules(TZP == ""S"" ~ aminopenicillins == ""S"",
                    TZP == ""R"" ~ aminopenicillins == ""R"")
```

 

These are two custom EUCAST rules: if TZP (piperacillin/tazobactam) is ""S"", all aminopenicillins (ampicillin and amoxicillin) must be made ""S"", and if TZP is ""R"", aminopenicillins must be made ""R"". These rules can also be printed to the console, so it is immediately clear how they work:

 

```
x
#> A set of custom EUCAST rules:
#>
#>   1. If TZP is ""S"" then set to  S :
#>      amoxicillin (AMX), ampicillin (AMP)
#>
#>   2. If TZP is ""R"" then set to  R :
#>      amoxicillin (AMX), ampicillin (AMP)
```

 

The rules (the part **before** the tilde, in above example `TZP == ""S""` and `TZP == ""R""`) must be evaluable in your data set: it should be able to run as a filter in your data set without errors. This means for the above example that the column `TZP` must exist. We will create a sample data set and test the rules set:


 

```
df <- data.frame(mo = c(""Escherichia coli"", ""Klebsiella pneumoniae""),
            TZP = as.sir(""R""),
            ampi = as.sir(""S""),
            cipro = as.sir(""S""))
df
#>                      mo TZP ampi cipro
#> 1      Escherichia coli   R    S     S
#> 2 Klebsiella pneumoniae   R    S     S

eucast_rules(df, rules = ""custom"", custom_rules = x, info = FALSE)
#>                      mo TZP ampi cipro
#> 1      Escherichia coli   R    R     S
#> 2 Klebsiella pneumoniae   R    R     S
```

 

### Using taxonomic properties in rules

 There is one exception in columns used for the rules: all column names of the microorganisms data set can also be used, but do not have to exist in the data set. These column names are: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", and ""snomed"". Thus, this next example will work as well, despite the fact that the `df` data set does not contain a column `genus`:

 

```
y <- custom_eucast_rules(TZP == ""S"" & genus == ""Klebsiella"" ~ aminopenicillins == ""S"",
                    TZP == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"")

eucast_rules(df, rules = ""custom"", custom_rules = y, info = FALSE)
#>                      mo TZP ampi cipro
#> 1      Escherichia coli   R    S     S
#> 2 Klebsiella pneumoniae   R    R     S
```

 

### Usage of antibiotic group names

 It is possible to define antibiotic groups instead of single antibiotics for the rule consequence, the part **after** the tilde. In above examples, the antibiotic group `aminopenicillins` is used to include ampicillin and amoxicillin. The following groups are allowed (case-insensitive). Within parentheses are the drugs that will be matched when running the rule.

 * ""aminoglycosides""
   
   (amikacin, amikacin/fosfomycin, amphotericin B-high, apramycin, arbekacin, astromicin, bekanamycin, dibekacin, framycetin, gentamicin, gentamicin-high, habekacin, hygromycin, isepamicin, kanamycin, kanamycin-high, kanamycin/cephalexin, micronomicin, neomycin, netilmicin, pentisomicin, plazomicin, propikacin, ribostamycin, sisomicin, streptoduocin, streptomycin, streptomycin-high, tobramycin, and tobramycin-high)
 * ""aminopenicillins""
   
   (amoxicillin and ampicillin)
 * ""antifungals""
   
   (amphotericin B, anidulafungin, butoconazole, caspofungin, ciclopirox, clotrimazole, econazole, fluconazole, flucytosine, fosfluconazole, griseofulvin, hachimycin, ibrexafungerp, isavuconazole, isoconazole, itraconazole, ketoconazole, manogepix, micafungin, miconazole, nystatin, oteseconazole, pimaricin, posaconazole, rezafungin, ribociclib, sulconazole, terbinafine, terconazole, and voriconazole)
 * ""antimycobacterials""
   
   (4-aminosalicylic acid, calcium aminosalicylate, capreomycin, clofazimine, delamanid, enviomycin, ethambutol, ethambutol/isoniazid, ethionamide, isoniazid, isoniazid/sulfamethoxazole/trimethoprim/pyridoxine, morinamide, p-aminosalicylic acid, pretomanid, protionamide, pyrazinamide, rifabutin, rifampicin, rifampicin/ethambutol/isoniazid, rifampicin/isoniazid, rifampicin/pyrazinamide/ethambutol/isoniazid, rifampicin/pyrazinamide/isoniazid, rifamycin, rifapentine, simvastatin/fenofibrate, sodium aminosalicylate, streptomycin/isoniazid, terizidone, thioacetazone, thioacetazone/isoniazid, tiocarlide, and viomycin)
 * ""betalactams""
   
   (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, biapenem, carbenicillin, carindacillin, cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/nacubactam, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, ciclacillin, clometocillin, cloxacillin, dicloxacillin, doripenem, epicillin, ertapenem, flucloxacillin, hetacillin, imipenem, imipenem/EDTA, imipenem/relebactam, latamoxef, lenampicillin, loracarbef, mecillinam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, panipenem, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, razupenem, ritipenem, ritipenem acoxil, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, tebipenem, temocillin, ticarcillin, and ticarcillin/clavulanic acid)
 * ""carbapenems""
   
   (biapenem, doripenem, ertapenem, imipenem, imipenem/EDTA, imipenem/relebactam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, panipenem, razupenem, ritipenem, ritipenem acoxil, and tebipenem)
 * ""cephalosporins""
   
   (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)
 * ""cephalosporins_1st""
   
   (cefacetrile, cefadroxil, cefalexin, cefaloridine, cefalotin, cefapirin, cefatrizine, cefazedone, cefazolin, cefroxadine, ceftezole, and cephradine)
 * ""cephalosporins_2nd""
   
   (cefaclor, cefamandole, cefmetazole, cefonicid, ceforanide, cefotetan, cefotiam, cefoxitin, cefoxitin screening, cefprozil, cefuroxime, cefuroxime axetil, and loracarbef)
 * ""cephalosporins_3rd""
   
   (cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefetamet, cefetamet pivoxil, cefixime, cefmenoxime, cefodizime, cefoperazone, cefoperazone/sulbactam, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotiam hexetil, cefovecin, cefpimizole, cefpiramide, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefsulodin, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, and latamoxef)
 * ""cephalosporins_4th""
   
   (cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetecol, cefoselis, cefozopran, cefpirome, and cefquinome)
 * ""cephalosporins_5th""
   
   (ceftaroline, ceftaroline/avibactam, ceftobiprole, ceftobiprole medocaril, and ceftolozane/tazobactam)
 * ""cephalosporins_except_caz""
   
   (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)
 * ""fluoroquinolones""
   
   (besifloxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nifuroquine, norfloxacin, ofloxacin, orbifloxacin, pazufloxacin, pefloxacin, pradofloxacin, premafloxacin, prulifloxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)
 * ""glycopeptides""
   
   (avoparcin, dalbavancin, norvancomycin, oritavancin, ramoplanin, teicoplanin, teicoplanin-macromethod, telavancin, vancomycin, and vancomycin-macromethod)
 * ""glycopeptides_except_lipo""
   
   (avoparcin, norvancomycin, ramoplanin, teicoplanin, teicoplanin-macromethod, vancomycin, and vancomycin-macromethod)
 * ""lincosamides""
   
   (acetylmidecamycin, acetylspiramycin, clindamycin, gamithromycin, kitasamycin, lincomycin, meleumycin, nafithromycin, pirlimycin, primycin, solithromycin, tildipirosin, tilmicosin, tulathromycin, tylosin, and tylvalosin)
 * ""lipoglycopeptides""
   
   (dalbavancin, oritavancin, and telavancin)
 * ""macrolides""
   
   (acetylmidecamycin, acetylspiramycin, azithromycin, clarithromycin, dirithromycin, erythromycin, flurithromycin, gamithromycin, josamycin, kitasamycin, meleumycin, midecamycin, miocamycin, nafithromycin, oleandomycin, pirlimycin, primycin, rokitamycin, roxithromycin, solithromycin, spiramycin, telithromycin, tildipirosin, tilmicosin, troleandomycin, tulathromycin, tylosin, and tylvalosin)
 * ""oxazolidinones""
   
   (cadazolid, cycloserine, linezolid, tedizolid, and thiacetazone)
 * ""penicillins""
   
   (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, carbenicillin, carindacillin, cefepime/nacubactam, ciclacillin, clometocillin, cloxacillin, dicloxacillin, epicillin, flucloxacillin, hetacillin, lenampicillin, mecillinam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, temocillin, ticarcillin, and ticarcillin/clavulanic acid)
 * ""polymyxins""
   
   (colistin, polymyxin B, and polymyxin B/polysorbate 80)
 * ""quinolones""
   
   (besifloxacin, cinoxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, flumequine, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nalidixic acid, nemonoxacin, nifuroquine, nitroxoline, norfloxacin, ofloxacin, orbifloxacin, oxolinic acid, pazufloxacin, pefloxacin, pipemidic acid, piromidic acid, pradofloxacin, premafloxacin, prulifloxacin, rosoxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)
 * ""streptogramins""
   
   (pristinamycin and quinupristin/dalfopristin)
 * ""tetracyclines""
   
   (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, tetracycline, and tigecycline)
 * ""tetracyclines_except_tgc""
   
   (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, and tetracycline)
 * ""trimethoprims""
   
   (brodimoprim, sulfadiazine, sulfadiazine/tetroxoprim, sulfadiazine/trimethoprim, sulfadimethoxine, sulfadimidine, sulfadimidine/trimethoprim, sulfafurazole, sulfaisodimidine, sulfalene, sulfamazone, sulfamerazine, sulfamerazine/trimethoprim, sulfamethizole, sulfamethoxazole, sulfamethoxypyridazine, sulfametomidine, sulfametoxydiazine, sulfametrole/trimethoprim, sulfamoxole, sulfamoxole/trimethoprim, sulfanilamide, sulfaperin, sulfaphenazole, sulfapyridine, sulfathiazole, sulfathiourea, trimethoprim, and trimethoprim/sulfamethoxazole)
 * ""ureidopenicillins""
   
   (azlocillin, mezlocillin, piperacillin, and piperacillin/tazobactam)

## Examples

```r
x <- custom_eucast_rules(
  AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",
  AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I""
)
x

# run the custom rule set (verbose = TRUE will return a logbook instead of the data set):
eucast_rules(example_isolates,
  rules = ""custom"",
  custom_rules = x,
  info = FALSE,
  verbose = TRUE
)

# combine rule sets
x2 <- c(
  x,
  custom_eucast_rules(TZP == ""R"" ~ carbapenems == ""R"")
)
x2
```



","['Define Custom EUCAST Rules```rcustom_eucast_rules(...)``` Arguments- `...`: rules in formula notation, see Examples ReturnsA list containing the custom rules DescriptionDefine custom EUCAST rules for your organisation or specific analysis and use the output of this function in `eucast_rules()`.', 'DetailsSome organisations have their own adoption of EUCAST rules.', 'This function can be used to define custom EUCAST rules to be used in the `eucast_rules()` function.', 'How it works Basics If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules.', ""Rules must be set using what considers to be the 'formula notation'."", 'The rule itself is written before the tilde (`~`) and the consequence of the rule is written after the tilde: ```x <- custom_eucast_rules(TZP == ""S"" ~ aminopenicillins == ""S"",                    TZP == ""R"" ~ aminopenicillins == ""R"")``` These are two custom EUCAST rules: if TZP (piperacillin/tazobactam) is ""S"", all aminopenicillins (ampicillin and amoxicillin) must be made ""S"", and if TZP is ""R"", aminopenicillins must be made ""R"".', 'These rules can also be printed to the console, so it is immediately clear how they work: ```x> A set of custom EUCAST rules:>>   1.', 'If TZP is ""S"" then set to  S :>      amoxicillin (AMX), ampicillin (AMP)>>   2.', 'If TZP is ""R"" then set to  R :>      amoxicillin (AMX), ampicillin (AMP)``` The rules (the part before the tilde, in above example `TZP == ""S""` and `TZP == ""R""`) must be evaluable in your data set: it should be able to run as a filter in your data set without errors.', 'This means for the above example that the column `TZP` must exist.', 'We will create a sample data set and test the rules set: ```df <- data.frame(mo = c(""Escherichia coli"", ""Klebsiella pneumoniae""),            TZP = as.sir(""R""),            ampi = as.sir(""S""),            cipro = as.sir(""S""))df>                      mo TZP ampi cipro> 1      Escherichia coli   R    S     S> 2 Klebsiella pneumoniae   R    S     Seucast_rules(df, rules = ""custom"", custom_rules = x, info = FALSE)>                      mo TZP ampi cipro> 1      Escherichia coli   R    R     S> 2 Klebsiella pneumoniae   R    R     S```  Using taxonomic properties in rules There is one exception in columns used for the rules: all column names of the microorganisms data set can also be used, but do not have to exist in the data set.', 'These column names are: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", and ""snomed"".', 'Thus, this next example will work as well, despite the fact that the `df` data set does not contain a column `genus`: ```y <- custom_eucast_rules(TZP == ""S"" & genus == ""Klebsiella"" ~ aminopenicillins == ""S"",                    TZP == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"")eucast_rules(df, rules = ""custom"", custom_rules = y, info = FALSE)>                      mo TZP ampi cipro> 1      Escherichia coli   R    S     S> 2 Klebsiella pneumoniae   R    R     S```  Usage of antibiotic group names It is possible to define antibiotic groups instead of single antibiotics for the rule consequence, the part after the tilde.', 'In above examples, the antibiotic group `aminopenicillins` is used to include ampicillin and amoxicillin.', 'The following groups are allowed (case-insensitive).', 'Within parentheses are the drugs that will be matched when running the rule.', '""aminoglycosides""      (amikacin, amikacin/fosfomycin, amphotericin B-high, apramycin, arbekacin, astromicin, bekanamycin, dibekacin, framycetin, gentamicin, gentamicin-high, habekacin, hygromycin, isepamicin, kanamycin, kanamycin-high, kanamycin/cephalexin, micronomicin, neomycin, netilmicin, pentisomicin, plazomicin, propikacin, ribostamycin, sisomicin, streptoduocin, streptomycin, streptomycin-high, tobramycin, and tobramycin-high)  ""aminopenicillins""      (amoxicillin and ampicillin)  ""antifungals""      (amphotericin B, anidulafungin, butoconazole, caspofungin, ciclopirox, clotrimazole, econazole, fluconazole, flucytosine, fosfluconazole, griseofulvin, hachimycin, ibrexafungerp, isavuconazole, isoconazole, itraconazole, ketoconazole, manogepix, micafungin, miconazole, nystatin, oteseconazole, pimaricin, posaconazole, rezafungin, ribociclib, sulconazole, terbinafine, terconazole, and voriconazole)  ""antimycobacterials""      (4-aminosalicylic acid, calcium aminosalicylate, capreomycin, clofazimine, delamanid, enviomycin, ethambutol, ethambutol/isoniazid, ethionamide, isoniazid, isoniazid/sulfamethoxazole/trimethoprim/pyridoxine, morinamide, p-aminosalicylic acid, pretomanid, protionamide, pyrazinamide, rifabutin, rifampicin, rifampicin/ethambutol/isoniazid, rifampicin/isoniazid, rifampicin/pyrazinamide/ethambutol/isoniazid, rifampicin/pyrazinamide/isoniazid, rifamycin, rifapentine, simvastatin/fenofibrate, sodium aminosalicylate, streptomycin/isoniazid, terizidone, thioacetazone, thioacetazone/isoniazid, tiocarlide, and viomycin)  ""betalactams""      (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, biapenem, carbenicillin, carindacillin, cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/nacubactam, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, ciclacillin, clometocillin, cloxacillin, dicloxacillin, doripenem, epicillin, ertapenem, flucloxacillin, hetacillin, imipenem, imipenem/EDTA, imipenem/relebactam, latamoxef, lenampicillin, loracarbef, mecillinam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, panipenem, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, razupenem, ritipenem, ritipenem acoxil, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, tebipenem, temocillin, ticarcillin, and ticarcillin/clavulanic acid)  ""carbapenems""      (biapenem, doripenem, ertapenem, imipenem, imipenem/EDTA, imipenem/relebactam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, panipenem, razupenem, ritipenem, ritipenem acoxil, and tebipenem)  ""cephalosporins""      (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)  ""cephalosporins_1st""      (cefacetrile, cefadroxil, cefalexin, cefaloridine, cefalotin, cefapirin, cefatrizine, cefazedone, cefazolin, cefroxadine, ceftezole, and cephradine)  ""cephalosporins_2nd""      (cefaclor, cefamandole, cefmetazole, cefonicid, ceforanide, cefotetan, cefotiam, cefoxitin, cefoxitin screening, cefprozil, cefuroxime, cefuroxime axetil, and loracarbef)  ""cephalosporins_3rd""      (cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefetamet, cefetamet pivoxil, cefixime, cefmenoxime, cefodizime, cefoperazone, cefoperazone/sulbactam, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotiam hexetil, cefovecin, cefpimizole, cefpiramide, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefsulodin, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, and latamoxef)  ""cephalosporins_4th""      (cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetecol, cefoselis, cefozopran, cefpirome, and cefquinome)  ""cephalosporins_5th""      (ceftaroline, ceftaroline/avibactam, ceftobiprole, ceftobiprole medocaril, and ceftolozane/tazobactam)  ""cephalosporins_except_caz""      (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)  ""fluoroquinolones""      (besifloxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nifuroquine, norfloxacin, ofloxacin, orbifloxacin, pazufloxacin, pefloxacin, pradofloxacin, premafloxacin, prulifloxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)  ""glycopeptides""      (avoparcin, dalbavancin, norvancomycin, oritavancin, ramoplanin, teicoplanin, teicoplanin-macromethod, telavancin, vancomycin, and vancomycin-macromethod)  ""glycopeptides_except_lipo""      (avoparcin, norvancomycin, ramoplanin, teicoplanin, teicoplanin-macromethod, vancomycin, and vancomycin-macromethod)  ""lincosamides""      (acetylmidecamycin, acetylspiramycin, clindamycin, gamithromycin, kitasamycin, lincomycin, meleumycin, nafithromycin, pirlimycin, primycin, solithromycin, tildipirosin, tilmicosin, tulathromycin, tylosin, and tylvalosin)  ""lipoglycopeptides""      (dalbavancin, oritavancin, and telavancin)  ""macrolides""      (acetylmidecamycin, acetylspiramycin, azithromycin, clarithromycin, dirithromycin, erythromycin, flurithromycin, gamithromycin, josamycin, kitasamycin, meleumycin, midecamycin, miocamycin, nafithromycin, oleandomycin, pirlimycin, primycin, rokitamycin, roxithromycin, solithromycin, spiramycin, telithromycin, tildipirosin, tilmicosin, troleandomycin, tulathromycin, tylosin, and tylvalosin)  ""oxazolidinones""      (cadazolid, cycloserine, linezolid, tedizolid, and thiacetazone)  ""penicillins""      (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, carbenicillin, carindacillin, cefepime/nacubactam, ciclacillin, clometocillin, cloxacillin, dicloxacillin, epicillin, flucloxacillin, hetacillin, lenampicillin, mecillinam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, temocillin, ticarcillin, and ticarcillin/clavulanic acid)  ""polymyxins""      (colistin, polymyxin B, and polymyxin B/polysorbate 80)  ""quinolones""      (besifloxacin, cinoxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, flumequine, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nalidixic acid, nemonoxacin, nifuroquine, nitroxoline, norfloxacin, ofloxacin, orbifloxacin, oxolinic acid, pazufloxacin, pefloxacin, pipemidic acid, piromidic acid, pradofloxacin, premafloxacin, prulifloxacin, rosoxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)  ""streptogramins""      (pristinamycin and quinupristin/dalfopristin)  ""tetracyclines""      (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, tetracycline, and tigecycline)  ""tetracyclines_except_tgc""      (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, and tetracycline)  ""trimethoprims""      (brodimoprim, sulfadiazine, sulfadiazine/tetroxoprim, sulfadiazine/trimethoprim, sulfadimethoxine, sulfadimidine, sulfadimidine/trimethoprim, sulfafurazole, sulfaisodimidine, sulfalene, sulfamazone, sulfamerazine, sulfamerazine/trimethoprim, sulfamethizole, sulfamethoxazole, sulfamethoxypyridazine, sulfametomidine, sulfametoxydiazine, sulfametrole/trimethoprim, sulfamoxole, sulfamoxole/trimethoprim, sulfanilamide, sulfaperin, sulfaphenazole, sulfapyridine, sulfathiazole, sulfathiourea, trimethoprim, and trimethoprim/sulfamethoxazole)  ""ureidopenicillins""      (azlocillin, mezlocillin, piperacillin, and piperacillin/tazobactam) Examples```rx <- custom_eucast_rules(  AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",  AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I"")x run the custom rule set (verbose = TRUE will return a logbook instead of the data set):eucast_rules(example_isolates,  rules = ""custom"",  custom_rules = x,  info = FALSE,  verbose = TRUE) combine rule setsx2 <- c(  x,  custom_eucast_rules(TZP == ""R"" ~ carbapenems == ""R""))x2```']",1," Define Custom EUCAST Rules```rcustom_eucast_rules(...)``` Arguments- `...`: rules in formula notation, see Examples ReturnsA list containing the custom rules DescriptionDefine custom EUCAST rules for your organisation or specific analysis and use the output of this function in `eucast_rules()`. DetailsSome organisations have their own adoption of EUCAST rules. This function can be used to define custom EUCAST rules to be used in the `eucast_rules()` function. How it works Basics If you are familiar with the `case_when()` function of the `dplyr` package, you will recognise the input method to set your own rules. Rules must be set using what considers to be the 'formula notation'. The rule itself is written before the tilde (`~`) and the consequence of the rule is written after the tilde: ```x <- custom_eucast_rules(TZP == ""S"" ~ aminopenicillins == ""S"",                    TZP == ""R"" ~ aminopenicillins == ""R"")``` These are two custom EUCAST rules: if TZP (piperacillin/tazobactam) is ""S"", all aminopenicillins (ampicillin and amoxicillin) must be made ""S"", and if TZP is ""R"", aminopenicillins must be made ""R"". These rules can also be printed to the console, so it is immediately clear how they work: ```x> A set of custom EUCAST rules:>>   1. If TZP is ""S"" then set to  S :>      amoxicillin (AMX), ampicillin (AMP)>>   2. If TZP is ""R"" then set to  R :>      amoxicillin (AMX), ampicillin (AMP)``` The rules (the part before the tilde, in above example `TZP == ""S""` and `TZP == ""R""`) must be evaluable in your data set: it should be able to run as a filter in your data set without errors. This means for the above example that the column `TZP` must exist. We will create a sample data set and test the rules set: ```df <- data.frame(mo = c(""Escherichia coli"", ""Klebsiella pneumoniae""),            TZP = as.sir(""R""),            ampi = as.sir(""S""),            cipro = as.sir(""S""))df>                      mo TZP ampi cipro> 1      Escherichia coli   R    S     S> 2 Klebsiella pneumoniae   R    S     Seucast_rules(df, rules = ""custom"", custom_rules = x, info = FALSE)>                      mo TZP ampi cipro> 1      Escherichia coli   R    R     S> 2 Klebsiella pneumoniae   R    R     S```  Using taxonomic properties in rules There is one exception in columns used for the rules: all column names of the microorganisms data set can also be used, but do not have to exist in the data set. These column names are: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", and ""snomed"". Thus, this next example will work as well, despite the fact that the `df` data set does not contain a column `genus`: ```y <- custom_eucast_rules(TZP == ""S"" & genus == ""Klebsiella"" ~ aminopenicillins == ""S"",                    TZP == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"")eucast_rules(df, rules = ""custom"", custom_rules = y, info = FALSE)>                      mo TZP ampi cipro> 1      Escherichia coli   R    S     S> 2 Klebsiella pneumoniae   R    R     S```  Usage of antibiotic group names It is possible to define antibiotic groups instead of single antibiotics for the rule consequence, the part after the tilde. In above examples, the antibiotic group `aminopenicillins` is used to include ampicillin and amoxicillin. The following groups are allowed (case-insensitive). Within parentheses are the drugs that will be matched when running the rule.  ""aminoglycosides""      (amikacin, amikacin/fosfomycin, amphotericin B-high, apramycin, arbekacin, astromicin, bekanamycin, dibekacin, framycetin, gentamicin, gentamicin-high, habekacin, hygromycin, isepamicin, kanamycin, kanamycin-high, kanamycin/cephalexin, micronomicin, neomycin, netilmicin, pentisomicin, plazomicin, propikacin, ribostamycin, sisomicin, streptoduocin, streptomycin, streptomycin-high, tobramycin, and tobramycin-high)  ""aminopenicillins""      (amoxicillin and ampicillin)  ""antifungals""      (amphotericin B, anidulafungin, butoconazole, caspofungin, ciclopirox, clotrimazole, econazole, fluconazole, flucytosine, fosfluconazole, griseofulvin, hachimycin, ibrexafungerp, isavuconazole, isoconazole, itraconazole, ketoconazole, manogepix, micafungin, miconazole, nystatin, oteseconazole, pimaricin, posaconazole, rezafungin, ribociclib, sulconazole, terbinafine, terconazole, and voriconazole)  ""antimycobacterials""      (4-aminosalicylic acid, calcium aminosalicylate, capreomycin, clofazimine, delamanid, enviomycin, ethambutol, ethambutol/isoniazid, ethionamide, isoniazid, isoniazid/sulfamethoxazole/trimethoprim/pyridoxine, morinamide, p-aminosalicylic acid, pretomanid, protionamide, pyrazinamide, rifabutin, rifampicin, rifampicin/ethambutol/isoniazid, rifampicin/isoniazid, rifampicin/pyrazinamide/ethambutol/isoniazid, rifampicin/pyrazinamide/isoniazid, rifamycin, rifapentine, simvastatin/fenofibrate, sodium aminosalicylate, streptomycin/isoniazid, terizidone, thioacetazone, thioacetazone/isoniazid, tiocarlide, and viomycin)  ""betalactams""      (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, biapenem, carbenicillin, carindacillin, cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/nacubactam, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, ciclacillin, clometocillin, cloxacillin, dicloxacillin, doripenem, epicillin, ertapenem, flucloxacillin, hetacillin, imipenem, imipenem/EDTA, imipenem/relebactam, latamoxef, lenampicillin, loracarbef, mecillinam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, panipenem, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, razupenem, ritipenem, ritipenem acoxil, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, tebipenem, temocillin, ticarcillin, and ticarcillin/clavulanic acid)  ""carbapenems""      (biapenem, doripenem, ertapenem, imipenem, imipenem/EDTA, imipenem/relebactam, meropenem, meropenem/nacubactam, meropenem/vaborbactam, panipenem, razupenem, ritipenem, ritipenem acoxil, and tebipenem)  ""cephalosporins""      (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)  ""cephalosporins_1st""      (cefacetrile, cefadroxil, cefalexin, cefaloridine, cefalotin, cefapirin, cefatrizine, cefazedone, cefazolin, cefroxadine, ceftezole, and cephradine)  ""cephalosporins_2nd""      (cefaclor, cefamandole, cefmetazole, cefonicid, ceforanide, cefotetan, cefotiam, cefoxitin, cefoxitin screening, cefprozil, cefuroxime, cefuroxime axetil, and loracarbef)  ""cephalosporins_3rd""      (cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefetamet, cefetamet pivoxil, cefixime, cefmenoxime, cefodizime, cefoperazone, cefoperazone/sulbactam, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotiam hexetil, cefovecin, cefpimizole, cefpiramide, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefsulodin, ceftazidime, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, and latamoxef)  ""cephalosporins_4th""      (cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetecol, cefoselis, cefozopran, cefpirome, and cefquinome)  ""cephalosporins_5th""      (ceftaroline, ceftaroline/avibactam, ceftobiprole, ceftobiprole medocaril, and ceftolozane/tazobactam)  ""cephalosporins_except_caz""      (cefacetrile, cefaclor, cefadroxil, cefalexin, cefaloridine, cefalotin, cefamandole, cefapirin, cefatrizine, cefazedone, cefazolin, cefcapene, cefcapene pivoxil, cefdinir, cefditoren, cefditoren pivoxil, cefepime, cefepime/clavulanic acid, cefepime/tazobactam, cefetamet, cefetamet pivoxil, cefetecol, cefetrizole, cefixime, cefmenoxime, cefmetazole, cefodizime, cefonicid, cefoperazone, cefoperazone/sulbactam, ceforanide, cefoselis, cefotaxime, cefotaxime/clavulanic acid, cefotaxime/sulbactam, cefotetan, cefotiam, cefotiam hexetil, cefovecin, cefoxitin, cefoxitin screening, cefozopran, cefpimizole, cefpiramide, cefpirome, cefpodoxime, cefpodoxime proxetil, cefpodoxime/clavulanic acid, cefprozil, cefquinome, cefroxadine, cefsulodin, cefsumide, ceftaroline, ceftaroline/avibactam, ceftazidime/avibactam, ceftazidime/clavulanic acid, cefteram, cefteram pivoxil, ceftezole, ceftibuten, ceftiofur, ceftizoxime, ceftizoxime alapivoxil, ceftobiprole, ceftobiprole medocaril, ceftolozane/tazobactam, ceftriaxone, ceftriaxone/beta-lactamase inhibitor, cefuroxime, cefuroxime axetil, cephradine, latamoxef, and loracarbef)  ""fluoroquinolones""      (besifloxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nifuroquine, norfloxacin, ofloxacin, orbifloxacin, pazufloxacin, pefloxacin, pradofloxacin, premafloxacin, prulifloxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)  ""glycopeptides""      (avoparcin, dalbavancin, norvancomycin, oritavancin, ramoplanin, teicoplanin, teicoplanin-macromethod, telavancin, vancomycin, and vancomycin-macromethod)  ""glycopeptides_except_lipo""      (avoparcin, norvancomycin, ramoplanin, teicoplanin, teicoplanin-macromethod, vancomycin, and vancomycin-macromethod)  ""lincosamides""      (acetylmidecamycin, acetylspiramycin, clindamycin, gamithromycin, kitasamycin, lincomycin, meleumycin, nafithromycin, pirlimycin, primycin, solithromycin, tildipirosin, tilmicosin, tulathromycin, tylosin, and tylvalosin)  ""lipoglycopeptides""      (dalbavancin, oritavancin, and telavancin)  ""macrolides""      (acetylmidecamycin, acetylspiramycin, azithromycin, clarithromycin, dirithromycin, erythromycin, flurithromycin, gamithromycin, josamycin, kitasamycin, meleumycin, midecamycin, miocamycin, nafithromycin, oleandomycin, pirlimycin, primycin, rokitamycin, roxithromycin, solithromycin, spiramycin, telithromycin, tildipirosin, tilmicosin, troleandomycin, tulathromycin, tylosin, and tylvalosin)  ""oxazolidinones""      (cadazolid, cycloserine, linezolid, tedizolid, and thiacetazone)  ""penicillins""      (amoxicillin, amoxicillin/clavulanic acid, amoxicillin/sulbactam, ampicillin, ampicillin/sulbactam, apalcillin, aspoxicillin, avibactam, azidocillin, azlocillin, aztreonam, aztreonam/avibactam, aztreonam/nacubactam, bacampicillin, benzathine benzylpenicillin, benzathine phenoxymethylpenicillin, benzylpenicillin, carbenicillin, carindacillin, cefepime/nacubactam, ciclacillin, clometocillin, cloxacillin, dicloxacillin, epicillin, flucloxacillin, hetacillin, lenampicillin, mecillinam, metampicillin, meticillin, mezlocillin, mezlocillin/sulbactam, nacubactam, nafcillin, oxacillin, penamecillin, penicillin/novobiocin, penicillin/sulbactam, pheneticillin, phenoxymethylpenicillin, piperacillin, piperacillin/sulbactam, piperacillin/tazobactam, piridicillin, pivampicillin, pivmecillinam, procaine benzylpenicillin, propicillin, sarmoxicillin, sulbactam, sulbenicillin, sultamicillin, talampicillin, tazobactam, temocillin, ticarcillin, and ticarcillin/clavulanic acid)  ""polymyxins""      (colistin, polymyxin B, and polymyxin B/polysorbate 80)  ""quinolones""      (besifloxacin, cinoxacin, ciprofloxacin, clinafloxacin, danofloxacin, delafloxacin, difloxacin, enoxacin, enrofloxacin, finafloxacin, fleroxacin, flumequine, garenoxacin, gatifloxacin, gemifloxacin, grepafloxacin, lascufloxacin, levofloxacin, levonadifloxacin, lomefloxacin, marbofloxacin, metioxate, miloxacin, moxifloxacin, nadifloxacin, nalidixic acid, nemonoxacin, nifuroquine, nitroxoline, norfloxacin, ofloxacin, orbifloxacin, oxolinic acid, pazufloxacin, pefloxacin, pipemidic acid, piromidic acid, pradofloxacin, premafloxacin, prulifloxacin, rosoxacin, rufloxacin, sarafloxacin, sitafloxacin, sparfloxacin, temafloxacin, tilbroquinol, tioxacin, tosufloxacin, and trovafloxacin)  ""streptogramins""      (pristinamycin and quinupristin/dalfopristin)  ""tetracyclines""      (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, tetracycline, and tigecycline)  ""tetracyclines_except_tgc""      (cetocycline, chlortetracycline, clomocycline, demeclocycline, doxycycline, eravacycline, lymecycline, metacycline, minocycline, omadacycline, oxytetracycline, penimepicycline, rolitetracycline, sarecycline, and tetracycline)  ""trimethoprims""      (brodimoprim, sulfadiazine, sulfadiazine/tetroxoprim, sulfadiazine/trimethoprim, sulfadimethoxine, sulfadimidine, sulfadimidine/trimethoprim, sulfafurazole, sulfaisodimidine, sulfalene, sulfamazone, sulfamerazine, sulfamerazine/trimethoprim, sulfamethizole, sulfamethoxazole, sulfamethoxypyridazine, sulfametomidine, sulfametoxydiazine, sulfametrole/trimethoprim, sulfamoxole, sulfamoxole/trimethoprim, sulfanilamide, sulfaperin, sulfaphenazole, sulfapyridine, sulfathiazole, sulfathiourea, trimethoprim, and trimethoprim/sulfamethoxazole)  ""ureidopenicillins""      (azlocillin, mezlocillin, piperacillin, and piperacillin/tazobactam) Examples```rx <- custom_eucast_rules(  AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",  AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I"")x run the custom rule set (verbose = TRUE will return a logbook instead of the data set):eucast_rules(example_isolates,  rules = ""custom"",  custom_rules = x,  info = FALSE,  verbose = TRUE) combine rule setsx2 <- c(  x,  custom_eucast_rules(TZP == ""R"" ~ carbapenems == ""R""))x2```",3
AMR,count.md,"# Count Available Isolates

```r
count_resistant(..., only_all_tested = FALSE)

count_susceptible(..., only_all_tested = FALSE)

count_R(..., only_all_tested = FALSE)

count_IR(..., only_all_tested = FALSE)

count_I(..., only_all_tested = FALSE)

count_SI(..., only_all_tested = FALSE)

count_S(..., only_all_tested = FALSE)

count_all(..., only_all_tested = FALSE)

n_sir(..., only_all_tested = FALSE)

count_df(
  data,
  translate_ab = ""name"",
  language = get_AMR_locale(),
  combine_SI = TRUE
)
```

## Arguments

- `...`: one or more vectors (or columns) with antibiotic interpretations. They will be transformed internally with `as.sir()` if needed.
- `only_all_tested`: (for combination therapies, i.e. using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section **Combination Therapy** below
- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)
- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`
- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`

## Returns

An integer

## Description

These functions can be used to count resistant/susceptible microbial isolates. All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see **Examples**. `count_resistant()` should be used to count resistant isolates, `count_susceptible()` should be used to count susceptible isolates.

## Details

These functions are meant to count isolates. Use the `resistance()`/`susceptibility()` functions to calculate microbial resistance/susceptibility.

The function `count_resistant()` is equal to the function `count_R()`. The function `count_susceptible()` is equal to the function `count_SI()`.

The function `n_sir()` is an alias of `count_all()`. They can be used to count all available isolates, i.e. where all input antibiotics have an available result (S, I or R). Their use is equal to `n_distinct()`. Their function is equal to `count_susceptible(...) + count_resistant(...)`.

The function `count_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and counts the number of S's, I's and R's. It also supports grouped variables. The function `sir_df()` works exactly like `count_df()`, but adds the percentage of S, I and R.

## Interpretation of SIR

 In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):

 * S - Susceptible, standard dosing regimen
   
   A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.
 * I - Susceptible, increased exposure **A microorganism is categorised as ""Susceptible, Increased exposure**"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.
 * R = Resistant
   
   A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.
   
    * **Exposure** is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.

This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.

## Combination Therapy

 When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for. See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI:

 

```
--------------------------------------------------------------------
               only_all_tested = FALSE  only_all_tested = TRUE
               -----------------------  -----------------------
 Drug A    Drug B   include as  include as   include as  include as
               numerator   denominator  numerator   denominator
--------  --------  ----------  -----------  ----------  -----------
 S or I    S or I       X            X            X            X
   R       S or I       X            X            X            X
  <NA>     S or I       X            X            -            -
 S or I      R          X            X            X            X
   R         R          -            X            -            X
  <NA>       R          -            -            -            -
 S or I     <NA>        X            X            -            -
   R        <NA>        -            -            -            -
  <NA>      <NA>        -            -            -            -
--------------------------------------------------------------------
```

 

Please note that, in combination therapies, for `only_all_tested = TRUE` applies that:

 

```
count_S()    +   count_I()    +   count_R()    = count_all()
  proportion_S() + proportion_I() + proportion_R() = 1
```

 

and that, in combination therapies, for `only_all_tested = FALSE` applies that:


 

```
count_S()    +   count_I()    +   count_R()    >= count_all()
  proportion_S() + proportion_I() + proportion_R() >= 1
```

 

Using `only_all_tested` has no impact when only using one antibiotic as input.

## Examples

```r
# example_isolates is a data set available in the AMR package.
# run ?example_isolates for more info.

# base R ------------------------------------------------------------
count_resistant(example_isolates$AMX) # counts ""R""
count_susceptible(example_isolates$AMX) # counts ""S"" and ""I""
count_all(example_isolates$AMX) # counts ""S"", ""I"" and ""R""

# be more specific
count_S(example_isolates$AMX)
count_SI(example_isolates$AMX)
count_I(example_isolates$AMX)
count_IR(example_isolates$AMX)
count_R(example_isolates$AMX)

# Count all available isolates
count_all(example_isolates$AMX)
n_sir(example_isolates$AMX)

# n_sir() is an alias of count_all().
# Since it counts all available isolates, you can
# calculate back to count e.g. susceptible isolates.
# These results are the same:
count_susceptible(example_isolates$AMX)
susceptibility(example_isolates$AMX) * n_sir(example_isolates$AMX)

# dplyr -------------------------------------------------------------

if (require(""dplyr"")) {
  example_isolates %>%
    group_by(ward) %>%
    summarise(
      R = count_R(CIP),
      I = count_I(CIP),
      S = count_S(CIP),
      n1 = count_all(CIP), # the actual total; sum of all three
      n2 = n_sir(CIP), # same - analogous to n_distinct
      total = n()
    ) # NOT the number of tested isolates!

  # Number of available isolates for a whole antibiotic class
  # (i.e., in this data set columns GEN, TOB, AMK, KAN)
  example_isolates %>%
    group_by(ward) %>%
    summarise(across(aminoglycosides(), n_sir))

  # Count co-resistance between amoxicillin/clav acid and gentamicin,
  # so we can see that combination therapy does a lot more than mono therapy.
  # Please mind that `susceptibility()` calculates percentages right away instead.
  example_isolates %>% count_susceptible(AMC) # 1433
  example_isolates %>% count_all(AMC) # 1879

  example_isolates %>% count_susceptible(GEN) # 1399
  example_isolates %>% count_all(GEN) # 1855

  example_isolates %>% count_susceptible(AMC, GEN) # 1764
  example_isolates %>% count_all(AMC, GEN) # 1936

  # Get number of S+I vs. R immediately of selected columns
  example_isolates %>%
    select(AMX, CIP) %>%
    count_df(translate = FALSE)

  # It also supports grouping variables
  example_isolates %>%
    select(ward, AMX, CIP) %>%
    group_by(ward) %>%
    count_df(translate = FALSE)
}
```

## See Also

`proportion_*` to calculate microbial resistance and susceptibility.



","['Count Available Isolates```rcount_resistant(..., only_all_tested = FALSE)count_susceptible(..., only_all_tested = FALSE)count_R(..., only_all_tested = FALSE)count_IR(..., only_all_tested = FALSE)count_I(..., only_all_tested = FALSE)count_SI(..., only_all_tested = FALSE)count_S(..., only_all_tested = FALSE)count_all(..., only_all_tested = FALSE)n_sir(..., only_all_tested = FALSE)count_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  combine_SI = TRUE)``` Arguments- `...`: one or more vectors (or columns) with antibiotic interpretations.', 'They will be transformed internally with `as.sir()` if needed.- `only_all_tested`: (for combination therapies, i.e.', 'using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section Combination Therapy below- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE` ReturnsAn integer DescriptionThese functions can be used to count resistant/susceptible microbial isolates.', 'All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see Examples.', '`count_resistant()` should be used to count resistant isolates, `count_susceptible()` should be used to count susceptible isolates.', 'DetailsThese functions are meant to count isolates.', 'Use the `resistance()`/`susceptibility()` functions to calculate microbial resistance/susceptibility.The function `count_resistant()` is equal to the function `count_R()`.', 'The function `count_susceptible()` is equal to the function `count_SI()`.The function `n_sir()` is an alias of `count_all()`.', 'They can be used to count all available isolates, i.e.', 'where all input antibiotics have an available result (S, I or R).', 'Their use is equal to `n_distinct()`.', ""Their function is equal to `count_susceptible(...) + count_resistant(...)`.The function `count_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and counts the number of S's, I's and R's."", 'It also supports grouped variables.', 'The function `sir_df()` works exactly like `count_df()`, but adds the percentage of S, I and R. Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.', 'I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.', 'R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.', 'Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight.', 'Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates.', 'Combination Therapy When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for.', 'See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------``` Please note that, in combination therapies, for `only_all_tested = TRUE` applies that: ```count_S()    +   count_I()    +   count_R()    = count_all()  proportion_S() + proportion_I() + proportion_R() = 1``` and that, in combination therapies, for `only_all_tested = FALSE` applies that: ```count_S()    +   count_I()    +   count_R()    >= count_all()  proportion_S() + proportion_I() + proportion_R() >= 1``` Using `only_all_tested` has no impact when only using one antibiotic as input.', 'Examples```r example_isolates is a data set available in the AMR package.', 'run ?example_isolates for more info.', 'base R ------------------------------------------------------------count_resistant(example_isolates$AMX)  counts ""R""count_susceptible(example_isolates$AMX)  counts ""S"" and ""I""count_all(example_isolates$AMX)  counts ""S"", ""I"" and ""R"" be more specificcount_S(example_isolates$AMX)count_SI(example_isolates$AMX)count_I(example_isolates$AMX)count_IR(example_isolates$AMX)count_R(example_isolates$AMX) Count all available isolatescount_all(example_isolates$AMX)n_sir(example_isolates$AMX) n_sir() is an alias of count_all().', 'Since it counts all available isolates, you can calculate back to count e.g.', 'These results are the same:count_susceptible(example_isolates$AMX)susceptibility(example_isolates$AMX)  n_sir(example_isolates$AMX) dplyr -------------------------------------------------------------if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      R = count_R(CIP),      I = count_I(CIP),      S = count_S(CIP),      n1 = count_all(CIP),  the actual total; sum of all three      n2 = n_sir(CIP),  same - analogous to n_distinct      total = n()    )  NOT the number of tested isolates!', 'Number of available isolates for a whole antibiotic class   (i.e., in this data set columns GEN, TOB, AMK, KAN)  example_isolates %>%    group_by(ward) %>%    summarise(across(aminoglycosides(), n_sir))   Count co-resistance between amoxicillin/clav acid and gentamicin,   so we can see that combination therapy does a lot more than mono therapy.', 'Please mind that `susceptibility()` calculates percentages right away instead.', 'example_isolates %>% count_susceptible(AMC)  1433  example_isolates %>% count_all(AMC)  1879  example_isolates %>% count_susceptible(GEN)  1399  example_isolates %>% count_all(GEN)  1855  example_isolates %>% count_susceptible(AMC, GEN)  1764  example_isolates %>% count_all(AMC, GEN)  1936   Get number of S+I vs. R immediately of selected columns  example_isolates %>%    select(AMX, CIP) %>%    count_df(translate = FALSE)   It also supports grouping variables  example_isolates %>%    select(ward, AMX, CIP) %>%    group_by(ward) %>%    count_df(translate = FALSE)}``` See Also`proportion_` to calculate microbial resistance and susceptibility.']",1," Count Available Isolates```rcount_resistant(..., only_all_tested = FALSE)count_susceptible(..., only_all_tested = FALSE)count_R(..., only_all_tested = FALSE)count_IR(..., only_all_tested = FALSE)count_I(..., only_all_tested = FALSE)count_SI(..., only_all_tested = FALSE)count_S(..., only_all_tested = FALSE)count_all(..., only_all_tested = FALSE)n_sir(..., only_all_tested = FALSE)count_df(  data,  translate_ab = ""name"",  language = get_AMR_locale(),  combine_SI = TRUE)``` Arguments- `...`: one or more vectors (or columns) with antibiotic interpretations. They will be transformed internally with `as.sir()` if needed.- `only_all_tested`: (for combination therapies, i.e. using more than one variable for `...`): a logical to indicate that isolates must be tested for all antibiotics, see section Combination Therapy below- `data`: a data.frame containing columns with class `sir` (see `as.sir()`)- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE` ReturnsAn integer DescriptionThese functions can be used to count resistant/susceptible microbial isolates. All functions support quasiquotation with pipes, can be used in `summarise()` from the `dplyr` package and also support grouped variables, see Examples. `count_resistant()` should be used to count resistant isolates, `count_susceptible()` should be used to count susceptible isolates. DetailsThese functions are meant to count isolates. Use the `resistance()`/`susceptibility()` functions to calculate microbial resistance/susceptibility.The function `count_resistant()` is equal to the function `count_R()`. The function `count_susceptible()` is equal to the function `count_SI()`.The function `n_sir()` is an alias of `count_all()`. They can be used to count all available isolates, i.e. where all input antibiotics have an available result (S, I or R). Their use is equal to `n_distinct()`. Their function is equal to `count_susceptible(...) + count_resistant(...)`.The function `count_df()` takes any variable from `data` that has an `sir` class (created with `as.sir()`) and counts the number of S's, I's and R's. It also supports grouped variables. The function `sir_df()` works exactly like `count_df()`, but adds the percentage of S, I and R. Interpretation of SIR In 2019, the European Committee on Antimicrobial Susceptibility Testing (EUCAST) has decided to change the definitions of susceptibility testing categories S, I, and R as shown below ([https://www.eucast.org/newsiandr](https://www.eucast.org/newsiandr)):  S - Susceptible, standard dosing regimen      A microorganism is categorised as ""Susceptible, standard dosing regimen"", when there is a high likelihood of therapeutic success using a standard dosing regimen of the agent.  I - Susceptible, increased exposure A microorganism is categorised as ""Susceptible, Increased exposure"" when there is a high likelihood of therapeutic success because exposure to the agent is increased by adjusting the dosing regimen or by its concentration at the site of infection.  R = Resistant      A microorganism is categorised as ""Resistant"" when there is a high likelihood of therapeutic failure even when there is increased exposure.        Exposure is a function of how the mode of administration, dose, dosing interval, infusion time, as well as distribution and excretion of the antimicrobial agent will influence the infecting organism at the site of infection.This AMR package honours this insight. Use `susceptibility()` (equal to `proportion_SI()`) to determine antimicrobial susceptibility and `count_susceptible()` (equal to `count_SI()`) to count susceptible isolates. Combination Therapy When using more than one variable for `...` (= combination therapy), use `only_all_tested` to only count isolates that are tested for all antibiotics/variables that you test them for. See this example for two antibiotics, Drug A and Drug B, about how `susceptibility()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------``` Please note that, in combination therapies, for `only_all_tested = TRUE` applies that: ```count_S()    +   count_I()    +   count_R()    = count_all()  proportion_S() + proportion_I() + proportion_R() = 1``` and that, in combination therapies, for `only_all_tested = FALSE` applies that: ```count_S()    +   count_I()    +   count_R()    >= count_all()  proportion_S() + proportion_I() + proportion_R() >= 1``` Using `only_all_tested` has no impact when only using one antibiotic as input. Examples```r example_isolates is a data set available in the AMR package. run ?example_isolates for more info. base R ------------------------------------------------------------count_resistant(example_isolates$AMX)  counts ""R""count_susceptible(example_isolates$AMX)  counts ""S"" and ""I""count_all(example_isolates$AMX)  counts ""S"", ""I"" and ""R"" be more specificcount_S(example_isolates$AMX)count_SI(example_isolates$AMX)count_I(example_isolates$AMX)count_IR(example_isolates$AMX)count_R(example_isolates$AMX) Count all available isolatescount_all(example_isolates$AMX)n_sir(example_isolates$AMX) n_sir() is an alias of count_all(). Since it counts all available isolates, you can calculate back to count e.g. susceptible isolates. These results are the same:count_susceptible(example_isolates$AMX)susceptibility(example_isolates$AMX)  n_sir(example_isolates$AMX) dplyr -------------------------------------------------------------if (require(""dplyr"")) {  example_isolates %>%    group_by(ward) %>%    summarise(      R = count_R(CIP),      I = count_I(CIP),      S = count_S(CIP),      n1 = count_all(CIP),  the actual total; sum of all three      n2 = n_sir(CIP),  same - analogous to n_distinct      total = n()    )  NOT the number of tested isolates!   Number of available isolates for a whole antibiotic class   (i.e., in this data set columns GEN, TOB, AMK, KAN)  example_isolates %>%    group_by(ward) %>%    summarise(across(aminoglycosides(), n_sir))   Count co-resistance between amoxicillin/clav acid and gentamicin,   so we can see that combination therapy does a lot more than mono therapy.   Please mind that `susceptibility()` calculates percentages right away instead.  example_isolates %>% count_susceptible(AMC)  1433  example_isolates %>% count_all(AMC)  1879  example_isolates %>% count_susceptible(GEN)  1399  example_isolates %>% count_all(GEN)  1855  example_isolates %>% count_susceptible(AMC, GEN)  1764  example_isolates %>% count_all(AMC, GEN)  1936   Get number of S+I vs. R immediately of selected columns  example_isolates %>%    select(AMX, CIP) %>%    count_df(translate = FALSE)   It also supports grouping variables  example_isolates %>%    select(ward, AMX, CIP) %>%    group_by(ward) %>%    count_df(translate = FALSE)}``` See Also`proportion_` to calculate microbial resistance and susceptibility.",3
AMR,WHOCC.md,"# WHOCC: WHO Collaborating Centre for Drug Statistics Methodology

## Description

All antimicrobial drugs and their official names, ATC codes, ATC groups and defined daily dose (DDD) are included in this package, using the WHO Collaborating Centre for Drug Statistics Methodology.

## WHOCC

 This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).

These have become the gold standard for international drug utilisation monitoring and research.

The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.

NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.)

## Examples

```r
as.ab(""meropenem"")
ab_name(""J01DH02"")

ab_tradenames(""flucloxacillin"")
```



","['WHOCC: WHO Collaborating Centre for Drug Statistics Methodology DescriptionAll antimicrobial drugs and their official names, ATC codes, ATC groups and defined daily dose (DDD) are included in this package, using the WHO Collaborating Centre for Drug Statistics Methodology.', 'WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government.', 'The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package.']",1," WHOCC: WHO Collaborating Centre for Drug Statistics Methodology DescriptionAll antimicrobial drugs and their official names, ATC codes, ATC groups and defined daily dose (DDD) are included in this package, using the WHO Collaborating Centre for Drug Statistics Methodology. WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.) Examples```ras.ab(""meropenem"")ab_name(""J01DH02"")ab_tradenames(""flucloxacillin"")```",3
AMR,as.disk.md," data

# Transform Input to Disk Diffusion Diameters

## Format

An object of class `disk` (inherits from `integer`) of length 1.

```r
as.disk(x, na.rm = FALSE)

NA_disk_

is.disk(x)
```

## Arguments

- `x`: vector
- `na.rm`: a logical indicating whether missing values should be removed

## Returns

An integer with additional class `disk`

## Description

This transforms a vector to a new class `disk`, which is a disk diffusion growth zone size (around an antibiotic disk) in millimetres between 6 and 50.

## Details

Interpret disk values as SIR values with `as.sir()`. It supports guidelines from EUCAST and CLSI.

Disk diffusion growth zone sizes must be between 6 and 50 millimetres. Values higher than 50 but lower than 100 will be maximised to 50. All others input values outside the 6-50 range will return `NA`. `NA_disk_` is a missing value of the new `disk` class.

## Examples

```r
# transform existing disk zones to the `disk` class (using base R)
df <- data.frame(
  microorganism = ""Escherichia coli"",
  AMP = 20,
  CIP = 14,
  GEN = 18,
  TOB = 16
)
df[, 2:5] <- lapply(df[, 2:5], as.disk)
str(df)


# transforming is easier with dplyr:
if (require(""dplyr"")) {
  df %>% mutate(across(AMP:TOB, as.disk))
}


# interpret disk values, see ?as.sir
as.sir(
  x = as.disk(18),
  mo = ""Strep pneu"", # `mo` will be coerced with as.mo()
  ab = ""ampicillin"", # and `ab` with as.ab()
  guideline = ""EUCAST""
)

# interpret whole data set, pretend to be all from urinary tract infections:
as.sir(df, uti = TRUE)
```

## See Also

`as.sir()`



","['data Transform Input to Disk Diffusion Diameters FormatAn object of class `disk` (inherits from `integer`) of length 1.```ras.disk(x, na.rm = FALSE)NA_disk_is.disk(x)``` Arguments- `x`: vector- `na.rm`: a logical indicating whether missing values should be removed ReturnsAn integer with additional class `disk` DescriptionThis transforms a vector to a new class `disk`, which is a disk diffusion growth zone size (around an antibiotic disk) in millimetres between 6 and 50.', 'DetailsInterpret disk values as SIR values with `as.sir()`.', 'It supports guidelines from EUCAST and CLSI.Disk diffusion growth zone sizes must be between 6 and 50 millimetres.', 'Values higher than 50 but lower than 100 will be maximised to 50.', 'All others input values outside the 6-50 range will return `NA`.', '`NA_disk_` is a missing value of the new `disk` class.', 'Examples```r transform existing disk zones to the `disk` class (using base R)df <- data.frame(  microorganism = ""Escherichia coli"",  AMP = 20,  CIP = 14,  GEN = 18,  TOB = 16)df[, 2:5] <- lapply(df[, 2:5], as.disk)str(df) transforming is easier with dplyr:if (require(""dplyr"")) {  df %>% mutate(across(AMP:TOB, as.disk))} interpret disk values, see ?as.siras.sir(  x = as.disk(18),  mo = ""Strep pneu"",  `mo` will be coerced with as.mo()  ab = ""ampicillin"",  and `ab` with as.ab()  guideline = ""EUCAST"") interpret whole data set, pretend to be all from urinary tract infections:as.sir(df, uti = TRUE)``` See Also`as.sir()`']",1," data Transform Input to Disk Diffusion Diameters FormatAn object of class `disk` (inherits from `integer`) of length 1.```ras.disk(x, na.rm = FALSE)NA_disk_is.disk(x)``` Arguments- `x`: vector- `na.rm`: a logical indicating whether missing values should be removed ReturnsAn integer with additional class `disk` DescriptionThis transforms a vector to a new class `disk`, which is a disk diffusion growth zone size (around an antibiotic disk) in millimetres between 6 and 50. DetailsInterpret disk values as SIR values with `as.sir()`. It supports guidelines from EUCAST and CLSI.Disk diffusion growth zone sizes must be between 6 and 50 millimetres. Values higher than 50 but lower than 100 will be maximised to 50. All others input values outside the 6-50 range will return `NA`. `NA_disk_` is a missing value of the new `disk` class. Examples```r transform existing disk zones to the `disk` class (using base R)df <- data.frame(  microorganism = ""Escherichia coli"",  AMP = 20,  CIP = 14,  GEN = 18,  TOB = 16)df[, 2:5] <- lapply(df[, 2:5], as.disk)str(df) transforming is easier with dplyr:if (require(""dplyr"")) {  df %>% mutate(across(AMP:TOB, as.disk))} interpret disk values, see ?as.siras.sir(  x = as.disk(18),  mo = ""Strep pneu"",  `mo` will be coerced with as.mo()  ab = ""ampicillin"",  and `ab` with as.ab()  guideline = ""EUCAST"") interpret whole data set, pretend to be all from urinary tract infections:as.sir(df, uti = TRUE)``` See Also`as.sir()`",3
AMR,ab_from_text.md,"# Retrieve Antimicrobial Drug Names and Doses from Clinical Text

```r
ab_from_text(
  text,
  type = c(""drug"", ""dose"", ""administration""),
  collapse = NULL,
  translate_ab = FALSE,
  thorough_search = NULL,
  info = interactive(),
  ...
)
```

## Arguments

- `text`: text to analyse
- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see **Examples**
- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see **Examples**
- `translate_ab`: if `type = ""drug""`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`. The default is `FALSE`. Using `TRUE` is equal to using ""name"".
- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values. Setting this to `TRUE` will take considerably more time than when using `FALSE`. At default, it will turn `TRUE` when all input elements contain a maximum of three words.
- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode
- `...`: arguments passed on to `as.ab()`

## Returns

A list , or a character if `collapse` is not `NULL`

## Description

Use this function on e.g. clinical texts from health care records. It returns a list with all antimicrobial drugs, doses and forms of administration found in the texts.

## Details

This function is also internally used by `as.ab()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned. Note: the `as.ab()` function may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems.

### Argument `type`

 At default, the function will search for antimicrobial drug names. All text elements will be searched for official names, ATC codes and brand names. As it uses `as.ab()` internally, it will correct for misspelling.

With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years. The output will be numeric . It supports any unit (g, mg, IE, etc.) and multiple values in one clinical text, see **Examples**.

With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration. It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal. Abbreviations for oral (such as 'po', 'per os') will become ""oral"", all values for intravenous (such as 'iv', 'intraven') will become ""iv"". It supports multiple values in one clinical text, see **Examples**.

### Argument `collapse`

 Without using `collapse`, this function will return a list . This can be convenient to use e.g. inside a `mutate()`):


`df %>% mutate(abx = ab_from_text(clinical_text))`

The returned AB codes can be transformed to official names, groups, etc. with all `ab_*` functions such as `ab_name()` and `ab_group()`, or by using the `translate_ab` argument.

With using `collapse`, this function will return a character :


`df %>% mutate(abx = ab_from_text(clinical_text, collapse = ""|""))`

## Examples

```r
# mind the bad spelling of amoxicillin in this line,
# straight from a true health care record:
ab_from_text(""28/03/2020 regular amoxicilliin 500mg po tid"")

ab_from_text(""500 mg amoxi po and 400mg cipro iv"")
ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""dose"")
ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""admin"")

ab_from_text(""500 mg amoxi po and 400mg cipro iv"", collapse = "", "")

# if you want to know which antibiotic groups were administered, do e.g.:
abx <- ab_from_text(""500 mg amoxi po and 400mg cipro iv"")
ab_group(abx[[1]])

if (require(""dplyr"")) {
  tibble(clinical_text = c(
    ""given 400mg cipro and 500 mg amox"",
    ""started on doxy iv today""
  )) %>%
    mutate(
      abx_codes = ab_from_text(clinical_text),
      abx_doses = ab_from_text(clinical_text, type = ""doses""),
      abx_admin = ab_from_text(clinical_text, type = ""admin""),
      abx_coll = ab_from_text(clinical_text, collapse = ""|""),
      abx_coll_names = ab_from_text(clinical_text,
        collapse = ""|"",
        translate_ab = ""name""
      ),
      abx_coll_doses = ab_from_text(clinical_text,
        type = ""doses"",
        collapse = ""|""
      ),
      abx_coll_admin = ab_from_text(clinical_text,
        type = ""admin"",
        collapse = ""|""
      )
    )
}
```



","['Retrieve Antimicrobial Drug Names and Doses from Clinical Text```rab_from_text(  text,  type = c(""drug"", ""dose"", ""administration""),  collapse = NULL,  translate_ab = FALSE,  thorough_search = NULL,  info = interactive(),  ...)``` Arguments- `text`: text to analyse- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see Examples- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see Examples- `translate_ab`: if `type = ""drug""`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`.', 'Using `TRUE` is equal to using ""name"".- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values.', 'Setting this to `TRUE` will take considerably more time than when using `FALSE`.', 'At default, it will turn `TRUE` when all input elements contain a maximum of three words.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to `as.ab()` ReturnsA list , or a character if `collapse` is not `NULL` DescriptionUse this function on e.g.', 'clinical texts from health care records.', 'It returns a list with all antimicrobial drugs, doses and forms of administration found in the texts.', 'DetailsThis function is also internally used by `as.ab()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned.', 'Note: the `as.ab()` function may use very long regular expression to match brand names of antimicrobial drugs.', 'This may fail on some systems.', 'Argument `type` At default, the function will search for antimicrobial drug names.', 'All text elements will be searched for official names, ATC codes and brand names.', 'As it uses `as.ab()` internally, it will correct for misspelling.With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years.', 'The output will be numeric .', 'It supports any unit (g, mg, IE, etc.)', 'and multiple values in one clinical text, see Examples.With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration.', 'It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal.', 'Abbreviations for oral (such as \'po\', \'per os\') will become ""oral"", all values for intravenous (such as \'iv\', \'intraven\') will become ""iv"".', 'It supports multiple values in one clinical text, see Examples.', 'Argument `collapse` Without using `collapse`, this function will return a list .', 'This can be convenient to use e.g.', 'inside a `mutate()`):`df %>% mutate(abx = ab_from_text(clinical_text))`The returned AB codes can be transformed to official names, groups, etc.', 'with all `ab_` functions such as `ab_name()` and `ab_group()`, or by using the `translate_ab` argument.With using `collapse`, this function will return a character :`df %>% mutate(abx = ab_from_text(clinical_text, collapse = ""|""))` Examples```r mind the bad spelling of amoxicillin in this line, straight from a true health care record:ab_from_text(""28/03/2020 regular amoxicilliin 500mg po tid"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""dose"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""admin"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", collapse = "", "") if you want to know which antibiotic groups were administered, do e.g.', ':abx <- ab_from_text(""500 mg amoxi po and 400mg cipro iv"")ab_group(abx[[1]])if (require(""dplyr"")) {  tibble(clinical_text = c(    ""given 400mg cipro and 500 mg amox"",    ""started on doxy iv today""  )) %>%    mutate(      abx_codes = ab_from_text(clinical_text),      abx_doses = ab_from_text(clinical_text, type = ""doses""),      abx_admin = ab_from_text(clinical_text, type = ""admin""),      abx_coll = ab_from_text(clinical_text, collapse = ""|""),      abx_coll_names = ab_from_text(clinical_text,        collapse = ""|"",        translate_ab = ""name""      ),      abx_coll_doses = ab_from_text(clinical_text,        type = ""doses"",        collapse = ""|""      ),      abx_coll_admin = ab_from_text(clinical_text,        type = ""admin"",        collapse = ""|""      )    )}```']",1," Retrieve Antimicrobial Drug Names and Doses from Clinical Text```rab_from_text(  text,  type = c(""drug"", ""dose"", ""administration""),  collapse = NULL,  translate_ab = FALSE,  thorough_search = NULL,  info = interactive(),  ...)``` Arguments- `text`: text to analyse- `type`: type of property to search for, either `""drug""`, `""dose""` or `""administration""`, see Examples- `collapse`: a character to pass on to `paste(, collapse = ...)` to only return one character per element of `text`, see Examples- `translate_ab`: if `type = ""drug""`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`. The default is `FALSE`. Using `TRUE` is equal to using ""name"".- `thorough_search`: a logical to indicate whether the input must be extensively searched for misspelling and other faulty input values. Setting this to `TRUE` will take considerably more time than when using `FALSE`. At default, it will turn `TRUE` when all input elements contain a maximum of three words.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to `as.ab()` ReturnsA list , or a character if `collapse` is not `NULL` DescriptionUse this function on e.g. clinical texts from health care records. It returns a list with all antimicrobial drugs, doses and forms of administration found in the texts. DetailsThis function is also internally used by `as.ab()`, although it then only searches for the first drug name and will throw a note if more drug names could have been returned. Note: the `as.ab()` function may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems. Argument `type` At default, the function will search for antimicrobial drug names. All text elements will be searched for official names, ATC codes and brand names. As it uses `as.ab()` internally, it will correct for misspelling.With `type = ""dose""` (or similar, like ""dosing"", ""doses""), all text elements will be searched for numeric values that are higher than 100 and do not resemble years. The output will be numeric . It supports any unit (g, mg, IE, etc.) and multiple values in one clinical text, see Examples.With `type = ""administration""` (or abbreviations, like ""admin"", ""adm""), all text elements will be searched for a form of drug administration. It supports the following forms (including common abbreviations): buccal, implant, inhalation, instillation, intravenous, nasal, oral, parenteral, rectal, sublingual, transdermal and vaginal. Abbreviations for oral (such as 'po', 'per os') will become ""oral"", all values for intravenous (such as 'iv', 'intraven') will become ""iv"". It supports multiple values in one clinical text, see Examples. Argument `collapse` Without using `collapse`, this function will return a list . This can be convenient to use e.g. inside a `mutate()`):`df %>% mutate(abx = ab_from_text(clinical_text))`The returned AB codes can be transformed to official names, groups, etc. with all `ab_` functions such as `ab_name()` and `ab_group()`, or by using the `translate_ab` argument.With using `collapse`, this function will return a character :`df %>% mutate(abx = ab_from_text(clinical_text, collapse = ""|""))` Examples```r mind the bad spelling of amoxicillin in this line, straight from a true health care record:ab_from_text(""28/03/2020 regular amoxicilliin 500mg po tid"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""dose"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", type = ""admin"")ab_from_text(""500 mg amoxi po and 400mg cipro iv"", collapse = "", "") if you want to know which antibiotic groups were administered, do e.g.:abx <- ab_from_text(""500 mg amoxi po and 400mg cipro iv"")ab_group(abx[[1]])if (require(""dplyr"")) {  tibble(clinical_text = c(    ""given 400mg cipro and 500 mg amox"",    ""started on doxy iv today""  )) %>%    mutate(      abx_codes = ab_from_text(clinical_text),      abx_doses = ab_from_text(clinical_text, type = ""doses""),      abx_admin = ab_from_text(clinical_text, type = ""admin""),      abx_coll = ab_from_text(clinical_text, collapse = ""|""),      abx_coll_names = ab_from_text(clinical_text,        collapse = ""|"",        translate_ab = ""name""      ),      abx_coll_doses = ab_from_text(clinical_text,        type = ""doses"",        collapse = ""|""      ),      abx_coll_admin = ab_from_text(clinical_text,        type = ""admin"",        collapse = ""|""      )    )}```",4
AMR,dosage.md," data

# Data Set with Treatment Dosages as Defined by EUCAST

## Format

A tibble with 503 observations and 9 variables:

 * `ab`
   
   Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available
 * `name`
   
   Official name of the antimicrobial drug as used by WHONET/EARS-Net or the WHO
 * `type`
   
   Type of the dosage, either ""high_dosage"", ""standard_dosage"", or ""uncomplicated_uti""
 * `dose`
   
   Dose, such as ""2 g"" or ""25 mg/kg""
 * `dose_times`
   
   Number of times a dose must be administered
 * `administration`
   
   Route of administration, either ""im"", ""iv"", or ""oral""
 * `notes`
   
   Additional dosage notes
 * `original_txt`
   
   Original text in the PDF file of EUCAST
 * `eucast_version`
   
   Version number of the EUCAST Clinical Breakpoints guideline to which these dosages apply, either 13, 12, or 11

```r
dosage
```

## Description

EUCAST breakpoints used in this package are based on the dosages in this data set. They can be retrieved with `eucast_dosage()`.

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
dosage
```



","['data Data Set with Treatment Dosages as Defined by EUCAST FormatA tibble with 503 observations and 9 variables:  `ab`      Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available  `name`      Official name of the antimicrobial drug as used by WHONET/EARS-Net or the WHO  `type`      Type of the dosage, either ""high_dosage"", ""standard_dosage"", or ""uncomplicated_uti""  `dose`      Dose, such as ""2 g"" or ""25 mg/kg""  `dose_times`      Number of times a dose must be administered  `administration`      Route of administration, either ""im"", ""iv"", or ""oral""  `notes`      Additional dosage notes  `original_txt`      Original text in the PDF file of EUCAST  `eucast_version`      Version number of the EUCAST Clinical Breakpoints guideline to which these dosages apply, either 13, 12, or 11```rdosage``` DescriptionEUCAST breakpoints used in this package are based on the dosages in this data set.', 'They can be retrieved with `eucast_dosage()`.', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).']",1," data Data Set with Treatment Dosages as Defined by EUCAST FormatA tibble with 503 observations and 9 variables:  `ab`      Antibiotic ID as used in this package (such as `AMC`), using the official EARS-Net (European Antimicrobial Resistance Surveillance Network) codes where available  `name`      Official name of the antimicrobial drug as used by WHONET/EARS-Net or the WHO  `type`      Type of the dosage, either ""high_dosage"", ""standard_dosage"", or ""uncomplicated_uti""  `dose`      Dose, such as ""2 g"" or ""25 mg/kg""  `dose_times`      Number of times a dose must be administered  `administration`      Route of administration, either ""im"", ""iv"", or ""oral""  `notes`      Additional dosage notes  `original_txt`      Original text in the PDF file of EUCAST  `eucast_version`      Version number of the EUCAST Clinical Breakpoints guideline to which these dosages apply, either 13, 12, or 11```rdosage``` DescriptionEUCAST breakpoints used in this package are based on the dosages in this data set. They can be retrieved with `eucast_dosage()`. DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rdosage```",4
AMR,ab_property.md,"# Get Properties of an Antibiotic

```r
ab_name(x, language = get_AMR_locale(), tolower = FALSE, ...)

ab_cid(x, ...)

ab_synonyms(x, ...)

ab_tradenames(x, ...)

ab_group(x, language = get_AMR_locale(), ...)

ab_atc(x, only_first = FALSE, ...)

ab_atc_group1(x, language = get_AMR_locale(), ...)

ab_atc_group2(x, language = get_AMR_locale(), ...)

ab_loinc(x, ...)

ab_ddd(x, administration = ""oral"", ...)

ab_ddd_units(x, administration = ""oral"", ...)

ab_info(x, language = get_AMR_locale(), ...)

ab_url(x, open = FALSE, ...)

ab_property(x, property = ""name"", language = get_AMR_locale(), ...)

set_ab_names(
  data,
  ...,
  property = ""name"",
  language = get_AMR_locale(),
  snake_case = NULL
)
```

## Arguments

- `x`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`
- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character . This will lead to e.g. ""polymyxin B"" and not ""polymyxin b"".
- `...`: in case of `set_ab_names()` and `data` is a data.frame : columns to select (supports tidy selection such as `column1:column4`), otherwise other arguments passed on to `as.ab()`
- `only_first`: a logical to indicate whether only the first ATC code must be returned, with giving preference to J0-codes (i.e., the antimicrobial drug group)
- `administration`: way of administration, either `""oral""` or `""iv""`
- `open`: browse the URL using `utils::browseURL()`
- `property`: one of the column names of one of the antibiotics data set: `vector_or(colnames(antibiotics), sort = FALSE)`.
- `data`: a data.frame of which the columns need to be renamed, or a character vector of column names
- `snake_case`: a logical to indicate whether the names should be in so-called [snake case](https://en.wikipedia.org/wiki/Snake_case): in lower case and all spaces/slashes replaced with an underscore (`_`)

## Returns

 * An integer in case of `ab_cid()`
 * A named list in case of `ab_info()` and multiple `ab_atc()`/`ab_synonyms()`/`ab_tradenames()`
 * A double in case of `ab_ddd()`
 * A data.frame in case of `set_ab_names()`
 * A character in all other cases

## Description

Use these functions to return a specific property of an antibiotic from the antibiotics data set. All input values will be evaluated internally with `as.ab()`.

## Details

All output will be translated where possible.

The function `ab_url()` will return the direct URL to the official WHO website. A warning will be returned if the required ATC code is not available.

The function `set_ab_names()` is a special column renaming function for data.frame s. It renames columns names that resemble antimicrobial drugs. It always makes sure that the new column names are unique. If `property = ""atc""` is set, preference is given to ATC codes from the J-group.

## Source

 World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)

European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# all properties:
ab_name(""AMX"")
ab_atc(""AMX"")
ab_cid(""AMX"")
ab_synonyms(""AMX"")
ab_tradenames(""AMX"")
ab_group(""AMX"")
ab_atc_group1(""AMX"")
ab_atc_group2(""AMX"")
ab_url(""AMX"")

# smart lowercase transformation
ab_name(x = c(""AMC"", ""PLB""))
ab_name(x = c(""AMC"", ""PLB""), tolower = TRUE)

# defined daily doses (DDD)
ab_ddd(""AMX"", ""oral"")
ab_ddd_units(""AMX"", ""oral"")
ab_ddd(""AMX"", ""iv"")
ab_ddd_units(""AMX"", ""iv"")

ab_info(""AMX"") # all properties as a list

# all ab_* functions use as.ab() internally, so you can go from 'any' to 'any':
ab_atc(""AMP"")
ab_group(""J01CA01"")
ab_loinc(""ampicillin"")
ab_name(""21066-6"")
ab_name(6249)
ab_name(""J01CA01"")

# spelling from different languages and dyslexia are no problem
ab_atc(""ceftriaxon"")
ab_atc(""cephtriaxone"")
ab_atc(""cephthriaxone"")
ab_atc(""seephthriaaksone"")

# use set_ab_names() for renaming columns
colnames(example_isolates)
colnames(set_ab_names(example_isolates))
colnames(set_ab_names(example_isolates, NIT:VAN))

if (require(""dplyr"")) {
  example_isolates %>%
    set_ab_names()

  # this does the same:
  example_isolates %>%
    rename_with(set_ab_names)

  # set_ab_names() works with any AB property:
  example_isolates %>%
    set_ab_names(property = ""atc"")

  example_isolates %>%
    set_ab_names(where(is.sir)) %>%
    colnames()

  example_isolates %>%
    set_ab_names(NIT:VAN) %>%
    colnames()
}
```

## See Also

antibiotics



","['Get Properties of an Antibiotic```rab_name(x, language = get_AMR_locale(), tolower = FALSE, ...)ab_cid(x, ...)ab_synonyms(x, ...)ab_tradenames(x, ...)ab_group(x, language = get_AMR_locale(), ...)ab_atc(x, only_first = FALSE, ...)ab_atc_group1(x, language = get_AMR_locale(), ...)ab_atc_group2(x, language = get_AMR_locale(), ...)ab_loinc(x, ...)ab_ddd(x, administration = ""oral"", ...)ab_ddd_units(x, administration = ""oral"", ...)ab_info(x, language = get_AMR_locale(), ...)ab_url(x, open = FALSE, ...)ab_property(x, property = ""name"", language = get_AMR_locale(), ...)set_ab_names(  data,  ...,  property = ""name"",  language = get_AMR_locale(),  snake_case = NULL)``` Arguments- `x`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character .', 'This will lead to e.g.', '""polymyxin B"" and not ""polymyxin b"".- `...`: in case of `set_ab_names()` and `data` is a data.frame : columns to select (supports tidy selection such as `column1:column4`), otherwise other arguments passed on to `as.ab()`- `only_first`: a logical to indicate whether only the first ATC code must be returned, with giving preference to J0-codes (i.e., the antimicrobial drug group)- `administration`: way of administration, either `""oral""` or `""iv""`- `open`: browse the URL using `utils::browseURL()`- `property`: one of the column names of one of the antibiotics data set: `vector_or(colnames(antibiotics), sort = FALSE)`.- `data`: a data.frame of which the columns need to be renamed, or a character vector of column names- `snake_case`: a logical to indicate whether the names should be in so-called [snake case](https://en.wikipedia.org/wiki/Snake_case): in lower case and all spaces/slashes replaced with an underscore (`_`) Returns  An integer in case of `ab_cid()`  A named list in case of `ab_info()` and multiple `ab_atc()`/`ab_synonyms()`/`ab_tradenames()`  A double in case of `ab_ddd()`  A data.frame in case of `set_ab_names()`  A character in all other cases DescriptionUse these functions to return a specific property of an antibiotic from the antibiotics data set.', 'All input values will be evaluated internally with `as.ab()`.', 'DetailsAll output will be translated where possible.The function `ab_url()` will return the direct URL to the official WHO website.', 'A warning will be returned if the required ATC code is not available.The function `set_ab_names()` is a special column renaming function for data.frame s. It renames columns names that resemble antimicrobial drugs.', 'It always makes sure that the new column names are unique.', 'If `property = ""atc""` is set, preference is given to ATC codes from the J-group.', 'Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r all properties:ab_name(""AMX"")ab_atc(""AMX"")ab_cid(""AMX"")ab_synonyms(""AMX"")ab_tradenames(""AMX"")ab_group(""AMX"")ab_atc_group1(""AMX"")ab_atc_group2(""AMX"")ab_url(""AMX"") smart lowercase transformationab_name(x = c(""AMC"", ""PLB""))ab_name(x = c(""AMC"", ""PLB""), tolower = TRUE) defined daily doses (DDD)ab_ddd(""AMX"", ""oral"")ab_ddd_units(""AMX"", ""oral"")ab_ddd(""AMX"", ""iv"")ab_ddd_units(""AMX"", ""iv"")ab_info(""AMX"")  all properties as a list all ab_ functions use as.ab() internally, so you can go from \'any\' to \'any\':ab_atc(""AMP"")ab_group(""J01CA01"")ab_loinc(""ampicillin"")ab_name(""21066-6"")ab_name(6249)ab_name(""J01CA01"") spelling from different languages and dyslexia are no problemab_atc(""ceftriaxon"")ab_atc(""cephtriaxone"")ab_atc(""cephthriaxone"")ab_atc(""seephthriaaksone"") use set_ab_names() for renaming columnscolnames(example_isolates)colnames(set_ab_names(example_isolates))colnames(set_ab_names(example_isolates, NIT:VAN))if (require(""dplyr"")) {  example_isolates %>%    set_ab_names()   this does the same:  example_isolates %>%    rename_with(set_ab_names)   set_ab_names() works with any AB property:  example_isolates %>%    set_ab_names(property = ""atc"")  example_isolates %>%    set_ab_names(where(is.sir)) %>%    colnames()  example_isolates %>%    set_ab_names(NIT:VAN) %>%    colnames()}``` See Alsoantibiotics']",1," Get Properties of an Antibiotic```rab_name(x, language = get_AMR_locale(), tolower = FALSE, ...)ab_cid(x, ...)ab_synonyms(x, ...)ab_tradenames(x, ...)ab_group(x, language = get_AMR_locale(), ...)ab_atc(x, only_first = FALSE, ...)ab_atc_group1(x, language = get_AMR_locale(), ...)ab_atc_group2(x, language = get_AMR_locale(), ...)ab_loinc(x, ...)ab_ddd(x, administration = ""oral"", ...)ab_ddd_units(x, administration = ""oral"", ...)ab_info(x, language = get_AMR_locale(), ...)ab_url(x, open = FALSE, ...)ab_property(x, property = ""name"", language = get_AMR_locale(), ...)set_ab_names(  data,  ...,  property = ""name"",  language = get_AMR_locale(),  snake_case = NULL)``` Arguments- `x`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character . This will lead to e.g. ""polymyxin B"" and not ""polymyxin b"".- `...`: in case of `set_ab_names()` and `data` is a data.frame : columns to select (supports tidy selection such as `column1:column4`), otherwise other arguments passed on to `as.ab()`- `only_first`: a logical to indicate whether only the first ATC code must be returned, with giving preference to J0-codes (i.e., the antimicrobial drug group)- `administration`: way of administration, either `""oral""` or `""iv""`- `open`: browse the URL using `utils::browseURL()`- `property`: one of the column names of one of the antibiotics data set: `vector_or(colnames(antibiotics), sort = FALSE)`.- `data`: a data.frame of which the columns need to be renamed, or a character vector of column names- `snake_case`: a logical to indicate whether the names should be in so-called [snake case](https://en.wikipedia.org/wiki/Snake_case): in lower case and all spaces/slashes replaced with an underscore (`_`) Returns  An integer in case of `ab_cid()`  A named list in case of `ab_info()` and multiple `ab_atc()`/`ab_synonyms()`/`ab_tradenames()`  A double in case of `ab_ddd()`  A data.frame in case of `set_ab_names()`  A character in all other cases DescriptionUse these functions to return a specific property of an antibiotic from the antibiotics data set. All input values will be evaluated internally with `as.ab()`. DetailsAll output will be translated where possible.The function `ab_url()` will return the direct URL to the official WHO website. A warning will be returned if the required ATC code is not available.The function `set_ab_names()` is a special column renaming function for data.frame s. It renames columns names that resemble antimicrobial drugs. It always makes sure that the new column names are unique. If `property = ""atc""` is set, preference is given to ATC codes from the J-group. Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r all properties:ab_name(""AMX"")ab_atc(""AMX"")ab_cid(""AMX"")ab_synonyms(""AMX"")ab_tradenames(""AMX"")ab_group(""AMX"")ab_atc_group1(""AMX"")ab_atc_group2(""AMX"")ab_url(""AMX"") smart lowercase transformationab_name(x = c(""AMC"", ""PLB""))ab_name(x = c(""AMC"", ""PLB""), tolower = TRUE) defined daily doses (DDD)ab_ddd(""AMX"", ""oral"")ab_ddd_units(""AMX"", ""oral"")ab_ddd(""AMX"", ""iv"")ab_ddd_units(""AMX"", ""iv"")ab_info(""AMX"")  all properties as a list all ab_ functions use as.ab() internally, so you can go from 'any' to 'any':ab_atc(""AMP"")ab_group(""J01CA01"")ab_loinc(""ampicillin"")ab_name(""21066-6"")ab_name(6249)ab_name(""J01CA01"") spelling from different languages and dyslexia are no problemab_atc(""ceftriaxon"")ab_atc(""cephtriaxone"")ab_atc(""cephthriaxone"")ab_atc(""seephthriaaksone"") use set_ab_names() for renaming columnscolnames(example_isolates)colnames(set_ab_names(example_isolates))colnames(set_ab_names(example_isolates, NIT:VAN))if (require(""dplyr"")) {  example_isolates %>%    set_ab_names()   this does the same:  example_isolates %>%    rename_with(set_ab_names)   set_ab_names() works with any AB property:  example_isolates %>%    set_ab_names(property = ""atc"")  example_isolates %>%    set_ab_names(where(is.sir)) %>%    colnames()  example_isolates %>%    set_ab_names(NIT:VAN) %>%    colnames()}``` See Alsoantibiotics",4
AMR,microorganisms.md," data

# Data Set with 52 171 Microorganisms

## Format

A tibble with 52 171 observations and 23 variables:

 * `mo`
   
   ID of microorganism as used by this package. **This is a unique identifier.**
 * `fullname`
   
   Full name, like `""Escherichia coli""`. For the taxonomic ranks genus, species and subspecies, this is the 'pasted' text of genus, species, and subspecies. For all taxonomic ranks higher than genus, this is the name of the taxon. **This is a unique identifier.**
 * `status`
   
   Status of the taxon, either ""accepted"" or ""synonym""
 * `kingdom`, `phylum`, `class`, `order`, `family`, `genus`, `species`, `subspecies`
   
   Taxonomic rank of the microorganism
 * `rank`
   
   Text of the taxonomic rank of the microorganism, such as `""species""` or `""genus""`
 * `ref`
   
   Author(s) and year of related scientific publication. This contains only the **first surname** and year of the **latest** authors, e.g. ""Wallis **et al.** 2006 **emend.** Smith and Jones 2018"" becomes ""Smith **et al.**, 2018"". This field is directly retrieved from the source specified in the column `source`. Moreover, accents were removed to comply with CRAN that only allows ASCII characters.
 * `lpsn`
   
   Identifier ('Record number') of the List of Prokaryotic names with Standing in Nomenclature (LPSN). This will be the first/highest LPSN identifier to keep one identifier per row. For example, **Acetobacter ascendens** has LPSN Record number 7864 and 11011. Only the first is available in the `microorganisms` data set.
 * `oxygen_tolerance`
   
   Oxygen tolerance, either ""aerobe"", ""anaerobe"", ""anaerobe/microaerophile"", ""facultative anaerobe"", ""likely facultative anaerobe"", or ""microaerophile"". These data were retrieved from BacDive (see **Source**). Items that contain ""likely"" are missing from BacDive and were extrapolated from other species within the same genus to guess the oxygen tolerance. Currently 73.4% of all ~37 000 bacteria in the data set contain an oxygen tolerance.
 * `lpsn_parent`
   
   LPSN identifier of the parent taxon
 * `lpsn_renamed_to`
   
   LPSN identifier of the currently valid taxon
 * `gbif`
   
   Identifier ('taxonID') of the Global Biodiversity Information Facility (GBIF)
 * `gbif_parent`
   
   GBIF identifier of the parent taxon
 * `gbif_renamed_to`
   
   GBIF identifier of the currently valid taxon
 * `source`
   
   Either ""GBIF"", ""LPSN"", or ""manually added"" (see **Source**)
 * `prevalence`
   
   Prevalence of the microorganism according to Bartlett **et al.** (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ), see `mo_matching_score()` for the full explanation
 * `snomed`
   
   Systematized Nomenclature of Medicine (SNOMED) code of the microorganism, version of July 1st, 2021 (see **Source**). Use `mo_snomed()` to retrieve it quickly, see `mo_property()`.

## Source

 * Parte, AC **et al.** (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.
 * GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.
 * Reimer, LC **et al.** (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.
 * Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)
 * Grimont **et al.** (2007). Antigenic Formulae of the Salmonella Serovars, 9th Edition. WHO Collaborating Centre for Reference and Research on **Salmonella** (WHOCC-SALM).
 * Bartlett **et al.** (2022). A comprehensive list of bacterial pathogens infecting humans **Microbiology** 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"")

```r
microorganisms
```

## Description

A data set containing the full microbial taxonomy (last updated: December 11th, 2022 ) of five kingdoms from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF). This data set is the backbone of this `AMR` package. MO codes can be looked up using `as.mo()`.

## Details

Please note that entries are only based on the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF) (see below). Since these sources incorporate entries based on (recent) publications in the International Journal of Systematic and Evolutionary Microbiology (IJSEM), it can happen that the year of publication is sometimes later than one might expect.

For example, **Staphylococcus pettenkoferi** was described for the first time in Diagnostic Microbiology and Infectious Disease in 2002 (tools:::Rd_expr_doi(""10.1016/s0732-8893(02)00399-1"") ), but it was not before 2007 that a publication in IJSEM followed (tools:::Rd_expr_doi(""10.1099/ijs.0.64381-0"") ). Consequently, the `AMR` package returns 2007 for `mo_year(""S. pettenkoferi"")`.

## Included Taxa

 Included taxonomic data are:

 * All ~37 000 (sub)species from the kingdoms of Archaea and Bacteria
 * ~7 900 (sub)species from the kingdom of Fungi. The kingdom of Fungi is a very large taxon with almost 300,000 different (sub)species, of which most are not microbial (but rather macroscopic, like mushrooms). Because of this, not all fungi fit the scope of this package. Only relevant fungi are covered (such as all species of **Aspergillus**, **Candida**, **Cryptococcus**, **Histoplasma**, **Pneumocystis**, **Saccharomyces** and **Trichophyton**).
 * ~5 100 (sub)species from the kingdom of Protozoa
 * ~1 400 (sub)species from 43 other relevant genera from the kingdom of Animalia (such as **Strongyloides** and **Taenia**)
 * All ~9 800 previously accepted names of all included (sub)species (these were taxonomically renamed)
 * The complete taxonomic tree of all included (sub)species: from kingdom to subspecies
 * The identifier of the parent taxons
 * The year and first author of the related scientific publication

### Manual additions

 For convenience, some entries were added manually:

 * ~1 500 entries of **Salmonella**, such as the city-like serovars and groups A to H
 * 36 species groups (such as the beta-haemolytic **Streptococcus** groups A to K, coagulase-negative **Staphylococcus** (CoNS), **Mycobacterium tuberculosis** complex, etc.), of which the group compositions are stored in the microorganisms.groups data set
 * 1 entry of **Blastocystis** (**B. hominis**), although it officially does not exist (Noel **et al.** 2005, PMID 15634993)
 * 1 entry of **Moraxella** (**M. catarrhalis**), which was formally named **Branhamella catarrhalis** (Catlin, 1970) though this change was never accepted within the field of clinical microbiology
 * 8 other 'undefined' entries (unknown, unknown Gram-negatives, unknown Gram-positives, unknown yeast, unknown fungus, and unknown anaerobic Gram-pos/Gram-neg bacteria)

The syntax used to transform the original data to a cleansed format, can be found here: [https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R](https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R).

### Direct download

 Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## About the Records from LPSN (see **Source**)

 LPSN is the main source for bacteriological taxonomy of this `AMR` package.

The List of Prokaryotic names with Standing in Nomenclature (LPSN) provides comprehensive information on the nomenclature of prokaryotes. LPSN is a free to use service founded by Jean P. Euzeby in 1997 and later on maintained by Aidan C. Parte.

## Examples

```r
microorganisms
```

## See Also

`as.mo()`, `mo_property()`, microorganisms.groups , microorganisms.codes , intrinsic_resistant



","['data Data Set with 52 171 Microorganisms FormatA tibble with 52 171 observations and 23 variables:  `mo`      ID of microorganism as used by this package.', 'This is a unique identifier.', '`fullname`      Full name, like `""Escherichia coli""`.', ""For the taxonomic ranks genus, species and subspecies, this is the 'pasted' text of genus, species, and subspecies."", 'For all taxonomic ranks higher than genus, this is the name of the taxon.', 'This is a unique identifier.', '`status`      Status of the taxon, either ""accepted"" or ""synonym""  `kingdom`, `phylum`, `class`, `order`, `family`, `genus`, `species`, `subspecies`      Taxonomic rank of the microorganism  `rank`      Text of the taxonomic rank of the microorganism, such as `""species""` or `""genus""`  `ref`      Author(s) and year of related scientific publication.', 'This contains only the first surname and year of the latest authors, e.g.', 'Smith and Jones 2018"" becomes ""Smith et al., 2018"".', 'This field is directly retrieved from the source specified in the column `source`.', 'Moreover, accents were removed to comply with CRAN that only allows ASCII characters.', ""`lpsn`      Identifier ('Record number') of the List of Prokaryotic names with Standing in Nomenclature (LPSN)."", 'This will be the first/highest LPSN identifier to keep one identifier per row.', 'For example, Acetobacter ascendens has LPSN Record number 7864 and 11011.', 'Only the first is available in the `microorganisms` data set.', '`oxygen_tolerance`      Oxygen tolerance, either ""aerobe"", ""anaerobe"", ""anaerobe/microaerophile"", ""facultative anaerobe"", ""likely facultative anaerobe"", or ""microaerophile"".', 'These data were retrieved from BacDive (see Source).', 'Items that contain ""likely"" are missing from BacDive and were extrapolated from other species within the same genus to guess the oxygen tolerance.', 'Currently 73.4% of all ~37 000 bacteria in the data set contain an oxygen tolerance.', '`lpsn_parent`      LPSN identifier of the parent taxon  `lpsn_renamed_to`      LPSN identifier of the currently valid taxon  `gbif`      Identifier (\'taxonID\') of the Global Biodiversity Information Facility (GBIF)  `gbif_parent`      GBIF identifier of the parent taxon  `gbif_renamed_to`      GBIF identifier of the currently valid taxon  `source`      Either ""GBIF"", ""LPSN"", or ""manually added"" (see Source)  `prevalence`      Prevalence of the microorganism according to Bartlett et al.', '(2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ), see `mo_matching_score()` for the full explanation  `snomed`      Systematized Nomenclature of Medicine (SNOMED) code of the microorganism, version of July 1st, 2021 (see Source).', 'Use `mo_snomed()` to retrieve it quickly, see `mo_property()`.', 'Source  Parte, AC et al.', 'List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ.', 'International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") .', 'Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.', 'Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.', '_BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data.', 'Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") .', 'Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.', 'Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS).', 'US Edition of SNOMED CT from 1 September 2020.', ""Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12)."", 'URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)  Grimont et al.', 'Antigenic Formulae of the Salmonella Serovars, 9th Edition.', 'WHO Collaborating Centre for Reference and Research on Salmonella (WHOCC-SALM).', 'A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"")```rmicroorganisms``` DescriptionA data set containing the full microbial taxonomy (last updated: December 11th, 2022 ) of five kingdoms from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF).', 'This data set is the backbone of this `AMR` package.', 'MO codes can be looked up using `as.mo()`.', 'DetailsPlease note that entries are only based on the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF) (see below).', 'Since these sources incorporate entries based on (recent) publications in the International Journal of Systematic and Evolutionary Microbiology (IJSEM), it can happen that the year of publication is sometimes later than one might expect.For example, Staphylococcus pettenkoferi was described for the first time in Diagnostic Microbiology and Infectious Disease in 2002 (tools:::Rd_expr_doi(""10.1016/s0732-8893(02)00399-1"") ), but it was not before 2007 that a publication in IJSEM followed (tools:::Rd_expr_doi(""10.1099/ijs.0.64381-0"") ).', 'Consequently, the `AMR` package returns 2007 for `mo_year(""S. pettenkoferi"")`.', 'Included Taxa Included taxonomic data are:  All ~37 000 (sub)species from the kingdoms of Archaea and Bacteria  ~7 900 (sub)species from the kingdom of Fungi.', 'The kingdom of Fungi is a very large taxon with almost 300,000 different (sub)species, of which most are not microbial (but rather macroscopic, like mushrooms).', 'Because of this, not all fungi fit the scope of this package.', 'Only relevant fungi are covered (such as all species of Aspergillus, Candida, Cryptococcus, Histoplasma, Pneumocystis, Saccharomyces and Trichophyton).', '~5 100 (sub)species from the kingdom of Protozoa  ~1 400 (sub)species from 43 other relevant genera from the kingdom of Animalia (such as Strongyloides and Taenia)  All ~9 800 previously accepted names of all included (sub)species (these were taxonomically renamed)  The complete taxonomic tree of all included (sub)species: from kingdom to subspecies  The identifier of the parent taxons  The year and first author of the related scientific publication Manual additions For convenience, some entries were added manually:  ~1 500 entries of Salmonella, such as the city-like serovars and groups A to H  36 species groups (such as the beta-haemolytic Streptococcus groups A to K, coagulase-negative Staphylococcus (CoNS), Mycobacterium tuberculosis complex, etc.', '), of which the group compositions are stored in the microorganisms.groups data set  1 entry of Blastocystis (B. hominis), although it officially does not exist (Noel et al.', ""2005, PMID 15634993)  1 entry of Moraxella (M. catarrhalis), which was formally named Branhamella catarrhalis (Catlin, 1970) though this change was never accepted within the field of clinical microbiology  8 other 'undefined' entries (unknown, unknown Gram-negatives, unknown Gram-positives, unknown yeast, unknown fungus, and unknown anaerobic Gram-pos/Gram-neg bacteria)The syntax used to transform the original data to a cleansed format, can be found here: [https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R](https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R)."", 'Direct download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'About the Records from LPSN (see Source) LPSN is the main source for bacteriological taxonomy of this `AMR` package.The List of Prokaryotic names with Standing in Nomenclature (LPSN) provides comprehensive information on the nomenclature of prokaryotes.', 'LPSN is a free to use service founded by Jean P. Euzeby in 1997 and later on maintained by Aidan C. Parte.', 'Examples```rmicroorganisms``` See Also`as.mo()`, `mo_property()`, microorganisms.groups , microorganisms.codes , intrinsic_resistant']",1," data Data Set with 52 171 Microorganisms FormatA tibble with 52 171 observations and 23 variables:  `mo`      ID of microorganism as used by this package. This is a unique identifier.  `fullname`      Full name, like `""Escherichia coli""`. For the taxonomic ranks genus, species and subspecies, this is the 'pasted' text of genus, species, and subspecies. For all taxonomic ranks higher than genus, this is the name of the taxon. This is a unique identifier.  `status`      Status of the taxon, either ""accepted"" or ""synonym""  `kingdom`, `phylum`, `class`, `order`, `family`, `genus`, `species`, `subspecies`      Taxonomic rank of the microorganism  `rank`      Text of the taxonomic rank of the microorganism, such as `""species""` or `""genus""`  `ref`      Author(s) and year of related scientific publication. This contains only the first surname and year of the latest authors, e.g. ""Wallis et al. 2006 emend. Smith and Jones 2018"" becomes ""Smith et al., 2018"". This field is directly retrieved from the source specified in the column `source`. Moreover, accents were removed to comply with CRAN that only allows ASCII characters.  `lpsn`      Identifier ('Record number') of the List of Prokaryotic names with Standing in Nomenclature (LPSN). This will be the first/highest LPSN identifier to keep one identifier per row. For example, Acetobacter ascendens has LPSN Record number 7864 and 11011. Only the first is available in the `microorganisms` data set.  `oxygen_tolerance`      Oxygen tolerance, either ""aerobe"", ""anaerobe"", ""anaerobe/microaerophile"", ""facultative anaerobe"", ""likely facultative anaerobe"", or ""microaerophile"". These data were retrieved from BacDive (see Source). Items that contain ""likely"" are missing from BacDive and were extrapolated from other species within the same genus to guess the oxygen tolerance. Currently 73.4% of all ~37 000 bacteria in the data set contain an oxygen tolerance.  `lpsn_parent`      LPSN identifier of the parent taxon  `lpsn_renamed_to`      LPSN identifier of the currently valid taxon  `gbif`      Identifier ('taxonID') of the Global Biodiversity Information Facility (GBIF)  `gbif_parent`      GBIF identifier of the parent taxon  `gbif_renamed_to`      GBIF identifier of the currently valid taxon  `source`      Either ""GBIF"", ""LPSN"", or ""manually added"" (see Source)  `prevalence`      Prevalence of the microorganism according to Bartlett et al. (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ), see `mo_matching_score()` for the full explanation  `snomed`      Systematized Nomenclature of Medicine (SNOMED) code of the microorganism, version of July 1st, 2021 (see Source). Use `mo_snomed()` to retrieve it quickly, see `mo_property()`. Source  Parte, AC et al. (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.  GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.  Reimer, LC et al. (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.  Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)  Grimont et al. (2007). Antigenic Formulae of the Salmonella Serovars, 9th Edition. WHO Collaborating Centre for Reference and Research on Salmonella (WHOCC-SALM).  Bartlett et al. (2022). A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"")```rmicroorganisms``` DescriptionA data set containing the full microbial taxonomy (last updated: December 11th, 2022 ) of five kingdoms from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF). This data set is the backbone of this `AMR` package. MO codes can be looked up using `as.mo()`. DetailsPlease note that entries are only based on the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF) (see below). Since these sources incorporate entries based on (recent) publications in the International Journal of Systematic and Evolutionary Microbiology (IJSEM), it can happen that the year of publication is sometimes later than one might expect.For example, Staphylococcus pettenkoferi was described for the first time in Diagnostic Microbiology and Infectious Disease in 2002 (tools:::Rd_expr_doi(""10.1016/s0732-8893(02)00399-1"") ), but it was not before 2007 that a publication in IJSEM followed (tools:::Rd_expr_doi(""10.1099/ijs.0.64381-0"") ). Consequently, the `AMR` package returns 2007 for `mo_year(""S. pettenkoferi"")`. Included Taxa Included taxonomic data are:  All ~37 000 (sub)species from the kingdoms of Archaea and Bacteria  ~7 900 (sub)species from the kingdom of Fungi. The kingdom of Fungi is a very large taxon with almost 300,000 different (sub)species, of which most are not microbial (but rather macroscopic, like mushrooms). Because of this, not all fungi fit the scope of this package. Only relevant fungi are covered (such as all species of Aspergillus, Candida, Cryptococcus, Histoplasma, Pneumocystis, Saccharomyces and Trichophyton).  ~5 100 (sub)species from the kingdom of Protozoa  ~1 400 (sub)species from 43 other relevant genera from the kingdom of Animalia (such as Strongyloides and Taenia)  All ~9 800 previously accepted names of all included (sub)species (these were taxonomically renamed)  The complete taxonomic tree of all included (sub)species: from kingdom to subspecies  The identifier of the parent taxons  The year and first author of the related scientific publication Manual additions For convenience, some entries were added manually:  ~1 500 entries of Salmonella, such as the city-like serovars and groups A to H  36 species groups (such as the beta-haemolytic Streptococcus groups A to K, coagulase-negative Staphylococcus (CoNS), Mycobacterium tuberculosis complex, etc.), of which the group compositions are stored in the microorganisms.groups data set  1 entry of Blastocystis (B. hominis), although it officially does not exist (Noel et al. 2005, PMID 15634993)  1 entry of Moraxella (M. catarrhalis), which was formally named Branhamella catarrhalis (Catlin, 1970) though this change was never accepted within the field of clinical microbiology  8 other 'undefined' entries (unknown, unknown Gram-negatives, unknown Gram-positives, unknown yeast, unknown fungus, and unknown anaerobic Gram-pos/Gram-neg bacteria)The syntax used to transform the original data to a cleansed format, can be found here: [https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R](https://github.com/msberends/AMR/blob/main/data-raw/reproduction_of_microorganisms.R). Direct download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). About the Records from LPSN (see Source) LPSN is the main source for bacteriological taxonomy of this `AMR` package.The List of Prokaryotic names with Standing in Nomenclature (LPSN) provides comprehensive information on the nomenclature of prokaryotes. LPSN is a free to use service founded by Jean P. Euzeby in 1997 and later on maintained by Aidan C. Parte. Examples```rmicroorganisms``` See Also`as.mo()`, `mo_property()`, microorganisms.groups , microorganisms.codes , intrinsic_resistant",4
AMR,availability.md,"# Check Availability of Columns

```r
availability(tbl, width = NULL)
```

## Arguments

- `tbl`: a data.frame or list
- `width`: number of characters to present the visual availability - the default is filling the width of the console

## Returns

data.frame with column names of `tbl` as row names

## Description

Easy check for data availability of all columns in a data set. This makes it easy to get an idea of which antimicrobial combinations can be used for calculation with e.g. `susceptibility()` and `resistance()`.

## Details

The function returns a data.frame with columns `""resistant""` and `""visual_resistance""`. The values in that columns are calculated with `resistance()`.

## Examples

```r
availability(example_isolates)

if (require(""dplyr"")) {
  example_isolates %>%
    filter(mo == as.mo(""Escherichia coli"")) %>%
    select_if(is.sir) %>%
    availability()
}
```



","['Check Availability of Columns```ravailability(tbl, width = NULL)``` Arguments- `tbl`: a data.frame or list- `width`: number of characters to present the visual availability - the default is filling the width of the console Returnsdata.frame with column names of `tbl` as row names DescriptionEasy check for data availability of all columns in a data set.', 'This makes it easy to get an idea of which antimicrobial combinations can be used for calculation with e.g.', 'DetailsThe function returns a data.frame with columns `""resistant""` and `""visual_resistance""`.', 'The values in that columns are calculated with `resistance()`.', 'Examples```ravailability(example_isolates)if (require(""dplyr"")) {  example_isolates %>%    filter(mo == as.mo(""Escherichia coli"")) %>%    select_if(is.sir) %>%    availability()}```']",1," Check Availability of Columns```ravailability(tbl, width = NULL)``` Arguments- `tbl`: a data.frame or list- `width`: number of characters to present the visual availability - the default is filling the width of the console Returnsdata.frame with column names of `tbl` as row names DescriptionEasy check for data availability of all columns in a data set. This makes it easy to get an idea of which antimicrobial combinations can be used for calculation with e.g. `susceptibility()` and `resistance()`. DetailsThe function returns a data.frame with columns `""resistant""` and `""visual_resistance""`. The values in that columns are calculated with `resistance()`. Examples```ravailability(example_isolates)if (require(""dplyr"")) {  example_isolates %>%    filter(mo == as.mo(""Escherichia coli"")) %>%    select_if(is.sir) %>%    availability()}```",4
AMR,key_antimicrobials.md,"# (Key) Antimicrobials for First Weighted Isolates

```r
key_antimicrobials(
  x = NULL,
  col_mo = NULL,
  universal = c(""ampicillin"", ""amoxicillin/clavulanic acid"", ""cefuroxime"",
    ""piperacillin/tazobactam"", ""ciprofloxacin"", ""trimethoprim/sulfamethoxazole""),
  gram_negative = c(""gentamicin"", ""tobramycin"", ""colistin"", ""cefotaxime"", ""ceftazidime"",
    ""meropenem""),
  gram_positive = c(""vancomycin"", ""teicoplanin"", ""tetracycline"", ""erythromycin"",
    ""oxacillin"", ""rifampin""),
  antifungal = c(""anidulafungin"", ""caspofungin"", ""fluconazole"", ""miconazole"", ""nystatin"",
    ""voriconazole""),
  only_sir_columns = FALSE,
  ...
)

all_antimicrobials(x = NULL, only_sir_columns = FALSE, ...)

antimicrobials_equal(
  y,
  z,
  type = c(""points"", ""keyantimicrobials""),
  ignore_I = TRUE,
  points_threshold = 2,
  ...
)
```

## Arguments

- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`. Can be left blank to determine automatically
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `universal`: names of broad-spectrum antimicrobial drugs, case-insensitive. Set to `NULL` to ignore. See **Details** for the default antimicrobial drugs
- `gram_negative`: names of antibiotic drugs for Gram-positives , case-insensitive. Set to `NULL` to ignore. See **Details** for the default antibiotic drugs
- `gram_positive`: names of antibiotic drugs for Gram-negatives , case-insensitive. Set to `NULL` to ignore. See **Details** for the default antibiotic drugs
- `antifungal`: names of antifungal drugs for fungi , case-insensitive. Set to `NULL` to ignore. See **Details** for the default antifungal drugs
- `only_sir_columns`: a logical to indicate whether only columns must be included that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)
- `...`: ignored, only in place to allow future extensions
- `y, z`: character vectors to compare
- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see **Details**
- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see **Details**
- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see **Details**

## Description

These functions can be used to determine first weighted isolates by considering the phenotype for isolate selection (see `first_isolate()`). Using a phenotype-based method to determine first isolates is more reliable than methods that disregard phenotypes.

## Details

The `key_antimicrobials()` and `all_antimicrobials()` functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see **Examples**.

The function `key_antimicrobials()` returns a character vector with 12 antimicrobial results for every isolate. The function `all_antimicrobials()` returns a character vector with all antimicrobial drug results for every isolate. These vectors can then be compared using `antimicrobials_equal()`, to check if two isolates have generally the same antibiogram. Missing and invalid values are replaced with a dot (`"".""`) by `key_antimicrobials()` and ignored by `antimicrobials_equal()`.

Please see the `first_isolate()` function how these important functions enable the 'phenotype-based' method for determination of first isolates.

The default antimicrobial drugs used for all rows (set in `universal`) are:

 * Ampicillin
 * Amoxicillin/clavulanic acid
 * Cefuroxime
 * Ciprofloxacin
 * Piperacillin/tazobactam
 * Trimethoprim/sulfamethoxazole

The default antimicrobial drugs used for Gram-negative bacteria (set in `gram_negative`) are:

 * Cefotaxime
 * Ceftazidime
 * Colistin
 * Gentamicin
 * Meropenem
 * Tobramycin

The default antimicrobial drugs used for Gram-positive bacteria  (set in `gram_positive`) are:


 * Erythromycin
 * Oxacillin
 * Rifampin
 * Teicoplanin
 * Tetracycline
 * Vancomycin

The default antimicrobial drugs used for fungi  (set in `antifungal`) are:


 * Anidulafungin
 * Caspofungin
 * Fluconazole
 * Miconazole
 * Nystatin
 * Voriconazole

## Examples

```r
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.

# output of the `key_antimicrobials()` function could be like this:
strainA <- ""SSSRR.S.R..S""
strainB <- ""SSSIRSSSRSSS""

# those strings can be compared with:
antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"")
# TRUE, because I is ignored (as well as missing values)

antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"", ignore_I = FALSE)
# FALSE, because I is not ignored and so the 4th [character] differs


if (require(""dplyr"")) {
  # set key antibiotics to a new variable
  my_patients <- example_isolates %>%
    mutate(keyab = key_antimicrobials(antifungal = NULL)) %>% # no need to define `x`
    mutate(
      # now calculate first isolates
      first_regular = first_isolate(col_keyantimicrobials = FALSE),
      # and first WEIGHTED isolates
      first_weighted = first_isolate(col_keyantimicrobials = ""keyab"")
    )

  # Check the difference in this data set, 'weighted' results in more isolates:
  sum(my_patients$first_regular, na.rm = TRUE)
  sum(my_patients$first_weighted, na.rm = TRUE)
}
```

## See Also

`first_isolate()`



","['(Key) Antimicrobials for First Weighted Isolates```rkey_antimicrobials(  x = NULL,  col_mo = NULL,  universal = c(""ampicillin"", ""amoxicillin/clavulanic acid"", ""cefuroxime"",    ""piperacillin/tazobactam"", ""ciprofloxacin"", ""trimethoprim/sulfamethoxazole""),  gram_negative = c(""gentamicin"", ""tobramycin"", ""colistin"", ""cefotaxime"", ""ceftazidime"",    ""meropenem""),  gram_positive = c(""vancomycin"", ""teicoplanin"", ""tetracycline"", ""erythromycin"",    ""oxacillin"", ""rifampin""),  antifungal = c(""anidulafungin"", ""caspofungin"", ""fluconazole"", ""miconazole"", ""nystatin"",    ""voriconazole""),  only_sir_columns = FALSE,  ...)all_antimicrobials(x = NULL, only_sir_columns = FALSE, ...)antimicrobials_equal(  y,  z,  type = c(""points"", ""keyantimicrobials""),  ignore_I = TRUE,  points_threshold = 2,  ...)``` Arguments- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`.', 'Can be left blank to determine automatically- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `universal`: names of broad-spectrum antimicrobial drugs, case-insensitive.', 'Set to `NULL` to ignore.', 'See Details for the default antimicrobial drugs- `gram_negative`: names of antibiotic drugs for Gram-positives , case-insensitive.', 'Set to `NULL` to ignore.', 'See Details for the default antibiotic drugs- `gram_positive`: names of antibiotic drugs for Gram-negatives , case-insensitive.', 'Set to `NULL` to ignore.', 'See Details for the default antibiotic drugs- `antifungal`: names of antifungal drugs for fungi , case-insensitive.', 'Set to `NULL` to ignore.', 'See Details for the default antifungal drugs- `only_sir_columns`: a logical to indicate whether only columns must be included that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `...`: ignored, only in place to allow future extensions- `y, z`: character vectors to compare- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see Details- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see Details- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see Details DescriptionThese functions can be used to determine first weighted isolates by considering the phenotype for isolate selection (see `first_isolate()`).', 'Using a phenotype-based method to determine first isolates is more reliable than methods that disregard phenotypes.', 'DetailsThe `key_antimicrobials()` and `all_antimicrobials()` functions are context-aware.', 'This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.The function `key_antimicrobials()` returns a character vector with 12 antimicrobial results for every isolate.', 'The function `all_antimicrobials()` returns a character vector with all antimicrobial drug results for every isolate.', 'These vectors can then be compared using `antimicrobials_equal()`, to check if two isolates have generally the same antibiogram.', 'Missing and invalid values are replaced with a dot (`"".', '""`) by `key_antimicrobials()` and ignored by `antimicrobials_equal()`.Please see the `first_isolate()` function how these important functions enable the \'phenotype-based\' method for determination of first isolates.The default antimicrobial drugs used for all rows (set in `universal`) are:  Ampicillin  Amoxicillin/clavulanic acid  Cefuroxime  Ciprofloxacin  Piperacillin/tazobactam  Trimethoprim/sulfamethoxazoleThe default antimicrobial drugs used for Gram-negative bacteria (set in `gram_negative`) are:  Cefotaxime  Ceftazidime  Colistin  Gentamicin  Meropenem  TobramycinThe default antimicrobial drugs used for Gram-positive bacteria  (set in `gram_positive`) are:  Erythromycin  Oxacillin  Rifampin  Teicoplanin  Tetracycline  VancomycinThe default antimicrobial drugs used for fungi  (set in `antifungal`) are:  Anidulafungin  Caspofungin  Fluconazole  Miconazole  Nystatin  Voriconazole Examples```r `example_isolates` is a data set available in the AMR package.', 'output of the `key_antimicrobials()` function could be like this:strainA <- ""SSSRR.S.R..S""strainB <- ""SSSIRSSSRSSS"" those strings can be compared with:antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"") TRUE, because I is ignored (as well as missing values)antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"", ignore_I = FALSE) FALSE, because I is not ignored and so the 4th [character] differsif (require(""dplyr"")) {   set key antibiotics to a new variable  my_patients <- example_isolates %>%    mutate(keyab = key_antimicrobials(antifungal = NULL)) %>%  no need to define `x`    mutate(       now calculate first isolates      first_regular = first_isolate(col_keyantimicrobials = FALSE),       and first WEIGHTED isolates      first_weighted = first_isolate(col_keyantimicrobials = ""keyab"")    )   Check the difference in this data set, \'weighted\' results in more isolates:  sum(my_patients$first_regular, na.rm = TRUE)  sum(my_patients$first_weighted, na.rm = TRUE)}``` See Also`first_isolate()`']",1," (Key) Antimicrobials for First Weighted Isolates```rkey_antimicrobials(  x = NULL,  col_mo = NULL,  universal = c(""ampicillin"", ""amoxicillin/clavulanic acid"", ""cefuroxime"",    ""piperacillin/tazobactam"", ""ciprofloxacin"", ""trimethoprim/sulfamethoxazole""),  gram_negative = c(""gentamicin"", ""tobramycin"", ""colistin"", ""cefotaxime"", ""ceftazidime"",    ""meropenem""),  gram_positive = c(""vancomycin"", ""teicoplanin"", ""tetracycline"", ""erythromycin"",    ""oxacillin"", ""rifampin""),  antifungal = c(""anidulafungin"", ""caspofungin"", ""fluconazole"", ""miconazole"", ""nystatin"",    ""voriconazole""),  only_sir_columns = FALSE,  ...)all_antimicrobials(x = NULL, only_sir_columns = FALSE, ...)antimicrobials_equal(  y,  z,  type = c(""points"", ""keyantimicrobials""),  ignore_I = TRUE,  points_threshold = 2,  ...)``` Arguments- `x`: a data.frame with antibiotics columns, like `AMX` or `amox`. Can be left blank to determine automatically- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `universal`: names of broad-spectrum antimicrobial drugs, case-insensitive. Set to `NULL` to ignore. See Details for the default antimicrobial drugs- `gram_negative`: names of antibiotic drugs for Gram-positives , case-insensitive. Set to `NULL` to ignore. See Details for the default antibiotic drugs- `gram_positive`: names of antibiotic drugs for Gram-negatives , case-insensitive. Set to `NULL` to ignore. See Details for the default antibiotic drugs- `antifungal`: names of antifungal drugs for fungi , case-insensitive. Set to `NULL` to ignore. See Details for the default antifungal drugs- `only_sir_columns`: a logical to indicate whether only columns must be included that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `...`: ignored, only in place to allow future extensions- `y, z`: character vectors to compare- `type`: type to determine weighed isolates; can be `""keyantimicrobials""` or `""points""`, see Details- `ignore_I`: logical to indicate whether antibiotic interpretations with `""I""` will be ignored when `type = ""keyantimicrobials""`, see Details- `points_threshold`: minimum number of points to require before differences in the antibiogram will lead to inclusion of an isolate when `type = ""points""`, see Details DescriptionThese functions can be used to determine first weighted isolates by considering the phenotype for isolate selection (see `first_isolate()`). Using a phenotype-based method to determine first isolates is more reliable than methods that disregard phenotypes. DetailsThe `key_antimicrobials()` and `all_antimicrobials()` functions are context-aware. This means that the `x` argument can be left blank if used inside a data.frame call, see Examples.The function `key_antimicrobials()` returns a character vector with 12 antimicrobial results for every isolate. The function `all_antimicrobials()` returns a character vector with all antimicrobial drug results for every isolate. These vectors can then be compared using `antimicrobials_equal()`, to check if two isolates have generally the same antibiogram. Missing and invalid values are replaced with a dot (`"".""`) by `key_antimicrobials()` and ignored by `antimicrobials_equal()`.Please see the `first_isolate()` function how these important functions enable the 'phenotype-based' method for determination of first isolates.The default antimicrobial drugs used for all rows (set in `universal`) are:  Ampicillin  Amoxicillin/clavulanic acid  Cefuroxime  Ciprofloxacin  Piperacillin/tazobactam  Trimethoprim/sulfamethoxazoleThe default antimicrobial drugs used for Gram-negative bacteria (set in `gram_negative`) are:  Cefotaxime  Ceftazidime  Colistin  Gentamicin  Meropenem  TobramycinThe default antimicrobial drugs used for Gram-positive bacteria  (set in `gram_positive`) are:  Erythromycin  Oxacillin  Rifampin  Teicoplanin  Tetracycline  VancomycinThe default antimicrobial drugs used for fungi  (set in `antifungal`) are:  Anidulafungin  Caspofungin  Fluconazole  Miconazole  Nystatin  Voriconazole Examples```r `example_isolates` is a data set available in the AMR package. See ?example_isolates. output of the `key_antimicrobials()` function could be like this:strainA <- ""SSSRR.S.R..S""strainB <- ""SSSIRSSSRSSS"" those strings can be compared with:antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"") TRUE, because I is ignored (as well as missing values)antimicrobials_equal(strainA, strainB, type = ""keyantimicrobials"", ignore_I = FALSE) FALSE, because I is not ignored and so the 4th [character] differsif (require(""dplyr"")) {   set key antibiotics to a new variable  my_patients <- example_isolates %>%    mutate(keyab = key_antimicrobials(antifungal = NULL)) %>%  no need to define `x`    mutate(       now calculate first isolates      first_regular = first_isolate(col_keyantimicrobials = FALSE),       and first WEIGHTED isolates      first_weighted = first_isolate(col_keyantimicrobials = ""keyab"")    )   Check the difference in this data set, 'weighted' results in more isolates:  sum(my_patients$first_regular, na.rm = TRUE)  sum(my_patients$first_weighted, na.rm = TRUE)}``` See Also`first_isolate()`",4
AMR,example_isolates_unclean.md," data

# Data Set with Unclean Data

## Format

A tibble with 3 000 observations and 8 variables:

 * `patient_id`
   
   ID of the patient
 * `date`
   
   date of receipt at the laboratory
 * `hospital`
   
   ID of the hospital, from A to C
 * `bacteria`
   
   info about microorganism that can be transformed with `as.mo()`, see also microorganisms
 * `AMX:GEN`
   
   4 different antibiotics that have to be transformed with `as.sir()`

```r
example_isolates_unclean
```

## Description

A data set containing 3 000 microbial isolates that are not cleaned up and consequently not ready for AMR data analysis. This data set can be used for practice.

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
example_isolates_unclean
```



","['data Data Set with Unclean Data FormatA tibble with 3 000 observations and 8 variables:  `patient_id`      ID of the patient  `date`      date of receipt at the laboratory  `hospital`      ID of the hospital, from A to C  `bacteria`      info about microorganism that can be transformed with `as.mo()`, see also microorganisms  `AMX:GEN`      4 different antibiotics that have to be transformed with `as.sir()````rexample_isolates_unclean``` DescriptionA data set containing 3 000 microbial isolates that are not cleaned up and consequently not ready for AMR data analysis.', 'This data set can be used for practice.', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).']",1," data Data Set with Unclean Data FormatA tibble with 3 000 observations and 8 variables:  `patient_id`      ID of the patient  `date`      date of receipt at the laboratory  `hospital`      ID of the hospital, from A to C  `bacteria`      info about microorganism that can be transformed with `as.mo()`, see also microorganisms  `AMX:GEN`      4 different antibiotics that have to be transformed with `as.sir()````rexample_isolates_unclean``` DescriptionA data set containing 3 000 microbial isolates that are not cleaned up and consequently not ready for AMR data analysis. This data set can be used for practice. DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rexample_isolates_unclean```",4
AMR,age_groups.md,"# Split Ages into Age Groups

```r
age_groups(x, split_at = c(12, 25, 55, 75), na.rm = FALSE)
```

## Arguments

- `x`: age, e.g. calculated with `age()`
- `split_at`: values to split `x` at - the default is age groups 0-11, 12-24, 25-54, 55-74 and 75+. See **Details**.
- `na.rm`: a logical to indicate whether missing values should be removed

## Returns

Ordered factor

## Description

Split ages into age groups defined by the `split` argument. This allows for easier demographic (antimicrobial resistance) analysis.

## Details

To split ages, the input for the `split_at` argument can be:

 * A numeric vector. A value of e.g. `c(10, 20)` will split `x` on 0-9, 10-19 and 20+. A value of only `50` will split `x` on 0-49 and 50+. The default is to split on young children (0-11), youth (12-24), young adults (25-54), middle-aged adults (55-74) and elderly (75+).
 * A character:
   
    * `""children""` or `""kids""`, equivalent of: `c(0, 1, 2, 4, 6, 13, 18)`. This will split on 0, 1, 2-3, 4-5, 6-12, 13-17 and 18+.
    * `""elderly""` or `""seniors""`, equivalent of: `c(65, 75, 85)`. This will split on 0-64, 65-74, 75-84, 85+.
    * `""fives""`, equivalent of: `1:20 * 5`. This will split on 0-4, 5-9, ..., 95-99, 100+.
    * `""tens""`, equivalent of: `1:10 * 10`. This will split on 0-9, 10-19, ..., 90-99, 100+.

## Examples

```r
ages <- c(3, 8, 16, 54, 31, 76, 101, 43, 21)

# split into 0-49 and 50+
age_groups(ages, 50)

# split into 0-19, 20-49 and 50+
age_groups(ages, c(20, 50))

# split into groups of ten years
age_groups(ages, 1:10 * 10)
age_groups(ages, split_at = ""tens"")

# split into groups of five years
age_groups(ages, 1:20 * 5)
age_groups(ages, split_at = ""fives"")

# split specifically for children
age_groups(ages, c(1, 2, 4, 6, 13, 18))
age_groups(ages, ""children"")


# resistance of ciprofloxacin per age group
if (require(""dplyr"") && require(""ggplot2"")) {
  example_isolates %>%
    filter_first_isolate() %>%
    filter(mo == as.mo(""Escherichia coli"")) %>%
    group_by(age_group = age_groups(age)) %>%
    select(age_group, CIP) %>%
    ggplot_sir(
      x = ""age_group"",
      minimum = 0,
      x.title = ""Age Group"",
      title = ""Ciprofloxacin resistance per age group""
    )
}
```

## See Also

To determine ages, based on one or more reference dates, use the `age()` function.



","['Split Ages into Age Groups```rage_groups(x, split_at = c(12, 25, 55, 75), na.rm = FALSE)``` Arguments- `x`: age, e.g.', 'calculated with `age()`- `split_at`: values to split `x` at - the default is age groups 0-11, 12-24, 25-54, 55-74 and 75+.', 'See Details.- `na.rm`: a logical to indicate whether missing values should be removed ReturnsOrdered factor DescriptionSplit ages into age groups defined by the `split` argument.', 'This allows for easier demographic (antimicrobial resistance) analysis.', 'DetailsTo split ages, the input for the `split_at` argument can be:  A numeric vector.', '`c(10, 20)` will split `x` on 0-9, 10-19 and 20+.', 'A value of only `50` will split `x` on 0-49 and 50+.', 'The default is to split on young children (0-11), youth (12-24), young adults (25-54), middle-aged adults (55-74) and elderly (75+).', 'A character:        `""children""` or `""kids""`, equivalent of: `c(0, 1, 2, 4, 6, 13, 18)`.', 'This will split on 0, 1, 2-3, 4-5, 6-12, 13-17 and 18+.', '`""elderly""` or `""seniors""`, equivalent of: `c(65, 75, 85)`.', 'This will split on 0-64, 65-74, 75-84, 85+.', '`""fives""`, equivalent of: `1:20  5`.', 'This will split on 0-4, 5-9, ..., 95-99, 100+.', '`""tens""`, equivalent of: `1:10  10`.', 'This will split on 0-9, 10-19, ..., 90-99, 100+.', 'Examples```rages <- c(3, 8, 16, 54, 31, 76, 101, 43, 21) split into 0-49 and 50+age_groups(ages, 50) split into 0-19, 20-49 and 50+age_groups(ages, c(20, 50)) split into groups of ten yearsage_groups(ages, 1:10  10)age_groups(ages, split_at = ""tens"") split into groups of five yearsage_groups(ages, 1:20  5)age_groups(ages, split_at = ""fives"") split specifically for childrenage_groups(ages, c(1, 2, 4, 6, 13, 18))age_groups(ages, ""children"") resistance of ciprofloxacin per age groupif (require(""dplyr"") && require(""ggplot2"")) {  example_isolates %>%    filter_first_isolate() %>%    filter(mo == as.mo(""Escherichia coli"")) %>%    group_by(age_group = age_groups(age)) %>%    select(age_group, CIP) %>%    ggplot_sir(      x = ""age_group"",      minimum = 0,      x.title = ""Age Group"",      title = ""Ciprofloxacin resistance per age group""    )}``` See AlsoTo determine ages, based on one or more reference dates, use the `age()` function.']",1," Split Ages into Age Groups```rage_groups(x, split_at = c(12, 25, 55, 75), na.rm = FALSE)``` Arguments- `x`: age, e.g. calculated with `age()`- `split_at`: values to split `x` at - the default is age groups 0-11, 12-24, 25-54, 55-74 and 75+. See Details.- `na.rm`: a logical to indicate whether missing values should be removed ReturnsOrdered factor DescriptionSplit ages into age groups defined by the `split` argument. This allows for easier demographic (antimicrobial resistance) analysis. DetailsTo split ages, the input for the `split_at` argument can be:  A numeric vector. A value of e.g. `c(10, 20)` will split `x` on 0-9, 10-19 and 20+. A value of only `50` will split `x` on 0-49 and 50+. The default is to split on young children (0-11), youth (12-24), young adults (25-54), middle-aged adults (55-74) and elderly (75+).  A character:        `""children""` or `""kids""`, equivalent of: `c(0, 1, 2, 4, 6, 13, 18)`. This will split on 0, 1, 2-3, 4-5, 6-12, 13-17 and 18+.     `""elderly""` or `""seniors""`, equivalent of: `c(65, 75, 85)`. This will split on 0-64, 65-74, 75-84, 85+.     `""fives""`, equivalent of: `1:20  5`. This will split on 0-4, 5-9, ..., 95-99, 100+.     `""tens""`, equivalent of: `1:10  10`. This will split on 0-9, 10-19, ..., 90-99, 100+. Examples```rages <- c(3, 8, 16, 54, 31, 76, 101, 43, 21) split into 0-49 and 50+age_groups(ages, 50) split into 0-19, 20-49 and 50+age_groups(ages, c(20, 50)) split into groups of ten yearsage_groups(ages, 1:10  10)age_groups(ages, split_at = ""tens"") split into groups of five yearsage_groups(ages, 1:20  5)age_groups(ages, split_at = ""fives"") split specifically for childrenage_groups(ages, c(1, 2, 4, 6, 13, 18))age_groups(ages, ""children"") resistance of ciprofloxacin per age groupif (require(""dplyr"") && require(""ggplot2"")) {  example_isolates %>%    filter_first_isolate() %>%    filter(mo == as.mo(""Escherichia coli"")) %>%    group_by(age_group = age_groups(age)) %>%    select(age_group, CIP) %>%    ggplot_sir(      x = ""age_group"",      minimum = 0,      x.title = ""Age Group"",      title = ""Ciprofloxacin resistance per age group""    )}``` See AlsoTo determine ages, based on one or more reference dates, use the `age()` function.",5
AMR,plot.md,"# Plotting for Classes `sir`, `mic` and `disk`

```r
## S3 method for class 'mic'
plot(
  x,
  mo = NULL,
  ab = NULL,
  guideline = ""EUCAST"",
  main = deparse(substitute(x)),
  ylab = translate_AMR(""Frequency"", language = language),
  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),
  colours_SIR = c(""#3CAEA3"", ""#F6D55C"", ""#ED553B""),
  language = get_AMR_locale(),
  expand = TRUE,
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'mic'
autoplot(
  object,
  mo = NULL,
  ab = NULL,
  guideline = ""EUCAST"",
  title = deparse(substitute(object)),
  ylab = translate_AMR(""Frequency"", language = language),
  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),
  colours_SIR = c(""#3CAEA3"", ""#F6D55C"", ""#ED553B""),
  language = get_AMR_locale(),
  expand = TRUE,
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'mic'
fortify(object, ...)

## S3 method for class 'disk'
plot(
  x,
  main = deparse(substitute(x)),
  ylab = translate_AMR(""Frequency"", language = language),
  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),
  mo = NULL,
  ab = NULL,
  guideline = ""EUCAST"",
  colours_SIR = c(""#3CAEA3"", ""#F6D55C"", ""#ED553B""),
  language = get_AMR_locale(),
  expand = TRUE,
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'disk'
autoplot(
  object,
  mo = NULL,
  ab = NULL,
  title = deparse(substitute(object)),
  ylab = translate_AMR(""Frequency"", language = language),
  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),
  guideline = ""EUCAST"",
  colours_SIR = c(""#3CAEA3"", ""#F6D55C"", ""#ED553B""),
  language = get_AMR_locale(),
  expand = TRUE,
  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),
  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),
  ...
)

## S3 method for class 'disk'
fortify(object, ...)

## S3 method for class 'sir'
plot(
  x,
  ylab = translate_AMR(""Percentage"", language = language),
  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),
  main = deparse(substitute(x)),
  language = get_AMR_locale(),
  ...
)

## S3 method for class 'sir'
autoplot(
  object,
  title = deparse(substitute(object)),
  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),
  ylab = translate_AMR(""Frequency"", language = language),
  colours_SIR = c(""#3CAEA3"", ""#F6D55C"", ""#ED553B""),
  language = get_AMR_locale(),
  ...
)

## S3 method for class 'sir'
fortify(object, ...)
```

## Arguments

- `x, object`: values created with `as.mic()`, `as.disk()` or `as.sir()` (or their `random_*` variants, such as `random_mic()`)
- `mo`: any (vector of) text that can be coerced to a valid microorganism code with `as.mo()`
- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`
- `guideline`: interpretation guideline to use - the default is the latest included EUCAST guideline, see **Details**
- `main, title`: title of the plot
- `xlab, ylab`: axis title
- `colours_SIR`: colours to use for filling in the bars, must be a vector of three values (in the order S, I and R). The default colours are colour-blind friendly.
- `language`: language to be used to translate 'Susceptible', 'Increased exposure'/'Intermediate' and 'Resistant' - the default is system language (see `get_AMR_locale()`) and can be overwritten by setting the package option `AMR_locale`, e.g. `options(AMR_locale = ""de"")`, see translate . Use `language = NULL` or `language = """"` to prevent translation.
- `expand`: a logical to indicate whether the range on the x axis should be expanded between the lowest and highest value. For MIC values, intermediate values will be factors of 2 starting from the highest MIC value. For disk diameters, the whole diameter range will be filled.
- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`. Can also be set with the package option `AMR_include_PKPD`.
- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"". ECOFF stands for Epidemiological Cut-Off values. The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.
- `...`: arguments passed on to methods

## Returns

The `autoplot()` functions return a `ggplot` model that is extendible with any `ggplot2` function.

The `fortify()` functions return a data.frame as an extension for usage in the `ggplot2::ggplot()` function.

## Description

Functions to plot classes `sir`, `mic` and `disk`, with support for base and `ggplot2`.

## Details

The interpretation of ""I"" will be named ""Increased exposure"" for all EUCAST guidelines since 2019, and will be named ""Intermediate"" in all other cases.

For interpreting MIC values as well as disk diffusion diameters, supported guidelines to be used as input for the `guideline` argument are: ""EUCAST 2023"", ""EUCAST 2022"", ""EUCAST 2021"", ""EUCAST 2020"", ""EUCAST 2019"", ""EUCAST 2018"", ""EUCAST 2017"", ""EUCAST 2016"", ""EUCAST 2015"", ""EUCAST 2014"", ""EUCAST 2013"", ""EUCAST 2012"", ""EUCAST 2011"", ""CLSI 2023"", ""CLSI 2022"", ""CLSI 2021"", ""CLSI 2020"", ""CLSI 2019"", ""CLSI 2018"", ""CLSI 2017"", ""CLSI 2016"", ""CLSI 2015"", ""CLSI 2014"", ""CLSI 2013"", ""CLSI 2012"", and ""CLSI 2011"".

Simply using `""CLSI""` or `""EUCAST""` as input will automatically select the latest version of that guideline.

## Examples

```r
some_mic_values <- random_mic(size = 100)
some_disk_values <- random_disk(size = 100, mo = ""Escherichia coli"", ab = ""cipro"")
some_sir_values <- random_sir(50, prob_SIR = c(0.55, 0.05, 0.30))

plot(some_mic_values)
plot(some_disk_values)
plot(some_sir_values)

# when providing the microorganism and antibiotic, colours will show interpretations:
plot(some_mic_values, mo = ""S. aureus"", ab = ""ampicillin"")
plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")
plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"", language = ""nl"")


if (require(""ggplot2"")) {
  autoplot(some_mic_values)
}
if (require(""ggplot2"")) {
  autoplot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")
}
if (require(""ggplot2"")) {
  autoplot(some_sir_values)
}
```



","['Plotting for Classes `sir`, `mic` and `disk````r S3 method for class \'mic\'plot(  x,  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  main = deparse(substitute(x)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'mic\'autoplot(  object,  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  title = deparse(substitute(object)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'mic\'fortify(object, ...) S3 method for class \'disk\'plot(  x,  main = deparse(substitute(x)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'disk\'autoplot(  object,  mo = NULL,  ab = NULL,  title = deparse(substitute(object)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),  guideline = ""EUCAST"",  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class \'disk\'fortify(object, ...) S3 method for class \'sir\'plot(  x,  ylab = translate_AMR(""Percentage"", language = language),  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),  main = deparse(substitute(x)),  language = get_AMR_locale(),  ...) S3 method for class \'sir\'autoplot(  object,  title = deparse(substitute(object)),  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),  ylab = translate_AMR(""Frequency"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  ...) S3 method for class \'sir\'fortify(object, ...)``` Arguments- `x, object`: values created with `as.mic()`, `as.disk()` or `as.sir()` (or their `random_` variants, such as `random_mic()`)- `mo`: any (vector of) text that can be coerced to a valid microorganism code with `as.mo()`- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`- `guideline`: interpretation guideline to use - the default is the latest included EUCAST guideline, see Details- `main, title`: title of the plot- `xlab, ylab`: axis title- `colours_SIR`: colours to use for filling in the bars, must be a vector of three values (in the order S, I and R).', ""The default colours are colour-blind friendly.- `language`: language to be used to translate 'Susceptible', 'Increased exposure'/'Intermediate' and 'Resistant' - the default is system language (see `get_AMR_locale()`) and can be overwritten by setting the package option `AMR_locale`, e.g."", '`options(AMR_locale = ""de"")`, see translate .', 'Use `language = NULL` or `language = """"` to prevent translation.- `expand`: a logical to indicate whether the range on the x axis should be expanded between the lowest and highest value.', 'For MIC values, intermediate values will be factors of 2 starting from the highest MIC value.', 'For disk diameters, the whole diameter range will be filled.- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`.', 'Can also be set with the package option `AMR_include_PKPD`.- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"".', 'ECOFF stands for Epidemiological Cut-Off values.', 'The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.- `...`: arguments passed on to methods ReturnsThe `autoplot()` functions return a `ggplot` model that is extendible with any `ggplot2` function.The `fortify()` functions return a data.frame as an extension for usage in the `ggplot2::ggplot()` function.', 'DescriptionFunctions to plot classes `sir`, `mic` and `disk`, with support for base and `ggplot2`.', 'DetailsThe interpretation of ""I"" will be named ""Increased exposure"" for all EUCAST guidelines since 2019, and will be named ""Intermediate"" in all other cases.For interpreting MIC values as well as disk diffusion diameters, supported guidelines to be used as input for the `guideline` argument are: ""EUCAST 2023"", ""EUCAST 2022"", ""EUCAST 2021"", ""EUCAST 2020"", ""EUCAST 2019"", ""EUCAST 2018"", ""EUCAST 2017"", ""EUCAST 2016"", ""EUCAST 2015"", ""EUCAST 2014"", ""EUCAST 2013"", ""EUCAST 2012"", ""EUCAST 2011"", ""CLSI 2023"", ""CLSI 2022"", ""CLSI 2021"", ""CLSI 2020"", ""CLSI 2019"", ""CLSI 2018"", ""CLSI 2017"", ""CLSI 2016"", ""CLSI 2015"", ""CLSI 2014"", ""CLSI 2013"", ""CLSI 2012"", and ""CLSI 2011"".Simply using `""CLSI""` or `""EUCAST""` as input will automatically select the latest version of that guideline.', 'Examples```rsome_mic_values <- random_mic(size = 100)some_disk_values <- random_disk(size = 100, mo = ""Escherichia coli"", ab = ""cipro"")some_sir_values <- random_sir(50, prob_SIR = c(0.55, 0.05, 0.30))plot(some_mic_values)plot(some_disk_values)plot(some_sir_values) when providing the microorganism and antibiotic, colours will show interpretations:plot(some_mic_values, mo = ""S. aureus"", ab = ""ampicillin"")plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"", language = ""nl"")if (require(""ggplot2"")) {  autoplot(some_mic_values)}if (require(""ggplot2"")) {  autoplot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")}if (require(""ggplot2"")) {  autoplot(some_sir_values)}```']",1," Plotting for Classes `sir`, `mic` and `disk````r S3 method for class 'mic'plot(  x,  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  main = deparse(substitute(x)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'mic'autoplot(  object,  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  title = deparse(substitute(object)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Minimum Inhibitory Concentration (mg/L)"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'mic'fortify(object, ...) S3 method for class 'disk'plot(  x,  main = deparse(substitute(x)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),  mo = NULL,  ab = NULL,  guideline = ""EUCAST"",  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'disk'autoplot(  object,  mo = NULL,  ab = NULL,  title = deparse(substitute(object)),  ylab = translate_AMR(""Frequency"", language = language),  xlab = translate_AMR(""Disk diffusion diameter (mm)"", language = language),  guideline = ""EUCAST"",  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  expand = TRUE,  include_PKPD = getOption(""AMR_include_PKPD"", TRUE),  breakpoint_type = getOption(""AMR_breakpoint_type"", ""human""),  ...) S3 method for class 'disk'fortify(object, ...) S3 method for class 'sir'plot(  x,  ylab = translate_AMR(""Percentage"", language = language),  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),  main = deparse(substitute(x)),  language = get_AMR_locale(),  ...) S3 method for class 'sir'autoplot(  object,  title = deparse(substitute(object)),  xlab = translate_AMR(""Antimicrobial Interpretation"", language = language),  ylab = translate_AMR(""Frequency"", language = language),  colours_SIR = c(""3CAEA3"", ""F6D55C"", ""ED553B""),  language = get_AMR_locale(),  ...) S3 method for class 'sir'fortify(object, ...)``` Arguments- `x, object`: values created with `as.mic()`, `as.disk()` or `as.sir()` (or their `random_` variants, such as `random_mic()`)- `mo`: any (vector of) text that can be coerced to a valid microorganism code with `as.mo()`- `ab`: any (vector of) text that can be coerced to a valid antimicrobial drug code with `as.ab()`- `guideline`: interpretation guideline to use - the default is the latest included EUCAST guideline, see Details- `main, title`: title of the plot- `xlab, ylab`: axis title- `colours_SIR`: colours to use for filling in the bars, must be a vector of three values (in the order S, I and R). The default colours are colour-blind friendly.- `language`: language to be used to translate 'Susceptible', 'Increased exposure'/'Intermediate' and 'Resistant' - the default is system language (see `get_AMR_locale()`) and can be overwritten by setting the package option `AMR_locale`, e.g. `options(AMR_locale = ""de"")`, see translate . Use `language = NULL` or `language = """"` to prevent translation.- `expand`: a logical to indicate whether the range on the x axis should be expanded between the lowest and highest value. For MIC values, intermediate values will be factors of 2 starting from the highest MIC value. For disk diameters, the whole diameter range will be filled.- `include_PKPD`: a logical to indicate that PK/PD clinical breakpoints must be applied as a last resort - the default is `TRUE`. Can also be set with the package option `AMR_include_PKPD`.- `breakpoint_type`: the type of breakpoints to use, either ""ECOFF"", ""animal"", or ""human"". ECOFF stands for Epidemiological Cut-Off values. The default is `""human""`, which can also be set with the package option `AMR_breakpoint_type`.- `...`: arguments passed on to methods ReturnsThe `autoplot()` functions return a `ggplot` model that is extendible with any `ggplot2` function.The `fortify()` functions return a data.frame as an extension for usage in the `ggplot2::ggplot()` function. DescriptionFunctions to plot classes `sir`, `mic` and `disk`, with support for base and `ggplot2`. DetailsThe interpretation of ""I"" will be named ""Increased exposure"" for all EUCAST guidelines since 2019, and will be named ""Intermediate"" in all other cases.For interpreting MIC values as well as disk diffusion diameters, supported guidelines to be used as input for the `guideline` argument are: ""EUCAST 2023"", ""EUCAST 2022"", ""EUCAST 2021"", ""EUCAST 2020"", ""EUCAST 2019"", ""EUCAST 2018"", ""EUCAST 2017"", ""EUCAST 2016"", ""EUCAST 2015"", ""EUCAST 2014"", ""EUCAST 2013"", ""EUCAST 2012"", ""EUCAST 2011"", ""CLSI 2023"", ""CLSI 2022"", ""CLSI 2021"", ""CLSI 2020"", ""CLSI 2019"", ""CLSI 2018"", ""CLSI 2017"", ""CLSI 2016"", ""CLSI 2015"", ""CLSI 2014"", ""CLSI 2013"", ""CLSI 2012"", and ""CLSI 2011"".Simply using `""CLSI""` or `""EUCAST""` as input will automatically select the latest version of that guideline. Examples```rsome_mic_values <- random_mic(size = 100)some_disk_values <- random_disk(size = 100, mo = ""Escherichia coli"", ab = ""cipro"")some_sir_values <- random_sir(50, prob_SIR = c(0.55, 0.05, 0.30))plot(some_mic_values)plot(some_disk_values)plot(some_sir_values) when providing the microorganism and antibiotic, colours will show interpretations:plot(some_mic_values, mo = ""S. aureus"", ab = ""ampicillin"")plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")plot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"", language = ""nl"")if (require(""ggplot2"")) {  autoplot(some_mic_values)}if (require(""ggplot2"")) {  autoplot(some_disk_values, mo = ""Escherichia coli"", ab = ""cipro"")}if (require(""ggplot2"")) {  autoplot(some_sir_values)}```",5
AMR,antibiogram.md,"# Generate Antibiogram: Traditional, Combined, Syndromic, or Weighted-Incidence Syndromic Combination (WISCA)

## Source

 * Klinker KP **et al.** (2021). Antimicrobial stewardship and antibiograms: importance of moving beyondtraditional antibiograms . **Therapeutic Advances in Infectious Disease**, May 5;8:20499361211011373; tools:::Rd_expr_doi(""10.1177/20499361211011373"")
 * Barbieri E **et al.** (2021). Development of a Weighted-Incidence Syndromic Combination Antibiogram(WISCA) to guide the choice of the empiric antibiotic treatment forurinary tract infection in paediatric patients: a Bayesian approach **Antimicrobial Resistance & Infection Control** May 1;10(1):74; tools:::Rd_expr_doi(""10.1186/s13756-021-00939-2"")
 * M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, **Clinical and Laboratory Standards Institute (CLSI)**. [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).

```r
antibiogram(
  x,
  antibiotics = where(is.sir),
  mo_transform = ""shortname"",
  ab_transform = NULL,
  syndromic_group = NULL,
  add_total_n = TRUE,
  only_all_tested = FALSE,
  digits = 0,
  col_mo = NULL,
  language = get_AMR_locale(),
  minimum = 30,
  combine_SI = TRUE,
  sep = "" + "",
  info = interactive()
)

## S3 method for class 'antibiogram'
plot(x, ...)

## S3 method for class 'antibiogram'
autoplot(object, ...)

## S3 method for class 'antibiogram'
knit_print(
  x,
  italicise = TRUE,
  na = getOption(""knitr.kable.NA"", default = """"),
  ...
)
```

## Arguments

- `x`: a data.frame containing at least a column with microorganisms and columns with antibiotic results (class 'sir', see `as.sir()`)
- `antibiotics`: vector of any antibiotic name or code (will be evaluated with `as.ab()`, column name of `x`, or (any combinations of) antibiotic selectors such as `aminoglycosides()` or `carbapenems()`. For combination antibiograms, this can also be set to values separated with `""+""`, such as ""TZP+TOB"" or ""cipro + genta"", given that columns resembling such antibiotics exist in `x`. See **Examples**.
- `mo_transform`: a character to transform microorganism input - must be ""name"", ""shortname"", ""gramstain"", or one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"". Can also be `NULL` to not transform the input.
- `ab_transform`: a character to transform antibiotic input - must be one of the column names of the antibiotics data set: ""ab"", ""cid"", ""name"", ""group"", ""atc"", ""atc_group1"", ""atc_group2"", ""abbreviations"", ""synonyms"", ""oral_ddd"", ""oral_units"", ""iv_ddd"", ""iv_units"", or ""loinc"". Can also be `NULL` to not transform the input.
- `syndromic_group`: a column name of `x`, or values calculated to split rows of `x`, e.g. by using `ifelse()` or `case_when()`. See **Examples**.
- `add_total_n`: a logical to indicate whether total available numbers per pathogen should be added to the table (default is `TRUE`). This will add the lowest and highest number of available isolate per antibiotic (e.g, if for **E. coli** 200 isolates are available for ciprofloxacin and 150 for amoxicillin, the returned number will be ""150-200"").
- `only_all_tested`: (for combination antibiograms): a logical to indicate that isolates must be tested for all antibiotics, see **Details**
- `digits`: number of digits to use for rounding
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `language`: language to translate text, which defaults to the system language (see `get_AMR_locale()`)
- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see **Source**.
- `combine_SI`: a logical to indicate whether all susceptibility should be determined by results of either S or I, instead of only S (default is `TRUE`)
- `sep`: a separating character for antibiotic columns in combination antibiograms
- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode
- `...`: when used in R Markdown or Quarto : arguments passed on to `knitr::kable()` (otherwise, has no use)
- `object`: an `antibiogram()` object
- `italicise`: a logical to indicate whether the microorganism names in the knitr table should be made italic, using `italicise_taxonomy()`.
- `na`: character to use for showing `NA` values

## Description

Generate an antibiogram, and communicate the results in plots or tables. These functions follow the logic of Klinker **et al.** and Barbieri **et al.** (see **Source**), and allow reporting in e.g. R Markdown and Quarto as well.

## Details

This function returns a table with values between 0 and 100 for **susceptibility**, not resistance.

Remember that you should filter your data to let it contain only firstisolates! This is needed to exclude duplicates and to reduce selection bias. Use `first_isolate()` to determine them in your data set with one of the four available algorithms.

All types of antibiograms as listed below can be plotted (using `ggplot2::autoplot()` or base `plot()`/`barplot()`). The `antibiogram` object can also be used directly in R Markdown / Quarto (i.e., `knitr`) for reports. In this case, `knitr::kable()` will be applied automatically and microorganism names will even be printed in italics at default (see argument `italicise`). You can also use functions from specific 'table reporting' packages to transform the output of `antibiogram()` to your needs, e.g. with `flextable::as_flextable()` or `gt::gt()`.

### Antibiogram Types

 There are four antibiogram types, as proposed by Klinker **et al.** (2021, tools:::Rd_expr_doi(""10.1177/20499361211011373"") ), and they are all supported by `antibiogram()`:

1. Traditional Antibiogram
   
   Case example: Susceptibility of **Pseudomonas aeruginosa** to piperacillin/tazobactam (TZP)
   
   Code example:
   
    
   
   ```
   antibiogram(your_data,
          antibiotics = ""TZP"")
   ```
2. Combination Antibiogram
   
   Case example: Additional susceptibility of **Pseudomonas aeruginosa** to TZP + tobramycin versus TZP alone
   
   Code example:
   
    
   
   ```
   antibiogram(your_data,
          antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""))
   ```
3. Syndromic Antibiogram
   
   Case example: Susceptibility of **Pseudomonas aeruginosa** to TZP among respiratory specimens (obtained among ICU patients only)
   
   Code example:
   
    
   
   ```
   antibiogram(your_data,
          antibiotics = penicillins(),
          syndromic_group = ""ward"")
   ```
4. Weighted-Incidence Syndromic Combination Antibiogram (WISCA)
   
   Case example: Susceptibility of **Pseudomonas aeruginosa** to TZP among respiratory specimens (obtained among ICU patients only) for male patients age \>=65 years with heart failure
   
   Code example:
   
    
   
   ```
   library(dplyr)
   your_data %\>%
     filter(ward == ""ICU"" & specimen_type == ""Respiratory"") %\>%
     antibiogram(antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),
            syndromic_group = ifelse(.$age \>= 65 &
                                       .$gender == ""Male"" &
                                       .$condition == ""Heart Disease"",
                                     ""Study Group"", ""Control Group""))
   ```

Note that for combination antibiograms, it is important to realise that susceptibility can be calculated in two ways, which can be set with the `only_all_tested` argument (default is `FALSE`). See this example for two antibiotics, Drug A and Drug B, about how `antibiogram()` works to calculate the %SI:

 

```
--------------------------------------------------------------------
               only_all_tested = FALSE  only_all_tested = TRUE
               -----------------------  -----------------------
 Drug A    Drug B   include as  include as   include as  include as
               numerator   denominator  numerator   denominator
--------  --------  ----------  -----------  ----------  -----------
 S or I    S or I       X            X            X            X
   R       S or I       X            X            X            X
  <NA>     S or I       X            X            -            -
 S or I      R          X            X            X            X
   R         R          -            X            -            X
  <NA>       R          -            -            -            -
 S or I     <NA>        X            X            -            -
   R        <NA>        -            -            -            -
  <NA>      <NA>        -            -            -            -
--------------------------------------------------------------------
```

 

## Examples

```r
# example_isolates is a data set available in the AMR package.
# run ?example_isolates for more info.
example_isolates


# Traditional antibiogram ----------------------------------------------

antibiogram(example_isolates,
  antibiotics = c(aminoglycosides(), carbapenems())
)

antibiogram(example_isolates,
  antibiotics = aminoglycosides(),
  ab_transform = ""atc"",
  mo_transform = ""gramstain""
)

antibiogram(example_isolates,
  antibiotics = carbapenems(),
  ab_transform = ""name"",
  mo_transform = ""name""
)


# Combined antibiogram -------------------------------------------------

# combined antibiotics yield higher empiric coverage
antibiogram(example_isolates,
  antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),
  mo_transform = ""gramstain""
)

# names of antibiotics do not need to resemble columns exactly:
antibiogram(example_isolates,
  antibiotics = c(""Cipro"", ""cipro + genta""),
  mo_transform = ""gramstain"",
  ab_transform = ""name"",
  sep = "" & ""
)


# Syndromic antibiogram ------------------------------------------------

# the data set could contain a filter for e.g. respiratory specimens
antibiogram(example_isolates,
  antibiotics = c(aminoglycosides(), carbapenems()),
  syndromic_group = ""ward""
)

# now define a data set with only E. coli
ex1 <- example_isolates[which(mo_genus() == ""Escherichia""), ]

# with a custom language, though this will be determined automatically
# (i.e., this table will be in Spanish on Spanish systems)
antibiogram(ex1,
  antibiotics = aminoglycosides(),
  ab_transform = ""name"",
  syndromic_group = ifelse(ex1$ward == ""ICU"",
    ""UCI"", ""No UCI""
  ),
  language = ""es""
)


# Weighted-incidence syndromic combination antibiogram (WISCA) ---------

# the data set could contain a filter for e.g. respiratory specimens/ICU
antibiogram(example_isolates,
  antibiotics = c(""AMC"", ""AMC+CIP"", ""TZP"", ""TZP+TOB""),
  mo_transform = ""gramstain"",
  minimum = 10, # this should be >=30, but now just as example
  syndromic_group = ifelse(example_isolates$age >= 65 &
    example_isolates$gender == ""M"",
  ""WISCA Group 1"", ""WISCA Group 2""
  )
)


# Print the output for R Markdown / Quarto -----------------------------

ureido <- antibiogram(example_isolates,
  antibiotics = ureidopenicillins(),
  ab_transform = ""name""
)

# in an Rmd file, you would just need to return `ureido` in a chunk,
# but to be explicit here:
if (requireNamespace(""knitr"")) {
  cat(knitr::knit_print(ureido))
}


# Generate plots with ggplot2 or base R --------------------------------

ab1 <- antibiogram(example_isolates,
  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),
  mo_transform = ""gramstain""
)
ab2 <- antibiogram(example_isolates,
  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),
  mo_transform = ""gramstain"",
  syndromic_group = ""ward""
)

if (requireNamespace(""ggplot2"")) {
  ggplot2::autoplot(ab1)
}
if (requireNamespace(""ggplot2"")) {
  ggplot2::autoplot(ab2)
}

plot(ab1)
plot(ab2)
```



","['Generate Antibiogram: Traditional, Combined, Syndromic, or Weighted-Incidence Syndromic Combination (WISCA) Source  Klinker KP et al.', 'Antimicrobial stewardship and antibiograms: importance of moving beyondtraditional antibiograms .', 'Therapeutic Advances in Infectious Disease, May 5;8:20499361211011373; tools:::Rd_expr_doi(""10.1177/20499361211011373"")  Barbieri E et al.', 'Development of a Weighted-Incidence Syndromic Combination Antibiogram(WISCA) to guide the choice of the empiric antibiotic treatment forurinary tract infection in paediatric patients: a Bayesian approach Antimicrobial Resistance & Infection Control May 1;10(1):74; tools:::Rd_expr_doi(""10.1186/s13756-021-00939-2"")  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI).', '[https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).```rantibiogram(  x,  antibiotics = where(is.sir),  mo_transform = ""shortname"",  ab_transform = NULL,  syndromic_group = NULL,  add_total_n = TRUE,  only_all_tested = FALSE,  digits = 0,  col_mo = NULL,  language = get_AMR_locale(),  minimum = 30,  combine_SI = TRUE,  sep = "" + "",  info = interactive()) S3 method for class \'antibiogram\'plot(x, ...) S3 method for class \'antibiogram\'autoplot(object, ...) S3 method for class \'antibiogram\'knit_print(  x,  italicise = TRUE,  na = getOption(""knitr.kable.NA"", default = """"),  ...)``` Arguments- `x`: a data.frame containing at least a column with microorganisms and columns with antibiotic results (class \'sir\', see `as.sir()`)- `antibiotics`: vector of any antibiotic name or code (will be evaluated with `as.ab()`, column name of `x`, or (any combinations of) antibiotic selectors such as `aminoglycosides()` or `carbapenems()`.', 'For combination antibiograms, this can also be set to values separated with `""+""`, such as ""TZP+TOB"" or ""cipro + genta"", given that columns resembling such antibiotics exist in `x`.', 'See Examples.- `mo_transform`: a character to transform microorganism input - must be ""name"", ""shortname"", ""gramstain"", or one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"".', 'Can also be `NULL` to not transform the input.- `ab_transform`: a character to transform antibiotic input - must be one of the column names of the antibiotics data set: ""ab"", ""cid"", ""name"", ""group"", ""atc"", ""atc_group1"", ""atc_group2"", ""abbreviations"", ""synonyms"", ""oral_ddd"", ""oral_units"", ""iv_ddd"", ""iv_units"", or ""loinc"".', 'Can also be `NULL` to not transform the input.- `syndromic_group`: a column name of `x`, or values calculated to split rows of `x`, e.g.', 'by using `ifelse()` or `case_when()`.', 'See Examples.- `add_total_n`: a logical to indicate whether total available numbers per pathogen should be added to the table (default is `TRUE`).', 'This will add the lowest and highest number of available isolate per antibiotic (e.g, if for E. coli 200 isolates are available for ciprofloxacin and 150 for amoxicillin, the returned number will be ""150-200"").- `only_all_tested`: (for combination antibiograms): a logical to indicate that isolates must be tested for all antibiotics, see Details- `digits`: number of digits to use for rounding- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `language`: language to translate text, which defaults to the system language (see `get_AMR_locale()`)- `minimum`: the minimum allowed number of available (tested) isolates.', 'Any isolate count lower than `minimum` will return `NA` with a warning.', 'The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `combine_SI`: a logical to indicate whether all susceptibility should be determined by results of either S or I, instead of only S (default is `TRUE`)- `sep`: a separating character for antibiotic columns in combination antibiograms- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode- `...`: when used in R Markdown or Quarto : arguments passed on to `knitr::kable()` (otherwise, has no use)- `object`: an `antibiogram()` object- `italicise`: a logical to indicate whether the microorganism names in the knitr table should be made italic, using `italicise_taxonomy()`.- `na`: character to use for showing `NA` values DescriptionGenerate an antibiogram, and communicate the results in plots or tables.', 'These functions follow the logic of Klinker et al.', '(see Source), and allow reporting in e.g.', 'R Markdown and Quarto as well.', 'DetailsThis function returns a table with values between 0 and 100 for susceptibility, not resistance.Remember that you should filter your data to let it contain only firstisolates!', 'This is needed to exclude duplicates and to reduce selection bias.', 'Use `first_isolate()` to determine them in your data set with one of the four available algorithms.All types of antibiograms as listed below can be plotted (using `ggplot2::autoplot()` or base `plot()`/`barplot()`).', 'The `antibiogram` object can also be used directly in R Markdown / Quarto (i.e., `knitr`) for reports.', 'In this case, `knitr::kable()` will be applied automatically and microorganism names will even be printed in italics at default (see argument `italicise`).', ""You can also use functions from specific 'table reporting' packages to transform the output of `antibiogram()` to your needs, e.g."", 'Antibiogram Types There are four antibiogram types, as proposed by Klinker et al.', '(2021, tools:::Rd_expr_doi(""10.1177/20499361211011373"") ), and they are all supported by `antibiogram()`:1.', 'Traditional Antibiogram      Case example: Susceptibility of Pseudomonas aeruginosa to piperacillin/tazobactam (TZP)      Code example:             ```   antibiogram(your_data,          antibiotics = ""TZP"")   ```2.', 'Combination Antibiogram      Case example: Additional susceptibility of Pseudomonas aeruginosa to TZP + tobramycin versus TZP alone      Code example:             ```   antibiogram(your_data,          antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""))   ```3.', 'Syndromic Antibiogram      Case example: Susceptibility of Pseudomonas aeruginosa to TZP among respiratory specimens (obtained among ICU patients only)      Code example:             ```   antibiogram(your_data,          antibiotics = penicillins(),          syndromic_group = ""ward"")   ```4.', 'Weighted-Incidence Syndromic Combination Antibiogram (WISCA)      Case example: Susceptibility of Pseudomonas aeruginosa to TZP among respiratory specimens (obtained among ICU patients only) for male patients age \\>=65 years with heart failure      Code example:             ```   library(dplyr)   your_data %\\>%     filter(ward == ""ICU"" & specimen_type == ""Respiratory"") %\\>%     antibiogram(antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),            syndromic_group = ifelse(.$age \\>= 65 &                                       .$gender == ""Male"" &                                       .$condition == ""Heart Disease"",                                     ""Study Group"", ""Control Group""))   ```Note that for combination antibiograms, it is important to realise that susceptibility can be calculated in two ways, which can be set with the `only_all_tested` argument (default is `FALSE`).', 'See this example for two antibiotics, Drug A and Drug B, about how `antibiogram()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------```  Examples```r example_isolates is a data set available in the AMR package.', 'run ?example_isolates for more info.example_isolates Traditional antibiogram ----------------------------------------------antibiogram(example_isolates,  antibiotics = c(aminoglycosides(), carbapenems()))antibiogram(example_isolates,  antibiotics = aminoglycosides(),  ab_transform = ""atc"",  mo_transform = ""gramstain"")antibiogram(example_isolates,  antibiotics = carbapenems(),  ab_transform = ""name"",  mo_transform = ""name"") Combined antibiogram ------------------------------------------------- combined antibiotics yield higher empiric coverageantibiogram(example_isolates,  antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),  mo_transform = ""gramstain"") names of antibiotics do not need to resemble columns exactly:antibiogram(example_isolates,  antibiotics = c(""Cipro"", ""cipro + genta""),  mo_transform = ""gramstain"",  ab_transform = ""name"",  sep = "" & "") Syndromic antibiogram ------------------------------------------------ the data set could contain a filter for e.g.', 'respiratory specimensantibiogram(example_isolates,  antibiotics = c(aminoglycosides(), carbapenems()),  syndromic_group = ""ward"") now define a data set with only E. coliex1 <- example_isolates[which(mo_genus() == ""Escherichia""), ] with a custom language, though this will be determined automatically (i.e., this table will be in Spanish on Spanish systems)antibiogram(ex1,  antibiotics = aminoglycosides(),  ab_transform = ""name"",  syndromic_group = ifelse(ex1$ward == ""ICU"",    ""UCI"", ""No UCI""  ),  language = ""es"") Weighted-incidence syndromic combination antibiogram (WISCA) --------- the data set could contain a filter for e.g.', 'respiratory specimens/ICUantibiogram(example_isolates,  antibiotics = c(""AMC"", ""AMC+CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"",  minimum = 10,  this should be >=30, but now just as example  syndromic_group = ifelse(example_isolates$age >= 65 &    example_isolates$gender == ""M"",  ""WISCA Group 1"", ""WISCA Group 2""  )) Print the output for R Markdown / Quarto -----------------------------ureido <- antibiogram(example_isolates,  antibiotics = ureidopenicillins(),  ab_transform = ""name"") in an Rmd file, you would just need to return `ureido` in a chunk, but to be explicit here:if (requireNamespace(""knitr"")) {  cat(knitr::knit_print(ureido))} Generate plots with ggplot2 or base R --------------------------------ab1 <- antibiogram(example_isolates,  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"")ab2 <- antibiogram(example_isolates,  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"",  syndromic_group = ""ward"")if (requireNamespace(""ggplot2"")) {  ggplot2::autoplot(ab1)}if (requireNamespace(""ggplot2"")) {  ggplot2::autoplot(ab2)}plot(ab1)plot(ab2)```']",1," Generate Antibiogram: Traditional, Combined, Syndromic, or Weighted-Incidence Syndromic Combination (WISCA) Source  Klinker KP et al. (2021). Antimicrobial stewardship and antibiograms: importance of moving beyondtraditional antibiograms . Therapeutic Advances in Infectious Disease, May 5;8:20499361211011373; tools:::Rd_expr_doi(""10.1177/20499361211011373"")  Barbieri E et al. (2021). Development of a Weighted-Incidence Syndromic Combination Antibiogram(WISCA) to guide the choice of the empiric antibiotic treatment forurinary tract infection in paediatric patients: a Bayesian approach Antimicrobial Resistance & Infection Control May 1;10(1):74; tools:::Rd_expr_doi(""10.1186/s13756-021-00939-2"")  M39 Analysis and Presentation of Cumulative AntimicrobialSusceptibility Test Data, 5th Edition , 2022, Clinical and Laboratory Standards Institute (CLSI). [https://clsi.org/standards/products/microbiology/documents/m39/](https://clsi.org/standards/products/microbiology/documents/m39/).```rantibiogram(  x,  antibiotics = where(is.sir),  mo_transform = ""shortname"",  ab_transform = NULL,  syndromic_group = NULL,  add_total_n = TRUE,  only_all_tested = FALSE,  digits = 0,  col_mo = NULL,  language = get_AMR_locale(),  minimum = 30,  combine_SI = TRUE,  sep = "" + "",  info = interactive()) S3 method for class 'antibiogram'plot(x, ...) S3 method for class 'antibiogram'autoplot(object, ...) S3 method for class 'antibiogram'knit_print(  x,  italicise = TRUE,  na = getOption(""knitr.kable.NA"", default = """"),  ...)``` Arguments- `x`: a data.frame containing at least a column with microorganisms and columns with antibiotic results (class 'sir', see `as.sir()`)- `antibiotics`: vector of any antibiotic name or code (will be evaluated with `as.ab()`, column name of `x`, or (any combinations of) antibiotic selectors such as `aminoglycosides()` or `carbapenems()`. For combination antibiograms, this can also be set to values separated with `""+""`, such as ""TZP+TOB"" or ""cipro + genta"", given that columns resembling such antibiotics exist in `x`. See Examples.- `mo_transform`: a character to transform microorganism input - must be ""name"", ""shortname"", ""gramstain"", or one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"". Can also be `NULL` to not transform the input.- `ab_transform`: a character to transform antibiotic input - must be one of the column names of the antibiotics data set: ""ab"", ""cid"", ""name"", ""group"", ""atc"", ""atc_group1"", ""atc_group2"", ""abbreviations"", ""synonyms"", ""oral_ddd"", ""oral_units"", ""iv_ddd"", ""iv_units"", or ""loinc"". Can also be `NULL` to not transform the input.- `syndromic_group`: a column name of `x`, or values calculated to split rows of `x`, e.g. by using `ifelse()` or `case_when()`. See Examples.- `add_total_n`: a logical to indicate whether total available numbers per pathogen should be added to the table (default is `TRUE`). This will add the lowest and highest number of available isolate per antibiotic (e.g, if for E. coli 200 isolates are available for ciprofloxacin and 150 for amoxicillin, the returned number will be ""150-200"").- `only_all_tested`: (for combination antibiograms): a logical to indicate that isolates must be tested for all antibiotics, see Details- `digits`: number of digits to use for rounding- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `language`: language to translate text, which defaults to the system language (see `get_AMR_locale()`)- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `combine_SI`: a logical to indicate whether all susceptibility should be determined by results of either S or I, instead of only S (default is `TRUE`)- `sep`: a separating character for antibiotic columns in combination antibiograms- `info`: a logical to indicate info should be printed - the default is `TRUE` only in interactive mode- `...`: when used in R Markdown or Quarto : arguments passed on to `knitr::kable()` (otherwise, has no use)- `object`: an `antibiogram()` object- `italicise`: a logical to indicate whether the microorganism names in the knitr table should be made italic, using `italicise_taxonomy()`.- `na`: character to use for showing `NA` values DescriptionGenerate an antibiogram, and communicate the results in plots or tables. These functions follow the logic of Klinker et al. and Barbieri et al. (see Source), and allow reporting in e.g. R Markdown and Quarto as well. DetailsThis function returns a table with values between 0 and 100 for susceptibility, not resistance.Remember that you should filter your data to let it contain only firstisolates! This is needed to exclude duplicates and to reduce selection bias. Use `first_isolate()` to determine them in your data set with one of the four available algorithms.All types of antibiograms as listed below can be plotted (using `ggplot2::autoplot()` or base `plot()`/`barplot()`). The `antibiogram` object can also be used directly in R Markdown / Quarto (i.e., `knitr`) for reports. In this case, `knitr::kable()` will be applied automatically and microorganism names will even be printed in italics at default (see argument `italicise`). You can also use functions from specific 'table reporting' packages to transform the output of `antibiogram()` to your needs, e.g. with `flextable::as_flextable()` or `gt::gt()`. Antibiogram Types There are four antibiogram types, as proposed by Klinker et al. (2021, tools:::Rd_expr_doi(""10.1177/20499361211011373"") ), and they are all supported by `antibiogram()`:1. Traditional Antibiogram      Case example: Susceptibility of Pseudomonas aeruginosa to piperacillin/tazobactam (TZP)      Code example:             ```   antibiogram(your_data,          antibiotics = ""TZP"")   ```2. Combination Antibiogram      Case example: Additional susceptibility of Pseudomonas aeruginosa to TZP + tobramycin versus TZP alone      Code example:             ```   antibiogram(your_data,          antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""))   ```3. Syndromic Antibiogram      Case example: Susceptibility of Pseudomonas aeruginosa to TZP among respiratory specimens (obtained among ICU patients only)      Code example:             ```   antibiogram(your_data,          antibiotics = penicillins(),          syndromic_group = ""ward"")   ```4. Weighted-Incidence Syndromic Combination Antibiogram (WISCA)      Case example: Susceptibility of Pseudomonas aeruginosa to TZP among respiratory specimens (obtained among ICU patients only) for male patients age \>=65 years with heart failure      Code example:             ```   library(dplyr)   your_data %\>%     filter(ward == ""ICU"" & specimen_type == ""Respiratory"") %\>%     antibiogram(antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),            syndromic_group = ifelse(.$age \>= 65 &                                       .$gender == ""Male"" &                                       .$condition == ""Heart Disease"",                                     ""Study Group"", ""Control Group""))   ```Note that for combination antibiograms, it is important to realise that susceptibility can be calculated in two ways, which can be set with the `only_all_tested` argument (default is `FALSE`). See this example for two antibiotics, Drug A and Drug B, about how `antibiogram()` works to calculate the %SI: ```--------------------------------------------------------------------               only_all_tested = FALSE  only_all_tested = TRUE               -----------------------  ----------------------- Drug A    Drug B   include as  include as   include as  include as               numerator   denominator  numerator   denominator--------  --------  ----------  -----------  ----------  ----------- S or I    S or I       X            X            X            X   R       S or I       X            X            X            X  <NA>     S or I       X            X            -            - S or I      R          X            X            X            X   R         R          -            X            -            X  <NA>       R          -            -            -            - S or I     <NA>        X            X            -            -   R        <NA>        -            -            -            -  <NA>      <NA>        -            -            -            ---------------------------------------------------------------------```  Examples```r example_isolates is a data set available in the AMR package. run ?example_isolates for more info.example_isolates Traditional antibiogram ----------------------------------------------antibiogram(example_isolates,  antibiotics = c(aminoglycosides(), carbapenems()))antibiogram(example_isolates,  antibiotics = aminoglycosides(),  ab_transform = ""atc"",  mo_transform = ""gramstain"")antibiogram(example_isolates,  antibiotics = carbapenems(),  ab_transform = ""name"",  mo_transform = ""name"") Combined antibiogram ------------------------------------------------- combined antibiotics yield higher empiric coverageantibiogram(example_isolates,  antibiotics = c(""TZP"", ""TZP+TOB"", ""TZP+GEN""),  mo_transform = ""gramstain"") names of antibiotics do not need to resemble columns exactly:antibiogram(example_isolates,  antibiotics = c(""Cipro"", ""cipro + genta""),  mo_transform = ""gramstain"",  ab_transform = ""name"",  sep = "" & "") Syndromic antibiogram ------------------------------------------------ the data set could contain a filter for e.g. respiratory specimensantibiogram(example_isolates,  antibiotics = c(aminoglycosides(), carbapenems()),  syndromic_group = ""ward"") now define a data set with only E. coliex1 <- example_isolates[which(mo_genus() == ""Escherichia""), ] with a custom language, though this will be determined automatically (i.e., this table will be in Spanish on Spanish systems)antibiogram(ex1,  antibiotics = aminoglycosides(),  ab_transform = ""name"",  syndromic_group = ifelse(ex1$ward == ""ICU"",    ""UCI"", ""No UCI""  ),  language = ""es"") Weighted-incidence syndromic combination antibiogram (WISCA) --------- the data set could contain a filter for e.g. respiratory specimens/ICUantibiogram(example_isolates,  antibiotics = c(""AMC"", ""AMC+CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"",  minimum = 10,  this should be >=30, but now just as example  syndromic_group = ifelse(example_isolates$age >= 65 &    example_isolates$gender == ""M"",  ""WISCA Group 1"", ""WISCA Group 2""  )) Print the output for R Markdown / Quarto -----------------------------ureido <- antibiogram(example_isolates,  antibiotics = ureidopenicillins(),  ab_transform = ""name"") in an Rmd file, you would just need to return `ureido` in a chunk, but to be explicit here:if (requireNamespace(""knitr"")) {  cat(knitr::knit_print(ureido))} Generate plots with ggplot2 or base R --------------------------------ab1 <- antibiogram(example_isolates,  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"")ab2 <- antibiogram(example_isolates,  antibiotics = c(""AMC"", ""CIP"", ""TZP"", ""TZP+TOB""),  mo_transform = ""gramstain"",  syndromic_group = ""ward"")if (requireNamespace(""ggplot2"")) {  ggplot2::autoplot(ab1)}if (requireNamespace(""ggplot2"")) {  ggplot2::autoplot(ab2)}plot(ab1)plot(ab2)```",5
AMR,atc_online.md,"# Get ATC Properties from WHOCC Website

## Source

[https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/](https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/)

```r
atc_online_property(
  atc_code,
  property,
  administration = ""O"",
  url = ""https://www.whocc.no/atc_ddd_index/?code=%s&showdescription=no"",
  url_vet = ""https://www.whocc.no/atcvet/atcvet_index/?code=%s&showdescription=no""
)

atc_online_groups(atc_code, ...)

atc_online_ddd(atc_code, ...)

atc_online_ddd_units(atc_code, ...)
```

## Arguments

- `atc_code`: a character (vector) with ATC code(s) of antibiotics, will be coerced with `as.ab()` and `ab_atc()` internally if not a valid ATC code
- `property`: property of an ATC code. Valid values are `""ATC""`, `""Name""`, `""DDD""`, `""U""` (`""unit""`), `""Adm.R""`, `""Note""` and `groups`. For this last option, all hierarchical groups of an ATC code will be returned, see **Examples**.
- `administration`: type of administration when using `property = ""Adm.R""`, see **Details**
- `url`: url of website of the WHOCC. The sign `%s` can be used as a placeholder for ATC codes.
- `url_vet`: url of website of the WHOCC for veterinary medicine. The sign `%s` can be used as a placeholder for ATC_vet codes (that all start with ""Q"").
- `...`: arguments to pass on to `atc_property`

## Description

Gets data from the WHOCC website to determine properties of an Anatomical Therapeutic Chemical (ATC) (e.g. an antibiotic), such as the name, defined daily dose (DDD) or standard unit.

## Details

Options for argument `administration`:

 * `""Implant""` = Implant
 * `""Inhal""` = Inhalation
 * `""Instill""` = Instillation
 * `""N""` = nasal
 * `""O""` = oral
 * `""P""` = parenteral
 * `""R""` = rectal
 * `""SL""` = sublingual/buccal
 * `""TD""` = transdermal
 * `""V""` = vaginal

Abbreviations of return values when using `property = ""U""` (unit):

 * `""g""` = gram
 * `""mg""` = milligram
 * `""mcg""` = microgram
 * `""U""` = unit
 * `""TU""` = thousand units
 * `""MU""` = million units
 * `""mmol""` = millimole
 * `""ml""` = millilitre (e.g. eyedrops)

N.B. This function requires an internet connection and only works ifthe following packages are installed: ‘curl’, ‘rvest’, ‘xml2’. 

## Examples

```r
if (requireNamespace(""curl"") && requireNamespace(""rvest"") && requireNamespace(""xml2"")) {
  # oral DDD (Defined Daily Dose) of amoxicillin
  atc_online_property(""J01CA04"", ""DDD"", ""O"")
  atc_online_ddd(ab_atc(""amox""))

  # parenteral DDD (Defined Daily Dose) of amoxicillin
  atc_online_property(""J01CA04"", ""DDD"", ""P"")

  atc_online_property(""J01CA04"", property = ""groups"") # search hierarchical groups of amoxicillin
}
```



","['Get ATC Properties from WHOCC Website Source[https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/](https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/)```ratc_online_property(  atc_code,  property,  administration = ""O"",  url = ""https://www.whocc.no/atc_ddd_index/?code=%s&showdescription=no"",  url_vet = ""https://www.whocc.no/atcvet/atcvet_index/?code=%s&showdescription=no"")atc_online_groups(atc_code, ...)atc_online_ddd(atc_code, ...)atc_online_ddd_units(atc_code, ...)``` Arguments- `atc_code`: a character (vector) with ATC code(s) of antibiotics, will be coerced with `as.ab()` and `ab_atc()` internally if not a valid ATC code- `property`: property of an ATC code.', 'Valid values are `""ATC""`, `""Name""`, `""DDD""`, `""U""` (`""unit""`), `""Adm.R""`, `""Note""` and `groups`.', 'For this last option, all hierarchical groups of an ATC code will be returned, see Examples.- `administration`: type of administration when using `property = ""Adm.R""`, see Details- `url`: url of website of the WHOCC.', 'The sign `%s` can be used as a placeholder for ATC codes.- `url_vet`: url of website of the WHOCC for veterinary medicine.', 'The sign `%s` can be used as a placeholder for ATC_vet codes (that all start with ""Q"").- `...`: arguments to pass on to `atc_property` DescriptionGets data from the WHOCC website to determine properties of an Anatomical Therapeutic Chemical (ATC) (e.g.', 'an antibiotic), such as the name, defined daily dose (DDD) or standard unit.', 'DetailsOptions for argument `administration`:  `""Implant""` = Implant  `""Inhal""` = Inhalation  `""Instill""` = Instillation  `""N""` = nasal  `""O""` = oral  `""P""` = parenteral  `""R""` = rectal  `""SL""` = sublingual/buccal  `""TD""` = transdermal  `""V""` = vaginalAbbreviations of return values when using `property = ""U""` (unit):  `""g""` = gram  `""mg""` = milligram  `""mcg""` = microgram  `""U""` = unit  `""TU""` = thousand units  `""MU""` = million units  `""mmol""` = millimole  `""ml""` = millilitre (e.g.', 'This function requires an internet connection and only works ifthe following packages are installed: ‘curl’, ‘rvest’, ‘xml2’.', 'Examples```rif (requireNamespace(""curl"") && requireNamespace(""rvest"") && requireNamespace(""xml2"")) {   oral DDD (Defined Daily Dose) of amoxicillin  atc_online_property(""J01CA04"", ""DDD"", ""O"")  atc_online_ddd(ab_atc(""amox""))   parenteral DDD (Defined Daily Dose) of amoxicillin  atc_online_property(""J01CA04"", ""DDD"", ""P"")  atc_online_property(""J01CA04"", property = ""groups"")  search hierarchical groups of amoxicillin}```']",1," Get ATC Properties from WHOCC Website Source[https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/](https://www.whocc.no/atc_ddd_alterations__cumulative/ddd_alterations/abbrevations/)```ratc_online_property(  atc_code,  property,  administration = ""O"",  url = ""https://www.whocc.no/atc_ddd_index/?code=%s&showdescription=no"",  url_vet = ""https://www.whocc.no/atcvet/atcvet_index/?code=%s&showdescription=no"")atc_online_groups(atc_code, ...)atc_online_ddd(atc_code, ...)atc_online_ddd_units(atc_code, ...)``` Arguments- `atc_code`: a character (vector) with ATC code(s) of antibiotics, will be coerced with `as.ab()` and `ab_atc()` internally if not a valid ATC code- `property`: property of an ATC code. Valid values are `""ATC""`, `""Name""`, `""DDD""`, `""U""` (`""unit""`), `""Adm.R""`, `""Note""` and `groups`. For this last option, all hierarchical groups of an ATC code will be returned, see Examples.- `administration`: type of administration when using `property = ""Adm.R""`, see Details- `url`: url of website of the WHOCC. The sign `%s` can be used as a placeholder for ATC codes.- `url_vet`: url of website of the WHOCC for veterinary medicine. The sign `%s` can be used as a placeholder for ATC_vet codes (that all start with ""Q"").- `...`: arguments to pass on to `atc_property` DescriptionGets data from the WHOCC website to determine properties of an Anatomical Therapeutic Chemical (ATC) (e.g. an antibiotic), such as the name, defined daily dose (DDD) or standard unit. DetailsOptions for argument `administration`:  `""Implant""` = Implant  `""Inhal""` = Inhalation  `""Instill""` = Instillation  `""N""` = nasal  `""O""` = oral  `""P""` = parenteral  `""R""` = rectal  `""SL""` = sublingual/buccal  `""TD""` = transdermal  `""V""` = vaginalAbbreviations of return values when using `property = ""U""` (unit):  `""g""` = gram  `""mg""` = milligram  `""mcg""` = microgram  `""U""` = unit  `""TU""` = thousand units  `""MU""` = million units  `""mmol""` = millimole  `""ml""` = millilitre (e.g. eyedrops)N.B. This function requires an internet connection and only works ifthe following packages are installed: ‘curl’, ‘rvest’, ‘xml2’.  Examples```rif (requireNamespace(""curl"") && requireNamespace(""rvest"") && requireNamespace(""xml2"")) {   oral DDD (Defined Daily Dose) of amoxicillin  atc_online_property(""J01CA04"", ""DDD"", ""O"")  atc_online_ddd(ab_atc(""amox""))   parenteral DDD (Defined Daily Dose) of amoxicillin  atc_online_property(""J01CA04"", ""DDD"", ""P"")  atc_online_property(""J01CA04"", property = ""groups"")  search hierarchical groups of amoxicillin}```",5
AMR,age.md,"# Age in Years of Individuals

```r
age(x, reference = Sys.Date(), exact = FALSE, na.rm = FALSE, ...)
```

## Arguments

- `x`: date(s), character (vectors) will be coerced with `as.POSIXlt()`
- `reference`: reference date(s) (default is today), character (vectors) will be coerced with `as.POSIXlt()`
- `exact`: a logical to indicate whether age calculation should be exact, i.e. with decimals. It divides the number of days of [year-to-date](https://en.wikipedia.org/wiki/Year-to-date) (YTD) of `x` by the number of days in the year of `reference` (either 365 or 366).
- `na.rm`: a logical to indicate whether missing values should be removed
- `...`: arguments passed on to `as.POSIXlt()`, such as `origin`

## Returns

An integer (no decimals) if `exact = FALSE`, a double (with decimals) otherwise

## Description

Calculates age in years based on a reference date, which is the system date at default.

## Details

Ages below 0 will be returned as `NA` with a warning. Ages above 120 will only give a warning.

This function vectorises over both `x` and `reference`, meaning that either can have a length of 1 while the other argument has a larger length.

## Examples

```r
# 10 random pre-Y2K birth dates
df <- data.frame(birth_date = as.Date(""2000-01-01"") - runif(10) * 25000)

# add ages
df$age <- age(df$birth_date)

# add exact ages
df$age_exact <- age(df$birth_date, exact = TRUE)

# add age at millenium switch
df$age_at_y2k <- age(df$birth_date, ""2000-01-01"")

df
```

## See Also

To split ages into groups, use the `age_groups()` function.



","['Age in Years of Individuals```rage(x, reference = Sys.Date(), exact = FALSE, na.rm = FALSE, ...)``` Arguments- `x`: date(s), character (vectors) will be coerced with `as.POSIXlt()`- `reference`: reference date(s) (default is today), character (vectors) will be coerced with `as.POSIXlt()`- `exact`: a logical to indicate whether age calculation should be exact, i.e.', 'It divides the number of days of [year-to-date](https://en.wikipedia.org/wiki/Year-to-date) (YTD) of `x` by the number of days in the year of `reference` (either 365 or 366).- `na.rm`: a logical to indicate whether missing values should be removed- `...`: arguments passed on to `as.POSIXlt()`, such as `origin` ReturnsAn integer (no decimals) if `exact = FALSE`, a double (with decimals) otherwise DescriptionCalculates age in years based on a reference date, which is the system date at default.', 'DetailsAges below 0 will be returned as `NA` with a warning.', 'Ages above 120 will only give a warning.This function vectorises over both `x` and `reference`, meaning that either can have a length of 1 while the other argument has a larger length.', 'Examples```r 10 random pre-Y2K birth datesdf <- data.frame(birth_date = as.Date(""2000-01-01"") - runif(10)  25000) add agesdf$age <- age(df$birth_date) add exact agesdf$age_exact <- age(df$birth_date, exact = TRUE) add age at millenium switchdf$age_at_y2k <- age(df$birth_date, ""2000-01-01"")df``` See AlsoTo split ages into groups, use the `age_groups()` function.']",1," Age in Years of Individuals```rage(x, reference = Sys.Date(), exact = FALSE, na.rm = FALSE, ...)``` Arguments- `x`: date(s), character (vectors) will be coerced with `as.POSIXlt()`- `reference`: reference date(s) (default is today), character (vectors) will be coerced with `as.POSIXlt()`- `exact`: a logical to indicate whether age calculation should be exact, i.e. with decimals. It divides the number of days of [year-to-date](https://en.wikipedia.org/wiki/Year-to-date) (YTD) of `x` by the number of days in the year of `reference` (either 365 or 366).- `na.rm`: a logical to indicate whether missing values should be removed- `...`: arguments passed on to `as.POSIXlt()`, such as `origin` ReturnsAn integer (no decimals) if `exact = FALSE`, a double (with decimals) otherwise DescriptionCalculates age in years based on a reference date, which is the system date at default. DetailsAges below 0 will be returned as `NA` with a warning. Ages above 120 will only give a warning.This function vectorises over both `x` and `reference`, meaning that either can have a length of 1 while the other argument has a larger length. Examples```r 10 random pre-Y2K birth datesdf <- data.frame(birth_date = as.Date(""2000-01-01"") - runif(10)  25000) add agesdf$age <- age(df$birth_date) add exact agesdf$age_exact <- age(df$birth_date, exact = TRUE) add age at millenium switchdf$age_at_y2k <- age(df$birth_date, ""2000-01-01"")df``` See AlsoTo split ages into groups, use the `age_groups()` function.",5
AMR,skewness.md,"# Skewness of the Sample

```r
skewness(x, na.rm = FALSE)

## Default S3 method:
skewness(x, na.rm = FALSE)

## S3 method for class 'matrix'
skewness(x, na.rm = FALSE)

## S3 method for class 'data.frame'
skewness(x, na.rm = FALSE)
```

## Arguments

- `x`: a vector of values, a matrix or a data.frame
- `na.rm`: a logical value indicating whether `NA` values should be stripped before the computation proceeds

## Description

Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.

When negative ('left-skewed'): the left tail is longer; the mass of the distribution is concentrated on the right of a histogram. When positive ('right-skewed'): the right tail is longer; the mass of the distribution is concentrated on the left of a histogram. A normal distribution has a skewness of 0.

## Examples

```r
skewness(runif(1000))
```

## See Also

`kurtosis()`



","[""Skewness of the Sample```rskewness(x, na.rm = FALSE) Default S3 method:skewness(x, na.rm = FALSE) S3 method for class 'matrix'skewness(x, na.rm = FALSE) S3 method for class 'data.frame'skewness(x, na.rm = FALSE)``` Arguments- `x`: a vector of values, a matrix or a data.frame- `na.rm`: a logical value indicating whether `NA` values should be stripped before the computation proceeds DescriptionSkewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.When negative ('left-skewed'): the left tail is longer; the mass of the distribution is concentrated on the right of a histogram."", ""When positive ('right-skewed'): the right tail is longer; the mass of the distribution is concentrated on the left of a histogram."", 'A normal distribution has a skewness of 0.']",1," Skewness of the Sample```rskewness(x, na.rm = FALSE) Default S3 method:skewness(x, na.rm = FALSE) S3 method for class 'matrix'skewness(x, na.rm = FALSE) S3 method for class 'data.frame'skewness(x, na.rm = FALSE)``` Arguments- `x`: a vector of values, a matrix or a data.frame- `na.rm`: a logical value indicating whether `NA` values should be stripped before the computation proceeds DescriptionSkewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.When negative ('left-skewed'): the left tail is longer; the mass of the distribution is concentrated on the right of a histogram. When positive ('right-skewed'): the right tail is longer; the mass of the distribution is concentrated on the left of a histogram. A normal distribution has a skewness of 0. Examples```rskewness(runif(1000))``` See Also`kurtosis()`",5
AMR,as.ab.md,"# Transform Input to an Antibiotic ID

```r
as.ab(x, flag_multiple_results = TRUE, info = interactive(), ...)

is.ab(x)
```

## Arguments

- `x`: a character vector to determine to antibiotic ID
- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antibiotic drug code or name can be retrieved from a single input value.
- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode
- `...`: arguments passed on to internal functions

## Returns

A character vector with additional class `ab`

## Description

Use this function to determine the antibiotic drug code of one or more antibiotics. The data set antibiotics will be searched for abbreviations, official names and synonyms (brand names).

## Details

All entries in the antibiotics data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem). The data set contains more than 5,000 official brand names from many different countries, as found in PubChem. Not that some drugs contain multiple ATC codes.

All these properties will be searched for the user input. The `as.ab()` can correct for different forms of misspelling:

 * Wrong spelling of drug names (such as ""tobramicin"" or ""gentamycin""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.
 * Too few or too many vowels or consonants
 * Switching two characters (such as ""mreopenem"", often the case in clinical data, when doctors typed too fast)
 * Digitalised paper records, leaving artefacts like 0/o/O (zero and O's), B/8, n/r, etc.

Use the `ab_*` functions to get properties based on the returned antibiotic ID, see **Examples**.

Note: the `as.ab()` and `ab_*` functions may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems.

You can add your own manual codes to be considered by `as.ab()` and all `ab_*` functions, see `add_custom_antimicrobials()`.

## Source

 World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)

European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)

## WHOCC

 This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).

These have become the gold standard for international drug utilisation monitoring and research.

The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.

NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.)

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# these examples all return ""ERY"", the ID of erythromycin:
as.ab(""J01FA01"")
as.ab(""J 01 FA 01"")
as.ab(""Erythromycin"")
as.ab(""eryt"")
as.ab(""   eryt 123"")
as.ab(""ERYT"")
as.ab(""ERY"")
as.ab(""eritromicine"") # spelled wrong, yet works
as.ab(""Erythrocin"") # trade name
as.ab(""Romycin"") # trade name

# spelling from different languages and dyslexia are no problem
ab_atc(""ceftriaxon"")
ab_atc(""cephtriaxone"") # small spelling error
ab_atc(""cephthriaxone"") # or a bit more severe
ab_atc(""seephthriaaksone"") # and even this works

# use ab_* functions to get a specific properties (see ?ab_property);
# they use as.ab() internally:
ab_name(""J01FA01"")
ab_name(""eryt"")


if (require(""dplyr"")) {
  # you can quickly rename 'sir' columns using set_ab_names() with dplyr:
  example_isolates %>%
    set_ab_names(where(is.sir), property = ""atc"")
}
```

## See Also

 * antibiotics for the data.frame that is being used to determine ATCs
 * `ab_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)



","['Transform Input to an Antibiotic ID```ras.ab(x, flag_multiple_results = TRUE, info = interactive(), ...)is.ab(x)``` Arguments- `x`: a character vector to determine to antibiotic ID- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antibiotic drug code or name can be retrieved from a single input value.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to internal functions ReturnsA character vector with additional class `ab` DescriptionUse this function to determine the antibiotic drug code of one or more antibiotics.', 'The data set antibiotics will be searched for abbreviations, official names and synonyms (brand names).', 'DetailsAll entries in the antibiotics data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem).', 'The data set contains more than 5,000 official brand names from many different countries, as found in PubChem.', 'Not that some drugs contain multiple ATC codes.All these properties will be searched for the user input.', 'The `as.ab()` can correct for different forms of misspelling:  Wrong spelling of drug names (such as ""tobramicin"" or ""gentamycin""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.', 'Too few or too many vowels or consonants  Switching two characters (such as ""mreopenem"", often the case in clinical data, when doctors typed too fast)  Digitalised paper records, leaving artefacts like 0/o/O (zero and O\'s), B/8, n/r, etc.Use the `ab_` functions to get properties based on the returned antibiotic ID, see Examples.Note: the `as.ab()` and `ab_` functions may use very long regular expression to match brand names of antimicrobial drugs.', 'This may fail on some systems.You can add your own manual codes to be considered by `as.ab()` and all `ab_` functions, see `add_custom_antimicrobials()`.', 'Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government.', 'The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r these examples all return ""ERY"", the ID of erythromycin:as.ab(""J01FA01"")as.ab(""J 01 FA 01"")as.ab(""Erythromycin"")as.ab(""eryt"")as.ab(""   eryt 123"")as.ab(""ERYT"")as.ab(""ERY"")as.ab(""eritromicine"")  spelled wrong, yet worksas.ab(""Erythrocin"")  trade nameas.ab(""Romycin"")  trade name spelling from different languages and dyslexia are no problemab_atc(""ceftriaxon"")ab_atc(""cephtriaxone"")  small spelling errorab_atc(""cephthriaxone"")  or a bit more severeab_atc(""seephthriaaksone"")  and even this works use ab_ functions to get a specific properties (see ?ab_property); they use as.ab() internally:ab_name(""J01FA01"")ab_name(""eryt"")if (require(""dplyr"")) {   you can quickly rename \'sir\' columns using set_ab_names() with dplyr:  example_isolates %>%    set_ab_names(where(is.sir), property = ""atc"")}``` See Also  antibiotics for the data.frame that is being used to determine ATCs  `ab_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)']",1," Transform Input to an Antibiotic ID```ras.ab(x, flag_multiple_results = TRUE, info = interactive(), ...)is.ab(x)``` Arguments- `x`: a character vector to determine to antibiotic ID- `flag_multiple_results`: a logical to indicate whether a note should be printed to the console that probably more than one antibiotic drug code or name can be retrieved from a single input value.- `info`: a logical to indicate whether a progress bar should be printed - the default is `TRUE` only in interactive mode- `...`: arguments passed on to internal functions ReturnsA character vector with additional class `ab` DescriptionUse this function to determine the antibiotic drug code of one or more antibiotics. The data set antibiotics will be searched for abbreviations, official names and synonyms (brand names). DetailsAll entries in the antibiotics data set have three different identifiers: a human readable EARS-Net code (column `ab`, used by ECDC and WHONET), an ATC code (column `atc`, used by WHO), and a CID code (column `cid`, Compound ID, used by PubChem). The data set contains more than 5,000 official brand names from many different countries, as found in PubChem. Not that some drugs contain multiple ATC codes.All these properties will be searched for the user input. The `as.ab()` can correct for different forms of misspelling:  Wrong spelling of drug names (such as ""tobramicin"" or ""gentamycin""), which corrects for most audible similarities such as f/ph, x/ks, c/z/s, t/th, etc.  Too few or too many vowels or consonants  Switching two characters (such as ""mreopenem"", often the case in clinical data, when doctors typed too fast)  Digitalised paper records, leaving artefacts like 0/o/O (zero and O's), B/8, n/r, etc.Use the `ab_` functions to get properties based on the returned antibiotic ID, see Examples.Note: the `as.ab()` and `ab_` functions may use very long regular expression to match brand names of antimicrobial drugs. This may fail on some systems.You can add your own manual codes to be considered by `as.ab()` and all `ab_` functions, see `add_custom_antimicrobials()`. Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) WHOCC This package contains all ~550 antibiotic, antimycotic and antiviral drugs and their Anatomical Therapeutic Chemical (ATC) codes, ATC groups and Defined Daily Dose (DDD) from the World Health Organization Collaborating Centre for Drug Statistics Methodology (WHOCC, [https://www.whocc.no](https://www.whocc.no)) and the Pharmaceuticals Community Register of the European Commission ([https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)).These have become the gold standard for international drug utilisation monitoring and research.The WHOCC is located in Oslo at the Norwegian Institute of Public Health and funded by the Norwegian government. The European Commission is the executive of the European Union and promotes its general interest.NOTE: The WHOCC copyright does not allow use for commercial purposes,unlike any other info from this package. See [https://www.whocc.no/copyright_disclaimer/.](https://www.whocc.no/copyright_disclaimer/.) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r these examples all return ""ERY"", the ID of erythromycin:as.ab(""J01FA01"")as.ab(""J 01 FA 01"")as.ab(""Erythromycin"")as.ab(""eryt"")as.ab(""   eryt 123"")as.ab(""ERYT"")as.ab(""ERY"")as.ab(""eritromicine"")  spelled wrong, yet worksas.ab(""Erythrocin"")  trade nameas.ab(""Romycin"")  trade name spelling from different languages and dyslexia are no problemab_atc(""ceftriaxon"")ab_atc(""cephtriaxone"")  small spelling errorab_atc(""cephthriaxone"")  or a bit more severeab_atc(""seephthriaaksone"")  and even this works use ab_ functions to get a specific properties (see ?ab_property); they use as.ab() internally:ab_name(""J01FA01"")ab_name(""eryt"")if (require(""dplyr"")) {   you can quickly rename 'sir' columns using set_ab_names() with dplyr:  example_isolates %>%    set_ab_names(where(is.sir), property = ""atc"")}``` See Also  antibiotics for the data.frame that is being used to determine ATCs  `ab_from_text()` for a function to retrieve antimicrobial drugs from clinical text (from health care records)",5
AMR,microorganisms.codes.md," data

# Data Set with 4 957 Common Microorganism Codes

## Format

A tibble with 4 957 observations and 2 variables:

 * `code`
   
   Commonly used code of a microorganism. **This is a unique identifier.**
 * `mo`
   
   ID of the microorganism in the microorganisms data set

```r
microorganisms.codes
```

## Description

A data set containing commonly used codes for microorganisms, from laboratory systems and [WHONET](https://whonet.org). Define your own with `set_mo_source()`. They will all be searched when using `as.mo()` and consequently all the `mo_*` functions.

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
microorganisms.codes

# 'ECO' or 'eco' is the WHONET code for E. coli:
microorganisms.codes[microorganisms.codes$code == ""ECO"", ]

# and therefore, 'eco' will be understood as E. coli in this package:
mo_info(""eco"")

# works for all AMR functions:
mo_is_intrinsic_resistant(""eco"", ab = ""vancomycin"")
```

## See Also

`as.mo()` microorganisms



","['data Data Set with 4 957 Common Microorganism Codes FormatA tibble with 4 957 observations and 2 variables:  `code`      Commonly used code of a microorganism.', 'This is a unique identifier.', '`mo`      ID of the microorganism in the microorganisms data set```rmicroorganisms.codes``` DescriptionA data set containing commonly used codes for microorganisms, from laboratory systems and [WHONET](https://whonet.org).', 'Define your own with `set_mo_source()`.', 'They will all be searched when using `as.mo()` and consequently all the `mo_` functions.', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```rmicroorganisms.codes \'ECO\' or \'eco\' is the WHONET code for E. coli:microorganisms.codes[microorganisms.codes$code == ""ECO"", ] and therefore, \'eco\' will be understood as E. coli in this package:mo_info(""eco"") works for all AMR functions:mo_is_intrinsic_resistant(""eco"", ab = ""vancomycin"")``` See Also`as.mo()` microorganisms']",1," data Data Set with 4 957 Common Microorganism Codes FormatA tibble with 4 957 observations and 2 variables:  `code`      Commonly used code of a microorganism. This is a unique identifier.  `mo`      ID of the microorganism in the microorganisms data set```rmicroorganisms.codes``` DescriptionA data set containing commonly used codes for microorganisms, from laboratory systems and [WHONET](https://whonet.org). Define your own with `set_mo_source()`. They will all be searched when using `as.mo()` and consequently all the `mo_` functions. DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rmicroorganisms.codes 'ECO' or 'eco' is the WHONET code for E. coli:microorganisms.codes[microorganisms.codes$code == ""ECO"", ] and therefore, 'eco' will be understood as E. coli in this package:mo_info(""eco"") works for all AMR functions:mo_is_intrinsic_resistant(""eco"", ab = ""vancomycin"")``` See Also`as.mo()` microorganisms",6
AMR,mo_property.md,"# Get Properties of a Microorganism

```r
mo_name(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_fullname(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_shortname(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_subspecies(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_species(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_genus(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_family(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_order(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_class(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_phylum(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_kingdom(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_domain(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_type(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_status(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_pathogenicity(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_gramstain(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_is_gram_negative(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_is_gram_positive(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_is_yeast(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_is_intrinsic_resistant(
  x,
  ab,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_oxygen_tolerance(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_is_anaerobic(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_snomed(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_ref(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_authors(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_year(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_lpsn(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_gbif(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_rank(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_taxonomy(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_synonyms(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_current(x, language = get_AMR_locale(), ...)

mo_info(
  x,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_url(
  x,
  open = FALSE,
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)

mo_property(
  x,
  property = ""fullname"",
  language = get_AMR_locale(),
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  ...
)
```

## Arguments

- `x`: any character (vector) that can be coerced to a valid microorganism code with `as.mo()`. Can be left blank for auto-guessing the column containing microorganism codes if used in a data set, see **Examples**.
- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)
- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`, which will return a note if old taxonomic names were processed. The default can be set with the package option `AMR_keep_synonyms`, i.e. `options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.
- `...`: other arguments passed on to `as.mo()`, such as 'minimum_matching_score', 'ignore_pattern', and 'remove_from_input'
- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`
- `open`: browse the URL using `browseURL()`
- `property`: one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"", or must be `""shortname""`

## Returns

 * An integer in case of `mo_year()`
 * An ordered factor in case of `mo_pathogenicity()`
 * A list in case of `mo_taxonomy()`, `mo_synonyms()`, `mo_snomed()` and `mo_info()`
 * A named character in case of `mo_url()`
 * A character in all other cases

## Description

Use these functions to return a specific property of a microorganism based on the latest accepted taxonomy. All input values will be evaluated internally with `as.mo()`, which makes it possible to use microbial abbreviations, codes and names as input. See **Examples**.

## Details

All functions will, at default, not keep old taxonomic properties, as synonyms are automatically replaced with the current taxonomy. Take for example **Enterobacter aerogenes**, which was initially named in 1960 but renamed to **Klebsiella aerogenes** in 2017:

 * `mo_genus(""Enterobacter aerogenes"")` will return `""Klebsiella""` (with a note about the renaming)
 * `mo_genus(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Enterobacter""` (with a once-per-session warning that the name is outdated)
 * `mo_ref(""Enterobacter aerogenes"")` will return `""Tindall et al., 2017""` (with a note)
 * `mo_ref(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Hormaeche et al., 1960""` (with a warning)

The short name (`mo_shortname()`) returns the first character of the genus and the full species, such as `""E. coli""`, for species and subspecies. Exceptions are abbreviations of staphylococci (such as **""CoNS""**, Coagulase-Negative Staphylococci) and beta-haemolytic streptococci (such as **""GBS""**, Group B Streptococci). Please bear in mind that e.g. **E. coli** could mean **Escherichia coli** (kingdom of Bacteria) as well as **Entamoeba coli** (kingdom of Protozoa). Returning to the full name will be done using `as.mo()` internally, giving priority to bacteria and human pathogens, i.e. `""E. coli""` will be considered **Escherichia coli**. As a result, `mo_fullname(mo_shortname(""Entamoeba coli""))` returns `""Escherichia coli""`.

Since the top-level of the taxonomy is sometimes referred to as 'kingdom' and sometimes as 'domain', the functions `mo_kingdom()` and `mo_domain()` return the exact same results.

Determination of human pathogenicity (`mo_pathogenicity()`) is strongly based on Bartlett **et al.** (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ). This function returns a factor with the levels **Pathogenic**, **Potentially pathogenic**, **Non-pathogenic**, and **Unknown**.

Determination of the Gram stain (`mo_gramstain()`) will be based on the taxonomic kingdom and phylum. Originally, Cavalier-Smith defined the so-called subkingdoms Negibacteria and Posibacteria (2002, [PMID 11837318](https://pubmed.ncbi.nlm.nih.gov/11837318/)), and only considered these phyla as Posibacteria: Actinobacteria, Chloroflexi, Firmicutes, and Tenericutes. These phyla were later renamed to Actinomycetota, Chloroflexota, Bacillota, and Mycoplasmatota (2021, [PMID 34694987](https://pubmed.ncbi.nlm.nih.gov/34694987/)). Bacteria in these phyla are considered Gram-positive in this `AMR` package, except for members of the class Negativicutes (within phylum Bacillota) which are Gram-negative. All other bacteria are considered Gram-negative. Species outside the kingdom of Bacteria will return a value `NA`. Functions `mo_is_gram_negative()` and `mo_is_gram_positive()` always return `TRUE` or `FALSE` (or `NA` when the input is `NA` or the MO code is `UNKNOWN`), thus always return `FALSE` for species outside the taxonomic kingdom of Bacteria.

Determination of yeasts (`mo_is_yeast()`) will be based on the taxonomic kingdom and class. **Budding yeasts** are fungi of the phylum Ascomycota, class Saccharomycetes (also called Hemiascomycetes). **True yeasts** are aggregated into the underlying order Saccharomycetales. Thus, for all microorganisms that are member of the taxonomic class Saccharomycetes, the function will return `TRUE`. It returns `FALSE` otherwise (or `NA` when the input is `NA` or the MO code is `UNKNOWN`).

Determination of intrinsic resistance (`mo_is_intrinsic_resistant()`) will be based on the intrinsic_resistant data set, which is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021). The `mo_is_intrinsic_resistant()` function can be vectorised over both argument `x` (input for microorganisms) and `ab` (input for antibiotics).

Determination of bacterial oxygen tolerance (`mo_oxygen_tolerance()`) will be based on BacDive, see **Source**. The function `mo_is_anaerobic()` only returns `TRUE` if the oxygen tolerance is `""anaerobe""`, indicting an obligate anaerobic species or genus. It always returns `FALSE` for species outside the taxonomic kingdom of Bacteria.

The function `mo_url()` will return the direct URL to the online database entry, which also shows the scientific reference of the concerned species.

SNOMED codes (`mo_snomed()`) are from the version of July 1st, 2021. See **Source** and the microorganisms data set for more info.

Old taxonomic names (so-called 'synonyms') can be retrieved with `mo_synonyms()` (which will have the scientific reference as name ), the current taxonomic name can be retrieved with `mo_current()`. Both functions return full names.

All output will be translated where possible.

## Matching Score for Microorganisms

 This function uses `as.mo()` internally, which uses an advanced algorithm to translate arbitrary user input to valid taxonomy using a so-called matching score. You can read about this public algorithm on the MO matching score page .

## Source

1. Berends MS **et al.** (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . **Journal of Statistical Software**, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")
2. Becker K **et al.** (2014). Coagulase-Negative Staphylococci. **Clin Microbiol Rev.** 27(4): 870-926; tools:::Rd_expr_doi(""10.1128/CMR.00109-13"")
3. Becker K **et al.** (2019). Implications of identifying the recently defined members of the _S.aureus_ complex, _S. argenteus_ and _S. schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS). **Clin Microbiol Infect**; tools:::Rd_expr_doi(""10.1016/j.cmi.2019.02.028"")
4. Becker K **et al.** (2020). Emergence of coagulase-negative staphylococci. **Expert Rev Anti Infect Ther.** 18(4):349-366; tools:::Rd_expr_doi(""10.1080/14787210.2020.1730813"")
5. Lancefield RC (1933). A serological differentiation of human and other groups of hemolyticstreptococci. **J Exp Med.** 57(4): 571-95; tools:::Rd_expr_doi(""10.1084/jem.57.4.571"")
6. Berends MS **et al.** (2022). Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ **Micro.rganisms** 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")
7. Parte, AC **et al.** (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.
8. GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.
9. Reimer, LC **et al.** (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.
10. Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)
11. Bartlett A **et al.** (2022). A comprehensive list of bacterial pathogens infecting humans **Microbiology** 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"")

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# taxonomic tree -----------------------------------------------------------

mo_kingdom(""Klebsiella pneumoniae"")
mo_phylum(""Klebsiella pneumoniae"")
mo_class(""Klebsiella pneumoniae"")
mo_order(""Klebsiella pneumoniae"")
mo_family(""Klebsiella pneumoniae"")
mo_genus(""Klebsiella pneumoniae"")
mo_species(""Klebsiella pneumoniae"")
mo_subspecies(""Klebsiella pneumoniae"")


# full names and short names -----------------------------------------------

mo_name(""Klebsiella pneumoniae"")
mo_fullname(""Klebsiella pneumoniae"")
mo_shortname(""Klebsiella pneumoniae"")


# other properties ---------------------------------------------------------

mo_pathogenicity(""Klebsiella pneumoniae"")
mo_gramstain(""Klebsiella pneumoniae"")
mo_snomed(""Klebsiella pneumoniae"")
mo_type(""Klebsiella pneumoniae"")
mo_rank(""Klebsiella pneumoniae"")
mo_url(""Klebsiella pneumoniae"")
mo_is_yeast(c(""Candida"", ""Trichophyton"", ""Klebsiella""))


# scientific reference -----------------------------------------------------

mo_ref(""Klebsiella aerogenes"")
mo_authors(""Klebsiella aerogenes"")
mo_year(""Klebsiella aerogenes"")
mo_lpsn(""Klebsiella aerogenes"")
mo_gbif(""Klebsiella aerogenes"")
mo_synonyms(""Klebsiella aerogenes"")


# abbreviations known in the field -----------------------------------------

mo_genus(""MRSA"")
mo_species(""MRSA"")
mo_shortname(""VISA"")
mo_gramstain(""VISA"")

mo_genus(""EHEC"")
mo_species(""EIEC"")
mo_name(""UPEC"")


# known subspecies ---------------------------------------------------------

mo_fullname(""K. pneu rh"")
mo_shortname(""K. pneu rh"")


# Becker classification, see ?as.mo ----------------------------------------

mo_fullname(""Staph epidermidis"")
mo_fullname(""Staph epidermidis"", Becker = TRUE)
mo_shortname(""Staph epidermidis"")
mo_shortname(""Staph epidermidis"", Becker = TRUE)


# Lancefield classification, see ?as.mo ------------------------------------

mo_fullname(""Strep agalactiae"")
mo_fullname(""Strep agalactiae"", Lancefield = TRUE)
mo_shortname(""Strep agalactiae"")
mo_shortname(""Strep agalactiae"", Lancefield = TRUE)


# language support  --------------------------------------------------------

mo_gramstain(""Klebsiella pneumoniae"", language = ""de"") # German
mo_gramstain(""Klebsiella pneumoniae"", language = ""nl"") # Dutch
mo_gramstain(""Klebsiella pneumoniae"", language = ""es"") # Spanish
mo_gramstain(""Klebsiella pneumoniae"", language = ""el"") # Greek
mo_gramstain(""Klebsiella pneumoniae"", language = ""uk"") # Ukrainian

# mo_type is equal to mo_kingdom, but mo_kingdom will remain untranslated
mo_kingdom(""Klebsiella pneumoniae"")
mo_type(""Klebsiella pneumoniae"")
mo_kingdom(""Klebsiella pneumoniae"", language = ""zh"") # Chinese, no effect
mo_type(""Klebsiella pneumoniae"", language = ""zh"") # Chinese, translated

mo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""de"")
mo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""uk"")


# other --------------------------------------------------------------------

# gram stains and intrinsic resistance can be used as a filter in dplyr verbs
if (require(""dplyr"")) {
  example_isolates %>%
    filter(mo_is_gram_positive()) %>%
    count(mo_genus(), sort = TRUE)
}
if (require(""dplyr"")) {
  example_isolates %>%
    filter(mo_is_intrinsic_resistant(ab = ""vanco"")) %>%
    count(mo_genus(), sort = TRUE)
}

# get a list with the complete taxonomy (from kingdom to subspecies)
mo_taxonomy(""Klebsiella pneumoniae"")

# get a list with the taxonomy, the authors, Gram-stain,
# SNOMED codes, and URL to the online database
mo_info(""Klebsiella pneumoniae"")
```

## See Also

Data set microorganisms



","['Get Properties of a Microorganism```rmo_name(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_fullname(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_shortname(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_subspecies(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_species(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_genus(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_family(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_order(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_class(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_phylum(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_kingdom(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_domain(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_type(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_status(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_pathogenicity(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_gramstain(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_gram_negative(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_gram_positive(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_yeast(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_intrinsic_resistant(  x,  ab,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_oxygen_tolerance(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_anaerobic(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_snomed(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_ref(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_authors(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_year(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_lpsn(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_gbif(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_rank(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_taxonomy(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_synonyms(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_current(x, language = get_AMR_locale(), ...)mo_info(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_url(  x,  open = FALSE,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_property(  x,  property = ""fullname"",  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)``` Arguments- `x`: any character (vector) that can be coerced to a valid microorganism code with `as.mo()`.', 'Can be left blank for auto-guessing the column containing microorganism codes if used in a data set, see Examples.- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names.', 'The default is `FALSE`, which will return a note if old taxonomic names were processed.', 'The default can be set with the package option `AMR_keep_synonyms`, i.e.', '`options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.- `...`: other arguments passed on to `as.mo()`, such as \'minimum_matching_score\', \'ignore_pattern\', and \'remove_from_input\'- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `open`: browse the URL using `browseURL()`- `property`: one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"", or must be `""shortname""` Returns  An integer in case of `mo_year()`  An ordered factor in case of `mo_pathogenicity()`  A list in case of `mo_taxonomy()`, `mo_synonyms()`, `mo_snomed()` and `mo_info()`  A named character in case of `mo_url()`  A character in all other cases DescriptionUse these functions to return a specific property of a microorganism based on the latest accepted taxonomy.', 'All input values will be evaluated internally with `as.mo()`, which makes it possible to use microbial abbreviations, codes and names as input.', 'DetailsAll functions will, at default, not keep old taxonomic properties, as synonyms are automatically replaced with the current taxonomy.', 'Take for example Enterobacter aerogenes, which was initially named in 1960 but renamed to Klebsiella aerogenes in 2017:  `mo_genus(""Enterobacter aerogenes"")` will return `""Klebsiella""` (with a note about the renaming)  `mo_genus(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Enterobacter""` (with a once-per-session warning that the name is outdated)  `mo_ref(""Enterobacter aerogenes"")` will return `""Tindall et al., 2017""` (with a note)  `mo_ref(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Hormaeche et al., 1960""` (with a warning)The short name (`mo_shortname()`) returns the first character of the genus and the full species, such as `""E. coli""`, for species and subspecies.', 'Exceptions are abbreviations of staphylococci (such as ""CoNS"", Coagulase-Negative Staphylococci) and beta-haemolytic streptococci (such as ""GBS"", Group B Streptococci).', 'Please bear in mind that e.g.', 'E. coli could mean Escherichia coli (kingdom of Bacteria) as well as Entamoeba coli (kingdom of Protozoa).', 'Returning to the full name will be done using `as.mo()` internally, giving priority to bacteria and human pathogens, i.e.', '`""E. coli""` will be considered Escherichia coli.', 'As a result, `mo_fullname(mo_shortname(""Entamoeba coli""))` returns `""Escherichia coli""`.Since the top-level of the taxonomy is sometimes referred to as \'kingdom\' and sometimes as \'domain\', the functions `mo_kingdom()` and `mo_domain()` return the exact same results.Determination of human pathogenicity (`mo_pathogenicity()`) is strongly based on Bartlett et al.', 'This function returns a factor with the levels Pathogenic, Potentially pathogenic, Non-pathogenic, and Unknown.Determination of the Gram stain (`mo_gramstain()`) will be based on the taxonomic kingdom and phylum.', 'Originally, Cavalier-Smith defined the so-called subkingdoms Negibacteria and Posibacteria (2002, [PMID 11837318](https://pubmed.ncbi.nlm.nih.gov/11837318/)), and only considered these phyla as Posibacteria: Actinobacteria, Chloroflexi, Firmicutes, and Tenericutes.', 'These phyla were later renamed to Actinomycetota, Chloroflexota, Bacillota, and Mycoplasmatota (2021, [PMID 34694987](https://pubmed.ncbi.nlm.nih.gov/34694987/)).', 'Bacteria in these phyla are considered Gram-positive in this `AMR` package, except for members of the class Negativicutes (within phylum Bacillota) which are Gram-negative.', 'All other bacteria are considered Gram-negative.', 'Species outside the kingdom of Bacteria will return a value `NA`.', 'Functions `mo_is_gram_negative()` and `mo_is_gram_positive()` always return `TRUE` or `FALSE` (or `NA` when the input is `NA` or the MO code is `UNKNOWN`), thus always return `FALSE` for species outside the taxonomic kingdom of Bacteria.Determination of yeasts (`mo_is_yeast()`) will be based on the taxonomic kingdom and class.', 'Budding yeasts are fungi of the phylum Ascomycota, class Saccharomycetes (also called Hemiascomycetes).', 'True yeasts are aggregated into the underlying order Saccharomycetales.', 'Thus, for all microorganisms that are member of the taxonomic class Saccharomycetes, the function will return `TRUE`.', ""It returns `FALSE` otherwise (or `NA` when the input is `NA` or the MO code is `UNKNOWN`).Determination of intrinsic resistance (`mo_is_intrinsic_resistant()`) will be based on the intrinsic_resistant data set, which is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021)."", 'The `mo_is_intrinsic_resistant()` function can be vectorised over both argument `x` (input for microorganisms) and `ab` (input for antibiotics).Determination of bacterial oxygen tolerance (`mo_oxygen_tolerance()`) will be based on BacDive, see Source.', 'The function `mo_is_anaerobic()` only returns `TRUE` if the oxygen tolerance is `""anaerobe""`, indicting an obligate anaerobic species or genus.', 'It always returns `FALSE` for species outside the taxonomic kingdom of Bacteria.The function `mo_url()` will return the direct URL to the online database entry, which also shows the scientific reference of the concerned species.SNOMED codes (`mo_snomed()`) are from the version of July 1st, 2021.', ""See Source and the microorganisms data set for more info.Old taxonomic names (so-called 'synonyms') can be retrieved with `mo_synonyms()` (which will have the scientific reference as name ), the current taxonomic name can be retrieved with `mo_current()`."", 'Both functions return full names.All output will be translated where possible.', 'Matching Score for Microorganisms This function uses `as.mo()` internally, which uses an advanced algorithm to translate arbitrary user input to valid taxonomy using a so-called matching score.', 'You can read about this public algorithm on the MO matching score page .', 'AMR: An R Package for Working with Antimicrobial Resistance Data .', 'Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")2.', 'Implications of identifying the recently defined members of the _S.aureus_ complex, _S.', 'schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS).', 'Expert Rev Anti Infect Ther.', 'A serological differentiation of human and other groups of hemolyticstreptococci.', 'Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ Micro.rganisms 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")7.', 'List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ.', 'International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") .', 'Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.8.', 'Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.9.', '_BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data.', 'Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") .', 'Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.10.', 'Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS).', 'US Edition of SNOMED CT from 1 September 2020.', ""Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12)."", 'A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"") Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r taxonomic tree -----------------------------------------------------------mo_kingdom(""Klebsiella pneumoniae"")mo_phylum(""Klebsiella pneumoniae"")mo_class(""Klebsiella pneumoniae"")mo_order(""Klebsiella pneumoniae"")mo_family(""Klebsiella pneumoniae"")mo_genus(""Klebsiella pneumoniae"")mo_species(""Klebsiella pneumoniae"")mo_subspecies(""Klebsiella pneumoniae"") full names and short names -----------------------------------------------mo_name(""Klebsiella pneumoniae"")mo_fullname(""Klebsiella pneumoniae"")mo_shortname(""Klebsiella pneumoniae"") other properties ---------------------------------------------------------mo_pathogenicity(""Klebsiella pneumoniae"")mo_gramstain(""Klebsiella pneumoniae"")mo_snomed(""Klebsiella pneumoniae"")mo_type(""Klebsiella pneumoniae"")mo_rank(""Klebsiella pneumoniae"")mo_url(""Klebsiella pneumoniae"")mo_is_yeast(c(""Candida"", ""Trichophyton"", ""Klebsiella"")) scientific reference -----------------------------------------------------mo_ref(""Klebsiella aerogenes"")mo_authors(""Klebsiella aerogenes"")mo_year(""Klebsiella aerogenes"")mo_lpsn(""Klebsiella aerogenes"")mo_gbif(""Klebsiella aerogenes"")mo_synonyms(""Klebsiella aerogenes"") abbreviations known in the field -----------------------------------------mo_genus(""MRSA"")mo_species(""MRSA"")mo_shortname(""VISA"")mo_gramstain(""VISA"")mo_genus(""EHEC"")mo_species(""EIEC"")mo_name(""UPEC"") known subspecies ---------------------------------------------------------mo_fullname(""K. pneu rh"")mo_shortname(""K. pneu rh"") Becker classification, see ?as.mo ----------------------------------------mo_fullname(""Staph epidermidis"")mo_fullname(""Staph epidermidis"", Becker = TRUE)mo_shortname(""Staph epidermidis"")mo_shortname(""Staph epidermidis"", Becker = TRUE) Lancefield classification, see ?as.mo ------------------------------------mo_fullname(""Strep agalactiae"")mo_fullname(""Strep agalactiae"", Lancefield = TRUE)mo_shortname(""Strep agalactiae"")mo_shortname(""Strep agalactiae"", Lancefield = TRUE) language support  --------------------------------------------------------mo_gramstain(""Klebsiella pneumoniae"", language = ""de"")  Germanmo_gramstain(""Klebsiella pneumoniae"", language = ""nl"")  Dutchmo_gramstain(""Klebsiella pneumoniae"", language = ""es"")  Spanishmo_gramstain(""Klebsiella pneumoniae"", language = ""el"")  Greekmo_gramstain(""Klebsiella pneumoniae"", language = ""uk"")  Ukrainian mo_type is equal to mo_kingdom, but mo_kingdom will remain untranslatedmo_kingdom(""Klebsiella pneumoniae"")mo_type(""Klebsiella pneumoniae"")mo_kingdom(""Klebsiella pneumoniae"", language = ""zh"")  Chinese, no effectmo_type(""Klebsiella pneumoniae"", language = ""zh"")  Chinese, translatedmo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""de"")mo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""uk"") other -------------------------------------------------------------------- gram stains and intrinsic resistance can be used as a filter in dplyr verbsif (require(""dplyr"")) {  example_isolates %>%    filter(mo_is_gram_positive()) %>%    count(mo_genus(), sort = TRUE)}if (require(""dplyr"")) {  example_isolates %>%    filter(mo_is_intrinsic_resistant(ab = ""vanco"")) %>%    count(mo_genus(), sort = TRUE)} get a list with the complete taxonomy (from kingdom to subspecies)mo_taxonomy(""Klebsiella pneumoniae"") get a list with the taxonomy, the authors, Gram-stain, SNOMED codes, and URL to the online databasemo_info(""Klebsiella pneumoniae"")``` See AlsoData set microorganisms']",1," Get Properties of a Microorganism```rmo_name(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_fullname(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_shortname(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_subspecies(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_species(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_genus(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_family(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_order(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_class(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_phylum(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_kingdom(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_domain(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_type(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_status(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_pathogenicity(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_gramstain(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_gram_negative(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_gram_positive(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_yeast(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_intrinsic_resistant(  x,  ab,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_oxygen_tolerance(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_is_anaerobic(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_snomed(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_ref(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_authors(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_year(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_lpsn(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_gbif(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_rank(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_taxonomy(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_synonyms(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_current(x, language = get_AMR_locale(), ...)mo_info(  x,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_url(  x,  open = FALSE,  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)mo_property(  x,  property = ""fullname"",  language = get_AMR_locale(),  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  ...)``` Arguments- `x`: any character (vector) that can be coerced to a valid microorganism code with `as.mo()`. Can be left blank for auto-guessing the column containing microorganism codes if used in a data set, see Examples.- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`, which will return a note if old taxonomic names were processed. The default can be set with the package option `AMR_keep_synonyms`, i.e. `options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.- `...`: other arguments passed on to `as.mo()`, such as 'minimum_matching_score', 'ignore_pattern', and 'remove_from_input'- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `open`: browse the URL using `browseURL()`- `property`: one of the column names of the microorganisms data set: ""mo"", ""fullname"", ""status"", ""kingdom"", ""phylum"", ""class"", ""order"", ""family"", ""genus"", ""species"", ""subspecies"", ""rank"", ""ref"", ""oxygen_tolerance"", ""source"", ""lpsn"", ""lpsn_parent"", ""lpsn_renamed_to"", ""gbif"", ""gbif_parent"", ""gbif_renamed_to"", ""prevalence"", or ""snomed"", or must be `""shortname""` Returns  An integer in case of `mo_year()`  An ordered factor in case of `mo_pathogenicity()`  A list in case of `mo_taxonomy()`, `mo_synonyms()`, `mo_snomed()` and `mo_info()`  A named character in case of `mo_url()`  A character in all other cases DescriptionUse these functions to return a specific property of a microorganism based on the latest accepted taxonomy. All input values will be evaluated internally with `as.mo()`, which makes it possible to use microbial abbreviations, codes and names as input. See Examples. DetailsAll functions will, at default, not keep old taxonomic properties, as synonyms are automatically replaced with the current taxonomy. Take for example Enterobacter aerogenes, which was initially named in 1960 but renamed to Klebsiella aerogenes in 2017:  `mo_genus(""Enterobacter aerogenes"")` will return `""Klebsiella""` (with a note about the renaming)  `mo_genus(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Enterobacter""` (with a once-per-session warning that the name is outdated)  `mo_ref(""Enterobacter aerogenes"")` will return `""Tindall et al., 2017""` (with a note)  `mo_ref(""Enterobacter aerogenes"", keep_synonyms = TRUE)` will return `""Hormaeche et al., 1960""` (with a warning)The short name (`mo_shortname()`) returns the first character of the genus and the full species, such as `""E. coli""`, for species and subspecies. Exceptions are abbreviations of staphylococci (such as ""CoNS"", Coagulase-Negative Staphylococci) and beta-haemolytic streptococci (such as ""GBS"", Group B Streptococci). Please bear in mind that e.g. E. coli could mean Escherichia coli (kingdom of Bacteria) as well as Entamoeba coli (kingdom of Protozoa). Returning to the full name will be done using `as.mo()` internally, giving priority to bacteria and human pathogens, i.e. `""E. coli""` will be considered Escherichia coli. As a result, `mo_fullname(mo_shortname(""Entamoeba coli""))` returns `""Escherichia coli""`.Since the top-level of the taxonomy is sometimes referred to as 'kingdom' and sometimes as 'domain', the functions `mo_kingdom()` and `mo_domain()` return the exact same results.Determination of human pathogenicity (`mo_pathogenicity()`) is strongly based on Bartlett et al. (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ). This function returns a factor with the levels Pathogenic, Potentially pathogenic, Non-pathogenic, and Unknown.Determination of the Gram stain (`mo_gramstain()`) will be based on the taxonomic kingdom and phylum. Originally, Cavalier-Smith defined the so-called subkingdoms Negibacteria and Posibacteria (2002, [PMID 11837318](https://pubmed.ncbi.nlm.nih.gov/11837318/)), and only considered these phyla as Posibacteria: Actinobacteria, Chloroflexi, Firmicutes, and Tenericutes. These phyla were later renamed to Actinomycetota, Chloroflexota, Bacillota, and Mycoplasmatota (2021, [PMID 34694987](https://pubmed.ncbi.nlm.nih.gov/34694987/)). Bacteria in these phyla are considered Gram-positive in this `AMR` package, except for members of the class Negativicutes (within phylum Bacillota) which are Gram-negative. All other bacteria are considered Gram-negative. Species outside the kingdom of Bacteria will return a value `NA`. Functions `mo_is_gram_negative()` and `mo_is_gram_positive()` always return `TRUE` or `FALSE` (or `NA` when the input is `NA` or the MO code is `UNKNOWN`), thus always return `FALSE` for species outside the taxonomic kingdom of Bacteria.Determination of yeasts (`mo_is_yeast()`) will be based on the taxonomic kingdom and class. Budding yeasts are fungi of the phylum Ascomycota, class Saccharomycetes (also called Hemiascomycetes). True yeasts are aggregated into the underlying order Saccharomycetales. Thus, for all microorganisms that are member of the taxonomic class Saccharomycetes, the function will return `TRUE`. It returns `FALSE` otherwise (or `NA` when the input is `NA` or the MO code is `UNKNOWN`).Determination of intrinsic resistance (`mo_is_intrinsic_resistant()`) will be based on the intrinsic_resistant data set, which is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021). The `mo_is_intrinsic_resistant()` function can be vectorised over both argument `x` (input for microorganisms) and `ab` (input for antibiotics).Determination of bacterial oxygen tolerance (`mo_oxygen_tolerance()`) will be based on BacDive, see Source. The function `mo_is_anaerobic()` only returns `TRUE` if the oxygen tolerance is `""anaerobe""`, indicting an obligate anaerobic species or genus. It always returns `FALSE` for species outside the taxonomic kingdom of Bacteria.The function `mo_url()` will return the direct URL to the online database entry, which also shows the scientific reference of the concerned species.SNOMED codes (`mo_snomed()`) are from the version of July 1st, 2021. See Source and the microorganisms data set for more info.Old taxonomic names (so-called 'synonyms') can be retrieved with `mo_synonyms()` (which will have the scientific reference as name ), the current taxonomic name can be retrieved with `mo_current()`. Both functions return full names.All output will be translated where possible. Matching Score for Microorganisms This function uses `as.mo()` internally, which uses an advanced algorithm to translate arbitrary user input to valid taxonomy using a so-called matching score. You can read about this public algorithm on the MO matching score page . Source1. Berends MS et al. (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")2. Becker K et al. (2014). Coagulase-Negative Staphylococci. Clin Microbiol Rev. 27(4): 870-926; tools:::Rd_expr_doi(""10.1128/CMR.00109-13"")3. Becker K et al. (2019). Implications of identifying the recently defined members of the _S.aureus_ complex, _S. argenteus_ and _S. schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS). Clin Microbiol Infect; tools:::Rd_expr_doi(""10.1016/j.cmi.2019.02.028"")4. Becker K et al. (2020). Emergence of coagulase-negative staphylococci. Expert Rev Anti Infect Ther. 18(4):349-366; tools:::Rd_expr_doi(""10.1080/14787210.2020.1730813"")5. Lancefield RC (1933). A serological differentiation of human and other groups of hemolyticstreptococci. J Exp Med. 57(4): 571-95; tools:::Rd_expr_doi(""10.1084/jem.57.4.571"")6. Berends MS et al. (2022). Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ Micro.rganisms 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")7. Parte, AC et al. (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.8. GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.9. Reimer, LC et al. (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.10. Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)11. Bartlett A et al. (2022). A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"") Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r taxonomic tree -----------------------------------------------------------mo_kingdom(""Klebsiella pneumoniae"")mo_phylum(""Klebsiella pneumoniae"")mo_class(""Klebsiella pneumoniae"")mo_order(""Klebsiella pneumoniae"")mo_family(""Klebsiella pneumoniae"")mo_genus(""Klebsiella pneumoniae"")mo_species(""Klebsiella pneumoniae"")mo_subspecies(""Klebsiella pneumoniae"") full names and short names -----------------------------------------------mo_name(""Klebsiella pneumoniae"")mo_fullname(""Klebsiella pneumoniae"")mo_shortname(""Klebsiella pneumoniae"") other properties ---------------------------------------------------------mo_pathogenicity(""Klebsiella pneumoniae"")mo_gramstain(""Klebsiella pneumoniae"")mo_snomed(""Klebsiella pneumoniae"")mo_type(""Klebsiella pneumoniae"")mo_rank(""Klebsiella pneumoniae"")mo_url(""Klebsiella pneumoniae"")mo_is_yeast(c(""Candida"", ""Trichophyton"", ""Klebsiella"")) scientific reference -----------------------------------------------------mo_ref(""Klebsiella aerogenes"")mo_authors(""Klebsiella aerogenes"")mo_year(""Klebsiella aerogenes"")mo_lpsn(""Klebsiella aerogenes"")mo_gbif(""Klebsiella aerogenes"")mo_synonyms(""Klebsiella aerogenes"") abbreviations known in the field -----------------------------------------mo_genus(""MRSA"")mo_species(""MRSA"")mo_shortname(""VISA"")mo_gramstain(""VISA"")mo_genus(""EHEC"")mo_species(""EIEC"")mo_name(""UPEC"") known subspecies ---------------------------------------------------------mo_fullname(""K. pneu rh"")mo_shortname(""K. pneu rh"") Becker classification, see ?as.mo ----------------------------------------mo_fullname(""Staph epidermidis"")mo_fullname(""Staph epidermidis"", Becker = TRUE)mo_shortname(""Staph epidermidis"")mo_shortname(""Staph epidermidis"", Becker = TRUE) Lancefield classification, see ?as.mo ------------------------------------mo_fullname(""Strep agalactiae"")mo_fullname(""Strep agalactiae"", Lancefield = TRUE)mo_shortname(""Strep agalactiae"")mo_shortname(""Strep agalactiae"", Lancefield = TRUE) language support  --------------------------------------------------------mo_gramstain(""Klebsiella pneumoniae"", language = ""de"")  Germanmo_gramstain(""Klebsiella pneumoniae"", language = ""nl"")  Dutchmo_gramstain(""Klebsiella pneumoniae"", language = ""es"")  Spanishmo_gramstain(""Klebsiella pneumoniae"", language = ""el"")  Greekmo_gramstain(""Klebsiella pneumoniae"", language = ""uk"")  Ukrainian mo_type is equal to mo_kingdom, but mo_kingdom will remain untranslatedmo_kingdom(""Klebsiella pneumoniae"")mo_type(""Klebsiella pneumoniae"")mo_kingdom(""Klebsiella pneumoniae"", language = ""zh"")  Chinese, no effectmo_type(""Klebsiella pneumoniae"", language = ""zh"")  Chinese, translatedmo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""de"")mo_fullname(""S. pyogenes"", Lancefield = TRUE, language = ""uk"") other -------------------------------------------------------------------- gram stains and intrinsic resistance can be used as a filter in dplyr verbsif (require(""dplyr"")) {  example_isolates %>%    filter(mo_is_gram_positive()) %>%    count(mo_genus(), sort = TRUE)}if (require(""dplyr"")) {  example_isolates %>%    filter(mo_is_intrinsic_resistant(ab = ""vanco"")) %>%    count(mo_genus(), sort = TRUE)} get a list with the complete taxonomy (from kingdom to subspecies)mo_taxonomy(""Klebsiella pneumoniae"") get a list with the taxonomy, the authors, Gram-stain, SNOMED codes, and URL to the online databasemo_info(""Klebsiella pneumoniae"")``` See AlsoData set microorganisms",6
AMR,eucast_rules.md,"# Apply EUCAST Rules

## Source

 * EUCAST Expert Rules. Version 2.0, 2012.
   
   Leclercq et al. EUCAST expert rules in antimicrobial susceptibility testing. **Clin Microbiol Infect.** 2013;19(2):141-60; tools:::Rd_expr_doi(""https://doi.org/10.1111/j.1469-0691.2011.03703.x"")
 * EUCAST Expert Rules, Intrinsic Resistance and Exceptional Phenotypes Tables. Version 3.1, 2016. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf)
 * EUCAST Intrinsic Resistance and Unusual Phenotypes. Version 3.2, 2020. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf)
 * EUCAST Intrinsic Resistance and Unusual Phenotypes. Version 3.3, 2021. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf)
 * EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 9.0, 2019. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_9.0_Breakpoint_Tables.xlsx)
 * EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 10.0, 2020. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_10.0_Breakpoint_Tables.xlsx)
 * EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 11.0, 2021. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_11.0_Breakpoint_Tables.xlsx)
 * EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 12.0, 2022. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_12.0_Breakpoint_Tables.xlsx)

```r
eucast_rules(
  x,
  col_mo = NULL,
  info = interactive(),
  rules = getOption(""AMR_eucastrules"", default = c(""breakpoints"", ""expert"")),
  verbose = FALSE,
  version_breakpoints = 12,
  version_expertrules = 3.3,
  ampc_cephalosporin_resistance = NA,
  only_sir_columns = FALSE,
  custom_rules = NULL,
  ...
)

eucast_dosage(ab, administration = ""iv"", version_breakpoints = 12)
```

## Arguments

- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`
- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.
- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions
- `rules`: a character vector that specifies which rules should be applied. Must be one or more of `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`. The default value can be set to another value using the package option `AMR_eucastrules`: `options(AMR_eucastrules = ""all"")`. If using `""custom""`, be sure to fill in argument `custom_rules` too. Custom rules can be created with `custom_eucast_rules()`.
- `verbose`: a logical to turn Verbose mode on and off (default is off). In Verbose mode, the function does not apply rules to the data, but instead returns a data set in logbook form with extensive info about which rows and columns would be effected and in which way. Using Verbose mode takes a lot more time.
- `version_breakpoints`: the version number to use for the EUCAST Clinical Breakpoints guideline. Can be ""12.0"", ""11.0"", or ""10.0"".
- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline. Can be ""3.3"", ""3.2"", or ""3.1"".
- `ampc_cephalosporin_resistance`: a character value that should be applied to cefotaxime, ceftriaxone and ceftazidime for AmpC de-repressed cephalosporin-resistant mutants - the default is `NA`. Currently only works when `version_expertrules` is `3.2` and higher; these version of '**EUCAST Expert Rules on Enterobacterales**' state that results of cefotaxime, ceftriaxone and ceftazidime should be reported with a note, or results should be suppressed (emptied) for these three drugs. A value of `NA` (the default) for this argument will remove results for these three drugs, while e.g. a value of `""R""` will make the results for these drugs resistant. Use `NULL` or `FALSE` to not alter results for these three drugs of AmpC de-repressed cephalosporin-resistant mutants. Using `TRUE` is equal to using `""R""`.
    
    For **EUCAST Expert Rules** v3.2, this rule applies to: **Citrobacter braakii**, **Citrobacter freundii**, **Citrobacter gillenii**, **Citrobacter murliniae**, **Citrobacter rodenticum**, **Citrobacter sedlakii**, **Citrobacter werkmanii**, **Citrobacter youngae**, **Enterobacter**, **Hafnia alvei**, **Klebsiella aerogenes**, **Morganella morganii**, **Providencia**, and **Serratia**.
- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)
- `custom_rules`: custom rules to apply, created with `custom_eucast_rules()`
- `...`: column name of an antibiotic, see section **Antibiotics** below
- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`
- `administration`: route of administration, either ""im"", ""iv"", or ""oral""

## Returns

The input of `x`, possibly with edited values of antibiotics. Or, if `verbose = TRUE`, a data.frame with all original and new values of the affected bug-drug combinations.

## Description

Apply rules for clinical breakpoints and intrinsic resistance as defined by the European Committee on Antimicrobial Susceptibility Testing (EUCAST, [https://www.eucast.org](https://www.eucast.org)), see **Source**. Use `eucast_dosage()` to get a data.frame with advised dosages of a certain bug-drug combination, which is based on the dosage data set.

To improve the interpretation of the antibiogram before EUCAST rules are applied, some non-EUCAST rules can applied at default, see **Details**.

## Details

Note: This function does not translate MIC values to SIR values. Use `as.sir()` for that.

Note: When ampicillin (AMP, J01CA01) is not available but amoxicillin (AMX, J01CA04) is, the latter will be used for all rules where there is a dependency on ampicillin. These drugs are interchangeable when it comes to expression of antimicrobial resistance.

The file containing all EUCAST rules is located here: [https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv](https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv). Note: Old taxonomic names are replaced with the current taxonomy where applicable. For example, **Ochrobactrum anthropi** was renamed to **Brucella anthropi** in 2020; the original EUCAST rules v3.1 and v3.2 did not yet contain this new taxonomic name. The `AMR` package contains the full microbial taxonomy updated until December 11th, 2022, see microorganisms .

### Custom Rules

 Custom rules can be created using `custom_eucast_rules()`, e.g.:

 

```
x <- custom_eucast_rules(AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",
                    AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I"")

eucast_rules(example_isolates, rules = ""custom"", custom_rules = x)
```

 

### 'Other' Rules

 Before further processing, two non-EUCAST rules about drug combinations can be applied to improve the efficacy of the EUCAST rules, and the reliability of your data (analysis). These rules are:

1. A drug with enzyme inhibitor will be set to S if the same drug without enzyme inhibitor is S
2. A drug without enzyme inhibitor will be set to R if the same drug with enzyme inhibitor is R

Important examples include amoxicillin and amoxicillin/clavulanic acid, and trimethoprim and trimethoprim/sulfamethoxazole. Needless to say, for these rules to work, both drugs must be available in the data set.

Since these rules are not officially approved by EUCAST, they are not applied at default. To use these rules, include `""other""` to the `rules` argument, or use `eucast_rules(..., rules = ""all"")`. You can also set the package option `AMR_eucastrules`, i.e. run `options(AMR_eucastrules = ""all"")`.

## Antibiotics

 To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g. `TIC = NULL` to skip ticarcillin). Manually defined but non-existing columns will be skipped with a warning.

The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`. These are shown below in the format 'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))', sorted alphabetically:

Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no))

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
a <- data.frame(
  mo = c(
    ""Staphylococcus aureus"",
    ""Enterococcus faecalis"",
    ""Escherichia coli"",
    ""Klebsiella pneumoniae"",
    ""Pseudomonas aeruginosa""
  ),
  VAN = ""-"", # Vancomycin
  AMX = ""-"", # Amoxicillin
  COL = ""-"", # Colistin
  CAZ = ""-"", # Ceftazidime
  CXM = ""-"", # Cefuroxime
  PEN = ""S"", # Benzylpenicillin
  FOX = ""S"", # Cefoxitin
  stringsAsFactors = FALSE
)

head(a)


# apply EUCAST rules: some results wil be changed
b <- eucast_rules(a)

head(b)


# do not apply EUCAST rules, but rather get a data.frame
# containing all details about the transformations:
c <- eucast_rules(a, verbose = TRUE)
head(c)


# Dosage guidelines:

eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"")

eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"", version_breakpoints = 10)
```



","['Apply EUCAST Rules Source  EUCAST Expert Rules.', 'EUCAST expert rules in antimicrobial susceptibility testing.', '2013;19(2):141-60; tools:::Rd_expr_doi(""https://doi.org/10.1111/j.1469-0691.2011.03703.x"")  EUCAST Expert Rules, Intrinsic Resistance and Exceptional Phenotypes Tables.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf)  EUCAST Intrinsic Resistance and Unusual Phenotypes.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf)  EUCAST Intrinsic Resistance and Unusual Phenotypes.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_9.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_10.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_11.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters.', '[(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_12.0_Breakpoint_Tables.xlsx)```reucast_rules(  x,  col_mo = NULL,  info = interactive(),  rules = getOption(""AMR_eucastrules"", default = c(""breakpoints"", ""expert"")),  verbose = FALSE,  version_breakpoints = 12,  version_expertrules = 3.3,  ampc_cephalosporin_resistance = NA,  only_sir_columns = FALSE,  custom_rules = NULL,  ...)eucast_dosage(ab, administration = ""iv"", version_breakpoints = 12)``` Arguments- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`.', 'Values will be coerced using `as.mo()`.- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions- `rules`: a character vector that specifies which rules should be applied.', 'Must be one or more of `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`.', 'The default value can be set to another value using the package option `AMR_eucastrules`: `options(AMR_eucastrules = ""all"")`.', 'If using `""custom""`, be sure to fill in argument `custom_rules` too.', 'Custom rules can be created with `custom_eucast_rules()`.- `verbose`: a logical to turn Verbose mode on and off (default is off).', 'In Verbose mode, the function does not apply rules to the data, but instead returns a data set in logbook form with extensive info about which rows and columns would be effected and in which way.', 'Using Verbose mode takes a lot more time.- `version_breakpoints`: the version number to use for the EUCAST Clinical Breakpoints guideline.', 'Can be ""12.0"", ""11.0"", or ""10.0"".- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline.', 'Can be ""3.3"", ""3.2"", or ""3.1"".- `ampc_cephalosporin_resistance`: a character value that should be applied to cefotaxime, ceftriaxone and ceftazidime for AmpC de-repressed cephalosporin-resistant mutants - the default is `NA`.', ""Currently only works when `version_expertrules` is `3.2` and higher; these version of 'EUCAST Expert Rules on Enterobacterales' state that results of cefotaxime, ceftriaxone and ceftazidime should be reported with a note, or results should be suppressed (emptied) for these three drugs."", 'A value of `NA` (the default) for this argument will remove results for these three drugs, while e.g.', 'a value of `""R""` will make the results for these drugs resistant.', 'Use `NULL` or `FALSE` to not alter results for these three drugs of AmpC de-repressed cephalosporin-resistant mutants.', 'Using `TRUE` is equal to using `""R""`.', 'For EUCAST Expert Rules v3.2, this rule applies to: Citrobacter braakii, Citrobacter freundii, Citrobacter gillenii, Citrobacter murliniae, Citrobacter rodenticum, Citrobacter sedlakii, Citrobacter werkmanii, Citrobacter youngae, Enterobacter, Hafnia alvei, Klebsiella aerogenes, Morganella morganii, Providencia, and Serratia.- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `custom_rules`: custom rules to apply, created with `custom_eucast_rules()`- `...`: column name of an antibiotic, see section Antibiotics below- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `administration`: route of administration, either ""im"", ""iv"", or ""oral"" ReturnsThe input of `x`, possibly with edited values of antibiotics.', 'Or, if `verbose = TRUE`, a data.frame with all original and new values of the affected bug-drug combinations.', 'DescriptionApply rules for clinical breakpoints and intrinsic resistance as defined by the European Committee on Antimicrobial Susceptibility Testing (EUCAST, [https://www.eucast.org](https://www.eucast.org)), see Source.', 'Use `eucast_dosage()` to get a data.frame with advised dosages of a certain bug-drug combination, which is based on the dosage data set.To improve the interpretation of the antibiogram before EUCAST rules are applied, some non-EUCAST rules can applied at default, see Details.', 'DetailsNote: This function does not translate MIC values to SIR values.', 'Use `as.sir()` for that.Note: When ampicillin (AMP, J01CA01) is not available but amoxicillin (AMX, J01CA04) is, the latter will be used for all rules where there is a dependency on ampicillin.', 'These drugs are interchangeable when it comes to expression of antimicrobial resistance.The file containing all EUCAST rules is located here: [https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv](https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv).', 'Note: Old taxonomic names are replaced with the current taxonomy where applicable.', 'For example, Ochrobactrum anthropi was renamed to Brucella anthropi in 2020; the original EUCAST rules v3.1 and v3.2 did not yet contain this new taxonomic name.', 'The `AMR` package contains the full microbial taxonomy updated until December 11th, 2022, see microorganisms .', 'Custom Rules Custom rules can be created using `custom_eucast_rules()`, e.g.', ': ```x <- custom_eucast_rules(AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",                    AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I"")eucast_rules(example_isolates, rules = ""custom"", custom_rules = x)```  \'Other\' Rules Before further processing, two non-EUCAST rules about drug combinations can be applied to improve the efficacy of the EUCAST rules, and the reliability of your data (analysis).', 'A drug with enzyme inhibitor will be set to S if the same drug without enzyme inhibitor is S2.', 'A drug without enzyme inhibitor will be set to R if the same drug with enzyme inhibitor is RImportant examples include amoxicillin and amoxicillin/clavulanic acid, and trimethoprim and trimethoprim/sulfamethoxazole.', 'Needless to say, for these rules to work, both drugs must be available in the data set.Since these rules are not officially approved by EUCAST, they are not applied at default.', 'To use these rules, include `""other""` to the `rules` argument, or use `eucast_rules(..., rules = ""all"")`.', 'You can also set the package option `AMR_eucastrules`, i.e.', 'Antibiotics To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g.', '`TIC = NULL` to skip ticarcillin).', 'Manually defined but non-existing columns will be skipped with a warning.The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`.', ""These are shown below in the format 'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))', sorted alphabetically:Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no)) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)"", 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```ra <- data.frame(  mo = c(    ""Staphylococcus aureus"",    ""Enterococcus faecalis"",    ""Escherichia coli"",    ""Klebsiella pneumoniae"",    ""Pseudomonas aeruginosa""  ),  VAN = ""-"",  Vancomycin  AMX = ""-"",  Amoxicillin  COL = ""-"",  Colistin  CAZ = ""-"",  Ceftazidime  CXM = ""-"",  Cefuroxime  PEN = ""S"",  Benzylpenicillin  FOX = ""S"",  Cefoxitin  stringsAsFactors = FALSE)head(a) apply EUCAST rules: some results wil be changedb <- eucast_rules(a)head(b) do not apply EUCAST rules, but rather get a data.frame containing all details about the transformations:c <- eucast_rules(a, verbose = TRUE)head(c) Dosage guidelines:eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"")eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"", version_breakpoints = 10)```']",1," Apply EUCAST Rules Source  EUCAST Expert Rules. Version 2.0, 2012.      Leclercq et al. EUCAST expert rules in antimicrobial susceptibility testing. Clin Microbiol Infect. 2013;19(2):141-60; tools:::Rd_expr_doi(""https://doi.org/10.1111/j.1469-0691.2011.03703.x"")  EUCAST Expert Rules, Intrinsic Resistance and Exceptional Phenotypes Tables. Version 3.1, 2016. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/Expert_rules_intrinsic_exceptional_V3.1.pdf)  EUCAST Intrinsic Resistance and Unusual Phenotypes. Version 3.2, 2020. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2020/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.2_20200225.pdf)  EUCAST Intrinsic Resistance and Unusual Phenotypes. Version 3.3, 2021. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Expert_Rules/2021/Intrinsic_Resistance_and_Unusual_Phenotypes_Tables_v3.3_20211018.pdf)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 9.0, 2019. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_9.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 10.0, 2020. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_10.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 11.0, 2021. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_11.0_Breakpoint_Tables.xlsx)  EUCAST Breakpoint tables for interpretation of MICs and zone diameters. Version 12.0, 2022. [(link)](https://www.eucast.org/fileadmin/src/media/PDFs/EUCAST_files/Breakpoint_tables/v_12.0_Breakpoint_Tables.xlsx)```reucast_rules(  x,  col_mo = NULL,  info = interactive(),  rules = getOption(""AMR_eucastrules"", default = c(""breakpoints"", ""expert"")),  verbose = FALSE,  version_breakpoints = 12,  version_expertrules = 3.3,  ampc_cephalosporin_resistance = NA,  only_sir_columns = FALSE,  custom_rules = NULL,  ...)eucast_dosage(ab, administration = ""iv"", version_breakpoints = 12)``` Arguments- `x`: a data set with antibiotic columns, such as `amox`, `AMX` and `AMC`- `col_mo`: column name of the names or codes of the microorganisms (see `as.mo()`) - the default is the first column of class `mo`. Values will be coerced using `as.mo()`.- `info`: a logical to indicate whether progress should be printed to the console - the default is only print while in interactive sessions- `rules`: a character vector that specifies which rules should be applied. Must be one or more of `""breakpoints""`, `""expert""`, `""other""`, `""custom""`, `""all""`, and defaults to `c(""breakpoints"", ""expert"")`. The default value can be set to another value using the package option `AMR_eucastrules`: `options(AMR_eucastrules = ""all"")`. If using `""custom""`, be sure to fill in argument `custom_rules` too. Custom rules can be created with `custom_eucast_rules()`.- `verbose`: a logical to turn Verbose mode on and off (default is off). In Verbose mode, the function does not apply rules to the data, but instead returns a data set in logbook form with extensive info about which rows and columns would be effected and in which way. Using Verbose mode takes a lot more time.- `version_breakpoints`: the version number to use for the EUCAST Clinical Breakpoints guideline. Can be ""12.0"", ""11.0"", or ""10.0"".- `version_expertrules`: the version number to use for the EUCAST Expert Rules and Intrinsic Resistance guideline. Can be ""3.3"", ""3.2"", or ""3.1"".- `ampc_cephalosporin_resistance`: a character value that should be applied to cefotaxime, ceftriaxone and ceftazidime for AmpC de-repressed cephalosporin-resistant mutants - the default is `NA`. Currently only works when `version_expertrules` is `3.2` and higher; these version of 'EUCAST Expert Rules on Enterobacterales' state that results of cefotaxime, ceftriaxone and ceftazidime should be reported with a note, or results should be suppressed (emptied) for these three drugs. A value of `NA` (the default) for this argument will remove results for these three drugs, while e.g. a value of `""R""` will make the results for these drugs resistant. Use `NULL` or `FALSE` to not alter results for these three drugs of AmpC de-repressed cephalosporin-resistant mutants. Using `TRUE` is equal to using `""R""`.        For EUCAST Expert Rules v3.2, this rule applies to: Citrobacter braakii, Citrobacter freundii, Citrobacter gillenii, Citrobacter murliniae, Citrobacter rodenticum, Citrobacter sedlakii, Citrobacter werkmanii, Citrobacter youngae, Enterobacter, Hafnia alvei, Klebsiella aerogenes, Morganella morganii, Providencia, and Serratia.- `only_sir_columns`: a logical to indicate whether only antibiotic columns must be detected that were transformed to class `sir` (see `as.sir()`) on beforehand (default is `FALSE`)- `custom_rules`: custom rules to apply, created with `custom_eucast_rules()`- `...`: column name of an antibiotic, see section Antibiotics below- `ab`: any (vector of) text that can be coerced to a valid antibiotic drug code with `as.ab()`- `administration`: route of administration, either ""im"", ""iv"", or ""oral"" ReturnsThe input of `x`, possibly with edited values of antibiotics. Or, if `verbose = TRUE`, a data.frame with all original and new values of the affected bug-drug combinations. DescriptionApply rules for clinical breakpoints and intrinsic resistance as defined by the European Committee on Antimicrobial Susceptibility Testing (EUCAST, [https://www.eucast.org](https://www.eucast.org)), see Source. Use `eucast_dosage()` to get a data.frame with advised dosages of a certain bug-drug combination, which is based on the dosage data set.To improve the interpretation of the antibiogram before EUCAST rules are applied, some non-EUCAST rules can applied at default, see Details. DetailsNote: This function does not translate MIC values to SIR values. Use `as.sir()` for that.Note: When ampicillin (AMP, J01CA01) is not available but amoxicillin (AMX, J01CA04) is, the latter will be used for all rules where there is a dependency on ampicillin. These drugs are interchangeable when it comes to expression of antimicrobial resistance.The file containing all EUCAST rules is located here: [https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv](https://github.com/msberends/AMR/blob/main/data-raw/eucast_rules.tsv). Note: Old taxonomic names are replaced with the current taxonomy where applicable. For example, Ochrobactrum anthropi was renamed to Brucella anthropi in 2020; the original EUCAST rules v3.1 and v3.2 did not yet contain this new taxonomic name. The `AMR` package contains the full microbial taxonomy updated until December 11th, 2022, see microorganisms . Custom Rules Custom rules can be created using `custom_eucast_rules()`, e.g.: ```x <- custom_eucast_rules(AMC == ""R"" & genus == ""Klebsiella"" ~ aminopenicillins == ""R"",                    AMC == ""I"" & genus == ""Klebsiella"" ~ aminopenicillins == ""I"")eucast_rules(example_isolates, rules = ""custom"", custom_rules = x)```  'Other' Rules Before further processing, two non-EUCAST rules about drug combinations can be applied to improve the efficacy of the EUCAST rules, and the reliability of your data (analysis). These rules are:1. A drug with enzyme inhibitor will be set to S if the same drug without enzyme inhibitor is S2. A drug without enzyme inhibitor will be set to R if the same drug with enzyme inhibitor is RImportant examples include amoxicillin and amoxicillin/clavulanic acid, and trimethoprim and trimethoprim/sulfamethoxazole. Needless to say, for these rules to work, both drugs must be available in the data set.Since these rules are not officially approved by EUCAST, they are not applied at default. To use these rules, include `""other""` to the `rules` argument, or use `eucast_rules(..., rules = ""all"")`. You can also set the package option `AMR_eucastrules`, i.e. run `options(AMR_eucastrules = ""all"")`. Antibiotics To define antibiotics column names, leave as it is to determine it automatically with `guess_ab_col()` or input a text (case-insensitive), or use `NULL` to skip a column (e.g. `TIC = NULL` to skip ticarcillin). Manually defined but non-existing columns will be skipped with a warning.The following antibiotics are eligible for the functions `eucast_rules()` and `mdro()`. These are shown below in the format 'name (`antimicrobial ID`, [ATC code](https://www.whocc.no/atc/structure_and_principles/))', sorted alphabetically:Amikacin (`AMK`, [J01GB06](https://www.whocc.no/atc_ddd_index/?code=J01GB06&showdescription=no)), amoxicillin (`AMX`, [J01CA04](https://www.whocc.no/atc_ddd_index/?code=J01CA04&showdescription=no)), amoxicillin/clavulanic acid (`AMC`, [J01CR02](https://www.whocc.no/atc_ddd_index/?code=J01CR02&showdescription=no)), ampicillin (`AMP`, [J01CA01](https://www.whocc.no/atc_ddd_index/?code=J01CA01&showdescription=no)), ampicillin/sulbactam (`SAM`, [J01CR01](https://www.whocc.no/atc_ddd_index/?code=J01CR01&showdescription=no)), arbekacin (`ARB`, [J01GB12](https://www.whocc.no/atc_ddd_index/?code=J01GB12&showdescription=no)), aspoxicillin (`APX`, [J01CA19](https://www.whocc.no/atc_ddd_index/?code=J01CA19&showdescription=no)), azidocillin (`AZD`, [J01CE04](https://www.whocc.no/atc_ddd_index/?code=J01CE04&showdescription=no)), azithromycin (`AZM`, [J01FA10](https://www.whocc.no/atc_ddd_index/?code=J01FA10&showdescription=no)), azlocillin (`AZL`, [J01CA09](https://www.whocc.no/atc_ddd_index/?code=J01CA09&showdescription=no)), aztreonam (`ATM`, [J01DF01](https://www.whocc.no/atc_ddd_index/?code=J01DF01&showdescription=no)), bacampicillin (`BAM`, [J01CA06](https://www.whocc.no/atc_ddd_index/?code=J01CA06&showdescription=no)), bekanamycin (`BEK`, [J01GB13](https://www.whocc.no/atc_ddd_index/?code=J01GB13&showdescription=no)), benzathine benzylpenicillin (`BNB`, [J01CE08](https://www.whocc.no/atc_ddd_index/?code=J01CE08&showdescription=no)), benzathine phenoxymethylpenicillin (`BNP`, [J01CE10](https://www.whocc.no/atc_ddd_index/?code=J01CE10&showdescription=no)), benzylpenicillin (`PEN`, [J01CE01](https://www.whocc.no/atc_ddd_index/?code=J01CE01&showdescription=no)), besifloxacin (`BES`, [S01AE08](https://www.whocc.no/atc_ddd_index/?code=S01AE08&showdescription=no)), biapenem (`BIA`, [J01DH05](https://www.whocc.no/atc_ddd_index/?code=J01DH05&showdescription=no)), carbenicillin (`CRB`, [J01CA03](https://www.whocc.no/atc_ddd_index/?code=J01CA03&showdescription=no)), carindacillin (`CRN`, [J01CA05](https://www.whocc.no/atc_ddd_index/?code=J01CA05&showdescription=no)), cefacetrile (`CAC`, [J01DB10](https://www.whocc.no/atc_ddd_index/?code=J01DB10&showdescription=no)), cefaclor (`CEC`, [J01DC04](https://www.whocc.no/atc_ddd_index/?code=J01DC04&showdescription=no)), cefadroxil (`CFR`, [J01DB05](https://www.whocc.no/atc_ddd_index/?code=J01DB05&showdescription=no)), cefalexin (`LEX`, [J01DB01](https://www.whocc.no/atc_ddd_index/?code=J01DB01&showdescription=no)), cefaloridine (`RID`, [J01DB02](https://www.whocc.no/atc_ddd_index/?code=J01DB02&showdescription=no)), cefalotin (`CEP`, [J01DB03](https://www.whocc.no/atc_ddd_index/?code=J01DB03&showdescription=no)), cefamandole (`MAN`, [J01DC03](https://www.whocc.no/atc_ddd_index/?code=J01DC03&showdescription=no)), cefapirin (`HAP`, [J01DB08](https://www.whocc.no/atc_ddd_index/?code=J01DB08&showdescription=no)), cefatrizine (`CTZ`, [J01DB07](https://www.whocc.no/atc_ddd_index/?code=J01DB07&showdescription=no)), cefazedone (`CZD`, [J01DB06](https://www.whocc.no/atc_ddd_index/?code=J01DB06&showdescription=no)), cefazolin (`CZO`, [J01DB04](https://www.whocc.no/atc_ddd_index/?code=J01DB04&showdescription=no)), cefcapene (`CCP`, [J01DD17](https://www.whocc.no/atc_ddd_index/?code=J01DD17&showdescription=no)), cefdinir (`CDR`, [J01DD15](https://www.whocc.no/atc_ddd_index/?code=J01DD15&showdescription=no)), cefditoren (`DIT`, [J01DD16](https://www.whocc.no/atc_ddd_index/?code=J01DD16&showdescription=no)), cefepime (`FEP`, [J01DE01](https://www.whocc.no/atc_ddd_index/?code=J01DE01&showdescription=no)), cefetamet (`CAT`, [J01DD10](https://www.whocc.no/atc_ddd_index/?code=J01DD10&showdescription=no)), cefixime (`CFM`, [J01DD08](https://www.whocc.no/atc_ddd_index/?code=J01DD08&showdescription=no)), cefmenoxime (`CMX`, [J01DD05](https://www.whocc.no/atc_ddd_index/?code=J01DD05&showdescription=no)), cefmetazole (`CMZ`, [J01DC09](https://www.whocc.no/atc_ddd_index/?code=J01DC09&showdescription=no)), cefodizime (`DIZ`, [J01DD09](https://www.whocc.no/atc_ddd_index/?code=J01DD09&showdescription=no)), cefonicid (`CID`, [J01DC06](https://www.whocc.no/atc_ddd_index/?code=J01DC06&showdescription=no)), cefoperazone (`CFP`, [J01DD12](https://www.whocc.no/atc_ddd_index/?code=J01DD12&showdescription=no)), cefoperazone/sulbactam (`CSL`, [J01DD62](https://www.whocc.no/atc_ddd_index/?code=J01DD62&showdescription=no)), ceforanide (`CND`, [J01DC11](https://www.whocc.no/atc_ddd_index/?code=J01DC11&showdescription=no)), cefotaxime (`CTX`, [J01DD01](https://www.whocc.no/atc_ddd_index/?code=J01DD01&showdescription=no)), cefotaxime/clavulanic acid (`CTC`, [J01DD51](https://www.whocc.no/atc_ddd_index/?code=J01DD51&showdescription=no)), cefotetan (`CTT`, [J01DC05](https://www.whocc.no/atc_ddd_index/?code=J01DC05&showdescription=no)), cefotiam (`CTF`, [J01DC07](https://www.whocc.no/atc_ddd_index/?code=J01DC07&showdescription=no)), cefoxitin (`FOX`, [J01DC01](https://www.whocc.no/atc_ddd_index/?code=J01DC01&showdescription=no)), cefozopran (`ZOP`, [J01DE03](https://www.whocc.no/atc_ddd_index/?code=J01DE03&showdescription=no)), cefpiramide (`CPM`, [J01DD11](https://www.whocc.no/atc_ddd_index/?code=J01DD11&showdescription=no)), cefpirome (`CPO`, [J01DE02](https://www.whocc.no/atc_ddd_index/?code=J01DE02&showdescription=no)), cefpodoxime (`CPD`, [J01DD13](https://www.whocc.no/atc_ddd_index/?code=J01DD13&showdescription=no)), cefprozil (`CPR`, [J01DC10](https://www.whocc.no/atc_ddd_index/?code=J01DC10&showdescription=no)), cefroxadine (`CRD`, [J01DB11](https://www.whocc.no/atc_ddd_index/?code=J01DB11&showdescription=no)), cefsulodin (`CFS`, [J01DD03](https://www.whocc.no/atc_ddd_index/?code=J01DD03&showdescription=no)), ceftaroline (`CPT`, [J01DI02](https://www.whocc.no/atc_ddd_index/?code=J01DI02&showdescription=no)), ceftazidime (`CAZ`, [J01DD02](https://www.whocc.no/atc_ddd_index/?code=J01DD02&showdescription=no)), ceftazidime/clavulanic acid (`CCV`, [J01DD52](https://www.whocc.no/atc_ddd_index/?code=J01DD52&showdescription=no)), cefteram (`CEM`, [J01DD18](https://www.whocc.no/atc_ddd_index/?code=J01DD18&showdescription=no)), ceftezole (`CTL`, [J01DB12](https://www.whocc.no/atc_ddd_index/?code=J01DB12&showdescription=no)), ceftibuten (`CTB`, [J01DD14](https://www.whocc.no/atc_ddd_index/?code=J01DD14&showdescription=no)), ceftizoxime (`CZX`, [J01DD07](https://www.whocc.no/atc_ddd_index/?code=J01DD07&showdescription=no)), ceftobiprole medocaril (`CFM1`, [J01DI01](https://www.whocc.no/atc_ddd_index/?code=J01DI01&showdescription=no)), ceftolozane/tazobactam (`CZT`, [J01DI54](https://www.whocc.no/atc_ddd_index/?code=J01DI54&showdescription=no)), ceftriaxone (`CRO`, [J01DD04](https://www.whocc.no/atc_ddd_index/?code=J01DD04&showdescription=no)), ceftriaxone/beta-lactamase inhibitor (`CEB`, [J01DD63](https://www.whocc.no/atc_ddd_index/?code=J01DD63&showdescription=no)), cefuroxime (`CXM`, [J01DC02](https://www.whocc.no/atc_ddd_index/?code=J01DC02&showdescription=no)), cephradine (`CED`, [J01DB09](https://www.whocc.no/atc_ddd_index/?code=J01DB09&showdescription=no)), chloramphenicol (`CHL`, [J01BA01](https://www.whocc.no/atc_ddd_index/?code=J01BA01&showdescription=no)), ciprofloxacin (`CIP`, [J01MA02](https://www.whocc.no/atc_ddd_index/?code=J01MA02&showdescription=no)), clarithromycin (`CLR`, [J01FA09](https://www.whocc.no/atc_ddd_index/?code=J01FA09&showdescription=no)), clindamycin (`CLI`, [J01FF01](https://www.whocc.no/atc_ddd_index/?code=J01FF01&showdescription=no)), clometocillin (`CLM`, [J01CE07](https://www.whocc.no/atc_ddd_index/?code=J01CE07&showdescription=no)), cloxacillin (`CLO`, [J01CF02](https://www.whocc.no/atc_ddd_index/?code=J01CF02&showdescription=no)), colistin (`COL`, [J01XB01](https://www.whocc.no/atc_ddd_index/?code=J01XB01&showdescription=no)), cycloserine (`CYC`, [J04AB01](https://www.whocc.no/atc_ddd_index/?code=J04AB01&showdescription=no)), dalbavancin (`DAL`, [J01XA04](https://www.whocc.no/atc_ddd_index/?code=J01XA04&showdescription=no)), daptomycin (`DAP`, [J01XX09](https://www.whocc.no/atc_ddd_index/?code=J01XX09&showdescription=no)), delafloxacin (`DFX`, [J01MA23](https://www.whocc.no/atc_ddd_index/?code=J01MA23&showdescription=no)), dibekacin (`DKB`, [J01GB09](https://www.whocc.no/atc_ddd_index/?code=J01GB09&showdescription=no)), dicloxacillin (`DIC`, [J01CF01](https://www.whocc.no/atc_ddd_index/?code=J01CF01&showdescription=no)), dirithromycin (`DIR`, [J01FA13](https://www.whocc.no/atc_ddd_index/?code=J01FA13&showdescription=no)), doripenem (`DOR`, [J01DH04](https://www.whocc.no/atc_ddd_index/?code=J01DH04&showdescription=no)), doxycycline (`DOX`, [J01AA02](https://www.whocc.no/atc_ddd_index/?code=J01AA02&showdescription=no)), enoxacin (`ENX`, [J01MA04](https://www.whocc.no/atc_ddd_index/?code=J01MA04&showdescription=no)), epicillin (`EPC`, [J01CA07](https://www.whocc.no/atc_ddd_index/?code=J01CA07&showdescription=no)), ertapenem (`ETP`, [J01DH03](https://www.whocc.no/atc_ddd_index/?code=J01DH03&showdescription=no)), erythromycin (`ERY`, [J01FA01](https://www.whocc.no/atc_ddd_index/?code=J01FA01&showdescription=no)), fleroxacin (`FLE`, [J01MA08](https://www.whocc.no/atc_ddd_index/?code=J01MA08&showdescription=no)), flucloxacillin (`FLC`, [J01CF05](https://www.whocc.no/atc_ddd_index/?code=J01CF05&showdescription=no)), flurithromycin (`FLR1`, [J01FA14](https://www.whocc.no/atc_ddd_index/?code=J01FA14&showdescription=no)), fosfomycin (`FOS`, [J01XX01](https://www.whocc.no/atc_ddd_index/?code=J01XX01&showdescription=no)), framycetin (`FRM`, [D09AA01](https://www.whocc.no/atc_ddd_index/?code=D09AA01&showdescription=no)), fusidic acid (`FUS`, [J01XC01](https://www.whocc.no/atc_ddd_index/?code=J01XC01&showdescription=no)), garenoxacin (`GRN`, [J01MA19](https://www.whocc.no/atc_ddd_index/?code=J01MA19&showdescription=no)), gatifloxacin (`GAT`, [J01MA16](https://www.whocc.no/atc_ddd_index/?code=J01MA16&showdescription=no)), gemifloxacin (`GEM`, [J01MA15](https://www.whocc.no/atc_ddd_index/?code=J01MA15&showdescription=no)), gentamicin (`GEN`, [J01GB03](https://www.whocc.no/atc_ddd_index/?code=J01GB03&showdescription=no)), grepafloxacin (`GRX`, [J01MA11](https://www.whocc.no/atc_ddd_index/?code=J01MA11&showdescription=no)), hetacillin (`HET`, [J01CA18](https://www.whocc.no/atc_ddd_index/?code=J01CA18&showdescription=no)), imipenem (`IPM`, [J01DH51](https://www.whocc.no/atc_ddd_index/?code=J01DH51&showdescription=no)), imipenem/relebactam (`IMR`, [J01DH56](https://www.whocc.no/atc_ddd_index/?code=J01DH56&showdescription=no)), isepamicin (`ISE`, [J01GB11](https://www.whocc.no/atc_ddd_index/?code=J01GB11&showdescription=no)), josamycin (`JOS`, [J01FA07](https://www.whocc.no/atc_ddd_index/?code=J01FA07&showdescription=no)), kanamycin (`KAN`, [J01GB04](https://www.whocc.no/atc_ddd_index/?code=J01GB04&showdescription=no)), lascufloxacin (`LSC`, [J01MA25](https://www.whocc.no/atc_ddd_index/?code=J01MA25&showdescription=no)), latamoxef (`LTM`, [J01DD06](https://www.whocc.no/atc_ddd_index/?code=J01DD06&showdescription=no)), levofloxacin (`LVX`, [J01MA12](https://www.whocc.no/atc_ddd_index/?code=J01MA12&showdescription=no)), levonadifloxacin (`LND`, [J01MA24](https://www.whocc.no/atc_ddd_index/?code=J01MA24&showdescription=no)), lincomycin (`LIN`, [J01FF02](https://www.whocc.no/atc_ddd_index/?code=J01FF02&showdescription=no)), linezolid (`LNZ`, [J01XX08](https://www.whocc.no/atc_ddd_index/?code=J01XX08&showdescription=no)), lomefloxacin (`LOM`, [J01MA07](https://www.whocc.no/atc_ddd_index/?code=J01MA07&showdescription=no)), loracarbef (`LOR`, [J01DC08](https://www.whocc.no/atc_ddd_index/?code=J01DC08&showdescription=no)), mecillinam (`MEC`, [J01CA11](https://www.whocc.no/atc_ddd_index/?code=J01CA11&showdescription=no)), meropenem (`MEM`, [J01DH02](https://www.whocc.no/atc_ddd_index/?code=J01DH02&showdescription=no)), meropenem/vaborbactam (`MEV`, [J01DH52](https://www.whocc.no/atc_ddd_index/?code=J01DH52&showdescription=no)), metampicillin (`MTM`, [J01CA14](https://www.whocc.no/atc_ddd_index/?code=J01CA14&showdescription=no)), meticillin (`MET`, [J01CF03](https://www.whocc.no/atc_ddd_index/?code=J01CF03&showdescription=no)), mezlocillin (`MEZ`, [J01CA10](https://www.whocc.no/atc_ddd_index/?code=J01CA10&showdescription=no)), micronomicin (`MCR`, [S01AA22](https://www.whocc.no/atc_ddd_index/?code=S01AA22&showdescription=no)), midecamycin (`MID`, [J01FA03](https://www.whocc.no/atc_ddd_index/?code=J01FA03&showdescription=no)), minocycline (`MNO`, [J01AA08](https://www.whocc.no/atc_ddd_index/?code=J01AA08&showdescription=no)), miocamycin (`MCM`, [J01FA11](https://www.whocc.no/atc_ddd_index/?code=J01FA11&showdescription=no)), moxifloxacin (`MFX`, [J01MA14](https://www.whocc.no/atc_ddd_index/?code=J01MA14&showdescription=no)), nadifloxacin (`NAD`, [D10AF05](https://www.whocc.no/atc_ddd_index/?code=D10AF05&showdescription=no)), nafcillin (`NAF`, [J01CF06](https://www.whocc.no/atc_ddd_index/?code=J01CF06&showdescription=no)), nalidixic acid (`NAL`, [J01MB02](https://www.whocc.no/atc_ddd_index/?code=J01MB02&showdescription=no)), neomycin (`NEO`, [J01GB05](https://www.whocc.no/atc_ddd_index/?code=J01GB05&showdescription=no)), netilmicin (`NET`, [J01GB07](https://www.whocc.no/atc_ddd_index/?code=J01GB07&showdescription=no)), nitrofurantoin (`NIT`, [J01XE01](https://www.whocc.no/atc_ddd_index/?code=J01XE01&showdescription=no)), norfloxacin (`NOR`, [J01MA06](https://www.whocc.no/atc_ddd_index/?code=J01MA06&showdescription=no)), ofloxacin (`OFX`, [J01MA01](https://www.whocc.no/atc_ddd_index/?code=J01MA01&showdescription=no)), oleandomycin (`OLE`, [J01FA05](https://www.whocc.no/atc_ddd_index/?code=J01FA05&showdescription=no)), oritavancin (`ORI`, [J01XA05](https://www.whocc.no/atc_ddd_index/?code=J01XA05&showdescription=no)), oxacillin (`OXA`, [J01CF04](https://www.whocc.no/atc_ddd_index/?code=J01CF04&showdescription=no)), panipenem (`PAN`, [J01DH55](https://www.whocc.no/atc_ddd_index/?code=J01DH55&showdescription=no)), pazufloxacin (`PAZ`, [J01MA18](https://www.whocc.no/atc_ddd_index/?code=J01MA18&showdescription=no)), pefloxacin (`PEF`, [J01MA03](https://www.whocc.no/atc_ddd_index/?code=J01MA03&showdescription=no)), penamecillin (`PNM`, [J01CE06](https://www.whocc.no/atc_ddd_index/?code=J01CE06&showdescription=no)), pheneticillin (`PHE`, [J01CE05](https://www.whocc.no/atc_ddd_index/?code=J01CE05&showdescription=no)), phenoxymethylpenicillin (`PHN`, [J01CE02](https://www.whocc.no/atc_ddd_index/?code=J01CE02&showdescription=no)), piperacillin (`PIP`, [J01CA12](https://www.whocc.no/atc_ddd_index/?code=J01CA12&showdescription=no)), piperacillin/tazobactam (`TZP`, [J01CR05](https://www.whocc.no/atc_ddd_index/?code=J01CR05&showdescription=no)), pivampicillin (`PVM`, [J01CA02](https://www.whocc.no/atc_ddd_index/?code=J01CA02&showdescription=no)), pivmecillinam (`PME`, [J01CA08](https://www.whocc.no/atc_ddd_index/?code=J01CA08&showdescription=no)), plazomicin (`PLZ`, [J01GB14](https://www.whocc.no/atc_ddd_index/?code=J01GB14&showdescription=no)), polymyxin B (`PLB`, [J01XB02](https://www.whocc.no/atc_ddd_index/?code=J01XB02&showdescription=no)), pristinamycin (`PRI`, [J01FG01](https://www.whocc.no/atc_ddd_index/?code=J01FG01&showdescription=no)), procaine benzylpenicillin (`PRB`, [J01CE09](https://www.whocc.no/atc_ddd_index/?code=J01CE09&showdescription=no)), propicillin (`PRP`, [J01CE03](https://www.whocc.no/atc_ddd_index/?code=J01CE03&showdescription=no)), prulifloxacin (`PRU`, [J01MA17](https://www.whocc.no/atc_ddd_index/?code=J01MA17&showdescription=no)), quinupristin/dalfopristin (`QDA`, [J01FG02](https://www.whocc.no/atc_ddd_index/?code=J01FG02&showdescription=no)), ribostamycin (`RST`, [J01GB10](https://www.whocc.no/atc_ddd_index/?code=J01GB10&showdescription=no)), rifampicin (`RIF`, [J04AB02](https://www.whocc.no/atc_ddd_index/?code=J04AB02&showdescription=no)), rokitamycin (`ROK`, [J01FA12](https://www.whocc.no/atc_ddd_index/?code=J01FA12&showdescription=no)), roxithromycin (`RXT`, [J01FA06](https://www.whocc.no/atc_ddd_index/?code=J01FA06&showdescription=no)), rufloxacin (`RFL`, [J01MA10](https://www.whocc.no/atc_ddd_index/?code=J01MA10&showdescription=no)), sisomicin (`SIS`, [J01GB08](https://www.whocc.no/atc_ddd_index/?code=J01GB08&showdescription=no)), sitafloxacin (`SIT`, [J01MA21](https://www.whocc.no/atc_ddd_index/?code=J01MA21&showdescription=no)), solithromycin (`SOL`, [J01FA16](https://www.whocc.no/atc_ddd_index/?code=J01FA16&showdescription=no)), sparfloxacin (`SPX`, [J01MA09](https://www.whocc.no/atc_ddd_index/?code=J01MA09&showdescription=no)), spiramycin (`SPI`, [J01FA02](https://www.whocc.no/atc_ddd_index/?code=J01FA02&showdescription=no)), streptoduocin (`STR`, [J01GA02](https://www.whocc.no/atc_ddd_index/?code=J01GA02&showdescription=no)), streptomycin (`STR1`, [J01GA01](https://www.whocc.no/atc_ddd_index/?code=J01GA01&showdescription=no)), sulbactam (`SUL`, [J01CG01](https://www.whocc.no/atc_ddd_index/?code=J01CG01&showdescription=no)), sulbenicillin (`SBC`, [J01CA16](https://www.whocc.no/atc_ddd_index/?code=J01CA16&showdescription=no)), sulfadiazine (`SDI`, [J01EC02](https://www.whocc.no/atc_ddd_index/?code=J01EC02&showdescription=no)), sulfadiazine/trimethoprim (`SLT1`, [J01EE02](https://www.whocc.no/atc_ddd_index/?code=J01EE02&showdescription=no)), sulfadimethoxine (`SUD`, [J01ED01](https://www.whocc.no/atc_ddd_index/?code=J01ED01&showdescription=no)), sulfadimidine (`SDM`, [J01EB03](https://www.whocc.no/atc_ddd_index/?code=J01EB03&showdescription=no)), sulfadimidine/trimethoprim (`SLT2`, [J01EE05](https://www.whocc.no/atc_ddd_index/?code=J01EE05&showdescription=no)), sulfafurazole (`SLF`, [J01EB05](https://www.whocc.no/atc_ddd_index/?code=J01EB05&showdescription=no)), sulfaisodimidine (`SLF1`, [J01EB01](https://www.whocc.no/atc_ddd_index/?code=J01EB01&showdescription=no)), sulfalene (`SLF2`, [J01ED02](https://www.whocc.no/atc_ddd_index/?code=J01ED02&showdescription=no)), sulfamazone (`SZO`, [J01ED09](https://www.whocc.no/atc_ddd_index/?code=J01ED09&showdescription=no)), sulfamerazine (`SLF3`, [J01ED07](https://www.whocc.no/atc_ddd_index/?code=J01ED07&showdescription=no)), sulfamerazine/trimethoprim (`SLT3`, [J01EE07](https://www.whocc.no/atc_ddd_index/?code=J01EE07&showdescription=no)), sulfamethizole (`SLF4`, [J01EB02](https://www.whocc.no/atc_ddd_index/?code=J01EB02&showdescription=no)), sulfamethoxazole (`SMX`, [J01EC01](https://www.whocc.no/atc_ddd_index/?code=J01EC01&showdescription=no)), sulfamethoxypyridazine (`SLF5`, [J01ED05](https://www.whocc.no/atc_ddd_index/?code=J01ED05&showdescription=no)), sulfametomidine (`SLF6`, [J01ED03](https://www.whocc.no/atc_ddd_index/?code=J01ED03&showdescription=no)), sulfametoxydiazine (`SLF7`, [J01ED04](https://www.whocc.no/atc_ddd_index/?code=J01ED04&showdescription=no)), sulfametrole/trimethoprim (`SLT4`, [J01EE03](https://www.whocc.no/atc_ddd_index/?code=J01EE03&showdescription=no)), sulfamoxole (`SLF8`, [J01EC03](https://www.whocc.no/atc_ddd_index/?code=J01EC03&showdescription=no)), sulfamoxole/trimethoprim (`SLT5`, [J01EE04](https://www.whocc.no/atc_ddd_index/?code=J01EE04&showdescription=no)), sulfanilamide (`SLF9`, [J01EB06](https://www.whocc.no/atc_ddd_index/?code=J01EB06&showdescription=no)), sulfaperin (`SLF10`, [J01ED06](https://www.whocc.no/atc_ddd_index/?code=J01ED06&showdescription=no)), sulfaphenazole (`SLF11`, [J01ED08](https://www.whocc.no/atc_ddd_index/?code=J01ED08&showdescription=no)), sulfapyridine (`SLF12`, [J01EB04](https://www.whocc.no/atc_ddd_index/?code=J01EB04&showdescription=no)), sulfathiazole (`SUT`, [J01EB07](https://www.whocc.no/atc_ddd_index/?code=J01EB07&showdescription=no)), sulfathiourea (`SLF13`, [J01EB08](https://www.whocc.no/atc_ddd_index/?code=J01EB08&showdescription=no)), sultamicillin (`SLT6`, [J01CR04](https://www.whocc.no/atc_ddd_index/?code=J01CR04&showdescription=no)), talampicillin (`TAL`, [J01CA15](https://www.whocc.no/atc_ddd_index/?code=J01CA15&showdescription=no)), tazobactam (`TAZ`, [J01CG02](https://www.whocc.no/atc_ddd_index/?code=J01CG02&showdescription=no)), tebipenem (`TBP`, [J01DH06](https://www.whocc.no/atc_ddd_index/?code=J01DH06&showdescription=no)), tedizolid (`TZD`, [J01XX11](https://www.whocc.no/atc_ddd_index/?code=J01XX11&showdescription=no)), teicoplanin (`TEC`, [J01XA02](https://www.whocc.no/atc_ddd_index/?code=J01XA02&showdescription=no)), telavancin (`TLV`, [J01XA03](https://www.whocc.no/atc_ddd_index/?code=J01XA03&showdescription=no)), telithromycin (`TLT`, [J01FA15](https://www.whocc.no/atc_ddd_index/?code=J01FA15&showdescription=no)), temafloxacin (`TMX`, [J01MA05](https://www.whocc.no/atc_ddd_index/?code=J01MA05&showdescription=no)), temocillin (`TEM`, [J01CA17](https://www.whocc.no/atc_ddd_index/?code=J01CA17&showdescription=no)), tetracycline (`TCY`, [J01AA07](https://www.whocc.no/atc_ddd_index/?code=J01AA07&showdescription=no)), ticarcillin (`TIC`, [J01CA13](https://www.whocc.no/atc_ddd_index/?code=J01CA13&showdescription=no)), ticarcillin/clavulanic acid (`TCC`, [J01CR03](https://www.whocc.no/atc_ddd_index/?code=J01CR03&showdescription=no)), tigecycline (`TGC`, [J01AA12](https://www.whocc.no/atc_ddd_index/?code=J01AA12&showdescription=no)), tilbroquinol (`TBQ`, [P01AA05](https://www.whocc.no/atc_ddd_index/?code=P01AA05&showdescription=no)), tobramycin (`TOB`, [J01GB01](https://www.whocc.no/atc_ddd_index/?code=J01GB01&showdescription=no)), tosufloxacin (`TFX`, [J01MA22](https://www.whocc.no/atc_ddd_index/?code=J01MA22&showdescription=no)), trimethoprim (`TMP`, [J01EA01](https://www.whocc.no/atc_ddd_index/?code=J01EA01&showdescription=no)), trimethoprim/sulfamethoxazole (`SXT`, [J01EE01](https://www.whocc.no/atc_ddd_index/?code=J01EE01&showdescription=no)), troleandomycin (`TRL`, [J01FA08](https://www.whocc.no/atc_ddd_index/?code=J01FA08&showdescription=no)), trovafloxacin (`TVA`, [J01MA13](https://www.whocc.no/atc_ddd_index/?code=J01MA13&showdescription=no)), vancomycin (`VAN`, [J01XA01](https://www.whocc.no/atc_ddd_index/?code=J01XA01&showdescription=no)) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```ra <- data.frame(  mo = c(    ""Staphylococcus aureus"",    ""Enterococcus faecalis"",    ""Escherichia coli"",    ""Klebsiella pneumoniae"",    ""Pseudomonas aeruginosa""  ),  VAN = ""-"",  Vancomycin  AMX = ""-"",  Amoxicillin  COL = ""-"",  Colistin  CAZ = ""-"",  Ceftazidime  CXM = ""-"",  Cefuroxime  PEN = ""S"",  Benzylpenicillin  FOX = ""S"",  Cefoxitin  stringsAsFactors = FALSE)head(a) apply EUCAST rules: some results wil be changedb <- eucast_rules(a)head(b) do not apply EUCAST rules, but rather get a data.frame containing all details about the transformations:c <- eucast_rules(a, verbose = TRUE)head(c) Dosage guidelines:eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"")eucast_dosage(c(""tobra"", ""genta"", ""cipro""), ""iv"", version_breakpoints = 10)```",6
AMR,ggplot_sir.md,"# AMR Plots with `ggplot2`

```r
ggplot_sir(
  data,
  position = NULL,
  x = ""antibiotic"",
  fill = ""interpretation"",
  facet = NULL,
  breaks = seq(0, 1, 0.1),
  limits = NULL,
  translate_ab = ""name"",
  combine_SI = TRUE,
  minimum = 30,
  language = get_AMR_locale(),
  nrow = NULL,
  colours = c(S = ""#3CAEA3"", SI = ""#3CAEA3"", I = ""#F6D55C"", IR = ""#ED553B"", R =
    ""#ED553B""),
  datalabels = TRUE,
  datalabels.size = 2.5,
  datalabels.colour = ""grey15"",
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  x.title = ""Antimicrobial"",
  y.title = ""Proportion"",
  ...
)

geom_sir(
  position = NULL,
  x = c(""antibiotic"", ""interpretation""),
  fill = ""interpretation"",
  translate_ab = ""name"",
  minimum = 30,
  language = get_AMR_locale(),
  combine_SI = TRUE,
  ...
)

facet_sir(facet = c(""interpretation"", ""antibiotic""), nrow = NULL)

scale_y_percent(breaks = seq(0, 1, 0.1), limits = NULL)

scale_sir_colours(..., aesthetics = ""fill"")

theme_sir()

labels_sir_count(
  position = NULL,
  x = ""antibiotic"",
  translate_ab = ""name"",
  minimum = 30,
  language = get_AMR_locale(),
  combine_SI = TRUE,
  datalabels.size = 3,
  datalabels.colour = ""grey15""
)
```

## Arguments

- `data`: a data.frame with column(s) of class `sir` (see `as.sir()`)
- `position`: position adjustment of bars, either `""fill""`, `""stack""` or `""dodge""`
- `x`: variable to show on x axis, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable
- `fill`: variable to categorise using the plots legend, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable
- `facet`: variable to split plots by, either `""interpretation""` (default) or `""antibiotic""` or a grouping variable
- `breaks`: a numeric vector of positions
- `limits`: a numeric vector of length two providing limits of the scale, use `NA` to refer to the existing minimum or maximum
- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`
- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`
- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see **Source**.
- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `nrow`: (when using `facet`) number of rows
- `colours`: a named vactor with colour to be used for filling. The default colours are colour-blind friendly.
- `datalabels`: show datalabels using `labels_sir_count()`
- `datalabels.size`: size of the datalabels
- `datalabels.colour`: colour of the datalabels
- `title`: text to show as title of the plot
- `subtitle`: text to show as subtitle of the plot
- `caption`: text to show as caption of the plot
- `x.title`: text to show as x axis description
- `y.title`: text to show as y axis description
- `...`: other arguments passed on to `geom_sir()` or, in case of `scale_sir_colours()`, named values to set colours. The default colours are colour-blind friendly, while maintaining the convention that e.g. 'susceptible' should be green and 'resistant' should be red. See **Examples**.
- `aesthetics`: aesthetics to apply the colours to - the default is ""fill"" but can also be (a combination of) ""alpha"", ""colour"", ""fill"", ""linetype"", ""shape"" or ""size""

## Description

Use these functions to create bar plots for AMR data analysis. All functions rely on ggplot2 functions.

## Details

At default, the names of antibiotics will be shown on the plots using `ab_name()`. This can be set with the `translate_ab` argument. See `count_df()`.

### The Functions

`geom_sir()` will take any variable from the data that has an `sir` class (created with `as.sir()`) using `sir_df()` and will plot bars with the percentage S, I, and R. The default behaviour is to have the bars stacked and to have the different antibiotics on the x axis. `facet_sir()` creates 2d plots (at default based on S/I/R) using `ggplot2::facet_wrap()`. `scale_y_percent()` transforms the y axis to a 0 to 100% range using `ggplot2::scale_y_continuous()`. `scale_sir_colours()` sets colours to the bars (green for S, yellow for I, and red for R). with multilingual support. The default colours are colour-blind friendly, while maintaining the convention that e.g. 'susceptible' should be green and 'resistant' should be red. `theme_sir()` is a [ggplot2 theme][`ggplot2::theme()` with minimal distraction. `labels_sir_count()` print datalabels on the bars with percentage and amount of isolates using `ggplot2::geom_text()`. `ggplot_sir()` is a wrapper around all above functions that uses data as first input. This makes it possible to use this function after a pipe (`%>%`). See **Examples**.

## Examples

```r
if (require(""ggplot2"") && require(""dplyr"")) {
  # get antimicrobial results for drugs against a UTI:
  ggplot(example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)) +
    geom_sir()
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # prettify the plot using some additional functions:
  df <- example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)
  ggplot(df) +
    geom_sir() +
    scale_y_percent() +
    scale_sir_colours() +
    labels_sir_count() +
    theme_sir()
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # or better yet, simplify this using the wrapper function - a single command:
  example_isolates %>%
    select(AMX, NIT, FOS, TMP, CIP) %>%
    ggplot_sir()
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # get only proportions and no counts:
  example_isolates %>%
    select(AMX, NIT, FOS, TMP, CIP) %>%
    ggplot_sir(datalabels = FALSE)
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # add other ggplot2 arguments as you like:
  example_isolates %>%
    select(AMX, NIT, FOS, TMP, CIP) %>%
    ggplot_sir(
      width = 0.5,
      colour = ""black"",
      size = 1,
      linetype = 2,
      alpha = 0.25
    )
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # you can alter the colours with colour names:
  example_isolates %>%
    select(AMX) %>%
    ggplot_sir(colours = c(SI = ""yellow""))
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # but you can also use the built-in colour-blind friendly colours for
  # your plots, where ""S"" is green, ""I"" is yellow and ""R"" is red:
  data.frame(
    x = c(""Value1"", ""Value2"", ""Value3""),
    y = c(1, 2, 3),
    z = c(""Value4"", ""Value5"", ""Value6"")
  ) %>%
    ggplot() +
    geom_col(aes(x = x, y = y, fill = z)) +
    scale_sir_colours(Value4 = ""S"", Value5 = ""I"", Value6 = ""R"")
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # resistance of ciprofloxacine per age group
  example_isolates %>%
    mutate(first_isolate = first_isolate()) %>%
    filter(
      first_isolate == TRUE,
      mo == as.mo(""Escherichia coli"")
    ) %>%
    # age_groups() is also a function in this AMR package:
    group_by(age_group = age_groups(age)) %>%
    select(age_group, CIP) %>%
    ggplot_sir(x = ""age_group"")
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # a shorter version which also adjusts data label colours:
  example_isolates %>%
    select(AMX, NIT, FOS, TMP, CIP) %>%
    ggplot_sir(colours = FALSE)
}
if (require(""ggplot2"") && require(""dplyr"")) {
  # it also supports groups (don't forget to use the group var on `x` or `facet`):
  example_isolates %>%
    filter(mo_is_gram_negative(), ward != ""Outpatient"") %>%
    # select only UTI-specific drugs
    select(ward, AMX, NIT, FOS, TMP, CIP) %>%
    group_by(ward) %>%
    ggplot_sir(
      x = ""ward"",
      facet = ""antibiotic"",
      nrow = 1,
      title = ""AMR of Anti-UTI Drugs Per Ward"",
      x.title = ""Ward"",
      datalabels = FALSE
    )
}
```



","['AMR Plots with `ggplot2````rggplot_sir(  data,  position = NULL,  x = ""antibiotic"",  fill = ""interpretation"",  facet = NULL,  breaks = seq(0, 1, 0.1),  limits = NULL,  translate_ab = ""name"",  combine_SI = TRUE,  minimum = 30,  language = get_AMR_locale(),  nrow = NULL,  colours = c(S = ""3CAEA3"", SI = ""3CAEA3"", I = ""F6D55C"", IR = ""ED553B"", R =    ""ED553B""),  datalabels = TRUE,  datalabels.size = 2.5,  datalabels.colour = ""grey15"",  title = NULL,  subtitle = NULL,  caption = NULL,  x.title = ""Antimicrobial"",  y.title = ""Proportion"",  ...)geom_sir(  position = NULL,  x = c(""antibiotic"", ""interpretation""),  fill = ""interpretation"",  translate_ab = ""name"",  minimum = 30,  language = get_AMR_locale(),  combine_SI = TRUE,  ...)facet_sir(facet = c(""interpretation"", ""antibiotic""), nrow = NULL)scale_y_percent(breaks = seq(0, 1, 0.1), limits = NULL)scale_sir_colours(..., aesthetics = ""fill"")theme_sir()labels_sir_count(  position = NULL,  x = ""antibiotic"",  translate_ab = ""name"",  minimum = 30,  language = get_AMR_locale(),  combine_SI = TRUE,  datalabels.size = 3,  datalabels.colour = ""grey15"")``` Arguments- `data`: a data.frame with column(s) of class `sir` (see `as.sir()`)- `position`: position adjustment of bars, either `""fill""`, `""stack""` or `""dodge""`- `x`: variable to show on x axis, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable- `fill`: variable to categorise using the plots legend, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable- `facet`: variable to split plots by, either `""interpretation""` (default) or `""antibiotic""` or a grouping variable- `breaks`: a numeric vector of positions- `limits`: a numeric vector of length two providing limits of the scale, use `NA` to refer to the existing minimum or maximum- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`- `minimum`: the minimum allowed number of available (tested) isolates.', 'Any isolate count lower than `minimum` will return `NA` with a warning.', 'The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `nrow`: (when using `facet`) number of rows- `colours`: a named vactor with colour to be used for filling.', 'The default colours are colour-blind friendly.- `datalabels`: show datalabels using `labels_sir_count()`- `datalabels.size`: size of the datalabels- `datalabels.colour`: colour of the datalabels- `title`: text to show as title of the plot- `subtitle`: text to show as subtitle of the plot- `caption`: text to show as caption of the plot- `x.title`: text to show as x axis description- `y.title`: text to show as y axis description- `...`: other arguments passed on to `geom_sir()` or, in case of `scale_sir_colours()`, named values to set colours.', 'The default colours are colour-blind friendly, while maintaining the convention that e.g.', ""'susceptible' should be green and 'resistant' should be red."", 'See Examples.- `aesthetics`: aesthetics to apply the colours to - the default is ""fill"" but can also be (a combination of) ""alpha"", ""colour"", ""fill"", ""linetype"", ""shape"" or ""size"" DescriptionUse these functions to create bar plots for AMR data analysis.', 'All functions rely on ggplot2 functions.', 'DetailsAt default, the names of antibiotics will be shown on the plots using `ab_name()`.', 'This can be set with the `translate_ab` argument.', 'The Functions`geom_sir()` will take any variable from the data that has an `sir` class (created with `as.sir()`) using `sir_df()` and will plot bars with the percentage S, I, and R. The default behaviour is to have the bars stacked and to have the different antibiotics on the x axis.', '`facet_sir()` creates 2d plots (at default based on S/I/R) using `ggplot2::facet_wrap()`.', '`scale_y_percent()` transforms the y axis to a 0 to 100% range using `ggplot2::scale_y_continuous()`.', '`scale_sir_colours()` sets colours to the bars (green for S, yellow for I, and red for R).', 'The default colours are colour-blind friendly, while maintaining the convention that e.g.', ""'susceptible' should be green and 'resistant' should be red."", '`theme_sir()` is a [ggplot2 theme][`ggplot2::theme()` with minimal distraction.', '`labels_sir_count()` print datalabels on the bars with percentage and amount of isolates using `ggplot2::geom_text()`.', '`ggplot_sir()` is a wrapper around all above functions that uses data as first input.', 'This makes it possible to use this function after a pipe (`%>%`).', 'Examples```rif (require(""ggplot2"") && require(""dplyr"")) {   get antimicrobial results for drugs against a UTI:  ggplot(example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)) +    geom_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   prettify the plot using some additional functions:  df <- example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)  ggplot(df) +    geom_sir() +    scale_y_percent() +    scale_sir_colours() +    labels_sir_count() +    theme_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   or better yet, simplify this using the wrapper function - a single command:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   get only proportions and no counts:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(datalabels = FALSE)}if (require(""ggplot2"") && require(""dplyr"")) {   add other ggplot2 arguments as you like:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(      width = 0.5,      colour = ""black"",      size = 1,      linetype = 2,      alpha = 0.25    )}if (require(""ggplot2"") && require(""dplyr"")) {   you can alter the colours with colour names:  example_isolates %>%    select(AMX) %>%    ggplot_sir(colours = c(SI = ""yellow""))}if (require(""ggplot2"") && require(""dplyr"")) {   but you can also use the built-in colour-blind friendly colours for   your plots, where ""S"" is green, ""I"" is yellow and ""R"" is red:  data.frame(    x = c(""Value1"", ""Value2"", ""Value3""),    y = c(1, 2, 3),    z = c(""Value4"", ""Value5"", ""Value6"")  ) %>%    ggplot() +    geom_col(aes(x = x, y = y, fill = z)) +    scale_sir_colours(Value4 = ""S"", Value5 = ""I"", Value6 = ""R"")}if (require(""ggplot2"") && require(""dplyr"")) {   resistance of ciprofloxacine per age group  example_isolates %>%    mutate(first_isolate = first_isolate()) %>%    filter(      first_isolate == TRUE,      mo == as.mo(""Escherichia coli"")    ) %>%     age_groups() is also a function in this AMR package:    group_by(age_group = age_groups(age)) %>%    select(age_group, CIP) %>%    ggplot_sir(x = ""age_group"")}if (require(""ggplot2"") && require(""dplyr"")) {   a shorter version which also adjusts data label colours:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(colours = FALSE)}if (require(""ggplot2"") && require(""dplyr"")) {   it also supports groups (don\'t forget to use the group var on `x` or `facet`):  example_isolates %>%    filter(mo_is_gram_negative(), ward != ""Outpatient"") %>%     select only UTI-specific drugs    select(ward, AMX, NIT, FOS, TMP, CIP) %>%    group_by(ward) %>%    ggplot_sir(      x = ""ward"",      facet = ""antibiotic"",      nrow = 1,      title = ""AMR of Anti-UTI Drugs Per Ward"",      x.title = ""Ward"",      datalabels = FALSE    )}```']",1," AMR Plots with `ggplot2````rggplot_sir(  data,  position = NULL,  x = ""antibiotic"",  fill = ""interpretation"",  facet = NULL,  breaks = seq(0, 1, 0.1),  limits = NULL,  translate_ab = ""name"",  combine_SI = TRUE,  minimum = 30,  language = get_AMR_locale(),  nrow = NULL,  colours = c(S = ""3CAEA3"", SI = ""3CAEA3"", I = ""F6D55C"", IR = ""ED553B"", R =    ""ED553B""),  datalabels = TRUE,  datalabels.size = 2.5,  datalabels.colour = ""grey15"",  title = NULL,  subtitle = NULL,  caption = NULL,  x.title = ""Antimicrobial"",  y.title = ""Proportion"",  ...)geom_sir(  position = NULL,  x = c(""antibiotic"", ""interpretation""),  fill = ""interpretation"",  translate_ab = ""name"",  minimum = 30,  language = get_AMR_locale(),  combine_SI = TRUE,  ...)facet_sir(facet = c(""interpretation"", ""antibiotic""), nrow = NULL)scale_y_percent(breaks = seq(0, 1, 0.1), limits = NULL)scale_sir_colours(..., aesthetics = ""fill"")theme_sir()labels_sir_count(  position = NULL,  x = ""antibiotic"",  translate_ab = ""name"",  minimum = 30,  language = get_AMR_locale(),  combine_SI = TRUE,  datalabels.size = 3,  datalabels.colour = ""grey15"")``` Arguments- `data`: a data.frame with column(s) of class `sir` (see `as.sir()`)- `position`: position adjustment of bars, either `""fill""`, `""stack""` or `""dodge""`- `x`: variable to show on x axis, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable- `fill`: variable to categorise using the plots legend, either `""antibiotic""` (default) or `""interpretation""` or a grouping variable- `facet`: variable to split plots by, either `""interpretation""` (default) or `""antibiotic""` or a grouping variable- `breaks`: a numeric vector of positions- `limits`: a numeric vector of length two providing limits of the scale, use `NA` to refer to the existing minimum or maximum- `translate_ab`: a column name of the antibiotics data set to translate the antibiotic abbreviations to, using `ab_property()`- `combine_SI`: a logical to indicate whether all values of S and I must be merged into one, so the output only consists of S+I vs. R (susceptible vs. resistant) - the default is `TRUE`- `minimum`: the minimum allowed number of available (tested) isolates. Any isolate count lower than `minimum` will return `NA` with a warning. The default number of `30` isolates is advised by the Clinical and Laboratory Standards Institute (CLSI) as best practice, see Source.- `language`: language of the returned text - the default is the current system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `nrow`: (when using `facet`) number of rows- `colours`: a named vactor with colour to be used for filling. The default colours are colour-blind friendly.- `datalabels`: show datalabels using `labels_sir_count()`- `datalabels.size`: size of the datalabels- `datalabels.colour`: colour of the datalabels- `title`: text to show as title of the plot- `subtitle`: text to show as subtitle of the plot- `caption`: text to show as caption of the plot- `x.title`: text to show as x axis description- `y.title`: text to show as y axis description- `...`: other arguments passed on to `geom_sir()` or, in case of `scale_sir_colours()`, named values to set colours. The default colours are colour-blind friendly, while maintaining the convention that e.g. 'susceptible' should be green and 'resistant' should be red. See Examples.- `aesthetics`: aesthetics to apply the colours to - the default is ""fill"" but can also be (a combination of) ""alpha"", ""colour"", ""fill"", ""linetype"", ""shape"" or ""size"" DescriptionUse these functions to create bar plots for AMR data analysis. All functions rely on ggplot2 functions. DetailsAt default, the names of antibiotics will be shown on the plots using `ab_name()`. This can be set with the `translate_ab` argument. See `count_df()`. The Functions`geom_sir()` will take any variable from the data that has an `sir` class (created with `as.sir()`) using `sir_df()` and will plot bars with the percentage S, I, and R. The default behaviour is to have the bars stacked and to have the different antibiotics on the x axis. `facet_sir()` creates 2d plots (at default based on S/I/R) using `ggplot2::facet_wrap()`. `scale_y_percent()` transforms the y axis to a 0 to 100% range using `ggplot2::scale_y_continuous()`. `scale_sir_colours()` sets colours to the bars (green for S, yellow for I, and red for R). with multilingual support. The default colours are colour-blind friendly, while maintaining the convention that e.g. 'susceptible' should be green and 'resistant' should be red. `theme_sir()` is a [ggplot2 theme][`ggplot2::theme()` with minimal distraction. `labels_sir_count()` print datalabels on the bars with percentage and amount of isolates using `ggplot2::geom_text()`. `ggplot_sir()` is a wrapper around all above functions that uses data as first input. This makes it possible to use this function after a pipe (`%>%`). See Examples. Examples```rif (require(""ggplot2"") && require(""dplyr"")) {   get antimicrobial results for drugs against a UTI:  ggplot(example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)) +    geom_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   prettify the plot using some additional functions:  df <- example_isolates %>% select(AMX, NIT, FOS, TMP, CIP)  ggplot(df) +    geom_sir() +    scale_y_percent() +    scale_sir_colours() +    labels_sir_count() +    theme_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   or better yet, simplify this using the wrapper function - a single command:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir()}if (require(""ggplot2"") && require(""dplyr"")) {   get only proportions and no counts:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(datalabels = FALSE)}if (require(""ggplot2"") && require(""dplyr"")) {   add other ggplot2 arguments as you like:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(      width = 0.5,      colour = ""black"",      size = 1,      linetype = 2,      alpha = 0.25    )}if (require(""ggplot2"") && require(""dplyr"")) {   you can alter the colours with colour names:  example_isolates %>%    select(AMX) %>%    ggplot_sir(colours = c(SI = ""yellow""))}if (require(""ggplot2"") && require(""dplyr"")) {   but you can also use the built-in colour-blind friendly colours for   your plots, where ""S"" is green, ""I"" is yellow and ""R"" is red:  data.frame(    x = c(""Value1"", ""Value2"", ""Value3""),    y = c(1, 2, 3),    z = c(""Value4"", ""Value5"", ""Value6"")  ) %>%    ggplot() +    geom_col(aes(x = x, y = y, fill = z)) +    scale_sir_colours(Value4 = ""S"", Value5 = ""I"", Value6 = ""R"")}if (require(""ggplot2"") && require(""dplyr"")) {   resistance of ciprofloxacine per age group  example_isolates %>%    mutate(first_isolate = first_isolate()) %>%    filter(      first_isolate == TRUE,      mo == as.mo(""Escherichia coli"")    ) %>%     age_groups() is also a function in this AMR package:    group_by(age_group = age_groups(age)) %>%    select(age_group, CIP) %>%    ggplot_sir(x = ""age_group"")}if (require(""ggplot2"") && require(""dplyr"")) {   a shorter version which also adjusts data label colours:  example_isolates %>%    select(AMX, NIT, FOS, TMP, CIP) %>%    ggplot_sir(colours = FALSE)}if (require(""ggplot2"") && require(""dplyr"")) {   it also supports groups (don't forget to use the group var on `x` or `facet`):  example_isolates %>%    filter(mo_is_gram_negative(), ward != ""Outpatient"") %>%     select only UTI-specific drugs    select(ward, AMX, NIT, FOS, TMP, CIP) %>%    group_by(ward) %>%    ggplot_sir(      x = ""ward"",      facet = ""antibiotic"",      nrow = 1,      title = ""AMR of Anti-UTI Drugs Per Ward"",      x.title = ""Ward"",      datalabels = FALSE    )}```",6
AMR,av_property.md,"# Get Properties of an Antiviral Drug

```r
av_name(x, language = get_AMR_locale(), tolower = FALSE, ...)

av_cid(x, ...)

av_synonyms(x, ...)

av_tradenames(x, ...)

av_group(x, language = get_AMR_locale(), ...)

av_atc(x, ...)

av_loinc(x, ...)

av_ddd(x, administration = ""oral"", ...)

av_ddd_units(x, administration = ""oral"", ...)

av_info(x, language = get_AMR_locale(), ...)

av_url(x, open = FALSE, ...)

av_property(x, property = ""name"", language = get_AMR_locale(), ...)
```

## Arguments

- `x`: any (vector of) text that can be coerced to a valid antiviral drug code with `as.av()`
- `language`: language of the returned text - the default is system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.
- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character .
- `...`: other arguments passed on to `as.av()`
- `administration`: way of administration, either `""oral""` or `""iv""`
- `open`: browse the URL using `utils::browseURL()`
- `property`: one of the column names of one of the antivirals data set: `vector_or(colnames(antivirals), sort = FALSE)`.

## Returns

 * An integer in case of `av_cid()`
 * A named list in case of `av_info()` and multiple `av_atc()`/`av_synonyms()`/`av_tradenames()`
 * A double in case of `av_ddd()`
 * A character in all other cases

## Description

Use these functions to return a specific property of an antiviral drug from the antivirals data set. All input values will be evaluated internally with `as.av()`.

## Details

All output will be translated where possible.

The function `av_url()` will return the direct URL to the official WHO website. A warning will be returned if the required ATC code is not available.

## Source

 World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)

European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm)

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# all properties:
av_name(""ACI"")
av_atc(""ACI"")
av_cid(""ACI"")
av_synonyms(""ACI"")
av_tradenames(""ACI"")
av_group(""ACI"")
av_url(""ACI"")

# lowercase transformation
av_name(x = c(""ACI"", ""VALA""))
av_name(x = c(""ACI"", ""VALA""), tolower = TRUE)

# defined daily doses (DDD)
av_ddd(""ACI"", ""oral"")
av_ddd_units(""ACI"", ""oral"")
av_ddd(""ACI"", ""iv"")
av_ddd_units(""ACI"", ""iv"")

av_info(""ACI"") # all properties as a list

# all av_* functions use as.av() internally, so you can go from 'any' to 'any':
av_atc(""ACI"")
av_group(""J05AB01"")
av_loinc(""abacavir"")
av_name(""29113-8"")
av_name(135398513)
av_name(""J05AB01"")
```

## See Also

antivirals



","['Get Properties of an Antiviral Drug```rav_name(x, language = get_AMR_locale(), tolower = FALSE, ...)av_cid(x, ...)av_synonyms(x, ...)av_tradenames(x, ...)av_group(x, language = get_AMR_locale(), ...)av_atc(x, ...)av_loinc(x, ...)av_ddd(x, administration = ""oral"", ...)av_ddd_units(x, administration = ""oral"", ...)av_info(x, language = get_AMR_locale(), ...)av_url(x, open = FALSE, ...)av_property(x, property = ""name"", language = get_AMR_locale(), ...)``` Arguments- `x`: any (vector of) text that can be coerced to a valid antiviral drug code with `as.av()`- `language`: language of the returned text - the default is system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`.', 'Use `language = NULL` or `language = """"` to prevent translation.- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character .- `...`: other arguments passed on to `as.av()`- `administration`: way of administration, either `""oral""` or `""iv""`- `open`: browse the URL using `utils::browseURL()`- `property`: one of the column names of one of the antivirals data set: `vector_or(colnames(antivirals), sort = FALSE)`.', 'Returns  An integer in case of `av_cid()`  A named list in case of `av_info()` and multiple `av_atc()`/`av_synonyms()`/`av_tradenames()`  A double in case of `av_ddd()`  A character in all other cases DescriptionUse these functions to return a specific property of an antiviral drug from the antivirals data set.', 'All input values will be evaluated internally with `as.av()`.', 'DetailsAll output will be translated where possible.The function `av_url()` will return the direct URL to the official WHO website.', 'A warning will be returned if the required ATC code is not available.', 'Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r all properties:av_name(""ACI"")av_atc(""ACI"")av_cid(""ACI"")av_synonyms(""ACI"")av_tradenames(""ACI"")av_group(""ACI"")av_url(""ACI"") lowercase transformationav_name(x = c(""ACI"", ""VALA""))av_name(x = c(""ACI"", ""VALA""), tolower = TRUE) defined daily doses (DDD)av_ddd(""ACI"", ""oral"")av_ddd_units(""ACI"", ""oral"")av_ddd(""ACI"", ""iv"")av_ddd_units(""ACI"", ""iv"")av_info(""ACI"")  all properties as a list all av_ functions use as.av() internally, so you can go from \'any\' to \'any\':av_atc(""ACI"")av_group(""J05AB01"")av_loinc(""abacavir"")av_name(""29113-8"")av_name(135398513)av_name(""J05AB01"")``` See Alsoantivirals']",1," Get Properties of an Antiviral Drug```rav_name(x, language = get_AMR_locale(), tolower = FALSE, ...)av_cid(x, ...)av_synonyms(x, ...)av_tradenames(x, ...)av_group(x, language = get_AMR_locale(), ...)av_atc(x, ...)av_loinc(x, ...)av_ddd(x, administration = ""oral"", ...)av_ddd_units(x, administration = ""oral"", ...)av_info(x, language = get_AMR_locale(), ...)av_url(x, open = FALSE, ...)av_property(x, property = ""name"", language = get_AMR_locale(), ...)``` Arguments- `x`: any (vector of) text that can be coerced to a valid antiviral drug code with `as.av()`- `language`: language of the returned text - the default is system language (see `get_AMR_locale()`) and can also be set with the package option `AMR_locale`. Use `language = NULL` or `language = """"` to prevent translation.- `tolower`: a logical to indicate whether the first character of every output should be transformed to a lower case character .- `...`: other arguments passed on to `as.av()`- `administration`: way of administration, either `""oral""` or `""iv""`- `open`: browse the URL using `utils::browseURL()`- `property`: one of the column names of one of the antivirals data set: `vector_or(colnames(antivirals), sort = FALSE)`. Returns  An integer in case of `av_cid()`  A named list in case of `av_info()` and multiple `av_atc()`/`av_synonyms()`/`av_tradenames()`  A double in case of `av_ddd()`  A character in all other cases DescriptionUse these functions to return a specific property of an antiviral drug from the antivirals data set. All input values will be evaluated internally with `as.av()`. DetailsAll output will be translated where possible.The function `av_url()` will return the direct URL to the official WHO website. A warning will be returned if the required ATC code is not available. Source World Health Organization (WHO) Collaborating Centre for Drug Statistics Methodology: [https://www.whocc.no/atc_ddd_index/](https://www.whocc.no/atc_ddd_index/)European Commission Public Health PHARMACEUTICALS - COMMUNITY REGISTER: [https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm](https://ec.europa.eu/health/documents/community-register/html/reg_hum_atc.htm) Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r all properties:av_name(""ACI"")av_atc(""ACI"")av_cid(""ACI"")av_synonyms(""ACI"")av_tradenames(""ACI"")av_group(""ACI"")av_url(""ACI"") lowercase transformationav_name(x = c(""ACI"", ""VALA""))av_name(x = c(""ACI"", ""VALA""), tolower = TRUE) defined daily doses (DDD)av_ddd(""ACI"", ""oral"")av_ddd_units(""ACI"", ""oral"")av_ddd(""ACI"", ""iv"")av_ddd_units(""ACI"", ""iv"")av_info(""ACI"")  all properties as a list all av_ functions use as.av() internally, so you can go from 'any' to 'any':av_atc(""ACI"")av_group(""J05AB01"")av_loinc(""abacavir"")av_name(""29113-8"")av_name(135398513)av_name(""J05AB01"")``` See Alsoantivirals",6
AMR,translate.md,"# Translate Strings from the AMR Package

```r
get_AMR_locale()

set_AMR_locale(language)

reset_AMR_locale()

translate_AMR(x, language = get_AMR_locale())
```

## Arguments

- `language`: language to choose. Use one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk).
- `x`: text to translate

## Description

For language-dependent output of `AMR` functions, such as `mo_name()`, `mo_gramstain()`, `mo_type()` and `ab_name()`.

## Details

The currently 20 supported languages are English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), and Ukrainian (uk). All these languages have translations available for all antimicrobial drugs and colloquial microorganism names.

To permanently silence the once-per-session language note on a non-English operating system, you can set the package option `AMR_locale` in your `.Rprofile` file like this:

 

```
# Open .Rprofile file
utils::file.edit(""~/.Rprofile"")

# Then add e.g. Italian support to that file using:
options(AMR_locale = ""Italian"")
```

 

And then save the file.

Please read about adding or updating a language in [our Wiki](https://github.com/msberends/AMR/wiki/).

### Changing the Default Language

 The system language will be used at default (as returned by `Sys.getenv(""LANG"")` or, if `LANG` is not set, `Sys.getlocale(""LC_COLLATE"")`), if that language is supported. But the language to be used can be overwritten in two ways and will be checked in this order:

1. Setting the package option `AMR_locale`, either by using e.g. `set_AMR_locale(""German"")` or by running e.g. `options(AMR_locale = ""German"")`.
   
   Note that setting an option only works in the same session. Save the command `options(AMR_locale = ""(your language)"")` to your `.Rprofile` file to apply it for every session. Run `utils::file.edit(""~/.Rprofile"")` to edit your `.Rprofile` file.
2. Setting the system variable `LANGUAGE` or `LANG`, e.g. by adding `LANGUAGE=""de_DE.utf8""` to your `.Renviron` file in your home directory.

Thus, if the package option `AMR_locale` is set, the system variables `LANGUAGE` and `LANG` will be ignored.

## Examples

```r
# Current settings (based on system language)
ab_name(""Ciprofloxacin"")
mo_name(""Coagulase-negative Staphylococcus (CoNS)"")

# setting another language
set_AMR_locale(""Dutch"")
ab_name(""Ciprofloxacin"")
mo_name(""Coagulase-negative Staphylococcus (CoNS)"")

# setting yet another language
set_AMR_locale(""German"")
ab_name(""Ciprofloxacin"")
mo_name(""Coagulase-negative Staphylococcus (CoNS)"")

# set_AMR_locale() understands endonyms, English exonyms, and ISO-639-1:
set_AMR_locale(""Deutsch"")
set_AMR_locale(""German"")
set_AMR_locale(""de"")
ab_name(""amox/clav"")

# reset to system default
reset_AMR_locale()
ab_name(""amox/clav"")
```



","['Translate Strings from the AMR Package```rget_AMR_locale()set_AMR_locale(language)reset_AMR_locale()translate_AMR(x, language = get_AMR_locale())``` Arguments- `language`: language to choose.', 'Use one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk).- `x`: text to translate DescriptionFor language-dependent output of `AMR` functions, such as `mo_name()`, `mo_gramstain()`, `mo_type()` and `ab_name()`.', 'DetailsThe currently 20 supported languages are English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), and Ukrainian (uk).', 'All these languages have translations available for all antimicrobial drugs and colloquial microorganism names.To permanently silence the once-per-session language note on a non-English operating system, you can set the package option `AMR_locale` in your `.Rprofile` file like this: ``` Open .Rprofile fileutils::file.edit(""~/.Rprofile"") Then add e.g.', 'Italian support to that file using:options(AMR_locale = ""Italian"")``` And then save the file.Please read about adding or updating a language in [our Wiki](https://github.com/msberends/AMR/wiki/).', 'Changing the Default Language The system language will be used at default (as returned by `Sys.getenv(""LANG"")` or, if `LANG` is not set, `Sys.getlocale(""LC_COLLATE"")`), if that language is supported.', 'But the language to be used can be overwritten in two ways and will be checked in this order:1.', 'Setting the package option `AMR_locale`, either by using e.g.', '`set_AMR_locale(""German"")` or by running e.g.', 'Note that setting an option only works in the same session.', 'Save the command `options(AMR_locale = ""(your language)"")` to your `.Rprofile` file to apply it for every session.', 'Run `utils::file.edit(""~/.Rprofile"")` to edit your `.Rprofile` file.2.', 'Setting the system variable `LANGUAGE` or `LANG`, e.g.', 'by adding `LANGUAGE=""de_DE.utf8""` to your `.Renviron` file in your home directory.Thus, if the package option `AMR_locale` is set, the system variables `LANGUAGE` and `LANG` will be ignored.', 'Examples```r Current settings (based on system language)ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") setting another languageset_AMR_locale(""Dutch"")ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") setting yet another languageset_AMR_locale(""German"")ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") set_AMR_locale() understands endonyms, English exonyms, and ISO-639-1:set_AMR_locale(""Deutsch"")set_AMR_locale(""German"")set_AMR_locale(""de"")ab_name(""amox/clav"") reset to system defaultreset_AMR_locale()ab_name(""amox/clav"")```']",1," Translate Strings from the AMR Package```rget_AMR_locale()set_AMR_locale(language)reset_AMR_locale()translate_AMR(x, language = get_AMR_locale())``` Arguments- `language`: language to choose. Use one of these supported language names or ISO-639-1 codes: English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), or Ukrainian (uk).- `x`: text to translate DescriptionFor language-dependent output of `AMR` functions, such as `mo_name()`, `mo_gramstain()`, `mo_type()` and `ab_name()`. DetailsThe currently 20 supported languages are English (en), Chinese (zh), Czech (cs), Danish (da), Dutch (nl), Finnish (fi), French (fr), German (de), Greek (el), Italian (it), Japanese (ja), Norwegian (no), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Spanish (es), Swedish (sv), Turkish (tr), and Ukrainian (uk). All these languages have translations available for all antimicrobial drugs and colloquial microorganism names.To permanently silence the once-per-session language note on a non-English operating system, you can set the package option `AMR_locale` in your `.Rprofile` file like this: ``` Open .Rprofile fileutils::file.edit(""~/.Rprofile"") Then add e.g. Italian support to that file using:options(AMR_locale = ""Italian"")``` And then save the file.Please read about adding or updating a language in [our Wiki](https://github.com/msberends/AMR/wiki/). Changing the Default Language The system language will be used at default (as returned by `Sys.getenv(""LANG"")` or, if `LANG` is not set, `Sys.getlocale(""LC_COLLATE"")`), if that language is supported. But the language to be used can be overwritten in two ways and will be checked in this order:1. Setting the package option `AMR_locale`, either by using e.g. `set_AMR_locale(""German"")` or by running e.g. `options(AMR_locale = ""German"")`.      Note that setting an option only works in the same session. Save the command `options(AMR_locale = ""(your language)"")` to your `.Rprofile` file to apply it for every session. Run `utils::file.edit(""~/.Rprofile"")` to edit your `.Rprofile` file.2. Setting the system variable `LANGUAGE` or `LANG`, e.g. by adding `LANGUAGE=""de_DE.utf8""` to your `.Renviron` file in your home directory.Thus, if the package option `AMR_locale` is set, the system variables `LANGUAGE` and `LANG` will be ignored. Examples```r Current settings (based on system language)ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") setting another languageset_AMR_locale(""Dutch"")ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") setting yet another languageset_AMR_locale(""German"")ab_name(""Ciprofloxacin"")mo_name(""Coagulase-negative Staphylococcus (CoNS)"") set_AMR_locale() understands endonyms, English exonyms, and ISO-639-1:set_AMR_locale(""Deutsch"")set_AMR_locale(""German"")set_AMR_locale(""de"")ab_name(""amox/clav"") reset to system defaultreset_AMR_locale()ab_name(""amox/clav"")```",6
AMR,g.test.md,"# **G**-test for Count Data

## Source

The code for this function is identical to that of `chisq.test()`, except that:

 * The calculation of the statistic was changed to `2 * sum(x * log(x / E))`
 * Yates' continuity correction was removed as it does not apply to a **G**-test
 * The possibility to simulate p values with `simulate.p.value` was removed

```r
g.test(x, y = NULL, p = rep(1/length(x), length(x)), rescale.p = FALSE)
```

## Arguments

- `x`: a numeric vector or matrix. `x` and `y` can also both be factors.
- `y`: a numeric vector; ignored if `x` is a matrix. If `x` is a factor, `y` should be a factor of the same length.
- `p`: a vector of probabilities of the same length as `x`. An error is given if any entry of `p` is negative.
- `rescale.p`: a logical scalar; if TRUE then `p` is rescaled (if necessary) to sum to 1. If `rescale.p` is FALSE, and `p` does not sum to 1, an error is given.

## Returns

A list with class `""htest""` containing the following components: - **statistic**: the value the chi-squared test statistic.

 - **parameter**: the degrees of freedom of the approximate chi-squared distribution of the test statistic, `NA` if the p-value is computed by Monte Carlo simulation.

 - **p.value**: the p-value for the test.

 - **method**: a character string indicating the type of test performed, and whether Monte Carlo simulation or continuity correction was used.

 - **data.name**: a character string giving the name(s) of the data.

 - **observed**: the observed counts.

 - **expected**: the expected counts under the null hypothesis.

 - **residuals**: the Pearson residuals, `(observed - expected) / sqrt(expected)`.

 - **stdres**: standardized residuals, `(observed - expected) / sqrt(V)`, where `V` is the residual cell variance (Agresti, 2007, section 2.4.5 for the case where `x` is a matrix, `n * p * (1 - p)` otherwise).

## Description

`g.test()` performs chi-squared contingency table tests and goodness-of-fit tests, just like `chisq.test()` but is more reliable (1). A **G**-test can be used to see whether the number of observations in each category fits a theoretical expectation (called a _G_-test of goodness-of-fit ), or to see whether the proportions of one variable are different for different values of the other variable (called a _G_-test of independence ).

## Details

If `x` is a matrix with one row or column, or if `x` is a vector and `y` is not given, then a **goodness-of-fit test** is performed (`x` is treated as a one-dimensional contingency table). The entries of `x` must be non-negative integers. In this case, the hypothesis tested is whether the population probabilities equal those in `p`, or are all equal if `p` is not given.

If `x` is a matrix with at least two rows and columns, it is taken as a two-dimensional contingency table: the entries of `x` must be non-negative integers. Otherwise, `x` and `y` must be vectors or factors of the same length; cases with missing values are removed, the objects are coerced to factors, and the contingency table is computed from these. Then Pearson's chi-squared test is performed of the null hypothesis that the joint distribution of the cell counts in a 2-dimensional contingency table is the product of the row and column marginals.

The p-value is computed from the asymptotic chi-squared distribution of the test statistic.

In the contingency table case simulation is done by random sampling from the set of all contingency tables with given marginals, and works only if the marginals are strictly positive. Note that this is not the usual sampling situation assumed for a chi-squared test (such as the **G**-test) but rather that for Fisher's exact test.

In the goodness-of-fit case simulation is done by random sampling from the discrete distribution specified by `p`, each sample being of size `n = sum(x)`. This simulation is done in and may be slow.

### **G**-test Of Goodness-of-Fit (Likelihood Ratio Test)

 Use the **G**-test of goodness-of-fit when you have one nominal variable with two or more values (such as male and female, or red, pink and white flowers). You compare the observed counts of numbers of observations in each category with the expected counts, which you calculate using some kind of theoretical expectation (such as a 1:1 sex ratio or a 1:2:1 ratio in a genetic cross).

If the expected number of observations in any category is too small, the **G**-test may give inaccurate results, and you should use an exact test instead (`fisher.test()`).

The **G**-test of goodness-of-fit is an alternative to the chi-square test of goodness-of-fit (`chisq.test()`); each of these tests has some advantages and some disadvantages, and the results of the two tests are usually very similar.

### **G**-test of Independence

 Use the **G**-test of independence when you have two nominal variables, each with two or more possible values. You want to know whether the proportions for one variable are different among values of the other variable.

It is also possible to do a **G**-test of independence with more than two nominal variables. For example, Jackson et al. (2013) also had data for children under 3, so you could do an analysis of old vs. young, thigh vs. arm, and reaction vs. no reaction, all analyzed together.

Fisher's exact test (`fisher.test()`) is an exact test, where the **G**-test is still only an approximation . For any 2x2 table, Fisher's Exact test may be slower but will still run in seconds, even if the sum of your observations is multiple millions.

The **G**-test of independence is an alternative to the chi-square test of independence (`chisq.test()`), and they will give approximately the same results.

### How the Test Works

 Unlike the exact test of goodness-of-fit (`fisher.test()`), the **G**-test does not directly calculate the probability of obtaining the observed results or something more extreme. Instead, like almost all statistical tests, the **G**-test has an intermediate step; it uses the data to calculate a test statistic that measures how far the observed data are from the null expectation. You then use a mathematical relationship, in this case the chi-square distribution, to estimate the probability of obtaining that value of the test statistic.

The **G**-test uses the log of the ratio of two likelihoods as the test statistic, which is why it is also called a likelihood ratio test or log-likelihood ratio test. The formula to calculate a **G**-statistic is:

`G = 2 * sum(x * log(x / E))`

where `E` are the expected values. Since this is chi-square distributed, the p value can be calculated in with:

 

```
p <- stats::pchisq(G, df, lower.tail = FALSE)
```

 

where `df` are the degrees of freedom.

If there are more than two categories and you want to find out which ones are significantly different from their null expectation, you can use the same method of testing each category vs. the sum of all categories, with the Bonferroni correction. You use **G**-tests for each category, of course.

## Examples

```r
# = EXAMPLE 1 =
# Shivrain et al. (2006) crossed clearfield rice (which are resistant
# to the herbicide imazethapyr) with red rice (which are susceptible to
# imazethapyr). They then crossed the hybrid offspring and examined the
# F2 generation, where they found 772 resistant plants, 1611 moderately
# resistant plants, and 737 susceptible plants. If resistance is controlled
# by a single gene with two co-dominant alleles, you would expect a 1:2:1
# ratio.

x <- c(772, 1611, 737)
g.test(x, p = c(1, 2, 1) / 4)

# There is no significant difference from a 1:2:1 ratio.
# Meaning: resistance controlled by a single gene with two co-dominant
# alleles, is plausible.


# = EXAMPLE 2 =
# Red crossbills (Loxia curvirostra) have the tip of the upper bill either
# right or left of the lower bill, which helps them extract seeds from pine
# cones. Some have hypothesized that frequency-dependent selection would
# keep the number of right and left-billed birds at a 1:1 ratio. Groth (1992)
# observed 1752 right-billed and 1895 left-billed crossbills.

x <- c(1752, 1895)
g.test(x)

# There is a significant difference from a 1:1 ratio.
# Meaning: there are significantly more left-billed birds.
```

## References

1. McDonald, J.H. 2014. Handbook of Biological Statistics (3rd ed.) . Sparky House Publishing, Baltimore, Maryland. [http://www.biostathandbook.com/gtestgof.html](http://www.biostathandbook.com/gtestgof.html).

## See Also

`chisq.test()`



","[""G-test for Count Data SourceThe code for this function is identical to that of `chisq.test()`, except that:  The calculation of the statistic was changed to `2  sum(x  log(x / E))`  Yates' continuity correction was removed as it does not apply to a G-test  The possibility to simulate p values with `simulate.p.value` was removed```rg.test(x, y = NULL, p = rep(1/length(x), length(x)), rescale.p = FALSE)``` Arguments- `x`: a numeric vector or matrix."", '`x` and `y` can also both be factors.- `y`: a numeric vector; ignored if `x` is a matrix.', 'If `x` is a factor, `y` should be a factor of the same length.- `p`: a vector of probabilities of the same length as `x`.', 'An error is given if any entry of `p` is negative.- `rescale.p`: a logical scalar; if TRUE then `p` is rescaled (if necessary) to sum to 1.', 'If `rescale.p` is FALSE, and `p` does not sum to 1, an error is given.', 'ReturnsA list with class `""htest""` containing the following components: - statistic: the value the chi-squared test statistic.', '- parameter: the degrees of freedom of the approximate chi-squared distribution of the test statistic, `NA` if the p-value is computed by Monte Carlo simulation.', '- p.value: the p-value for the test.', '- method: a character string indicating the type of test performed, and whether Monte Carlo simulation or continuity correction was used.', '- data.name: a character string giving the name(s) of the data.', '- observed: the observed counts.', '- expected: the expected counts under the null hypothesis.', '- residuals: the Pearson residuals, `(observed - expected) / sqrt(expected)`.', '- stdres: standardized residuals, `(observed - expected) / sqrt(V)`, where `V` is the residual cell variance (Agresti, 2007, section 2.4.5 for the case where `x` is a matrix, `n  p  (1 - p)` otherwise).', 'Description`g.test()` performs chi-squared contingency table tests and goodness-of-fit tests, just like `chisq.test()` but is more reliable (1).', 'A G-test can be used to see whether the number of observations in each category fits a theoretical expectation (called a _G_-test of goodness-of-fit ), or to see whether the proportions of one variable are different for different values of the other variable (called a _G_-test of independence ).', 'DetailsIf `x` is a matrix with one row or column, or if `x` is a vector and `y` is not given, then a goodness-of-fit test is performed (`x` is treated as a one-dimensional contingency table).', 'The entries of `x` must be non-negative integers.', 'In this case, the hypothesis tested is whether the population probabilities equal those in `p`, or are all equal if `p` is not given.If `x` is a matrix with at least two rows and columns, it is taken as a two-dimensional contingency table: the entries of `x` must be non-negative integers.', 'Otherwise, `x` and `y` must be vectors or factors of the same length; cases with missing values are removed, the objects are coerced to factors, and the contingency table is computed from these.', ""Then Pearson's chi-squared test is performed of the null hypothesis that the joint distribution of the cell counts in a 2-dimensional contingency table is the product of the row and column marginals.The p-value is computed from the asymptotic chi-squared distribution of the test statistic.In the contingency table case simulation is done by random sampling from the set of all contingency tables with given marginals, and works only if the marginals are strictly positive."", ""Note that this is not the usual sampling situation assumed for a chi-squared test (such as the G-test) but rather that for Fisher's exact test.In the goodness-of-fit case simulation is done by random sampling from the discrete distribution specified by `p`, each sample being of size `n = sum(x)`."", 'This simulation is done in and may be slow.', 'G-test Of Goodness-of-Fit (Likelihood Ratio Test) Use the G-test of goodness-of-fit when you have one nominal variable with two or more values (such as male and female, or red, pink and white flowers).', 'You compare the observed counts of numbers of observations in each category with the expected counts, which you calculate using some kind of theoretical expectation (such as a 1:1 sex ratio or a 1:2:1 ratio in a genetic cross).If the expected number of observations in any category is too small, the G-test may give inaccurate results, and you should use an exact test instead (`fisher.test()`).The G-test of goodness-of-fit is an alternative to the chi-square test of goodness-of-fit (`chisq.test()`); each of these tests has some advantages and some disadvantages, and the results of the two tests are usually very similar.', 'G-test of Independence Use the G-test of independence when you have two nominal variables, each with two or more possible values.', 'You want to know whether the proportions for one variable are different among values of the other variable.It is also possible to do a G-test of independence with more than two nominal variables.', 'For example, Jackson et al.', ""(2013) also had data for children under 3, so you could do an analysis of old vs. young, thigh vs. arm, and reaction vs. no reaction, all analyzed together.Fisher's exact test (`fisher.test()`) is an exact test, where the G-test is still only an approximation ."", ""For any 2x2 table, Fisher's Exact test may be slower but will still run in seconds, even if the sum of your observations is multiple millions.The G-test of independence is an alternative to the chi-square test of independence (`chisq.test()`), and they will give approximately the same results."", 'How the Test Works Unlike the exact test of goodness-of-fit (`fisher.test()`), the G-test does not directly calculate the probability of obtaining the observed results or something more extreme.', 'Instead, like almost all statistical tests, the G-test has an intermediate step; it uses the data to calculate a test statistic that measures how far the observed data are from the null expectation.', 'You then use a mathematical relationship, in this case the chi-square distribution, to estimate the probability of obtaining that value of the test statistic.The G-test uses the log of the ratio of two likelihoods as the test statistic, which is why it is also called a likelihood ratio test or log-likelihood ratio test.', 'The formula to calculate a G-statistic is:`G = 2  sum(x  log(x / E))`where `E` are the expected values.', 'Since this is chi-square distributed, the p value can be calculated in with: ```p <- stats::pchisq(G, df, lower.tail = FALSE)``` where `df` are the degrees of freedom.If there are more than two categories and you want to find out which ones are significantly different from their null expectation, you can use the same method of testing each category vs. the sum of all categories, with the Bonferroni correction.', 'You use G-tests for each category, of course.', 'Examples```r = EXAMPLE 1 = Shivrain et al.', '(2006) crossed clearfield rice (which are resistant to the herbicide imazethapyr) with red rice (which are susceptible to imazethapyr).', 'They then crossed the hybrid offspring and examined the F2 generation, where they found 772 resistant plants, 1611 moderately resistant plants, and 737 susceptible plants.', 'If resistance is controlled by a single gene with two co-dominant alleles, you would expect a 1:2:1 ratio.x <- c(772, 1611, 737)g.test(x, p = c(1, 2, 1) / 4) There is no significant difference from a 1:2:1 ratio.', 'Meaning: resistance controlled by a single gene with two co-dominant alleles, is plausible.', '= EXAMPLE 2 = Red crossbills (Loxia curvirostra) have the tip of the upper bill either right or left of the lower bill, which helps them extract seeds from pine cones.', 'Some have hypothesized that frequency-dependent selection would keep the number of right and left-billed birds at a 1:1 ratio.', 'Groth (1992) observed 1752 right-billed and 1895 left-billed crossbills.x <- c(1752, 1895)g.test(x) There is a significant difference from a 1:1 ratio.', 'Meaning: there are significantly more left-billed birds.``` References1.', 'Handbook of Biological Statistics (3rd ed.)', 'Sparky House Publishing, Baltimore, Maryland.']",1," G-test for Count Data SourceThe code for this function is identical to that of `chisq.test()`, except that:  The calculation of the statistic was changed to `2  sum(x  log(x / E))`  Yates' continuity correction was removed as it does not apply to a G-test  The possibility to simulate p values with `simulate.p.value` was removed```rg.test(x, y = NULL, p = rep(1/length(x), length(x)), rescale.p = FALSE)``` Arguments- `x`: a numeric vector or matrix. `x` and `y` can also both be factors.- `y`: a numeric vector; ignored if `x` is a matrix. If `x` is a factor, `y` should be a factor of the same length.- `p`: a vector of probabilities of the same length as `x`. An error is given if any entry of `p` is negative.- `rescale.p`: a logical scalar; if TRUE then `p` is rescaled (if necessary) to sum to 1. If `rescale.p` is FALSE, and `p` does not sum to 1, an error is given. ReturnsA list with class `""htest""` containing the following components: - statistic: the value the chi-squared test statistic. - parameter: the degrees of freedom of the approximate chi-squared distribution of the test statistic, `NA` if the p-value is computed by Monte Carlo simulation. - p.value: the p-value for the test. - method: a character string indicating the type of test performed, and whether Monte Carlo simulation or continuity correction was used. - data.name: a character string giving the name(s) of the data. - observed: the observed counts. - expected: the expected counts under the null hypothesis. - residuals: the Pearson residuals, `(observed - expected) / sqrt(expected)`. - stdres: standardized residuals, `(observed - expected) / sqrt(V)`, where `V` is the residual cell variance (Agresti, 2007, section 2.4.5 for the case where `x` is a matrix, `n  p  (1 - p)` otherwise). Description`g.test()` performs chi-squared contingency table tests and goodness-of-fit tests, just like `chisq.test()` but is more reliable (1). A G-test can be used to see whether the number of observations in each category fits a theoretical expectation (called a _G_-test of goodness-of-fit ), or to see whether the proportions of one variable are different for different values of the other variable (called a _G_-test of independence ). DetailsIf `x` is a matrix with one row or column, or if `x` is a vector and `y` is not given, then a goodness-of-fit test is performed (`x` is treated as a one-dimensional contingency table). The entries of `x` must be non-negative integers. In this case, the hypothesis tested is whether the population probabilities equal those in `p`, or are all equal if `p` is not given.If `x` is a matrix with at least two rows and columns, it is taken as a two-dimensional contingency table: the entries of `x` must be non-negative integers. Otherwise, `x` and `y` must be vectors or factors of the same length; cases with missing values are removed, the objects are coerced to factors, and the contingency table is computed from these. Then Pearson's chi-squared test is performed of the null hypothesis that the joint distribution of the cell counts in a 2-dimensional contingency table is the product of the row and column marginals.The p-value is computed from the asymptotic chi-squared distribution of the test statistic.In the contingency table case simulation is done by random sampling from the set of all contingency tables with given marginals, and works only if the marginals are strictly positive. Note that this is not the usual sampling situation assumed for a chi-squared test (such as the G-test) but rather that for Fisher's exact test.In the goodness-of-fit case simulation is done by random sampling from the discrete distribution specified by `p`, each sample being of size `n = sum(x)`. This simulation is done in and may be slow. G-test Of Goodness-of-Fit (Likelihood Ratio Test) Use the G-test of goodness-of-fit when you have one nominal variable with two or more values (such as male and female, or red, pink and white flowers). You compare the observed counts of numbers of observations in each category with the expected counts, which you calculate using some kind of theoretical expectation (such as a 1:1 sex ratio or a 1:2:1 ratio in a genetic cross).If the expected number of observations in any category is too small, the G-test may give inaccurate results, and you should use an exact test instead (`fisher.test()`).The G-test of goodness-of-fit is an alternative to the chi-square test of goodness-of-fit (`chisq.test()`); each of these tests has some advantages and some disadvantages, and the results of the two tests are usually very similar. G-test of Independence Use the G-test of independence when you have two nominal variables, each with two or more possible values. You want to know whether the proportions for one variable are different among values of the other variable.It is also possible to do a G-test of independence with more than two nominal variables. For example, Jackson et al. (2013) also had data for children under 3, so you could do an analysis of old vs. young, thigh vs. arm, and reaction vs. no reaction, all analyzed together.Fisher's exact test (`fisher.test()`) is an exact test, where the G-test is still only an approximation . For any 2x2 table, Fisher's Exact test may be slower but will still run in seconds, even if the sum of your observations is multiple millions.The G-test of independence is an alternative to the chi-square test of independence (`chisq.test()`), and they will give approximately the same results. How the Test Works Unlike the exact test of goodness-of-fit (`fisher.test()`), the G-test does not directly calculate the probability of obtaining the observed results or something more extreme. Instead, like almost all statistical tests, the G-test has an intermediate step; it uses the data to calculate a test statistic that measures how far the observed data are from the null expectation. You then use a mathematical relationship, in this case the chi-square distribution, to estimate the probability of obtaining that value of the test statistic.The G-test uses the log of the ratio of two likelihoods as the test statistic, which is why it is also called a likelihood ratio test or log-likelihood ratio test. The formula to calculate a G-statistic is:`G = 2  sum(x  log(x / E))`where `E` are the expected values. Since this is chi-square distributed, the p value can be calculated in with: ```p <- stats::pchisq(G, df, lower.tail = FALSE)``` where `df` are the degrees of freedom.If there are more than two categories and you want to find out which ones are significantly different from their null expectation, you can use the same method of testing each category vs. the sum of all categories, with the Bonferroni correction. You use G-tests for each category, of course. Examples```r = EXAMPLE 1 = Shivrain et al. (2006) crossed clearfield rice (which are resistant to the herbicide imazethapyr) with red rice (which are susceptible to imazethapyr). They then crossed the hybrid offspring and examined the F2 generation, where they found 772 resistant plants, 1611 moderately resistant plants, and 737 susceptible plants. If resistance is controlled by a single gene with two co-dominant alleles, you would expect a 1:2:1 ratio.x <- c(772, 1611, 737)g.test(x, p = c(1, 2, 1) / 4) There is no significant difference from a 1:2:1 ratio. Meaning: resistance controlled by a single gene with two co-dominant alleles, is plausible. = EXAMPLE 2 = Red crossbills (Loxia curvirostra) have the tip of the upper bill either right or left of the lower bill, which helps them extract seeds from pine cones. Some have hypothesized that frequency-dependent selection would keep the number of right and left-billed birds at a 1:1 ratio. Groth (1992) observed 1752 right-billed and 1895 left-billed crossbills.x <- c(1752, 1895)g.test(x) There is a significant difference from a 1:1 ratio. Meaning: there are significantly more left-billed birds.``` References1. McDonald, J.H. 2014. Handbook of Biological Statistics (3rd ed.) . Sparky House Publishing, Baltimore, Maryland. [http://www.biostathandbook.com/gtestgof.html](http://www.biostathandbook.com/gtestgof.html). See Also`chisq.test()`",6
AMR,like.md,"# Vectorised Pattern Matching with Keyboard Shortcut

## Source

Idea from the c(""[list(\""like\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ function from the ](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[list(\""data.table\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ package](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)""), although altered as explained in **Details**.

```r
like(x, pattern, ignore.case = TRUE)

x %like% pattern

x %unlike% pattern

x %like_case% pattern

x %unlike_case% pattern
```

## Arguments

- `x`: a character vector where matches are sought, or an object which can be coerced by `as.character()` to a character vector.
- `pattern`: a character vector containing regular expressions (or a character string for `fixed = TRUE`) to be matched in the given character vector. Coerced by `as.character()` to a character string if possible.
- `ignore.case`: if `FALSE`, the pattern matching is **case sensitive** and if `TRUE`, case is ignored during matching.

## Returns

A logical vector

## Description

Convenient wrapper around `grepl()` to match a pattern: `x %like% pattern`. It always returns a `logical` vector and is always case-insensitive (use `x %like_case% pattern` for case-sensitive matching). Also, `pattern` can be as long as `x` to compare items of each index in both vectors, or they both can have the same length to iterate over all cases.

## Details

These `like()` and `%like%`/`%unlike%` functions:

 * Are case-insensitive (use `%like_case%`/`%unlike_case%` for case-sensitive matching)
 * Support multiple patterns
 * Check if `pattern` is a valid regular expression and sets `fixed = TRUE` if not, to greatly improve speed (vectorised over `pattern`)
 * Always use compatibility with Perl unless `fixed = TRUE`, to greatly improve speed

Using RStudio? The `%like%`/`%unlike%` functions can also be directly inserted in your code from the Addins menu and can have its own keyboard shortcut like `Shift+Ctrl+L` or `Shift+Cmd+L` (see menu `Tools` > `Modify Keyboard Shortcuts...`). If you keep pressing your shortcut, the inserted text will be iterated over `%like%` -> `%unlike%` -> `%like_case%` -> `%unlike_case%`.

## Examples

```r
# data.table has a more limited version of %like%, so unload it:
try(detach(""package:data.table"", unload = TRUE), silent = TRUE)

a <- ""This is a test""
b <- ""TEST""
a %like% b
b %like% a

# also supports multiple patterns
a <- c(""Test case"", ""Something different"", ""Yet another thing"")
b <- c(""case"", ""diff"", ""yet"")
a %like% b
a %unlike% b

a[1] %like% b
a %like% b[1]


# get isolates whose name start with 'Entero' (case-insensitive)
example_isolates[which(mo_name() %like% ""^entero""), ]

if (require(""dplyr"")) {
  example_isolates %>%
    filter(mo_name() %like% ""^ent"")
}
```

## See Also

`grepl()`



","['Vectorised Pattern Matching with Keyboard Shortcut SourceIdea from the c(""[list(\\""like\\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ function from the ](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[list(\\""data.table\\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ package](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)""), although altered as explained in Details.```rlike(x, pattern, ignore.case = TRUE)x %like% patternx %unlike% patternx %like_case% patternx %unlike_case% pattern``` Arguments- `x`: a character vector where matches are sought, or an object which can be coerced by `as.character()` to a character vector.- `pattern`: a character vector containing regular expressions (or a character string for `fixed = TRUE`) to be matched in the given character vector.', 'Coerced by `as.character()` to a character string if possible.- `ignore.case`: if `FALSE`, the pattern matching is case sensitive and if `TRUE`, case is ignored during matching.', 'ReturnsA logical vector DescriptionConvenient wrapper around `grepl()` to match a pattern: `x %like% pattern`.', 'It always returns a `logical` vector and is always case-insensitive (use `x %like_case% pattern` for case-sensitive matching).', 'Also, `pattern` can be as long as `x` to compare items of each index in both vectors, or they both can have the same length to iterate over all cases.', 'DetailsThese `like()` and `%like%`/`%unlike%` functions:  Are case-insensitive (use `%like_case%`/`%unlike_case%` for case-sensitive matching)  Support multiple patterns  Check if `pattern` is a valid regular expression and sets `fixed = TRUE` if not, to greatly improve speed (vectorised over `pattern`)  Always use compatibility with Perl unless `fixed = TRUE`, to greatly improve speedUsing RStudio?', 'The `%like%`/`%unlike%` functions can also be directly inserted in your code from the Addins menu and can have its own keyboard shortcut like `Shift+Ctrl+L` or `Shift+Cmd+L` (see menu `Tools` > `Modify Keyboard Shortcuts...`).', 'If you keep pressing your shortcut, the inserted text will be iterated over `%like%` -> `%unlike%` -> `%like_case%` -> `%unlike_case%`.', 'Examples```r data.table has a more limited version of %like%, so unload it:try(detach(""package:data.table"", unload = TRUE), silent = TRUE)a <- ""This is a test""b <- ""TEST""a %like% bb %like% a also supports multiple patternsa <- c(""Test case"", ""Something different"", ""Yet another thing"")b <- c(""case"", ""diff"", ""yet"")a %like% ba %unlike% ba[1] %like% ba %like% b[1] get isolates whose name start with \'Entero\' (case-insensitive)example_isolates[which(mo_name() %like% ""^entero""), ]if (require(""dplyr"")) {  example_isolates %>%    filter(mo_name() %like% ""^ent"")}``` See Also`grepl()`']",1," Vectorised Pattern Matching with Keyboard Shortcut SourceIdea from the c(""[list(\""like\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ function from the ](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[list(\""data.table\"")](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)"", ""[ package](https://github.com/Rdatatable/data.table/blob/ec1259af1bf13fc0c96a1d3f9e84d55d8106a9a4/R/like.R)""), although altered as explained in Details.```rlike(x, pattern, ignore.case = TRUE)x %like% patternx %unlike% patternx %like_case% patternx %unlike_case% pattern``` Arguments- `x`: a character vector where matches are sought, or an object which can be coerced by `as.character()` to a character vector.- `pattern`: a character vector containing regular expressions (or a character string for `fixed = TRUE`) to be matched in the given character vector. Coerced by `as.character()` to a character string if possible.- `ignore.case`: if `FALSE`, the pattern matching is case sensitive and if `TRUE`, case is ignored during matching. ReturnsA logical vector DescriptionConvenient wrapper around `grepl()` to match a pattern: `x %like% pattern`. It always returns a `logical` vector and is always case-insensitive (use `x %like_case% pattern` for case-sensitive matching). Also, `pattern` can be as long as `x` to compare items of each index in both vectors, or they both can have the same length to iterate over all cases. DetailsThese `like()` and `%like%`/`%unlike%` functions:  Are case-insensitive (use `%like_case%`/`%unlike_case%` for case-sensitive matching)  Support multiple patterns  Check if `pattern` is a valid regular expression and sets `fixed = TRUE` if not, to greatly improve speed (vectorised over `pattern`)  Always use compatibility with Perl unless `fixed = TRUE`, to greatly improve speedUsing RStudio? The `%like%`/`%unlike%` functions can also be directly inserted in your code from the Addins menu and can have its own keyboard shortcut like `Shift+Ctrl+L` or `Shift+Cmd+L` (see menu `Tools` > `Modify Keyboard Shortcuts...`). If you keep pressing your shortcut, the inserted text will be iterated over `%like%` -> `%unlike%` -> `%like_case%` -> `%unlike_case%`. Examples```r data.table has a more limited version of %like%, so unload it:try(detach(""package:data.table"", unload = TRUE), silent = TRUE)a <- ""This is a test""b <- ""TEST""a %like% bb %like% a also supports multiple patternsa <- c(""Test case"", ""Something different"", ""Yet another thing"")b <- c(""case"", ""diff"", ""yet"")a %like% ba %unlike% ba[1] %like% ba %like% b[1] get isolates whose name start with 'Entero' (case-insensitive)example_isolates[which(mo_name() %like% ""^entero""), ]if (require(""dplyr"")) {  example_isolates %>%    filter(mo_name() %like% ""^ent"")}``` See Also`grepl()`",7
AMR,as.mic.md," data

# Transform Input to Minimum Inhibitory Concentrations (MIC)

```r
as.mic(x, na.rm = FALSE)

NA_mic_

is.mic(x)

## S3 method for class 'mic'
droplevels(x, as.mic = FALSE, ...)
```

## Arguments

- `x`: a character or numeric vector
- `na.rm`: a logical indicating whether missing values should be removed
- `as.mic`: a logical to indicate whether the `mic` class should be kept - the default is `FALSE`
- `...`: arguments passed on to methods

## Returns

Ordered factor with additional class `mic`, that in mathematical operations acts as decimal numbers. Bare in mind that the outcome of any mathematical operation on MICs will return a numeric value.

## Description

This transforms vectors to a new class `mic`, which treats the input as decimal numbers, while maintaining operators (such as "">="") and only allowing valid MIC values known to the field of (medical) microbiology.

## Details

To interpret MIC values as SIR values, use `as.sir()` on MIC values. It supports guidelines from EUCAST (2011-2023) and CLSI (2011-2023).

This class for MIC values is a quite a special data type: formally it is an ordered factor with valid MIC values as factor levels (to make sure only valid MIC values are retained), but for any mathematical operation it acts as decimal numbers:

 

```
x <- random_mic(10)
x
#> Class 'mic'
#>  [1] 16     1      8      8      64     >=128  0.0625 32     32     16

is.factor(x)
#> [1] TRUE

x[1] * 2
#> [1] 32

median(x)
#> [1] 26
```

 

This makes it possible to maintain operators that often come with MIC values, such "">="" and ""<="", even when filtering using numeric values in data analysis, e.g.:

 

```
x[x > 4]
#> Class 'mic'
#> [1] 16    8     8     64    >=128 32    32    16

df <- data.frame(x, hospital = ""A"")
subset(df, x > 4) # or with dplyr: df %>% filter(x > 4)
#>        x hospital
#> 1     16        A
#> 5     64        A
#> 6  >=128        A
#> 8     32        A
#> 9     32        A
#> 10    16        A
```

 

The following generic functions  are implemented for the MIC class: `!`, `!=`, `%%`, `%/%`, `&`, `*`, `+`, `-`, `/`, `<`, `<=`, `==`, `>`, `>=`, `^`, `|`, `abs()`, `acos()`, `acosh()`, `all()`, `any()`, `asin()`, `asinh()`, `atan()`, `atanh()`, `ceiling()`, `cos()`, `cosh()`, `cospi()`, `cummax()`, `cummin()`, `cumprod()`, `cumsum()`, `digamma()`, `exp()`, `expm1()`, `floor()`, `gamma()`, `lgamma()`, `log()`, `log1p()`, `log2()`, `log10()`, `max()`, `mean()`, `min()`, `prod()`, `range()`, `round()`, `sign()`, `signif()`, `sin()`, `sinh()`, `sinpi()`, `sqrt()`, `sum()`, `tan()`, `tanh()`, `tanpi()`, `trigamma()` and `trunc()`. Some functions of the `stats` package are also implemented: `median()`, `quantile()`, `mad()`, `IQR()`, `fivenum()`. Also, `boxplot.stats()` is supported. Since `sd()` and `var()` are non-generic functions, these could not be extended. Use `mad()` as an alternative, or use e.g. `sd(as.numeric(x))` where `x` is your vector of MIC values.

Using `as.double()` or `as.numeric()` on MIC values will remove the operators and return a numeric vector. Do not use `as.integer()` on MIC values as by the convention on factor s, it will return the index of the factor levels (which is often useless for regular users).

Use `droplevels()` to drop unused levels. At default, it will return a plain factor. Use `droplevels(..., as.mic = TRUE)` to maintain the `mic` class. `NA_mic_` is a missing value of the new `mic` class, analogous to e.g. base 's `NA_character_`.

## Examples

```r
mic_data <- as.mic(c("">=32"", ""1.0"", ""1"", ""1.00"", 8, ""<=0.128"", ""8"", ""16"", ""16""))
mic_data
is.mic(mic_data)

# this can also coerce combined MIC/SIR values:
as.mic(""<=0.002; S"")

# mathematical processing treats MICs as numeric values
fivenum(mic_data)
quantile(mic_data)
all(mic_data < 512)

# interpret MIC values
as.sir(
  x = as.mic(2),
  mo = as.mo(""Streptococcus pneumoniae""),
  ab = ""AMX"",
  guideline = ""EUCAST""
)
as.sir(
  x = as.mic(c(0.01, 2, 4, 8)),
  mo = as.mo(""Streptococcus pneumoniae""),
  ab = ""AMX"",
  guideline = ""EUCAST""
)

# plot MIC values, see ?plot
plot(mic_data)
plot(mic_data, mo = ""E. coli"", ab = ""cipro"")

if (require(""ggplot2"")) {
  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"")
}
if (require(""ggplot2"")) {
  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"", language = ""nl"") # Dutch
}
```

## See Also

`as.sir()`



","[""data Transform Input to Minimum Inhibitory Concentrations (MIC)```ras.mic(x, na.rm = FALSE)NA_mic_is.mic(x) S3 method for class 'mic'droplevels(x, as.mic = FALSE, ...)``` Arguments- `x`: a character or numeric vector- `na.rm`: a logical indicating whether missing values should be removed- `as.mic`: a logical to indicate whether the `mic` class should be kept - the default is `FALSE`- `...`: arguments passed on to methods ReturnsOrdered factor with additional class `mic`, that in mathematical operations acts as decimal numbers."", 'Bare in mind that the outcome of any mathematical operation on MICs will return a numeric value.', 'DescriptionThis transforms vectors to a new class `mic`, which treats the input as decimal numbers, while maintaining operators (such as "">="") and only allowing valid MIC values known to the field of (medical) microbiology.', 'DetailsTo interpret MIC values as SIR values, use `as.sir()` on MIC values.', 'It supports guidelines from EUCAST (2011-2023) and CLSI (2011-2023).This class for MIC values is a quite a special data type: formally it is an ordered factor with valid MIC values as factor levels (to make sure only valid MIC values are retained), but for any mathematical operation it acts as decimal numbers: ```x <- random_mic(10)x> Class \'mic\'>  [1] 16     1      8      8      64     >=128  0.0625 32     32     16is.factor(x)> [1] TRUEx[1]  2> [1] 32median(x)> [1] 26``` This makes it possible to maintain operators that often come with MIC values, such "">="" and ""<="", even when filtering using numeric values in data analysis, e.g.', ': ```x[x > 4]> Class \'mic\'> [1] 16    8     8     64    >=128 32    32    16df <- data.frame(x, hospital = ""A"")subset(df, x > 4)  or with dplyr: df %>% filter(x > 4)>        x hospital> 1     16        A> 5     64        A> 6  >=128        A> 8     32        A> 9     32        A> 10    16        A``` The following generic functions  are implemented for the MIC class: `!`, `!=`, `%%`, `%/%`, `&`, ``, `+`, `-`, `/`, `<`, `<=`, `==`, `>`, `>=`, `^`, `|`, `abs()`, `acos()`, `acosh()`, `all()`, `any()`, `asin()`, `asinh()`, `atan()`, `atanh()`, `ceiling()`, `cos()`, `cosh()`, `cospi()`, `cummax()`, `cummin()`, `cumprod()`, `cumsum()`, `digamma()`, `exp()`, `expm1()`, `floor()`, `gamma()`, `lgamma()`, `log()`, `log1p()`, `log2()`, `log10()`, `max()`, `mean()`, `min()`, `prod()`, `range()`, `round()`, `sign()`, `signif()`, `sin()`, `sinh()`, `sinpi()`, `sqrt()`, `sum()`, `tan()`, `tanh()`, `tanpi()`, `trigamma()` and `trunc()`.', 'Some functions of the `stats` package are also implemented: `median()`, `quantile()`, `mad()`, `IQR()`, `fivenum()`.', 'Since `sd()` and `var()` are non-generic functions, these could not be extended.', 'Use `mad()` as an alternative, or use e.g.', '`sd(as.numeric(x))` where `x` is your vector of MIC values.Using `as.double()` or `as.numeric()` on MIC values will remove the operators and return a numeric vector.', 'Do not use `as.integer()` on MIC values as by the convention on factor s, it will return the index of the factor levels (which is often useless for regular users).Use `droplevels()` to drop unused levels.', 'At default, it will return a plain factor.', 'Use `droplevels(..., as.mic = TRUE)` to maintain the `mic` class.', '`NA_mic_` is a missing value of the new `mic` class, analogous to e.g.', 'Examples```rmic_data <- as.mic(c("">=32"", ""1.0"", ""1"", ""1.00"", 8, ""<=0.128"", ""8"", ""16"", ""16""))mic_datais.mic(mic_data) this can also coerce combined MIC/SIR values:as.mic(""<=0.002; S"") mathematical processing treats MICs as numeric valuesfivenum(mic_data)quantile(mic_data)all(mic_data < 512) interpret MIC valuesas.sir(  x = as.mic(2),  mo = as.mo(""Streptococcus pneumoniae""),  ab = ""AMX"",  guideline = ""EUCAST"")as.sir(  x = as.mic(c(0.01, 2, 4, 8)),  mo = as.mo(""Streptococcus pneumoniae""),  ab = ""AMX"",  guideline = ""EUCAST"") plot MIC values, see ?plotplot(mic_data)plot(mic_data, mo = ""E. coli"", ab = ""cipro"")if (require(""ggplot2"")) {  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"")}if (require(""ggplot2"")) {  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"", language = ""nl"")  Dutch}``` See Also`as.sir()`']",1," data Transform Input to Minimum Inhibitory Concentrations (MIC)```ras.mic(x, na.rm = FALSE)NA_mic_is.mic(x) S3 method for class 'mic'droplevels(x, as.mic = FALSE, ...)``` Arguments- `x`: a character or numeric vector- `na.rm`: a logical indicating whether missing values should be removed- `as.mic`: a logical to indicate whether the `mic` class should be kept - the default is `FALSE`- `...`: arguments passed on to methods ReturnsOrdered factor with additional class `mic`, that in mathematical operations acts as decimal numbers. Bare in mind that the outcome of any mathematical operation on MICs will return a numeric value. DescriptionThis transforms vectors to a new class `mic`, which treats the input as decimal numbers, while maintaining operators (such as "">="") and only allowing valid MIC values known to the field of (medical) microbiology. DetailsTo interpret MIC values as SIR values, use `as.sir()` on MIC values. It supports guidelines from EUCAST (2011-2023) and CLSI (2011-2023).This class for MIC values is a quite a special data type: formally it is an ordered factor with valid MIC values as factor levels (to make sure only valid MIC values are retained), but for any mathematical operation it acts as decimal numbers: ```x <- random_mic(10)x> Class 'mic'>  [1] 16     1      8      8      64     >=128  0.0625 32     32     16is.factor(x)> [1] TRUEx[1]  2> [1] 32median(x)> [1] 26``` This makes it possible to maintain operators that often come with MIC values, such "">="" and ""<="", even when filtering using numeric values in data analysis, e.g.: ```x[x > 4]> Class 'mic'> [1] 16    8     8     64    >=128 32    32    16df <- data.frame(x, hospital = ""A"")subset(df, x > 4)  or with dplyr: df %>% filter(x > 4)>        x hospital> 1     16        A> 5     64        A> 6  >=128        A> 8     32        A> 9     32        A> 10    16        A``` The following generic functions  are implemented for the MIC class: `!`, `!=`, `%%`, `%/%`, `&`, ``, `+`, `-`, `/`, `<`, `<=`, `==`, `>`, `>=`, `^`, `|`, `abs()`, `acos()`, `acosh()`, `all()`, `any()`, `asin()`, `asinh()`, `atan()`, `atanh()`, `ceiling()`, `cos()`, `cosh()`, `cospi()`, `cummax()`, `cummin()`, `cumprod()`, `cumsum()`, `digamma()`, `exp()`, `expm1()`, `floor()`, `gamma()`, `lgamma()`, `log()`, `log1p()`, `log2()`, `log10()`, `max()`, `mean()`, `min()`, `prod()`, `range()`, `round()`, `sign()`, `signif()`, `sin()`, `sinh()`, `sinpi()`, `sqrt()`, `sum()`, `tan()`, `tanh()`, `tanpi()`, `trigamma()` and `trunc()`. Some functions of the `stats` package are also implemented: `median()`, `quantile()`, `mad()`, `IQR()`, `fivenum()`. Also, `boxplot.stats()` is supported. Since `sd()` and `var()` are non-generic functions, these could not be extended. Use `mad()` as an alternative, or use e.g. `sd(as.numeric(x))` where `x` is your vector of MIC values.Using `as.double()` or `as.numeric()` on MIC values will remove the operators and return a numeric vector. Do not use `as.integer()` on MIC values as by the convention on factor s, it will return the index of the factor levels (which is often useless for regular users).Use `droplevels()` to drop unused levels. At default, it will return a plain factor. Use `droplevels(..., as.mic = TRUE)` to maintain the `mic` class. `NA_mic_` is a missing value of the new `mic` class, analogous to e.g. base 's `NA_character_`. Examples```rmic_data <- as.mic(c("">=32"", ""1.0"", ""1"", ""1.00"", 8, ""<=0.128"", ""8"", ""16"", ""16""))mic_datais.mic(mic_data) this can also coerce combined MIC/SIR values:as.mic(""<=0.002; S"") mathematical processing treats MICs as numeric valuesfivenum(mic_data)quantile(mic_data)all(mic_data < 512) interpret MIC valuesas.sir(  x = as.mic(2),  mo = as.mo(""Streptococcus pneumoniae""),  ab = ""AMX"",  guideline = ""EUCAST"")as.sir(  x = as.mic(c(0.01, 2, 4, 8)),  mo = as.mo(""Streptococcus pneumoniae""),  ab = ""AMX"",  guideline = ""EUCAST"") plot MIC values, see ?plotplot(mic_data)plot(mic_data, mo = ""E. coli"", ab = ""cipro"")if (require(""ggplot2"")) {  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"")}if (require(""ggplot2"")) {  autoplot(mic_data, mo = ""E. coli"", ab = ""cipro"", language = ""nl"")  Dutch}``` See Also`as.sir()`",7
AMR,random.md,"# Random MIC Values/Disk Zones/SIR Generation

```r
random_mic(size = NULL, mo = NULL, ab = NULL, ...)

random_disk(size = NULL, mo = NULL, ab = NULL, ...)

random_sir(size = NULL, prob_SIR = c(0.33, 0.33, 0.33), ...)
```

## Arguments

- `size`: desired size of the returned vector. If used in a data.frame call or `dplyr` verb, will get the current (group) size if left blank.
- `mo`: any character that can be coerced to a valid microorganism code with `as.mo()`
- `ab`: any character that can be coerced to a valid antimicrobial drug code with `as.ab()`
- `...`: ignored, only in place to allow future extensions
- `prob_SIR`: a vector of length 3: the probabilities for ""S"" (1st value), ""I"" (2nd value) and ""R"" (3rd value)

## Returns

class `mic` for `random_mic()` (see `as.mic()`) and class `disk` for `random_disk()` (see `as.disk()`)

## Description

These functions can be used for generating random MIC values and disk diffusion diameters, for AMR data analysis practice. By providing a microorganism and antimicrobial drug, the generated results will reflect reality as much as possible.

## Details

The base function `sample()` is used for generating values.

Generated values are based on the EUCAST 2023 guideline as implemented in the clinical_breakpoints data set. To create specific generated values per bug or drug, set the `mo` and/or `ab` argument.

## Examples

```r
random_mic(25)
random_disk(25)
random_sir(25)


# make the random generation more realistic by setting a bug and/or drug:
random_mic(25, ""Klebsiella pneumoniae"") # range 0.0625-64
random_mic(25, ""Klebsiella pneumoniae"", ""meropenem"") # range 0.0625-16
random_mic(25, ""Streptococcus pneumoniae"", ""meropenem"") # range 0.0625-4

random_disk(25, ""Klebsiella pneumoniae"") # range 8-50
random_disk(25, ""Klebsiella pneumoniae"", ""ampicillin"") # range 11-17
random_disk(25, ""Streptococcus pneumoniae"", ""ampicillin"") # range 12-27
```



","['Random MIC Values/Disk Zones/SIR Generation```rrandom_mic(size = NULL, mo = NULL, ab = NULL, ...)random_disk(size = NULL, mo = NULL, ab = NULL, ...)random_sir(size = NULL, prob_SIR = c(0.33, 0.33, 0.33), ...)``` Arguments- `size`: desired size of the returned vector.', 'If used in a data.frame call or `dplyr` verb, will get the current (group) size if left blank.- `mo`: any character that can be coerced to a valid microorganism code with `as.mo()`- `ab`: any character that can be coerced to a valid antimicrobial drug code with `as.ab()`- `...`: ignored, only in place to allow future extensions- `prob_SIR`: a vector of length 3: the probabilities for ""S"" (1st value), ""I"" (2nd value) and ""R"" (3rd value) Returnsclass `mic` for `random_mic()` (see `as.mic()`) and class `disk` for `random_disk()` (see `as.disk()`) DescriptionThese functions can be used for generating random MIC values and disk diffusion diameters, for AMR data analysis practice.', 'By providing a microorganism and antimicrobial drug, the generated results will reflect reality as much as possible.', 'DetailsThe base function `sample()` is used for generating values.Generated values are based on the EUCAST 2023 guideline as implemented in the clinical_breakpoints data set.', 'To create specific generated values per bug or drug, set the `mo` and/or `ab` argument.', 'Examples```rrandom_mic(25)random_disk(25)random_sir(25) make the random generation more realistic by setting a bug and/or drug:random_mic(25, ""Klebsiella pneumoniae"")  range 0.0625-64random_mic(25, ""Klebsiella pneumoniae"", ""meropenem"")  range 0.0625-16random_mic(25, ""Streptococcus pneumoniae"", ""meropenem"")  range 0.0625-4random_disk(25, ""Klebsiella pneumoniae"")  range 8-50random_disk(25, ""Klebsiella pneumoniae"", ""ampicillin"")  range 11-17random_disk(25, ""Streptococcus pneumoniae"", ""ampicillin"")  range 12-27```']",1," Random MIC Values/Disk Zones/SIR Generation```rrandom_mic(size = NULL, mo = NULL, ab = NULL, ...)random_disk(size = NULL, mo = NULL, ab = NULL, ...)random_sir(size = NULL, prob_SIR = c(0.33, 0.33, 0.33), ...)``` Arguments- `size`: desired size of the returned vector. If used in a data.frame call or `dplyr` verb, will get the current (group) size if left blank.- `mo`: any character that can be coerced to a valid microorganism code with `as.mo()`- `ab`: any character that can be coerced to a valid antimicrobial drug code with `as.ab()`- `...`: ignored, only in place to allow future extensions- `prob_SIR`: a vector of length 3: the probabilities for ""S"" (1st value), ""I"" (2nd value) and ""R"" (3rd value) Returnsclass `mic` for `random_mic()` (see `as.mic()`) and class `disk` for `random_disk()` (see `as.disk()`) DescriptionThese functions can be used for generating random MIC values and disk diffusion diameters, for AMR data analysis practice. By providing a microorganism and antimicrobial drug, the generated results will reflect reality as much as possible. DetailsThe base function `sample()` is used for generating values.Generated values are based on the EUCAST 2023 guideline as implemented in the clinical_breakpoints data set. To create specific generated values per bug or drug, set the `mo` and/or `ab` argument. Examples```rrandom_mic(25)random_disk(25)random_sir(25) make the random generation more realistic by setting a bug and/or drug:random_mic(25, ""Klebsiella pneumoniae"")  range 0.0625-64random_mic(25, ""Klebsiella pneumoniae"", ""meropenem"")  range 0.0625-16random_mic(25, ""Streptococcus pneumoniae"", ""meropenem"")  range 0.0625-4random_disk(25, ""Klebsiella pneumoniae"")  range 8-50random_disk(25, ""Klebsiella pneumoniae"", ""ampicillin"")  range 11-17random_disk(25, ""Streptococcus pneumoniae"", ""ampicillin"")  range 12-27```",7
AMR,join.md,"# Join microorganisms to a Data Set

```r
inner_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)

left_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)

right_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)

full_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)

semi_join_microorganisms(x, by = NULL, ...)

anti_join_microorganisms(x, by = NULL, ...)
```

## Arguments

- `x`: existing data set to join, or character vector. In case of a character vector, the resulting data.frame will contain a column 'x' with these values.
- `by`: a variable to join by - if left empty will search for a column with class `mo` (created with `as.mo()`) or will be `""mo""` if that column name exists in `x`, could otherwise be a column name of `x` with values that exist in `microorganisms$mo` (such as `by = ""bacteria_id""`), or another column in microorganisms (but then it should be named, like `by = c(""bacteria_id"" = ""fullname"")`)
- `suffix`: if there are non-joined duplicate variables in `x` and `y`, these suffixes will be added to the output to disambiguate them. Should be a character vector of length 2.
- `...`: ignored, only in place to allow future extensions

## Returns

a data.frame

## Description

Join the data set microorganisms easily to an existing data set or to a character vector.

## Details

Note: As opposed to the `join()` functions of `dplyr`, character vectors are supported and at default existing columns will get a suffix `""2""` and the newly joined columns will not get a suffix.

If the `dplyr` package is installed, their join functions will be used. Otherwise, the much slower `merge()` and `interaction()` functions from base will be used.

## Examples

```r
left_join_microorganisms(as.mo(""K. pneumoniae""))
left_join_microorganisms(""B_KLBSL_PNMN"")

df <- data.frame(
  date = seq(
    from = as.Date(""2018-01-01""),
    to = as.Date(""2018-01-07""),
    by = 1
  ),
  bacteria = as.mo(c(
    ""S. aureus"", ""MRSA"", ""MSSA"", ""STAAUR"",
    ""E. coli"", ""E. coli"", ""E. coli""
  )),
  stringsAsFactors = FALSE
)
colnames(df)

df_joined <- left_join_microorganisms(df, ""bacteria"")
colnames(df_joined)


if (require(""dplyr"")) {
  example_isolates %>%
    left_join_microorganisms() %>%
    colnames()
}
```



","['Join microorganisms to a Data Set```rinner_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)left_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)right_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)full_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)semi_join_microorganisms(x, by = NULL, ...)anti_join_microorganisms(x, by = NULL, ...)``` Arguments- `x`: existing data set to join, or character vector.', 'In case of a character vector, the resulting data.frame will contain a column \'x\' with these values.- `by`: a variable to join by - if left empty will search for a column with class `mo` (created with `as.mo()`) or will be `""mo""` if that column name exists in `x`, could otherwise be a column name of `x` with values that exist in `microorganisms$mo` (such as `by = ""bacteria_id""`), or another column in microorganisms (but then it should be named, like `by = c(""bacteria_id"" = ""fullname"")`)- `suffix`: if there are non-joined duplicate variables in `x` and `y`, these suffixes will be added to the output to disambiguate them.', 'Should be a character vector of length 2.- `...`: ignored, only in place to allow future extensions Returnsa data.frame DescriptionJoin the data set microorganisms easily to an existing data set or to a character vector.', 'DetailsNote: As opposed to the `join()` functions of `dplyr`, character vectors are supported and at default existing columns will get a suffix `""2""` and the newly joined columns will not get a suffix.If the `dplyr` package is installed, their join functions will be used.', 'Otherwise, the much slower `merge()` and `interaction()` functions from base will be used.', 'Examples```rleft_join_microorganisms(as.mo(""K. pneumoniae""))left_join_microorganisms(""B_KLBSL_PNMN"")df <- data.frame(  date = seq(    from = as.Date(""2018-01-01""),    to = as.Date(""2018-01-07""),    by = 1  ),  bacteria = as.mo(c(    ""S. aureus"", ""MRSA"", ""MSSA"", ""STAAUR"",    ""E. coli"", ""E. coli"", ""E. coli""  )),  stringsAsFactors = FALSE)colnames(df)df_joined <- left_join_microorganisms(df, ""bacteria"")colnames(df_joined)if (require(""dplyr"")) {  example_isolates %>%    left_join_microorganisms() %>%    colnames()}```']",1," Join microorganisms to a Data Set```rinner_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)left_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)right_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)full_join_microorganisms(x, by = NULL, suffix = c(""2"", """"), ...)semi_join_microorganisms(x, by = NULL, ...)anti_join_microorganisms(x, by = NULL, ...)``` Arguments- `x`: existing data set to join, or character vector. In case of a character vector, the resulting data.frame will contain a column 'x' with these values.- `by`: a variable to join by - if left empty will search for a column with class `mo` (created with `as.mo()`) or will be `""mo""` if that column name exists in `x`, could otherwise be a column name of `x` with values that exist in `microorganisms$mo` (such as `by = ""bacteria_id""`), or another column in microorganisms (but then it should be named, like `by = c(""bacteria_id"" = ""fullname"")`)- `suffix`: if there are non-joined duplicate variables in `x` and `y`, these suffixes will be added to the output to disambiguate them. Should be a character vector of length 2.- `...`: ignored, only in place to allow future extensions Returnsa data.frame DescriptionJoin the data set microorganisms easily to an existing data set or to a character vector. DetailsNote: As opposed to the `join()` functions of `dplyr`, character vectors are supported and at default existing columns will get a suffix `""2""` and the newly joined columns will not get a suffix.If the `dplyr` package is installed, their join functions will be used. Otherwise, the much slower `merge()` and `interaction()` functions from base will be used. Examples```rleft_join_microorganisms(as.mo(""K. pneumoniae""))left_join_microorganisms(""B_KLBSL_PNMN"")df <- data.frame(  date = seq(    from = as.Date(""2018-01-01""),    to = as.Date(""2018-01-07""),    by = 1  ),  bacteria = as.mo(c(    ""S. aureus"", ""MRSA"", ""MSSA"", ""STAAUR"",    ""E. coli"", ""E. coli"", ""E. coli""  )),  stringsAsFactors = FALSE)colnames(df)df_joined <- left_join_microorganisms(df, ""bacteria"")colnames(df_joined)if (require(""dplyr"")) {  example_isolates %>%    left_join_microorganisms() %>%    colnames()}```",7
AMR,as.mo.md,"# Transform Arbitrary Input to Valid Microbial Taxonomy

```r
as.mo(
  x,
  Becker = FALSE,
  Lancefield = FALSE,
  minimum_matching_score = NULL,
  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),
  reference_df = get_mo_source(),
  ignore_pattern = getOption(""AMR_ignore_pattern"", NULL),
  cleaning_regex = getOption(""AMR_cleaning_regex"", mo_cleaning_regex()),
  language = get_AMR_locale(),
  info = interactive(),
  ...
)

is.mo(x)

mo_uncertainties()

mo_renamed()

mo_failures()

mo_reset_session()

mo_cleaning_regex()
```

## Arguments

- `x`: a character vector or a data.frame with one or two columns
- `Becker`: a logical to indicate whether staphylococci should be categorised into coagulase-negative staphylococci (""CoNS"") and coagulase-positive staphylococci (""CoPS"") instead of their own species, according to Karsten Becker **et al.** (see **Source**). Please see **Details** for a full list of staphylococcal species that will be converted.
    
    This excludes **Staphylococcus aureus** at default, use `Becker = ""all""` to also categorise **S. aureus** as ""CoPS"".
- `Lancefield`: a logical to indicate whether a beta-haemolytic **Streptococcus** should be categorised into Lancefield groups instead of their own species, according to Rebecca C. Lancefield (see **Source**). These streptococci will be categorised in their first group, e.g. **Streptococcus dysgalactiae** will be group C, although officially it was also categorised into groups G and L. . Please see **Details** for a full list of streptococcal species that will be converted.
    
    This excludes enterococci at default (who are in group D), use `Lancefield = ""all""` to also categorise all enterococci as group D.
- `minimum_matching_score`: a numeric value to set as the lower limit for the MO matching score . When left blank, this will be determined automatically based on the character length of `x`, its taxonomic kingdom and human pathogenicity .
- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`, which will return a note if old taxonomic names were processed. The default can be set with the package option `AMR_keep_synonyms`, i.e. `options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.
- `reference_df`: a data.frame to be used for extra reference when translating `x` to a valid `mo`. See `set_mo_source()` and `get_mo_source()` to automate the usage of your own codes (e.g. used in your analysis or organisation).
- `ignore_pattern`: a Perl-compatible regular expression (case-insensitive) of which all matches in `x` must return `NA`. This can be convenient to exclude known non-relevant input and can also be set with the package option `AMR_ignore_pattern`, e.g. `options(AMR_ignore_pattern = ""(not reported|contaminated flora)"")`.
- `cleaning_regex`: a Perl-compatible regular expression (case-insensitive) to clean the input of `x`. Every matched part in `x` will be removed. At default, this is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"". The default can be set with the package option `AMR_cleaning_regex`.
- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)
- `info`: a logical to indicate if a progress bar should be printed if more than 25 items are to be coerced - the default is `TRUE` only in interactive mode
- `...`: other arguments passed on to functions

## Returns

A character vector with additional class `mo`

## Description

Use this function to get a valid microorganism code (`mo`) based on arbitrary user input. Determination is done using intelligent rules and the complete taxonomic tree of the kingdoms Animalia, Archaea, Bacteria, and Protozoa, and most microbial species from the kingdom Fungi (see **Source**). The input can be almost anything: a full name (like `""Staphylococcus aureus""`), an abbreviated name (such as `""S. aureus""`), an abbreviation known in the field (such as `""MRSA""`), or just a genus. See **Examples**.

## Details

A microorganism (MO) code from this package (class: `mo`) is human readable and typically looks like these examples:

 

```
Code               Full name
  ---------------    --------------------------------------
  B_KLBSL            Klebsiella
  B_KLBSL_PNMN       Klebsiella pneumoniae
  B_KLBSL_PNMN_RHNS  Klebsiella pneumoniae rhinoscleromatis
  |   |    |    |
  |   |    |    |
  |   |    |    \---> subspecies, a 3-5 letter acronym
  |   |    \----> species, a 3-6 letter acronym
  |   \----> genus, a 4-8 letter acronym
  \----> taxonomic kingdom: A (Archaea), AN (Animalia), B (Bacteria),
                       F (Fungi), PL (Plantae), P (Protozoa)
```

 

Values that cannot be coerced will be considered 'unknown' and will be returned as the MO code `UNKNOWN` with a warning.

Use the `mo_*` functions to get properties based on the returned code, see **Examples**.

The `as.mo()` function uses a novel matching score algorithm (see **Matching Score for Microorganisms** below) to match input against the available microbial taxonomy in this package. This will lead to the effect that e.g. `""E. coli""` (a microorganism highly prevalent in humans) will return the microbial ID of **Escherichia coli** and not **Entamoeba coli** (a microorganism less prevalent in humans), although the latter would alphabetically come first.

With `Becker = TRUE`, the following 85 staphylococci will be converted to the coagulase-negative group : **S. argensis**, **S. arlettae**, **S. auricularis**, **S. borealis**, **S. caeli**, **S. caledonicus**, **S. canis**, **S. capitis**, **S. capitis capitis**, **S. capitis urealyticus**, **S. capitis ureolyticus**, **S. caprae**, **S. carnosus**, **S. carnosus carnosus**, **S. carnosus utilis**, **S. casei**, **S. caseolyticus**, **S. chromogenes**, **S. cohnii**, **S. cohnii cohnii**, **S. cohnii urealyticum**, **S. cohnii urealyticus**, **S. condimenti**, **S. croceilyticus**, **S. debuckii**, **S. devriesei**, **S. durrellii**, **S. edaphicus**, **S. epidermidis**, **S. equorum**, **S. equorum equorum**, **S. equorum linens**, **S. felis**, **S. fleurettii**, **S. gallinarum**, **S. haemolyticus**, **S. hominis**, **S. hominis hominis**, **S. hominis novobiosepticus**, **S. jettensis**, **S. kloosii**, **S. lentus**, **S. lloydii**, **S. lugdunensis**, **S. massiliensis**, **S. microti**, **S. muscae**, **S. nepalensis**, **S. pasteuri**, **S. petrasii**, **S. petrasii croceilyticus**, **S. petrasii jettensis**, **S. petrasii petrasii**, **S. petrasii pragensis**, **S. pettenkoferi**, **S. piscifermentans**, **S. pragensis**, **S. pseudoxylosus**, **S. pulvereri**, **S. ratti**, **S. rostri**, **S. saccharolyticus**, **S. saprophyticus**, **S. saprophyticus bovis**, **S. saprophyticus saprophyticus**, **S. schleiferi**, **S. schleiferi schleiferi**, **S. sciuri**, **S. sciuri carnaticus**, **S. sciuri lentus**, **S. sciuri rodentium**, **S. sciuri sciuri**, **S. simulans**, **S. stepanovicii**, **S. succinus**, **S. succinus casei**, **S. succinus succinus**, **S. taiwanensis**, **S. urealyticus**, **S. ureilyticus**, **S. veratri**, **S. vitulinus**, **S. vitulus**, **S. warneri**, and **S. xylosus**.

The following 16 staphylococci will be converted to the coagulase-positive group : **S. agnetis**, **S. argenteus**, **S. coagulans**, **S. cornubiensis**, **S. delphini**, **S. hyicus**, **S. hyicus chromogenes**, **S. hyicus hyicus**, **S. intermedius**, **S. lutrae**, **S. pseudintermedius**, **S. roterodami**, **S. schleiferi coagulans**, **S. schweitzeri**, **S. simiae**, and **S. singaporensis**.

With `Lancefield = TRUE`, the following streptococci will be converted to their corresponding Lancefield group: **S. agalactiae** (Group B), **S. anginosus anginosus** (Group F), **S. anginosus whileyi** (Group F), **S. anginosus** (Group F), **S. canis** (Group G), **S. dysgalactiae dysgalactiae** (Group C), **S. dysgalactiae equisimilis** (Group C), **S. dysgalactiae** (Group C), **S. equi equi** (Group C), **S. equi ruminatorum** (Group C), **S. equi zooepidemicus** (Group C), **S. equi** (Group C), **S. pyogenes** (Group A), **S. salivarius salivarius** (Group K), **S. salivarius thermophilus** (Group K), **S. salivarius** (Group K), and **S. sanguinis** (Group H).

### Coping with Uncertain Results

 Results of non-exact taxonomic input are based on their matching score . The lowest allowed score can be set with the `minimum_matching_score` argument. At default this will be determined based on the character length of the input, and the taxonomic kingdom and human pathogenicity of the taxonomic outcome. If values are matched with uncertainty, a message will be shown to suggest the user to evaluate the results with `mo_uncertainties()`, which returns a data.frame with all specifications.

To increase the quality of matching, the `cleaning_regex` argument can be used to clean the input (i.e., `x`). This must be a regular expression that matches parts of the input that should be removed before the input is matched against the available microbial taxonomy . It will be matched Perl-compatible and case-insensitive. The default value of `cleaning_regex` is the outcome of the helper function `mo_cleaning_regex()`.

There are three helper functions that can be run after using the `as.mo()` function:

 * Use `mo_uncertainties()` to get a data.frame that prints in a pretty format with all taxonomic names that were guessed. The output contains the matching score for all matches (see **Matching Score for Microorganisms** below).
 * Use `mo_failures()` to get a character vector with all values that could not be coerced to a valid value.
 * Use `mo_renamed()` to get a data.frame with all values that could be coerced based on old, previously accepted taxonomic names.

### Microbial Prevalence of Pathogens in Humans

 The coercion rules consider the prevalence of microorganisms in humans, which is available as the `prevalence` column in the microorganisms data set. The grouping into human pathogenic prevalence is explained in the section **Matching Score for Microorganisms** below.

## Source

1. Berends MS **et al.** (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . **Journal of Statistical Software**, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")
2. Becker K **et al.** (2014). Coagulase-Negative Staphylococci. **Clin Microbiol Rev.** 27(4): 870-926; tools:::Rd_expr_doi(""10.1128/CMR.00109-13"")
3. Becker K **et al.** (2019). Implications of identifying the recently defined members of the _S.aureus_ complex, _S. argenteus_ and _S. schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS). **Clin Microbiol Infect**; tools:::Rd_expr_doi(""10.1016/j.cmi.2019.02.028"")
4. Becker K **et al.** (2020). Emergence of coagulase-negative staphylococci. **Expert Rev Anti Infect Ther.** 18(4):349-366; tools:::Rd_expr_doi(""10.1080/14787210.2020.1730813"")
5. Lancefield RC (1933). A serological differentiation of human and other groups of hemolyticstreptococci. **J Exp Med.** 57(4): 571-95; tools:::Rd_expr_doi(""10.1084/jem.57.4.571"")
6. Berends MS **et al.** (2022). Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ **Micro.rganisms** 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")
7. Parte, AC **et al.** (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.
8. GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.
9. Reimer, LC **et al.** (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.
10. Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)
11. Bartlett A **et al.** (2022). A comprehensive list of bacterial pathogens infecting humans **Microbiology** 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"")

## Matching Score for Microorganisms

 With ambiguous user input in `as.mo()` and all the `mo_*` functions, the returned results are chosen based on their matching score using `mo_matching_score()`. This matching score `m`, is calculated as:

 

where:

 * `x` is the user input;
 * `n` is a taxonomic name (genus, species, and subspecies);
 * `l_n` is the length of `n`;
 * `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;
 * `p_n` is the human pathogenic prevalence group of `n`, as described below;
 * `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.

The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett **et al.** (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:

 * Established , if a taxonomic species has infected at least three persons in three or more references. These records have `prevalence = 1.0` in the microorganisms data set;
 * Putative , if a taxonomic species has fewer than three known cases. These records have `prevalence = 1.25` in the microorganisms data set.

Furthermore,


 * Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;
 * Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;
 * Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;
 * Any **non-bacterial** genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: **Absidia**, **Acanthamoeba**, **Acremonium**, **Aedes**, **Alternaria**, **Amoeba**, **Ancylostoma**, **Angiostrongylus**, **Anisakis**, **Anopheles**, **Apophysomyces**, **Aspergillus**, **Aureobasidium**, **Basidiobolus**, **Beauveria**, **Blastocystis**, **Blastomyces**, **Candida**, **Capillaria**, **Chaetomium**, **Chrysonilia**, **Cladophialophora**, **Cladosporium**, **Conidiobolus**, **Contracaecum**, **Cordylobia**, **Cryptococcus**, **Curvularia**, **Demodex**, **Dermatobia**, **Dientamoeba**, **Diphyllobothrium**, **Dirofilaria**, **Echinostoma**, **Entamoeba**, **Enterobius**, **Exophiala**, **Exserohilum**, **Fasciola**, **Fonsecaea**, **Fusarium**, **Giardia**, **Haloarcula**, **Halobacterium**, **Halococcus**, **Hendersonula**, **Heterophyes**, **Histomonas**, **Histoplasma**, **Hymenolepis**, **Hypomyces**, **Hysterothylacium**, **Leishmania**, **Malassezia**, **Malbranchea**, **Metagonimus**, **Meyerozyma**, **Microsporidium**, **Microsporum**, **Mortierella**, **Mucor**, **Mycocentrospora**, **Necator**, **Nectria**, **Ochroconis**, **Oesophagostomum**, **Oidiodendron**, **Opisthorchis**, **Pediculus**, **Penicillium**, **Phlebotomus**, **Phoma**, **Pichia**, **Piedraia**, **Pithomyces**, **Pityrosporum**, **Pneumocystis**, **Pseudallescheria**, **Pseudoterranova**, **Pulex**, **Rhizomucor**, **Rhizopus**, **Rhodotorula**, **Saccharomyces**, **Sarcoptes**, **Scolecobasidium**, **Scopulariopsis**, **Scytalidium**, **Spirometra**, **Sporobolomyces**, **Stachybotrys**, **Strongyloides**, **Syngamus**, **Taenia**, **Talaromyces**, **Toxocara**, **Trichinella**, **Trichobilharzia**, **Trichoderma**, **Trichomonas**, **Trichophyton**, **Trichosporon**, **Trichostrongylus**, **Trichuris**, **Tritirachium**, **Trombicula**, **Trypanosoma**, **Tunga**, or **Wuchereria**;
 * All other records have `prevalence = 2.0` in the microorganisms data set.

When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.


All matches are sorted descending on their matching score and for all user input values, the top match will be returned. This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of **Escherichia coli** (`m = 0.688`, a highly prevalent microorganism found in humans) and not **Entamoeba coli** (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first.

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
# These examples all return ""B_STPHY_AURS"", the ID of S. aureus:
as.mo(c(
  ""sau"", # WHONET code
  ""stau"",
  ""STAU"",
  ""staaur"",
  ""S. aureus"",
  ""S aureus"",
  ""Sthafilokkockus aureus"", # handles incorrect spelling
  ""Staphylococcus aureus (MRSA)"",
  ""MRSA"", # Methicillin Resistant S. aureus
  ""VISA"", # Vancomycin Intermediate S. aureus
  ""VRSA"", # Vancomycin Resistant S. aureus
  115329001 # SNOMED CT code
))

# Dyslexia is no problem - these all work:
as.mo(c(
  ""Ureaplasma urealyticum"",
  ""Ureaplasma urealyticus"",
  ""Ureaplasmium urealytica"",
  ""Ureaplazma urealitycium""
))

# input will get cleaned up with the input given in the `cleaning_regex` argument,
# which defaults to `mo_cleaning_regex()`:
cat(mo_cleaning_regex(), ""\n"")

as.mo(""Streptococcus group A"")

as.mo(""S. epidermidis"") # will remain species: B_STPHY_EPDR
as.mo(""S. epidermidis"", Becker = TRUE) # will not remain species: B_STPHY_CONS

as.mo(""S. pyogenes"") # will remain species: B_STRPT_PYGN
as.mo(""S. pyogenes"", Lancefield = TRUE) # will not remain species: B_STRPT_GRPA

# All mo_* functions use as.mo() internally too (see ?mo_property):
mo_genus(""E. coli"")
mo_gramstain(""ESCO"")
mo_is_intrinsic_resistant(""ESCCOL"", ab = ""vanco"")
```

## See Also

microorganisms for the data.frame that is being used to determine ID's.

The `mo_*` functions (such as `mo_genus()`, `mo_gramstain()`) to get properties based on the returned code.



","['Transform Arbitrary Input to Valid Microbial Taxonomy```ras.mo(  x,  Becker = FALSE,  Lancefield = FALSE,  minimum_matching_score = NULL,  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  reference_df = get_mo_source(),  ignore_pattern = getOption(""AMR_ignore_pattern"", NULL),  cleaning_regex = getOption(""AMR_cleaning_regex"", mo_cleaning_regex()),  language = get_AMR_locale(),  info = interactive(),  ...)is.mo(x)mo_uncertainties()mo_renamed()mo_failures()mo_reset_session()mo_cleaning_regex()``` Arguments- `x`: a character vector or a data.frame with one or two columns- `Becker`: a logical to indicate whether staphylococci should be categorised into coagulase-negative staphylococci (""CoNS"") and coagulase-positive staphylococci (""CoPS"") instead of their own species, according to Karsten Becker et al.', 'Please see Details for a full list of staphylococcal species that will be converted.', 'This excludes Staphylococcus aureus at default, use `Becker = ""all""` to also categorise S. aureus as ""CoPS"".- `Lancefield`: a logical to indicate whether a beta-haemolytic Streptococcus should be categorised into Lancefield groups instead of their own species, according to Rebecca C. Lancefield (see Source).', 'These streptococci will be categorised in their first group, e.g.', 'Streptococcus dysgalactiae will be group C, although officially it was also categorised into groups G and L. .', 'Please see Details for a full list of streptococcal species that will be converted.', 'This excludes enterococci at default (who are in group D), use `Lancefield = ""all""` to also categorise all enterococci as group D.- `minimum_matching_score`: a numeric value to set as the lower limit for the MO matching score .', 'When left blank, this will be determined automatically based on the character length of `x`, its taxonomic kingdom and human pathogenicity .- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names.', 'The default is `FALSE`, which will return a note if old taxonomic names were processed.', 'The default can be set with the package option `AMR_keep_synonyms`, i.e.', '`options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.- `reference_df`: a data.frame to be used for extra reference when translating `x` to a valid `mo`.', 'See `set_mo_source()` and `get_mo_source()` to automate the usage of your own codes (e.g.', 'used in your analysis or organisation).- `ignore_pattern`: a Perl-compatible regular expression (case-insensitive) of which all matches in `x` must return `NA`.', 'This can be convenient to exclude known non-relevant input and can also be set with the package option `AMR_ignore_pattern`, e.g.', '`options(AMR_ignore_pattern = ""(not reported|contaminated flora)"")`.- `cleaning_regex`: a Perl-compatible regular expression (case-insensitive) to clean the input of `x`.', 'Every matched part in `x` will be removed.', 'At default, this is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"".', 'The default can be set with the package option `AMR_cleaning_regex`.- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)- `info`: a logical to indicate if a progress bar should be printed if more than 25 items are to be coerced - the default is `TRUE` only in interactive mode- `...`: other arguments passed on to functions ReturnsA character vector with additional class `mo` DescriptionUse this function to get a valid microorganism code (`mo`) based on arbitrary user input.', 'Determination is done using intelligent rules and the complete taxonomic tree of the kingdoms Animalia, Archaea, Bacteria, and Protozoa, and most microbial species from the kingdom Fungi (see Source).', 'The input can be almost anything: a full name (like `""Staphylococcus aureus""`), an abbreviated name (such as `""S. aureus""`), an abbreviation known in the field (such as `""MRSA""`), or just a genus.', ""DetailsA microorganism (MO) code from this package (class: `mo`) is human readable and typically looks like these examples: ```Code               Full name  ---------------    --------------------------------------  B_KLBSL            Klebsiella  B_KLBSL_PNMN       Klebsiella pneumoniae  B_KLBSL_PNMN_RHNS  Klebsiella pneumoniae rhinoscleromatis  |   |    |    |  |   |    |    |  |   |    |    \\---> subspecies, a 3-5 letter acronym  |   |    \\----> species, a 3-6 letter acronym  |   \\----> genus, a 4-8 letter acronym  \\----> taxonomic kingdom: A (Archaea), AN (Animalia), B (Bacteria),                       F (Fungi), PL (Plantae), P (Protozoa)``` Values that cannot be coerced will be considered 'unknown' and will be returned as the MO code `UNKNOWN` with a warning.Use the `mo_` functions to get properties based on the returned code, see Examples.The `as.mo()` function uses a novel matching score algorithm (see Matching Score for Microorganisms below) to match input against the available microbial taxonomy in this package."", 'This will lead to the effect that e.g.', '`""E. coli""` (a microorganism highly prevalent in humans) will return the microbial ID of Escherichia coli and not Entamoeba coli (a microorganism less prevalent in humans), although the latter would alphabetically come first.With `Becker = TRUE`, the following 85 staphylococci will be converted to the coagulase-negative group : S. argensis, S. arlettae, S. auricularis, S. borealis, S. caeli, S. caledonicus, S. canis, S. capitis, S. capitis capitis, S. capitis urealyticus, S. capitis ureolyticus, S. caprae, S. carnosus, S. carnosus carnosus, S. carnosus utilis, S. casei, S. caseolyticus, S. chromogenes, S. cohnii, S. cohnii cohnii, S. cohnii urealyticum, S. cohnii urealyticus, S. condimenti, S. croceilyticus, S. debuckii, S. devriesei, S. durrellii, S. edaphicus, S. epidermidis, S. equorum, S. equorum equorum, S. equorum linens, S. felis, S. fleurettii, S. gallinarum, S. haemolyticus, S. hominis, S. hominis hominis, S. hominis novobiosepticus, S. jettensis, S. kloosii, S. lentus, S. lloydii, S. lugdunensis, S. massiliensis, S. microti, S. muscae, S. nepalensis, S. pasteuri, S. petrasii, S. petrasii croceilyticus, S. petrasii jettensis, S. petrasii petrasii, S. petrasii pragensis, S. pettenkoferi, S. piscifermentans, S. pragensis, S. pseudoxylosus, S. pulvereri, S. ratti, S. rostri, S. saccharolyticus, S. saprophyticus, S. saprophyticus bovis, S. saprophyticus saprophyticus, S. schleiferi, S. schleiferi schleiferi, S. sciuri, S. sciuri carnaticus, S. sciuri lentus, S. sciuri rodentium, S. sciuri sciuri, S. simulans, S. stepanovicii, S. succinus, S. succinus casei, S. succinus succinus, S. taiwanensis, S. urealyticus, S. ureilyticus, S. veratri, S. vitulinus, S. vitulus, S. warneri, and S. xylosus.The following 16 staphylococci will be converted to the coagulase-positive group : S. agnetis, S. argenteus, S. coagulans, S. cornubiensis, S. delphini, S. hyicus, S. hyicus chromogenes, S. hyicus hyicus, S. intermedius, S. lutrae, S. pseudintermedius, S. roterodami, S. schleiferi coagulans, S. schweitzeri, S. simiae, and S. singaporensis.With `Lancefield = TRUE`, the following streptococci will be converted to their corresponding Lancefield group: S. agalactiae (Group B), S. anginosus anginosus (Group F), S. anginosus whileyi (Group F), S. anginosus (Group F), S. canis (Group G), S. dysgalactiae dysgalactiae (Group C), S. dysgalactiae equisimilis (Group C), S. dysgalactiae (Group C), S. equi equi (Group C), S. equi ruminatorum (Group C), S. equi zooepidemicus (Group C), S. equi (Group C), S. pyogenes (Group A), S. salivarius salivarius (Group K), S. salivarius thermophilus (Group K), S. salivarius (Group K), and S. sanguinis (Group H).', 'Coping with Uncertain Results Results of non-exact taxonomic input are based on their matching score .', 'The lowest allowed score can be set with the `minimum_matching_score` argument.', 'At default this will be determined based on the character length of the input, and the taxonomic kingdom and human pathogenicity of the taxonomic outcome.', 'If values are matched with uncertainty, a message will be shown to suggest the user to evaluate the results with `mo_uncertainties()`, which returns a data.frame with all specifications.To increase the quality of matching, the `cleaning_regex` argument can be used to clean the input (i.e., `x`).', 'This must be a regular expression that matches parts of the input that should be removed before the input is matched against the available microbial taxonomy .', 'It will be matched Perl-compatible and case-insensitive.', 'The default value of `cleaning_regex` is the outcome of the helper function `mo_cleaning_regex()`.There are three helper functions that can be run after using the `as.mo()` function:  Use `mo_uncertainties()` to get a data.frame that prints in a pretty format with all taxonomic names that were guessed.', 'The output contains the matching score for all matches (see Matching Score for Microorganisms below).', 'Use `mo_failures()` to get a character vector with all values that could not be coerced to a valid value.', 'Use `mo_renamed()` to get a data.frame with all values that could be coerced based on old, previously accepted taxonomic names.', 'Microbial Prevalence of Pathogens in Humans The coercion rules consider the prevalence of microorganisms in humans, which is available as the `prevalence` column in the microorganisms data set.', 'The grouping into human pathogenic prevalence is explained in the section Matching Score for Microorganisms below.', 'AMR: An R Package for Working with Antimicrobial Resistance Data .', 'Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")2.', 'Implications of identifying the recently defined members of the _S.aureus_ complex, _S.', 'schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS).', 'Expert Rev Anti Infect Ther.', 'A serological differentiation of human and other groups of hemolyticstreptococci.', 'Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ Micro.rganisms 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")7.', 'List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ.', 'International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") .', 'Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.8.', 'Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.9.', '_BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data.', 'Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") .', 'Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.10.', 'Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS).', 'US Edition of SNOMED CT from 1 September 2020.', ""Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12)."", 'A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"") Matching Score for Microorganisms With ambiguous user input in `as.mo()` and all the `mo_` functions, the returned results are chosen based on their matching score using `mo_matching_score()`.', 'This matching score `m`, is calculated as: where:  `x` is the user input;  `n` is a taxonomic name (genus, species, and subspecies);  `l_n` is the length of `n`;  `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;  `p_n` is the human pathogenic prevalence group of `n`, as described below;  `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett et al.', '(2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:  Established , if a taxonomic species has infected at least three persons in three or more references.', 'These records have `prevalence = 1.0` in the microorganisms data set;  Putative , if a taxonomic species has fewer than three known cases.', 'These records have `prevalence = 1.25` in the microorganisms data set.Furthermore,  Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;  Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;  Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;  Any non-bacterial genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: Absidia, Acanthamoeba, Acremonium, Aedes, Alternaria, Amoeba, Ancylostoma, Angiostrongylus, Anisakis, Anopheles, Apophysomyces, Aspergillus, Aureobasidium, Basidiobolus, Beauveria, Blastocystis, Blastomyces, Candida, Capillaria, Chaetomium, Chrysonilia, Cladophialophora, Cladosporium, Conidiobolus, Contracaecum, Cordylobia, Cryptococcus, Curvularia, Demodex, Dermatobia, Dientamoeba, Diphyllobothrium, Dirofilaria, Echinostoma, Entamoeba, Enterobius, Exophiala, Exserohilum, Fasciola, Fonsecaea, Fusarium, Giardia, Haloarcula, Halobacterium, Halococcus, Hendersonula, Heterophyes, Histomonas, Histoplasma, Hymenolepis, Hypomyces, Hysterothylacium, Leishmania, Malassezia, Malbranchea, Metagonimus, Meyerozyma, Microsporidium, Microsporum, Mortierella, Mucor, Mycocentrospora, Necator, Nectria, Ochroconis, Oesophagostomum, Oidiodendron, Opisthorchis, Pediculus, Penicillium, Phlebotomus, Phoma, Pichia, Piedraia, Pithomyces, Pityrosporum, Pneumocystis, Pseudallescheria, Pseudoterranova, Pulex, Rhizomucor, Rhizopus, Rhodotorula, Saccharomyces, Sarcoptes, Scolecobasidium, Scopulariopsis, Scytalidium, Spirometra, Sporobolomyces, Stachybotrys, Strongyloides, Syngamus, Taenia, Talaromyces, Toxocara, Trichinella, Trichobilharzia, Trichoderma, Trichomonas, Trichophyton, Trichosporon, Trichostrongylus, Trichuris, Tritirachium, Trombicula, Trypanosoma, Tunga, or Wuchereria;  All other records have `prevalence = 2.0` in the microorganisms data set.When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.All matches are sorted descending on their matching score and for all user input values, the top match will be returned.', 'This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of Escherichia coli (`m = 0.688`, a highly prevalent microorganism found in humans) and not Entamoeba coli (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```r These examples all return ""B_STPHY_AURS"", the ID of S. aureus:as.mo(c(  ""sau"",  WHONET code  ""stau"",  ""STAU"",  ""staaur"",  ""S. aureus"",  ""S aureus"",  ""Sthafilokkockus aureus"",  handles incorrect spelling  ""Staphylococcus aureus (MRSA)"",  ""MRSA"",  Methicillin Resistant S. aureus  ""VISA"",  Vancomycin Intermediate S. aureus  ""VRSA"",  Vancomycin Resistant S. aureus  115329001  SNOMED CT code)) Dyslexia is no problem - these all work:as.mo(c(  ""Ureaplasma urealyticum"",  ""Ureaplasma urealyticus"",  ""Ureaplasmium urealytica"",  ""Ureaplazma urealitycium"")) input will get cleaned up with the input given in the `cleaning_regex` argument, which defaults to `mo_cleaning_regex()`:cat(mo_cleaning_regex(), ""\\n"")as.mo(""Streptococcus group A"")as.mo(""S. epidermidis"")  will remain species: B_STPHY_EPDRas.mo(""S. epidermidis"", Becker = TRUE)  will not remain species: B_STPHY_CONSas.mo(""S. pyogenes"")  will remain species: B_STRPT_PYGNas.mo(""S. pyogenes"", Lancefield = TRUE)  will not remain species: B_STRPT_GRPA All mo_ functions use as.mo() internally too (see ?mo_property):mo_genus(""E. coli"")mo_gramstain(""ESCO"")mo_is_intrinsic_resistant(""ESCCOL"", ab = ""vanco"")``` See Alsomicroorganisms for the data.frame that is being used to determine ID\'s.The `mo_` functions (such as `mo_genus()`, `mo_gramstain()`) to get properties based on the returned code.']",1," Transform Arbitrary Input to Valid Microbial Taxonomy```ras.mo(  x,  Becker = FALSE,  Lancefield = FALSE,  minimum_matching_score = NULL,  keep_synonyms = getOption(""AMR_keep_synonyms"", FALSE),  reference_df = get_mo_source(),  ignore_pattern = getOption(""AMR_ignore_pattern"", NULL),  cleaning_regex = getOption(""AMR_cleaning_regex"", mo_cleaning_regex()),  language = get_AMR_locale(),  info = interactive(),  ...)is.mo(x)mo_uncertainties()mo_renamed()mo_failures()mo_reset_session()mo_cleaning_regex()``` Arguments- `x`: a character vector or a data.frame with one or two columns- `Becker`: a logical to indicate whether staphylococci should be categorised into coagulase-negative staphylococci (""CoNS"") and coagulase-positive staphylococci (""CoPS"") instead of their own species, according to Karsten Becker et al. (see Source). Please see Details for a full list of staphylococcal species that will be converted.        This excludes Staphylococcus aureus at default, use `Becker = ""all""` to also categorise S. aureus as ""CoPS"".- `Lancefield`: a logical to indicate whether a beta-haemolytic Streptococcus should be categorised into Lancefield groups instead of their own species, according to Rebecca C. Lancefield (see Source). These streptococci will be categorised in their first group, e.g. Streptococcus dysgalactiae will be group C, although officially it was also categorised into groups G and L. . Please see Details for a full list of streptococcal species that will be converted.        This excludes enterococci at default (who are in group D), use `Lancefield = ""all""` to also categorise all enterococci as group D.- `minimum_matching_score`: a numeric value to set as the lower limit for the MO matching score . When left blank, this will be determined automatically based on the character length of `x`, its taxonomic kingdom and human pathogenicity .- `keep_synonyms`: a logical to indicate if old, previously valid taxonomic names must be preserved and not be corrected to currently accepted names. The default is `FALSE`, which will return a note if old taxonomic names were processed. The default can be set with the package option `AMR_keep_synonyms`, i.e. `options(AMR_keep_synonyms = TRUE)` or `options(AMR_keep_synonyms = FALSE)`.- `reference_df`: a data.frame to be used for extra reference when translating `x` to a valid `mo`. See `set_mo_source()` and `get_mo_source()` to automate the usage of your own codes (e.g. used in your analysis or organisation).- `ignore_pattern`: a Perl-compatible regular expression (case-insensitive) of which all matches in `x` must return `NA`. This can be convenient to exclude known non-relevant input and can also be set with the package option `AMR_ignore_pattern`, e.g. `options(AMR_ignore_pattern = ""(not reported|contaminated flora)"")`.- `cleaning_regex`: a Perl-compatible regular expression (case-insensitive) to clean the input of `x`. Every matched part in `x` will be removed. At default, this is the outcome of `mo_cleaning_regex()`, which removes texts between brackets and texts such as ""species"" and ""serovar"". The default can be set with the package option `AMR_cleaning_regex`.- `language`: language to translate text like ""no growth"", which defaults to the system language (see `get_AMR_locale()`)- `info`: a logical to indicate if a progress bar should be printed if more than 25 items are to be coerced - the default is `TRUE` only in interactive mode- `...`: other arguments passed on to functions ReturnsA character vector with additional class `mo` DescriptionUse this function to get a valid microorganism code (`mo`) based on arbitrary user input. Determination is done using intelligent rules and the complete taxonomic tree of the kingdoms Animalia, Archaea, Bacteria, and Protozoa, and most microbial species from the kingdom Fungi (see Source). The input can be almost anything: a full name (like `""Staphylococcus aureus""`), an abbreviated name (such as `""S. aureus""`), an abbreviation known in the field (such as `""MRSA""`), or just a genus. See Examples. DetailsA microorganism (MO) code from this package (class: `mo`) is human readable and typically looks like these examples: ```Code               Full name  ---------------    --------------------------------------  B_KLBSL            Klebsiella  B_KLBSL_PNMN       Klebsiella pneumoniae  B_KLBSL_PNMN_RHNS  Klebsiella pneumoniae rhinoscleromatis  |   |    |    |  |   |    |    |  |   |    |    \---> subspecies, a 3-5 letter acronym  |   |    \----> species, a 3-6 letter acronym  |   \----> genus, a 4-8 letter acronym  \----> taxonomic kingdom: A (Archaea), AN (Animalia), B (Bacteria),                       F (Fungi), PL (Plantae), P (Protozoa)``` Values that cannot be coerced will be considered 'unknown' and will be returned as the MO code `UNKNOWN` with a warning.Use the `mo_` functions to get properties based on the returned code, see Examples.The `as.mo()` function uses a novel matching score algorithm (see Matching Score for Microorganisms below) to match input against the available microbial taxonomy in this package. This will lead to the effect that e.g. `""E. coli""` (a microorganism highly prevalent in humans) will return the microbial ID of Escherichia coli and not Entamoeba coli (a microorganism less prevalent in humans), although the latter would alphabetically come first.With `Becker = TRUE`, the following 85 staphylococci will be converted to the coagulase-negative group : S. argensis, S. arlettae, S. auricularis, S. borealis, S. caeli, S. caledonicus, S. canis, S. capitis, S. capitis capitis, S. capitis urealyticus, S. capitis ureolyticus, S. caprae, S. carnosus, S. carnosus carnosus, S. carnosus utilis, S. casei, S. caseolyticus, S. chromogenes, S. cohnii, S. cohnii cohnii, S. cohnii urealyticum, S. cohnii urealyticus, S. condimenti, S. croceilyticus, S. debuckii, S. devriesei, S. durrellii, S. edaphicus, S. epidermidis, S. equorum, S. equorum equorum, S. equorum linens, S. felis, S. fleurettii, S. gallinarum, S. haemolyticus, S. hominis, S. hominis hominis, S. hominis novobiosepticus, S. jettensis, S. kloosii, S. lentus, S. lloydii, S. lugdunensis, S. massiliensis, S. microti, S. muscae, S. nepalensis, S. pasteuri, S. petrasii, S. petrasii croceilyticus, S. petrasii jettensis, S. petrasii petrasii, S. petrasii pragensis, S. pettenkoferi, S. piscifermentans, S. pragensis, S. pseudoxylosus, S. pulvereri, S. ratti, S. rostri, S. saccharolyticus, S. saprophyticus, S. saprophyticus bovis, S. saprophyticus saprophyticus, S. schleiferi, S. schleiferi schleiferi, S. sciuri, S. sciuri carnaticus, S. sciuri lentus, S. sciuri rodentium, S. sciuri sciuri, S. simulans, S. stepanovicii, S. succinus, S. succinus casei, S. succinus succinus, S. taiwanensis, S. urealyticus, S. ureilyticus, S. veratri, S. vitulinus, S. vitulus, S. warneri, and S. xylosus.The following 16 staphylococci will be converted to the coagulase-positive group : S. agnetis, S. argenteus, S. coagulans, S. cornubiensis, S. delphini, S. hyicus, S. hyicus chromogenes, S. hyicus hyicus, S. intermedius, S. lutrae, S. pseudintermedius, S. roterodami, S. schleiferi coagulans, S. schweitzeri, S. simiae, and S. singaporensis.With `Lancefield = TRUE`, the following streptococci will be converted to their corresponding Lancefield group: S. agalactiae (Group B), S. anginosus anginosus (Group F), S. anginosus whileyi (Group F), S. anginosus (Group F), S. canis (Group G), S. dysgalactiae dysgalactiae (Group C), S. dysgalactiae equisimilis (Group C), S. dysgalactiae (Group C), S. equi equi (Group C), S. equi ruminatorum (Group C), S. equi zooepidemicus (Group C), S. equi (Group C), S. pyogenes (Group A), S. salivarius salivarius (Group K), S. salivarius thermophilus (Group K), S. salivarius (Group K), and S. sanguinis (Group H). Coping with Uncertain Results Results of non-exact taxonomic input are based on their matching score . The lowest allowed score can be set with the `minimum_matching_score` argument. At default this will be determined based on the character length of the input, and the taxonomic kingdom and human pathogenicity of the taxonomic outcome. If values are matched with uncertainty, a message will be shown to suggest the user to evaluate the results with `mo_uncertainties()`, which returns a data.frame with all specifications.To increase the quality of matching, the `cleaning_regex` argument can be used to clean the input (i.e., `x`). This must be a regular expression that matches parts of the input that should be removed before the input is matched against the available microbial taxonomy . It will be matched Perl-compatible and case-insensitive. The default value of `cleaning_regex` is the outcome of the helper function `mo_cleaning_regex()`.There are three helper functions that can be run after using the `as.mo()` function:  Use `mo_uncertainties()` to get a data.frame that prints in a pretty format with all taxonomic names that were guessed. The output contains the matching score for all matches (see Matching Score for Microorganisms below).  Use `mo_failures()` to get a character vector with all values that could not be coerced to a valid value.  Use `mo_renamed()` to get a data.frame with all values that could be coerced based on old, previously accepted taxonomic names. Microbial Prevalence of Pathogens in Humans The coercion rules consider the prevalence of microorganisms in humans, which is available as the `prevalence` column in the microorganisms data set. The grouping into human pathogenic prevalence is explained in the section Matching Score for Microorganisms below. Source1. Berends MS et al. (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"")2. Becker K et al. (2014). Coagulase-Negative Staphylococci. Clin Microbiol Rev. 27(4): 870-926; tools:::Rd_expr_doi(""10.1128/CMR.00109-13"")3. Becker K et al. (2019). Implications of identifying the recently defined members of the _S.aureus_ complex, _S. argenteus_ and _S. schweitzeri_: A position paperof members of the ESCMID Study Group for staphylococci andStaphylococcal Diseases (ESGS). Clin Microbiol Infect; tools:::Rd_expr_doi(""10.1016/j.cmi.2019.02.028"")4. Becker K et al. (2020). Emergence of coagulase-negative staphylococci. Expert Rev Anti Infect Ther. 18(4):349-366; tools:::Rd_expr_doi(""10.1080/14787210.2020.1730813"")5. Lancefield RC (1933). A serological differentiation of human and other groups of hemolyticstreptococci. J Exp Med. 57(4): 571-95; tools:::Rd_expr_doi(""10.1084/jem.57.4.571"")6. Berends MS et al. (2022). Trends in Occurrence and Phenotypic Resistance of Coagulase-NegativeStaphylococci (CoNS) Found in Human Blood in the Northern Netherlandsbetween 2013 and 2019/ Micro.rganisms 10(9), 1801; tools:::Rd_expr_doi(""10.3390/microorganisms10091801"")7. Parte, AC et al. (2020). List of Prokaryotic names with Standing in Nomenclature (LPSN) moves tothe DSMZ. International Journal of Systematic and Evolutionary Microbiology, 70, 5607-5612; tools:::Rd_expr_doi(""10.1099/ijsem.0.004332"") . Accessed from [https://lpsn.dsmz.de](https://lpsn.dsmz.de) on December 11th, 2022.8. GBIF Secretariat (2022). GBIF Backbone Taxonomy. Checklist dataset tools:::Rd_expr_doi(""10.15468/39omei"") . Accessed from [https://www.gbif.org](https://www.gbif.org) on December 11th, 2022.9. Reimer, LC et al. (2022). _BacDive_ in 2022: the knowledge base for standardized bacterial andarchaeal data. Nucleic Acids Res., 50(D1):D741-D74; tools:::Rd_expr_doi(""10.1093/nar/gkab961"") . Accessed from [https://bacdive.dsmz.de](https://bacdive.dsmz.de) on May 12th, 2023.10. Public Health Information Network Vocabulary Access and Distribution System (PHIN VADS). US Edition of SNOMED CT from 1 September 2020. Value Set Name 'Microorganism', OID 2.16.840.1.114222.4.11.1009 (v12). URL: [https://phinvads.cdc.gov](https://phinvads.cdc.gov)11. Bartlett A et al. (2022). A comprehensive list of bacterial pathogens infecting humans Microbiology 168:001269; tools:::Rd_expr_doi(""10.1099/mic.0.001269"") Matching Score for Microorganisms With ambiguous user input in `as.mo()` and all the `mo_` functions, the returned results are chosen based on their matching score using `mo_matching_score()`. This matching score `m`, is calculated as: where:  `x` is the user input;  `n` is a taxonomic name (genus, species, and subspecies);  `l_n` is the length of `n`;  `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;  `p_n` is the human pathogenic prevalence group of `n`, as described below;  `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett et al. (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:  Established , if a taxonomic species has infected at least three persons in three or more references. These records have `prevalence = 1.0` in the microorganisms data set;  Putative , if a taxonomic species has fewer than three known cases. These records have `prevalence = 1.25` in the microorganisms data set.Furthermore,  Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;  Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;  Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;  Any non-bacterial genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: Absidia, Acanthamoeba, Acremonium, Aedes, Alternaria, Amoeba, Ancylostoma, Angiostrongylus, Anisakis, Anopheles, Apophysomyces, Aspergillus, Aureobasidium, Basidiobolus, Beauveria, Blastocystis, Blastomyces, Candida, Capillaria, Chaetomium, Chrysonilia, Cladophialophora, Cladosporium, Conidiobolus, Contracaecum, Cordylobia, Cryptococcus, Curvularia, Demodex, Dermatobia, Dientamoeba, Diphyllobothrium, Dirofilaria, Echinostoma, Entamoeba, Enterobius, Exophiala, Exserohilum, Fasciola, Fonsecaea, Fusarium, Giardia, Haloarcula, Halobacterium, Halococcus, Hendersonula, Heterophyes, Histomonas, Histoplasma, Hymenolepis, Hypomyces, Hysterothylacium, Leishmania, Malassezia, Malbranchea, Metagonimus, Meyerozyma, Microsporidium, Microsporum, Mortierella, Mucor, Mycocentrospora, Necator, Nectria, Ochroconis, Oesophagostomum, Oidiodendron, Opisthorchis, Pediculus, Penicillium, Phlebotomus, Phoma, Pichia, Piedraia, Pithomyces, Pityrosporum, Pneumocystis, Pseudallescheria, Pseudoterranova, Pulex, Rhizomucor, Rhizopus, Rhodotorula, Saccharomyces, Sarcoptes, Scolecobasidium, Scopulariopsis, Scytalidium, Spirometra, Sporobolomyces, Stachybotrys, Strongyloides, Syngamus, Taenia, Talaromyces, Toxocara, Trichinella, Trichobilharzia, Trichoderma, Trichomonas, Trichophyton, Trichosporon, Trichostrongylus, Trichuris, Tritirachium, Trombicula, Trypanosoma, Tunga, or Wuchereria;  All other records have `prevalence = 2.0` in the microorganisms data set.When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.All matches are sorted descending on their matching score and for all user input values, the top match will be returned. This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of Escherichia coli (`m = 0.688`, a highly prevalent microorganism found in humans) and not Entamoeba coli (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first. Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```r These examples all return ""B_STPHY_AURS"", the ID of S. aureus:as.mo(c(  ""sau"",  WHONET code  ""stau"",  ""STAU"",  ""staaur"",  ""S. aureus"",  ""S aureus"",  ""Sthafilokkockus aureus"",  handles incorrect spelling  ""Staphylococcus aureus (MRSA)"",  ""MRSA"",  Methicillin Resistant S. aureus  ""VISA"",  Vancomycin Intermediate S. aureus  ""VRSA"",  Vancomycin Resistant S. aureus  115329001  SNOMED CT code)) Dyslexia is no problem - these all work:as.mo(c(  ""Ureaplasma urealyticum"",  ""Ureaplasma urealyticus"",  ""Ureaplasmium urealytica"",  ""Ureaplazma urealitycium"")) input will get cleaned up with the input given in the `cleaning_regex` argument, which defaults to `mo_cleaning_regex()`:cat(mo_cleaning_regex(), ""\n"")as.mo(""Streptococcus group A"")as.mo(""S. epidermidis"")  will remain species: B_STPHY_EPDRas.mo(""S. epidermidis"", Becker = TRUE)  will not remain species: B_STPHY_CONSas.mo(""S. pyogenes"")  will remain species: B_STRPT_PYGNas.mo(""S. pyogenes"", Lancefield = TRUE)  will not remain species: B_STRPT_GRPA All mo_ functions use as.mo() internally too (see ?mo_property):mo_genus(""E. coli"")mo_gramstain(""ESCO"")mo_is_intrinsic_resistant(""ESCCOL"", ab = ""vanco"")``` See Alsomicroorganisms for the data.frame that is being used to determine ID's.The `mo_` functions (such as `mo_genus()`, `mo_gramstain()`) to get properties based on the returned code.",7
AMR,intrinsic_resistant.md," data

# Data Set with Bacterial Intrinsic Resistance

## Format

A tibble with 134 634 observations and 2 variables:

 * `mo`
   
   Microorganism ID
 * `ab`
   
   Antibiotic ID

```r
intrinsic_resistant
```

## Description

Data set containing defined intrinsic resistance by EUCAST of all bug-drug combinations.

## Details

This data set is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021).

### Direct download

 Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

They allow for machine reading EUCAST and CLSI guidelines , which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI.

## Examples

```r
intrinsic_resistant
```



","['data Data Set with Bacterial Intrinsic Resistance FormatA tibble with 134 634 observations and 2 variables:  `mo`      Microorganism ID  `ab`      Antibiotic ID```rintrinsic_resistant``` DescriptionData set containing defined intrinsic resistance by EUCAST of all bug-drug combinations.', ""DetailsThis data set is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021)."", 'Direct download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).They allow for machine reading EUCAST and CLSI guidelines , which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI.']",1," data Data Set with Bacterial Intrinsic Resistance FormatA tibble with 134 634 observations and 2 variables:  `mo`      Microorganism ID  `ab`      Antibiotic ID```rintrinsic_resistant``` DescriptionData set containing defined intrinsic resistance by EUCAST of all bug-drug combinations. DetailsThis data set is based on ['EUCAST Expert Rules' and 'EUCAST Intrinsic Resistance and Unusual Phenotypes' v3.3](https://www.eucast.org/expert_rules_and_expected_phenotypes) (2021). Direct download Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).They allow for machine reading EUCAST and CLSI guidelines , which is almost impossible with the MS Excel and PDF files distributed by EUCAST and CLSI. Examples```rintrinsic_resistant```",7
AMR,add_custom_antimicrobials.md,"# Add Custom Antimicrobials

```r
add_custom_antimicrobials(x)

clear_custom_antimicrobials()
```

## Arguments

- `x`: a data.frame resembling the antibiotics data set, at least containing columns ""ab"" and ""name""

## Description

With `add_custom_antimicrobials()` you can add your own custom antimicrobial drug names and codes.

## Details

Important: Due to how works, the `add_custom_antimicrobials()` function has to be run in every session - added antimicrobials are not stored between sessions and are thus lost when is exited.

There are two ways to circumvent this and automate the process of adding antimicrobials:

Method 1: Using the package option `AMR_custom_ab`, which is the preferred method. To use this method:

1. Create a data set in the structure of the antibiotics data set (containing at the very least columns ""ab"" and ""name"") and save it with `saveRDS()` to a location of choice, e.g. `""~/my_custom_ab.rds""`, or any remote location.
2. Set the file location to the package option `AMR_custom_ab`: `options(AMR_custom_ab = ""~/my_custom_ab.rds"")`. This can even be a remote file location, such as an https URL. Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of . To do this, open the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`, add this text and save the file:
   
    
   
   ```
   # Add custom antimicrobial codes:
   options(AMR_custom_ab = ""~/my_custom_ab.rds"")
   ```
   
    
   
   Upon package load, this file will be loaded and run through the `add_custom_antimicrobials()` function.

Method 2: Loading the antimicrobial additions directly from your `.Rprofile` file. Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow. To use this method:

1. Edit the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`.
2. Add a text like below and save the file:
   
    
   
   ```
   # Add custom antibiotic drug codes:
    AMR::add_custom_antimicrobials(
      data.frame(ab = ""TESTAB"",
            name = ""Test Antibiotic"",
            group = ""Test Group"")
    )
   ```

Use `clear_custom_antimicrobials()` to clear the previously added antimicrobials.

## Examples

```r
# returns NA and throws a warning (which is suppressed here):
suppressWarnings(
  as.ab(""testab"")
)

# now add a custom entry - it will be considered by as.ab() and
# all ab_*() functions
add_custom_antimicrobials(
  data.frame(
    ab = ""TESTAB"",
    name = ""Test Antibiotic"",
    # you can add any property present in the
    # 'antibiotics' data set, such as 'group':
    group = ""Test Group""
  )
)

# ""testab"" is now a new antibiotic:
as.ab(""testab"")
ab_name(""testab"")
ab_group(""testab"")

ab_info(""testab"")


# Add Co-fluampicil, which is one of the many J01CR50 codes, see
# https://www.whocc.no/ddd/list_of_ddds_combined_products/
add_custom_antimicrobials(
  data.frame(
    ab = ""COFLU"",
    name = ""Co-fluampicil"",
    atc = ""J01CR50"",
    group = ""Beta-lactams/penicillins""
  )
)
ab_atc(""Co-fluampicil"")
ab_name(""J01CR50"")

# even antibiotic selectors work
x <- data.frame(
  random_column = ""some value"",
  coflu = as.sir(""S""),
  ampicillin = as.sir(""R"")
)
x
x[, betalactams()]
```

## See Also

`add_custom_microorganisms()` to add custom microorganisms.



","['Add Custom Antimicrobials```radd_custom_antimicrobials(x)clear_custom_antimicrobials()``` Arguments- `x`: a data.frame resembling the antibiotics data set, at least containing columns ""ab"" and ""name"" DescriptionWith `add_custom_antimicrobials()` you can add your own custom antimicrobial drug names and codes.', 'DetailsImportant: Due to how works, the `add_custom_antimicrobials()` function has to be run in every session - added antimicrobials are not stored between sessions and are thus lost when is exited.There are two ways to circumvent this and automate the process of adding antimicrobials:Method 1: Using the package option `AMR_custom_ab`, which is the preferred method.', 'Create a data set in the structure of the antibiotics data set (containing at the very least columns ""ab"" and ""name"") and save it with `saveRDS()` to a location of choice, e.g.', '`""~/my_custom_ab.rds""`, or any remote location.2.', 'Set the file location to the package option `AMR_custom_ab`: `options(AMR_custom_ab = ""~/my_custom_ab.rds"")`.', 'This can even be a remote file location, such as an https URL.', 'Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of .', 'To do this, open the `.Rprofile` file using e.g.', '`utils::file.edit(""~/.Rprofile"")`, add this text and save the file:             ```    Add custom antimicrobial codes:   options(AMR_custom_ab = ""~/my_custom_ab.rds"")   ```             Upon package load, this file will be loaded and run through the `add_custom_antimicrobials()` function.Method 2: Loading the antimicrobial additions directly from your `.Rprofile` file.', 'Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow.', 'Edit the `.Rprofile` file using e.g.', 'Add a text like below and save the file:             ```    Add custom antibiotic drug codes:    AMR::add_custom_antimicrobials(      data.frame(ab = ""TESTAB"",            name = ""Test Antibiotic"",            group = ""Test Group"")    )   ```Use `clear_custom_antimicrobials()` to clear the previously added antimicrobials.', 'Examples```r returns NA and throws a warning (which is suppressed here):suppressWarnings(  as.ab(""testab"")) now add a custom entry - it will be considered by as.ab() and all ab_() functionsadd_custom_antimicrobials(  data.frame(    ab = ""TESTAB"",    name = ""Test Antibiotic"",     you can add any property present in the     \'antibiotics\' data set, such as \'group\':    group = ""Test Group""  )) ""testab"" is now a new antibiotic:as.ab(""testab"")ab_name(""testab"")ab_group(""testab"")ab_info(""testab"") Add Co-fluampicil, which is one of the many J01CR50 codes, see https://www.whocc.no/ddd/list_of_ddds_combined_products/add_custom_antimicrobials(  data.frame(    ab = ""COFLU"",    name = ""Co-fluampicil"",    atc = ""J01CR50"",    group = ""Beta-lactams/penicillins""  ))ab_atc(""Co-fluampicil"")ab_name(""J01CR50"") even antibiotic selectors workx <- data.frame(  random_column = ""some value"",  coflu = as.sir(""S""),  ampicillin = as.sir(""R""))xx[, betalactams()]``` See Also`add_custom_microorganisms()` to add custom microorganisms.']",1," Add Custom Antimicrobials```radd_custom_antimicrobials(x)clear_custom_antimicrobials()``` Arguments- `x`: a data.frame resembling the antibiotics data set, at least containing columns ""ab"" and ""name"" DescriptionWith `add_custom_antimicrobials()` you can add your own custom antimicrobial drug names and codes. DetailsImportant: Due to how works, the `add_custom_antimicrobials()` function has to be run in every session - added antimicrobials are not stored between sessions and are thus lost when is exited.There are two ways to circumvent this and automate the process of adding antimicrobials:Method 1: Using the package option `AMR_custom_ab`, which is the preferred method. To use this method:1. Create a data set in the structure of the antibiotics data set (containing at the very least columns ""ab"" and ""name"") and save it with `saveRDS()` to a location of choice, e.g. `""~/my_custom_ab.rds""`, or any remote location.2. Set the file location to the package option `AMR_custom_ab`: `options(AMR_custom_ab = ""~/my_custom_ab.rds"")`. This can even be a remote file location, such as an https URL. Since options are not saved between sessions, it is best to save this option to the `.Rprofile` file so that it will be loaded on start-up of . To do this, open the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`, add this text and save the file:             ```    Add custom antimicrobial codes:   options(AMR_custom_ab = ""~/my_custom_ab.rds"")   ```             Upon package load, this file will be loaded and run through the `add_custom_antimicrobials()` function.Method 2: Loading the antimicrobial additions directly from your `.Rprofile` file. Note that the definitions will be stored in a user-specific file, which is a suboptimal workflow. To use this method:1. Edit the `.Rprofile` file using e.g. `utils::file.edit(""~/.Rprofile"")`.2. Add a text like below and save the file:             ```    Add custom antibiotic drug codes:    AMR::add_custom_antimicrobials(      data.frame(ab = ""TESTAB"",            name = ""Test Antibiotic"",            group = ""Test Group"")    )   ```Use `clear_custom_antimicrobials()` to clear the previously added antimicrobials. Examples```r returns NA and throws a warning (which is suppressed here):suppressWarnings(  as.ab(""testab"")) now add a custom entry - it will be considered by as.ab() and all ab_() functionsadd_custom_antimicrobials(  data.frame(    ab = ""TESTAB"",    name = ""Test Antibiotic"",     you can add any property present in the     'antibiotics' data set, such as 'group':    group = ""Test Group""  )) ""testab"" is now a new antibiotic:as.ab(""testab"")ab_name(""testab"")ab_group(""testab"")ab_info(""testab"") Add Co-fluampicil, which is one of the many J01CR50 codes, see https://www.whocc.no/ddd/list_of_ddds_combined_products/add_custom_antimicrobials(  data.frame(    ab = ""COFLU"",    name = ""Co-fluampicil"",    atc = ""J01CR50"",    group = ""Beta-lactams/penicillins""  ))ab_atc(""Co-fluampicil"")ab_name(""J01CR50"") even antibiotic selectors workx <- data.frame(  random_column = ""some value"",  coflu = as.sir(""S""),  ampicillin = as.sir(""R""))xx[, betalactams()]``` See Also`add_custom_microorganisms()` to add custom microorganisms.",7
AMR,mo_matching_score.md,"# Calculate the Matching Score for Microorganisms

```r
mo_matching_score(x, n)
```

## Arguments

- `x`: Any user input value(s)
- `n`: A full taxonomic name, that exists in `microorganisms$fullname`

## Description

This algorithm is used by `as.mo()` and all the `mo_*` functions to determine the most probable match of taxonomic records based on user input.

## Note

This algorithm was originally described in: Berends MS **et al.** (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . **Journal of Statistical Software**, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") .

Later, the work of Bartlett A **et al.** about bacterial pathogens infecting humans (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) was incorporated.

## Matching Score for Microorganisms

 With ambiguous user input in `as.mo()` and all the `mo_*` functions, the returned results are chosen based on their matching score using `mo_matching_score()`. This matching score `m`, is calculated as:

 

where:

 * `x` is the user input;
 * `n` is a taxonomic name (genus, species, and subspecies);
 * `l_n` is the length of `n`;
 * `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;
 * `p_n` is the human pathogenic prevalence group of `n`, as described below;
 * `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.

The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett **et al.** (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:

 * Established , if a taxonomic species has infected at least three persons in three or more references. These records have `prevalence = 1.0` in the microorganisms data set;
 * Putative , if a taxonomic species has fewer than three known cases. These records have `prevalence = 1.25` in the microorganisms data set.

Furthermore,


 * Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;
 * Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;
 * Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;
 * Any **non-bacterial** genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: **Absidia**, **Acanthamoeba**, **Acremonium**, **Aedes**, **Alternaria**, **Amoeba**, **Ancylostoma**, **Angiostrongylus**, **Anisakis**, **Anopheles**, **Apophysomyces**, **Aspergillus**, **Aureobasidium**, **Basidiobolus**, **Beauveria**, **Blastocystis**, **Blastomyces**, **Candida**, **Capillaria**, **Chaetomium**, **Chrysonilia**, **Cladophialophora**, **Cladosporium**, **Conidiobolus**, **Contracaecum**, **Cordylobia**, **Cryptococcus**, **Curvularia**, **Demodex**, **Dermatobia**, **Dientamoeba**, **Diphyllobothrium**, **Dirofilaria**, **Echinostoma**, **Entamoeba**, **Enterobius**, **Exophiala**, **Exserohilum**, **Fasciola**, **Fonsecaea**, **Fusarium**, **Giardia**, **Haloarcula**, **Halobacterium**, **Halococcus**, **Hendersonula**, **Heterophyes**, **Histomonas**, **Histoplasma**, **Hymenolepis**, **Hypomyces**, **Hysterothylacium**, **Leishmania**, **Malassezia**, **Malbranchea**, **Metagonimus**, **Meyerozyma**, **Microsporidium**, **Microsporum**, **Mortierella**, **Mucor**, **Mycocentrospora**, **Necator**, **Nectria**, **Ochroconis**, **Oesophagostomum**, **Oidiodendron**, **Opisthorchis**, **Pediculus**, **Penicillium**, **Phlebotomus**, **Phoma**, **Pichia**, **Piedraia**, **Pithomyces**, **Pityrosporum**, **Pneumocystis**, **Pseudallescheria**, **Pseudoterranova**, **Pulex**, **Rhizomucor**, **Rhizopus**, **Rhodotorula**, **Saccharomyces**, **Sarcoptes**, **Scolecobasidium**, **Scopulariopsis**, **Scytalidium**, **Spirometra**, **Sporobolomyces**, **Stachybotrys**, **Strongyloides**, **Syngamus**, **Taenia**, **Talaromyces**, **Toxocara**, **Trichinella**, **Trichobilharzia**, **Trichoderma**, **Trichomonas**, **Trichophyton**, **Trichosporon**, **Trichostrongylus**, **Trichuris**, **Tritirachium**, **Trombicula**, **Trypanosoma**, **Tunga**, or **Wuchereria**;
 * All other records have `prevalence = 2.0` in the microorganisms data set.

When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.


All matches are sorted descending on their matching score and for all user input values, the top match will be returned. This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of **Escherichia coli** (`m = 0.688`, a highly prevalent microorganism found in humans) and not **Entamoeba coli** (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first.

## Reference Data Publicly Available

 All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
mo_reset_session()

as.mo(""E. coli"")
mo_uncertainties()

mo_matching_score(
  x = ""E. coli"",
  n = c(""Escherichia coli"", ""Entamoeba coli"")
)
```

## Author(s)

Dr. Matthijs Berends, 2018



","['Calculate the Matching Score for Microorganisms```rmo_matching_score(x, n)``` Arguments- `x`: Any user input value(s)- `n`: A full taxonomic name, that exists in `microorganisms$fullname` DescriptionThis algorithm is used by `as.mo()` and all the `mo_` functions to determine the most probable match of taxonomic records based on user input.', 'NoteThis algorithm was originally described in: Berends MS et al.', 'AMR: An R Package for Working with Antimicrobial Resistance Data .', 'Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") .Later, the work of Bartlett A et al.', 'about bacterial pathogens infecting humans (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) was incorporated.', 'Matching Score for Microorganisms With ambiguous user input in `as.mo()` and all the `mo_` functions, the returned results are chosen based on their matching score using `mo_matching_score()`.', 'This matching score `m`, is calculated as: where:  `x` is the user input;  `n` is a taxonomic name (genus, species, and subspecies);  `l_n` is the length of `n`;  `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;  `p_n` is the human pathogenic prevalence group of `n`, as described below;  `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett et al.', '(2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:  Established , if a taxonomic species has infected at least three persons in three or more references.', 'These records have `prevalence = 1.0` in the microorganisms data set;  Putative , if a taxonomic species has fewer than three known cases.', 'These records have `prevalence = 1.25` in the microorganisms data set.Furthermore,  Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;  Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;  Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;  Any non-bacterial genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: Absidia, Acanthamoeba, Acremonium, Aedes, Alternaria, Amoeba, Ancylostoma, Angiostrongylus, Anisakis, Anopheles, Apophysomyces, Aspergillus, Aureobasidium, Basidiobolus, Beauveria, Blastocystis, Blastomyces, Candida, Capillaria, Chaetomium, Chrysonilia, Cladophialophora, Cladosporium, Conidiobolus, Contracaecum, Cordylobia, Cryptococcus, Curvularia, Demodex, Dermatobia, Dientamoeba, Diphyllobothrium, Dirofilaria, Echinostoma, Entamoeba, Enterobius, Exophiala, Exserohilum, Fasciola, Fonsecaea, Fusarium, Giardia, Haloarcula, Halobacterium, Halococcus, Hendersonula, Heterophyes, Histomonas, Histoplasma, Hymenolepis, Hypomyces, Hysterothylacium, Leishmania, Malassezia, Malbranchea, Metagonimus, Meyerozyma, Microsporidium, Microsporum, Mortierella, Mucor, Mycocentrospora, Necator, Nectria, Ochroconis, Oesophagostomum, Oidiodendron, Opisthorchis, Pediculus, Penicillium, Phlebotomus, Phoma, Pichia, Piedraia, Pithomyces, Pityrosporum, Pneumocystis, Pseudallescheria, Pseudoterranova, Pulex, Rhizomucor, Rhizopus, Rhodotorula, Saccharomyces, Sarcoptes, Scolecobasidium, Scopulariopsis, Scytalidium, Spirometra, Sporobolomyces, Stachybotrys, Strongyloides, Syngamus, Taenia, Talaromyces, Toxocara, Trichinella, Trichobilharzia, Trichoderma, Trichomonas, Trichophyton, Trichosporon, Trichostrongylus, Trichuris, Tritirachium, Trombicula, Trypanosoma, Tunga, or Wuchereria;  All other records have `prevalence = 2.0` in the microorganisms data set.When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.All matches are sorted descending on their matching score and for all user input values, the top match will be returned.', 'This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of Escherichia coli (`m = 0.688`, a highly prevalent microorganism found in humans) and not Entamoeba coli (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first.', 'Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```rmo_reset_session()as.mo(""E. coli"")mo_uncertainties()mo_matching_score(  x = ""E. coli"",  n = c(""Escherichia coli"", ""Entamoeba coli""))``` Author(s)Dr. Matthijs Berends, 2018']",1," Calculate the Matching Score for Microorganisms```rmo_matching_score(x, n)``` Arguments- `x`: Any user input value(s)- `n`: A full taxonomic name, that exists in `microorganisms$fullname` DescriptionThis algorithm is used by `as.mo()` and all the `mo_` functions to determine the most probable match of taxonomic records based on user input. NoteThis algorithm was originally described in: Berends MS et al. (2022). AMR: An R Package for Working with Antimicrobial Resistance Data . Journal of Statistical Software, 104(3), 1-31; tools:::Rd_expr_doi(""10.18637/jss.v104.i03"") .Later, the work of Bartlett A et al. about bacterial pathogens infecting humans (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) was incorporated. Matching Score for Microorganisms With ambiguous user input in `as.mo()` and all the `mo_` functions, the returned results are chosen based on their matching score using `mo_matching_score()`. This matching score `m`, is calculated as: where:  `x` is the user input;  `n` is a taxonomic name (genus, species, and subspecies);  `l_n` is the length of `n`;  `lev` is the [Levenshtein distance function](https://en.wikipedia.org/wiki/Levenshtein_distance) (counting any insertion as 1, and any deletion or substitution as 2) that is needed to change `x` into `n`;  `p_n` is the human pathogenic prevalence group of `n`, as described below;  `k_n` is the taxonomic kingdom of `n`, set as Bacteria = 1, Fungi = 1.25, Protozoa = 1.5, Archaea = 2, others = 3.The grouping into human pathogenic prevalence `p` is based on recent work from Bartlett et al. (2022, tools:::Rd_expr_doi(""10.1099/mic.0.001269"") ) who extensively studied medical-scientific literature to categorise all bacterial species into these groups:  Established , if a taxonomic species has infected at least three persons in three or more references. These records have `prevalence = 1.0` in the microorganisms data set;  Putative , if a taxonomic species has fewer than three known cases. These records have `prevalence = 1.25` in the microorganisms data set.Furthermore,  Any genus present in the established list also has `prevalence = 1.0` in the microorganisms data set;  Any other genus present in the putative list has `prevalence = 1.25` in the microorganisms data set;  Any other species or subspecies of which the genus is present in the two aforementioned groups, has `prevalence = 1.5` in the microorganisms data set;  Any non-bacterial genus, species or subspecies of which the genus is present in the following list, has `prevalence = 1.25` in the microorganisms data set: Absidia, Acanthamoeba, Acremonium, Aedes, Alternaria, Amoeba, Ancylostoma, Angiostrongylus, Anisakis, Anopheles, Apophysomyces, Aspergillus, Aureobasidium, Basidiobolus, Beauveria, Blastocystis, Blastomyces, Candida, Capillaria, Chaetomium, Chrysonilia, Cladophialophora, Cladosporium, Conidiobolus, Contracaecum, Cordylobia, Cryptococcus, Curvularia, Demodex, Dermatobia, Dientamoeba, Diphyllobothrium, Dirofilaria, Echinostoma, Entamoeba, Enterobius, Exophiala, Exserohilum, Fasciola, Fonsecaea, Fusarium, Giardia, Haloarcula, Halobacterium, Halococcus, Hendersonula, Heterophyes, Histomonas, Histoplasma, Hymenolepis, Hypomyces, Hysterothylacium, Leishmania, Malassezia, Malbranchea, Metagonimus, Meyerozyma, Microsporidium, Microsporum, Mortierella, Mucor, Mycocentrospora, Necator, Nectria, Ochroconis, Oesophagostomum, Oidiodendron, Opisthorchis, Pediculus, Penicillium, Phlebotomus, Phoma, Pichia, Piedraia, Pithomyces, Pityrosporum, Pneumocystis, Pseudallescheria, Pseudoterranova, Pulex, Rhizomucor, Rhizopus, Rhodotorula, Saccharomyces, Sarcoptes, Scolecobasidium, Scopulariopsis, Scytalidium, Spirometra, Sporobolomyces, Stachybotrys, Strongyloides, Syngamus, Taenia, Talaromyces, Toxocara, Trichinella, Trichobilharzia, Trichoderma, Trichomonas, Trichophyton, Trichosporon, Trichostrongylus, Trichuris, Tritirachium, Trombicula, Trypanosoma, Tunga, or Wuchereria;  All other records have `prevalence = 2.0` in the microorganisms data set.When calculating the matching score, all characters in `x` and `n` are ignored that are other than A-Z, a-z, 0-9, spaces and parentheses.All matches are sorted descending on their matching score and for all user input values, the top match will be returned. This will lead to the effect that e.g., `""E. coli""` will return the microbial ID of Escherichia coli (`m = 0.688`, a highly prevalent microorganism found in humans) and not Entamoeba coli (`m = 0.381`, a less prevalent microorganism in humans), although the latter would alphabetically come first. Reference Data Publicly Available All data sets in this `AMR` package (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) are publicly and freely available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. We also provide tab-separated plain text files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rmo_reset_session()as.mo(""E. coli"")mo_uncertainties()mo_matching_score(  x = ""E. coli"",  n = c(""Escherichia coli"", ""Entamoeba coli""))``` Author(s)Dr. Matthijs Berends, 2018",8
AMR,ggplot_pca.md,"# PCA Biplot with `ggplot2`

## Source

The `ggplot_pca()` function is based on the `ggbiplot()` function from the `ggbiplot` package by Vince Vu, as found on GitHub: [https://github.com/vqv/ggbiplot](https://github.com/vqv/ggbiplot) (retrieved: 2 March 2020, their latest commit: [list(""7325e88"")](https://github.com/vqv/ggbiplot/commit/7325e880485bea4c07465a0304c470608fffb5d9); 12 February 2015).

As per their GPL-2 licence that demands documentation of code changes, the changes made based on the source code were:

1. Rewritten code to remove the dependency on packages `plyr`, `scales` and `grid`
2. Parametrised more options, like arrow and ellipse settings
3. Hardened all input possibilities by defining the exact type of user input for every argument
4. Added total amount of explained variance as a caption in the plot
5. Cleaned all syntax based on the `lintr` package, fixed grammatical errors and added integrity checks
6. Updated documentation

```r
ggplot_pca(
  x,
  choices = 1:2,
  scale = 1,
  pc.biplot = TRUE,
  labels = NULL,
  labels_textsize = 3,
  labels_text_placement = 1.5,
  groups = NULL,
  ellipse = TRUE,
  ellipse_prob = 0.68,
  ellipse_size = 0.5,
  ellipse_alpha = 0.5,
  points_size = 2,
  points_alpha = 0.25,
  arrows = TRUE,
  arrows_colour = ""darkblue"",
  arrows_size = 0.5,
  arrows_textsize = 3,
  arrows_textangled = TRUE,
  arrows_alpha = 0.75,
  base_textsize = 10,
  ...
)
```

## Arguments

- `x`: an object returned by `pca()`, `prcomp()` or `princomp()`
- `choices`: length 2 vector specifying the components to plot. Only the default is a biplot in the strict sense.
- `scale`: The variables are scaled by `lambda ^ scale` and the observations are scaled by `lambda ^ (1-scale)` where `lambda` are the singular values as computed by `princomp`. Normally `0 <= scale <= 1`, and a warning will be issued if the specified `scale` is outside this range.
- `pc.biplot`: If true, use what Gabriel (1971) refers to as a ""principal component biplot"", with `lambda = 1` and observations scaled up by sqrt(n) and variables scaled down by sqrt(n). Then inner products between variables approximate covariances and distances between observations approximate Mahalanobis distance.
- `labels`: an optional vector of labels for the observations. If set, the labels will be placed below their respective points. When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.
- `labels_textsize`: the size of the text used for the labels
- `labels_text_placement`: adjustment factor the placement of the variable names (`>=1` means further away from the arrow head)
- `groups`: an optional vector of groups for the labels, with the same length as `labels`. If set, the points and labels will be coloured according to these groups. When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.
- `ellipse`: a logical to indicate whether a normal data ellipse should be drawn for each group (set with `groups`)
- `ellipse_prob`: statistical size of the ellipse in normal probability
- `ellipse_size`: the size of the ellipse line
- `ellipse_alpha`: the alpha (transparency) of the ellipse line
- `points_size`: the size of the points
- `points_alpha`: the alpha (transparency) of the points
- `arrows`: a logical to indicate whether arrows should be drawn
- `arrows_colour`: the colour of the arrow and their text
- `arrows_size`: the size (thickness) of the arrow lines
- `arrows_textsize`: the size of the text at the end of the arrows
- `arrows_textangled`: a logical whether the text at the end of the arrows should be angled
- `arrows_alpha`: the alpha (transparency) of the arrows and their text
- `base_textsize`: the text size for all plot elements except the labels and arrows
- `...`: arguments passed on to functions

## Description

Produces a `ggplot2` variant of a so-called [biplot](https://en.wikipedia.org/wiki/Biplot) for PCA (principal component analysis), but is more flexible and more appealing than the base `biplot()` function.

## Details

The colours for labels and points can be changed by adding another scale layer for colour, such as `scale_colour_viridis_d()` and `scale_colour_brewer()`.

## Examples

```r
# `example_isolates` is a data set available in the AMR package.
# See ?example_isolates.


if (require(""dplyr"")) {
  # calculate the resistance per group first
  resistance_data <- example_isolates %>%
    group_by(
      order = mo_order(mo), # group on anything, like order
      genus = mo_genus(mo)
    ) %>% #   and genus as we do here;
    filter(n() >= 30) %>% # filter on only 30 results per group
    summarise_if(is.sir, resistance) # then get resistance of all drugs

  # now conduct PCA for certain antimicrobial drugs
  pca_result <- resistance_data %>%
    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)

  summary(pca_result)

  # old base R plotting method:
  biplot(pca_result)

  # new ggplot2 plotting method using this package:
  if (require(""ggplot2"")) {
    ggplot_pca(pca_result)

    # still extendible with any ggplot2 function
    ggplot_pca(pca_result) +
      scale_colour_viridis_d() +
      labs(title = ""Title here"")
  }
}
```



","['PCA Biplot with `ggplot2` SourceThe `ggplot_pca()` function is based on the `ggbiplot()` function from the `ggbiplot` package by Vince Vu, as found on GitHub: [https://github.com/vqv/ggbiplot](https://github.com/vqv/ggbiplot) (retrieved: 2 March 2020, their latest commit: [list(""7325e88"")](https://github.com/vqv/ggbiplot/commit/7325e880485bea4c07465a0304c470608fffb5d9); 12 February 2015).As per their GPL-2 licence that demands documentation of code changes, the changes made based on the source code were:1.', 'Rewritten code to remove the dependency on packages `plyr`, `scales` and `grid`2.', 'Parametrised more options, like arrow and ellipse settings3.', 'Hardened all input possibilities by defining the exact type of user input for every argument4.', 'Added total amount of explained variance as a caption in the plot5.', 'Cleaned all syntax based on the `lintr` package, fixed grammatical errors and added integrity checks6.', 'Updated documentation```rggplot_pca(  x,  choices = 1:2,  scale = 1,  pc.biplot = TRUE,  labels = NULL,  labels_textsize = 3,  labels_text_placement = 1.5,  groups = NULL,  ellipse = TRUE,  ellipse_prob = 0.68,  ellipse_size = 0.5,  ellipse_alpha = 0.5,  points_size = 2,  points_alpha = 0.25,  arrows = TRUE,  arrows_colour = ""darkblue"",  arrows_size = 0.5,  arrows_textsize = 3,  arrows_textangled = TRUE,  arrows_alpha = 0.75,  base_textsize = 10,  ...)``` Arguments- `x`: an object returned by `pca()`, `prcomp()` or `princomp()`- `choices`: length 2 vector specifying the components to plot.', 'Only the default is a biplot in the strict sense.- `scale`: The variables are scaled by `lambda ^ scale` and the observations are scaled by `lambda ^ (1-scale)` where `lambda` are the singular values as computed by `princomp`.', 'Normally `0 <= scale <= 1`, and a warning will be issued if the specified `scale` is outside this range.- `pc.biplot`: If true, use what Gabriel (1971) refers to as a ""principal component biplot"", with `lambda = 1` and observations scaled up by sqrt(n) and variables scaled down by sqrt(n).', 'Then inner products between variables approximate covariances and distances between observations approximate Mahalanobis distance.- `labels`: an optional vector of labels for the observations.', 'If set, the labels will be placed below their respective points.', 'When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.- `labels_textsize`: the size of the text used for the labels- `labels_text_placement`: adjustment factor the placement of the variable names (`>=1` means further away from the arrow head)- `groups`: an optional vector of groups for the labels, with the same length as `labels`.', 'If set, the points and labels will be coloured according to these groups.', 'When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.- `ellipse`: a logical to indicate whether a normal data ellipse should be drawn for each group (set with `groups`)- `ellipse_prob`: statistical size of the ellipse in normal probability- `ellipse_size`: the size of the ellipse line- `ellipse_alpha`: the alpha (transparency) of the ellipse line- `points_size`: the size of the points- `points_alpha`: the alpha (transparency) of the points- `arrows`: a logical to indicate whether arrows should be drawn- `arrows_colour`: the colour of the arrow and their text- `arrows_size`: the size (thickness) of the arrow lines- `arrows_textsize`: the size of the text at the end of the arrows- `arrows_textangled`: a logical whether the text at the end of the arrows should be angled- `arrows_alpha`: the alpha (transparency) of the arrows and their text- `base_textsize`: the text size for all plot elements except the labels and arrows- `...`: arguments passed on to functions DescriptionProduces a `ggplot2` variant of a so-called [biplot](https://en.wikipedia.org/wiki/Biplot) for PCA (principal component analysis), but is more flexible and more appealing than the base `biplot()` function.', 'DetailsThe colours for labels and points can be changed by adding another scale layer for colour, such as `scale_colour_viridis_d()` and `scale_colour_brewer()`.', 'Examples```r `example_isolates` is a data set available in the AMR package.', 'See ?example_isolates.if (require(""dplyr"")) {   calculate the resistance per group first  resistance_data <- example_isolates %>%    group_by(      order = mo_order(mo),  group on anything, like order      genus = mo_genus(mo)    ) %>%    and genus as we do here;    filter(n() >= 30) %>%  filter on only 30 results per group    summarise_if(is.sir, resistance)  then get resistance of all drugs   now conduct PCA for certain antimicrobial drugs  pca_result <- resistance_data %>%    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)  summary(pca_result)   old base R plotting method:  biplot(pca_result)   new ggplot2 plotting method using this package:  if (require(""ggplot2"")) {    ggplot_pca(pca_result)     still extendible with any ggplot2 function    ggplot_pca(pca_result) +      scale_colour_viridis_d() +      labs(title = ""Title here"")  }}```']",1," PCA Biplot with `ggplot2` SourceThe `ggplot_pca()` function is based on the `ggbiplot()` function from the `ggbiplot` package by Vince Vu, as found on GitHub: [https://github.com/vqv/ggbiplot](https://github.com/vqv/ggbiplot) (retrieved: 2 March 2020, their latest commit: [list(""7325e88"")](https://github.com/vqv/ggbiplot/commit/7325e880485bea4c07465a0304c470608fffb5d9); 12 February 2015).As per their GPL-2 licence that demands documentation of code changes, the changes made based on the source code were:1. Rewritten code to remove the dependency on packages `plyr`, `scales` and `grid`2. Parametrised more options, like arrow and ellipse settings3. Hardened all input possibilities by defining the exact type of user input for every argument4. Added total amount of explained variance as a caption in the plot5. Cleaned all syntax based on the `lintr` package, fixed grammatical errors and added integrity checks6. Updated documentation```rggplot_pca(  x,  choices = 1:2,  scale = 1,  pc.biplot = TRUE,  labels = NULL,  labels_textsize = 3,  labels_text_placement = 1.5,  groups = NULL,  ellipse = TRUE,  ellipse_prob = 0.68,  ellipse_size = 0.5,  ellipse_alpha = 0.5,  points_size = 2,  points_alpha = 0.25,  arrows = TRUE,  arrows_colour = ""darkblue"",  arrows_size = 0.5,  arrows_textsize = 3,  arrows_textangled = TRUE,  arrows_alpha = 0.75,  base_textsize = 10,  ...)``` Arguments- `x`: an object returned by `pca()`, `prcomp()` or `princomp()`- `choices`: length 2 vector specifying the components to plot. Only the default is a biplot in the strict sense.- `scale`: The variables are scaled by `lambda ^ scale` and the observations are scaled by `lambda ^ (1-scale)` where `lambda` are the singular values as computed by `princomp`. Normally `0 <= scale <= 1`, and a warning will be issued if the specified `scale` is outside this range.- `pc.biplot`: If true, use what Gabriel (1971) refers to as a ""principal component biplot"", with `lambda = 1` and observations scaled up by sqrt(n) and variables scaled down by sqrt(n). Then inner products between variables approximate covariances and distances between observations approximate Mahalanobis distance.- `labels`: an optional vector of labels for the observations. If set, the labels will be placed below their respective points. When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.- `labels_textsize`: the size of the text used for the labels- `labels_text_placement`: adjustment factor the placement of the variable names (`>=1` means further away from the arrow head)- `groups`: an optional vector of groups for the labels, with the same length as `labels`. If set, the points and labels will be coloured according to these groups. When using the `pca()` function as input for `x`, this will be determined automatically based on the attribute `non_numeric_cols`, see `pca()`.- `ellipse`: a logical to indicate whether a normal data ellipse should be drawn for each group (set with `groups`)- `ellipse_prob`: statistical size of the ellipse in normal probability- `ellipse_size`: the size of the ellipse line- `ellipse_alpha`: the alpha (transparency) of the ellipse line- `points_size`: the size of the points- `points_alpha`: the alpha (transparency) of the points- `arrows`: a logical to indicate whether arrows should be drawn- `arrows_colour`: the colour of the arrow and their text- `arrows_size`: the size (thickness) of the arrow lines- `arrows_textsize`: the size of the text at the end of the arrows- `arrows_textangled`: a logical whether the text at the end of the arrows should be angled- `arrows_alpha`: the alpha (transparency) of the arrows and their text- `base_textsize`: the text size for all plot elements except the labels and arrows- `...`: arguments passed on to functions DescriptionProduces a `ggplot2` variant of a so-called [biplot](https://en.wikipedia.org/wiki/Biplot) for PCA (principal component analysis), but is more flexible and more appealing than the base `biplot()` function. DetailsThe colours for labels and points can be changed by adding another scale layer for colour, such as `scale_colour_viridis_d()` and `scale_colour_brewer()`. Examples```r `example_isolates` is a data set available in the AMR package. See ?example_isolates.if (require(""dplyr"")) {   calculate the resistance per group first  resistance_data <- example_isolates %>%    group_by(      order = mo_order(mo),  group on anything, like order      genus = mo_genus(mo)    ) %>%    and genus as we do here;    filter(n() >= 30) %>%  filter on only 30 results per group    summarise_if(is.sir, resistance)  then get resistance of all drugs   now conduct PCA for certain antimicrobial drugs  pca_result <- resistance_data %>%    pca(AMC, CXM, CTX, CAZ, GEN, TOB, TMP, SXT)  summary(pca_result)   old base R plotting method:  biplot(pca_result)   new ggplot2 plotting method using this package:  if (require(""ggplot2"")) {    ggplot_pca(pca_result)     still extendible with any ggplot2 function    ggplot_pca(pca_result) +      scale_colour_viridis_d() +      labs(title = ""Title here"")  }}```",8
AMR,microorganisms.groups.md," data

# Data Set with 521 Microorganisms In Species Groups

## Format

A tibble with 521 observations and 4 variables:

 * `mo_group`
   
   ID of the species group / microbiological complex
 * `mo`
   
   ID of the microorganism belonging in the species group / microbiological complex
 * `mo_group_name`
   
   Name of the species group / microbiological complex, as retrieved with `mo_name()`
 * `mo_name`
   
   Name of the microorganism belonging in the species group / microbiological complex, as retrieved with `mo_name()`

```r
microorganisms.groups
```

## Description

A data set containing species groups and microbiological complexes, which are used in the clinical breakpoints table .

## Details

Like all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).

## Examples

```r
microorganisms.groups

# these are all species in the Bacteroides fragilis group, as per WHONET:
microorganisms.groups[microorganisms.groups$mo_group == ""B_BCTRD_FRGL-C"", ]
```

## See Also

`as.mo()` microorganisms



","['data Data Set with 521 Microorganisms In Species Groups FormatA tibble with 521 observations and 4 variables:  `mo_group`      ID of the species group / microbiological complex  `mo`      ID of the microorganism belonging in the species group / microbiological complex  `mo_group_name`      Name of the species group / microbiological complex, as retrieved with `mo_name()`  `mo_name`      Name of the microorganism belonging in the species group / microbiological complex, as retrieved with `mo_name()````rmicroorganisms.groups``` DescriptionA data set containing species groups and microbiological complexes, which are used in the clinical breakpoints table .', 'DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata.', 'Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html).', 'The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw).', 'Examples```rmicroorganisms.groups these are all species in the Bacteroides fragilis group, as per WHONET:microorganisms.groups[microorganisms.groups$mo_group == ""B_BCTRD_FRGL-C"", ]``` See Also`as.mo()` microorganisms']",1," data Data Set with 521 Microorganisms In Species Groups FormatA tibble with 521 observations and 4 variables:  `mo_group`      ID of the species group / microbiological complex  `mo`      ID of the microorganism belonging in the species group / microbiological complex  `mo_group_name`      Name of the species group / microbiological complex, as retrieved with `mo_name()`  `mo_name`      Name of the microorganism belonging in the species group / microbiological complex, as retrieved with `mo_name()````rmicroorganisms.groups``` DescriptionA data set containing species groups and microbiological complexes, which are used in the clinical breakpoints table . DetailsLike all data sets in this package, this data set is publicly available for download in the following formats: R, MS Excel, Apache Feather, Apache Parquet, SPSS, SAS, and Stata. Please visit [our website for the download links](https://msberends.github.io/AMR/articles/datasets.html). The actual files are of course available on [our GitHub repository](https://github.com/msberends/AMR/tree/main/data-raw). Examples```rmicroorganisms.groups these are all species in the Bacteroides fragilis group, as per WHONET:microorganisms.groups[microorganisms.groups$mo_group == ""B_BCTRD_FRGL-C"", ]``` See Also`as.mo()` microorganisms",8
AMR,welcome_to_AMR.md,"---
title: ""Welcome to the `AMR` package""
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Welcome to the `AMR` package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, results = 'markup'}
knitr::opts_chunk$set(
  warning = FALSE,
  collapse = TRUE,
  comment = ""#>"",
  fig.width = 7.5,
  fig.height = 5
)
```

Note: to keep the package size as small as possible, we only include this vignette on CRAN. You can read more vignettes on our website about how to conduct AMR data analysis, determine MDROs, find explanation of EUCAST and CLSI breakpoints, and much more: <https://msberends.github.io/AMR/articles/>.

----

The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/#copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods. **Our aim is to provide a standard** for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting. [Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!

This work was published in the Journal of Statistical Software (Volume 104(3); [DOI 10.18637/jss.v104.i03](https://doi.org/10.18637/jss.v104.i03)) and formed the basis of two PhD theses ([DOI 10.33612/diss.177417131](https://doi.org/10.33612/diss.177417131) and [DOI 10.33612/diss.192486375](https://doi.org/10.33612/diss.192486375)).

After installing this package, R knows `r AMR:::format_included_data_number(AMR::microorganisms)` distinct microbial species and all `r AMR:::format_included_data_number(rbind(AMR::antibiotics[, ""atc"", drop = FALSE], AMR::antivirals[, ""atc"", drop = FALSE]))` antibiotic, antimycotic and antiviral drugs by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values. The integral breakpoint guidelines from CLSI and EUCAST are included from the last 10 years. It supports and can read any data format, including WHONET data.

With the help of contributors from all corners of the world, the `AMR` package is available in English, Czech, Chinese, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian. Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages.

This package is fully independent of any other R package and works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013). **It was designed to work in any setting, including those with very limited resources**. Since its first public release in early 2018, this package has been downloaded from more than 175 countries.

This package can be used for:

  * Reference for the taxonomy of microorganisms, since the package contains all microbial (sub)species from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF)
  * Interpreting raw MIC and disk diffusion values, based on the latest CLSI or EUCAST guidelines
  * Retrieving antimicrobial drug names, doses and forms of administration from clinical health care records
  * Determining first isolates to be used for AMR data analysis
  * Calculating antimicrobial resistance
  * Determining multi-drug resistance (MDR) / multi-drug resistant organisms (MDRO)
  * Calculating (empirical) susceptibility of both mono therapy and combination therapies
  * Predicting future antimicrobial resistance using regression models
  * Getting properties for any microorganism (like Gram stain, species, genus or family)
  * Getting properties for any antibiotic (like name, code of EARS-Net/ATC/LOINC/PubChem, defined daily dose or trade name)
  * Plotting antimicrobial resistance
  * Applying EUCAST expert rules
  * Getting SNOMED codes of a microorganism, or getting properties of a microorganism based on a SNOMED code
  * Getting LOINC codes of an antibiotic, or getting properties of an antibiotic based on a LOINC code
  * Machine reading the EUCAST and CLSI guidelines from 2011-2020 to translate MIC values and disk diffusion diameters to SIR
  * Principal component analysis for AMR
  
All reference data sets (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) in this `AMR` package are publicly and freely available. We continually export our data sets to formats for use in R, SPSS, SAS, Stata and Excel. We also supply flat files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please find [all download links on our website](https://msberends.github.io/AMR/articles/datasets.html), which is automatically updated with every code change.

This R package was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl), and is being [actively and durably maintained](https://msberends.github.io/AMR/news/) by two public healthcare organisations in the Netherlands.

----

<small>
This AMR package for R is free, open-source software and licensed under the [GNU General Public License v2.0 (GPL-2)](https://msberends.github.io/AMR/LICENSE-text.html). These requirements are consequently legally binding: modifications must be released under the same license when distributing the package, changes made to the code must be documented, source code must be made available when the package is distributed, and a copy of the license and copyright notice must be included with the package.
</small>

","['---title: ""Welcome to the `AMR` package""output:   rmarkdown::html_vignette:    toc: true    toc_depth: 3vignette: >  %\\VignetteIndexEntry{Welcome to the `AMR` package}  %\\VignetteEncoding{UTF-8}  %\\VignetteEngine{knitr::rmarkdown}editor_options:   chunk_output_type: console---```{r setup, include = FALSE, results = \'markup\'}knitr::opts_chunk$set(  warning = FALSE,  collapse = TRUE,  comment = "">"",  fig.width = 7.5,  fig.height = 5)```Note: to keep the package size as small as possible, we only include this vignette on CRAN.', 'You can read more vignettes on our website about how to conduct AMR data analysis, determine MDROs, find explanation of EUCAST and CLSI breakpoints, and much more: <https://msberends.github.io/AMR/articles/>.----The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods.', 'Our aim is to provide a standard for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting.', '[Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!This work was published in the Journal of Statistical Software (Volume 104(3); [DOI 10.18637/jss.v104.i03](https://doi.org/10.18637/jss.v104.i03)) and formed the basis of two PhD theses ([DOI 10.33612/diss.177417131](https://doi.org/10.33612/diss.177417131) and [DOI 10.33612/diss.192486375](https://doi.org/10.33612/diss.192486375)).After installing this package, R knows `r AMR:::format_included_data_number(AMR::microorganisms)` distinct microbial species and all `r AMR:::format_included_data_number(rbind(AMR::antibiotics[, ""atc"", drop = FALSE], AMR::antivirals[, ""atc"", drop = FALSE]))` antibiotic, antimycotic and antiviral drugs by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values.', 'The integral breakpoint guidelines from CLSI and EUCAST are included from the last 10 years.', 'It supports and can read any data format, including WHONET data.With the help of contributors from all corners of the world, the `AMR` package is available in English, Czech, Chinese, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian.', 'Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages.This package is fully independent of any other R package and works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013).', 'It was designed to work in any setting, including those with very limited resources.', 'Since its first public release in early 2018, this package has been downloaded from more than 175 countries.This package can be used for:   Reference for the taxonomy of microorganisms, since the package contains all microbial (sub)species from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF)   Interpreting raw MIC and disk diffusion values, based on the latest CLSI or EUCAST guidelines   Retrieving antimicrobial drug names, doses and forms of administration from clinical health care records   Determining first isolates to be used for AMR data analysis   Calculating antimicrobial resistance   Determining multi-drug resistance (MDR) / multi-drug resistant organisms (MDRO)   Calculating (empirical) susceptibility of both mono therapy and combination therapies   Predicting future antimicrobial resistance using regression models   Getting properties for any microorganism (like Gram stain, species, genus or family)   Getting properties for any antibiotic (like name, code of EARS-Net/ATC/LOINC/PubChem, defined daily dose or trade name)   Plotting antimicrobial resistance   Applying EUCAST expert rules   Getting SNOMED codes of a microorganism, or getting properties of a microorganism based on a SNOMED code   Getting LOINC codes of an antibiotic, or getting properties of an antibiotic based on a LOINC code   Machine reading the EUCAST and CLSI guidelines from 2011-2020 to translate MIC values and disk diffusion diameters to SIR   Principal component analysis for AMR  All reference data sets (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.)', 'in this `AMR` package are publicly and freely available.', 'We continually export our data sets to formats for use in R, SPSS, SAS, Stata and Excel.', 'We also supply flat files that are machine-readable and suitable for input in any software program, such as laboratory information systems.', 'Please find [all download links on our website](https://msberends.github.io/AMR/articles/datasets.html), which is automatically updated with every code change.This R package was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl), and is being [actively and durably maintained](https://msberends.github.io/AMR/news/) by two public healthcare organisations in the Netherlands.----<small>This AMR package for R is free, open-source software and licensed under the [GNU General Public License v2.0 (GPL-2)](https://msberends.github.io/AMR/LICENSE-text.html).', 'These requirements are consequently legally binding: modifications must be released under the same license when distributing the package, changes made to the code must be documented, source code must be made available when the package is distributed, and a copy of the license and copyright notice must be included with the package.</small>']",1,"---title: ""Welcome to the `AMR` package""output:   rmarkdown::html_vignette:    toc: true    toc_depth: 3vignette: >  %\VignetteIndexEntry{Welcome to the `AMR` package}  %\VignetteEncoding{UTF-8}  %\VignetteEngine{knitr::rmarkdown}editor_options:   chunk_output_type: console---```{r setup, include = FALSE, results = 'markup'}knitr::opts_chunk$set(  warning = FALSE,  collapse = TRUE,  comment = "">"",  fig.width = 7.5,  fig.height = 5)```Note: to keep the package size as small as possible, we only include this vignette on CRAN. You can read more vignettes on our website about how to conduct AMR data analysis, determine MDROs, find explanation of EUCAST and CLSI breakpoints, and much more: <https://msberends.github.io/AMR/articles/>.----The `AMR` package is a [free and open-source](https://msberends.github.io/AMR/copyright) R package with [zero dependencies](https://en.wikipedia.org/wiki/Dependency_hell) to simplify the analysis and prediction of Antimicrobial Resistance (AMR) and to work with microbial and antimicrobial data and properties, by using evidence-based methods. Our aim is to provide a standard for clean and reproducible AMR data analysis, that can therefore empower epidemiological analyses to continuously enable surveillance and treatment evaluation in any setting. [Many different researchers](https://msberends.github.io/AMR/authors.html) from around the globe are continually helping us to make this a successful and durable project!This work was published in the Journal of Statistical Software (Volume 104(3); [DOI 10.18637/jss.v104.i03](https://doi.org/10.18637/jss.v104.i03)) and formed the basis of two PhD theses ([DOI 10.33612/diss.177417131](https://doi.org/10.33612/diss.177417131) and [DOI 10.33612/diss.192486375](https://doi.org/10.33612/diss.192486375)).After installing this package, R knows `r AMR:::format_included_data_number(AMR::microorganisms)` distinct microbial species and all `r AMR:::format_included_data_number(rbind(AMR::antibiotics[, ""atc"", drop = FALSE], AMR::antivirals[, ""atc"", drop = FALSE]))` antibiotic, antimycotic and antiviral drugs by name and code (including ATC, EARS-Net, ASIARS-Net, PubChem, LOINC and SNOMED CT), and knows all about valid SIR and MIC values. The integral breakpoint guidelines from CLSI and EUCAST are included from the last 10 years. It supports and can read any data format, including WHONET data.With the help of contributors from all corners of the world, the `AMR` package is available in English, Czech, Chinese, Danish, Dutch, Finnish, French, German, Greek, Italian, Japanese, Norwegian, Polish, Portuguese, Romanian, Russian, Spanish, Swedish, Turkish, and Ukrainian. Antimicrobial drug (group) names and colloquial microorganism names are provided in these languages.This package is fully independent of any other R package and works on Windows, macOS and Linux with all versions of R since R-3.0 (April 2013). It was designed to work in any setting, including those with very limited resources. Since its first public release in early 2018, this package has been downloaded from more than 175 countries.This package can be used for:   Reference for the taxonomy of microorganisms, since the package contains all microbial (sub)species from the List of Prokaryotic names with Standing in Nomenclature (LPSN) and the Global Biodiversity Information Facility (GBIF)   Interpreting raw MIC and disk diffusion values, based on the latest CLSI or EUCAST guidelines   Retrieving antimicrobial drug names, doses and forms of administration from clinical health care records   Determining first isolates to be used for AMR data analysis   Calculating antimicrobial resistance   Determining multi-drug resistance (MDR) / multi-drug resistant organisms (MDRO)   Calculating (empirical) susceptibility of both mono therapy and combination therapies   Predicting future antimicrobial resistance using regression models   Getting properties for any microorganism (like Gram stain, species, genus or family)   Getting properties for any antibiotic (like name, code of EARS-Net/ATC/LOINC/PubChem, defined daily dose or trade name)   Plotting antimicrobial resistance   Applying EUCAST expert rules   Getting SNOMED codes of a microorganism, or getting properties of a microorganism based on a SNOMED code   Getting LOINC codes of an antibiotic, or getting properties of an antibiotic based on a LOINC code   Machine reading the EUCAST and CLSI guidelines from 2011-2020 to translate MIC values and disk diffusion diameters to SIR   Principal component analysis for AMR  All reference data sets (about microorganisms, antibiotics, SIR interpretation, EUCAST rules, etc.) in this `AMR` package are publicly and freely available. We continually export our data sets to formats for use in R, SPSS, SAS, Stata and Excel. We also supply flat files that are machine-readable and suitable for input in any software program, such as laboratory information systems. Please find [all download links on our website](https://msberends.github.io/AMR/articles/datasets.html), which is automatically updated with every code change.This R package was created for both routine data analysis and academic research at the Faculty of Medical Sciences of the [University of Groningen](https://www.rug.nl), in collaboration with non-profit organisations [Certe Medical Diagnostics and Advice Foundation](https://www.certe.nl) and [University Medical Center Groningen](https://www.umcg.nl), and is being [actively and durably maintained](https://msberends.github.io/AMR/news/) by two public healthcare organisations in the Netherlands.----<small>This AMR package for R is free, open-source software and licensed under the [GNU General Public License v2.0 (GPL-2)](https://msberends.github.io/AMR/LICENSE-text.html). These requirements are consequently legally binding: modifications must be released under the same license when distributing the package, changes made to the code must be documented, source code must be made available when the package is distributed, and a copy of the license and copyright notice must be included with the package.</small>",8
apisensr,run_app.md,"# Run the Shiny Application

```r
run_app(...)
```

## Arguments

- `...`: Unused arguments.

## Description

Runs the 'apisensr' Shiny application. This function does not return; interrupt R to stop the application (usually by pressing Ctrl+C or Esc).

## Examples

```r
## Not run:

run_app()
## End(Not run)
```



","['Run the Shiny Application```rrun_app(...)``` Arguments- `...`: Unused arguments.', ""DescriptionRuns the 'apisensr' Shiny application."", 'This function does not return; interrupt R to stop the application (usually by pressing Ctrl+C or Esc).', 'Examples```r Not run:run_app() End(Not run)```']",1, Run the Shiny Application```rrun_app(...)``` Arguments- `...`: Unused arguments. DescriptionRuns the 'apisensr' Shiny application. This function does not return; interrupt R to stop the application (usually by pressing Ctrl+C or Esc). Examples```r Not run:run_app() End(Not run)```,8
apisensr,apisensr-package.md," package

# Interface to 'episensr' for sensitivity analysis of epidemiological results

## Description

API for using 'episensr' which provides basic sensitivity analysis of the observed relative risks adjusting for unmeasured confounding and misclassification of the exposure/outcome, or both.

## Examples

```r
## Not run:

run_app()
## End(Not run)
```

## References

'episensr' on R CRAN [https://cran.r-project.org/package=episensr](https://cran.r-project.org/package=episensr)

## See Also

Useful links:

 * [https://github.com/dhaine/apisensr](https://github.com/dhaine/apisensr)
 * Report bugs at [https://github.com/dhaine/apisensr/issues](https://github.com/dhaine/apisensr/issues)

## Author(s)

Maintainer : Denis Haine denis.haine@gmail.com ([ORCID](https://orcid.org/0000-0002-6691-7335))



","[""package Interface to 'episensr' for sensitivity analysis of epidemiological results DescriptionAPI for using 'episensr' which provides basic sensitivity analysis of the observed relative risks adjusting for unmeasured confounding and misclassification of the exposure/outcome, or both."", ""Examples```r Not run:run_app() End(Not run)``` References'episensr' on R CRAN [https://cran.r-project.org/package=episensr](https://cran.r-project.org/package=episensr) See AlsoUseful links:  [https://github.com/dhaine/apisensr](https://github.com/dhaine/apisensr)  Report bugs at [https://github.com/dhaine/apisensr/issues](https://github.com/dhaine/apisensr/issues) Author(s)Maintainer : Denis Haine denis.haine@gmail.com ([ORCID](https://orcid.org/0000-0002-6691-7335))""]",1," package Interface to 'episensr' for sensitivity analysis of epidemiological results DescriptionAPI for using 'episensr' which provides basic sensitivity analysis of the observed relative risks adjusting for unmeasured confounding and misclassification of the exposure/outcome, or both. Examples```r Not run:run_app() End(Not run)``` References'episensr' on R CRAN [https://cran.r-project.org/package=episensr](https://cran.r-project.org/package=episensr) See AlsoUseful links:  [https://github.com/dhaine/apisensr](https://github.com/dhaine/apisensr)  Report bugs at [https://github.com/dhaine/apisensr/issues](https://github.com/dhaine/apisensr/issues) Author(s)Maintainer : Denis Haine denis.haine@gmail.com ([ORCID](https://orcid.org/0000-0002-6691-7335))",8
apisensr,apisensr.md,"---
title: ""apisensr""
author: ""Denis Haine""
date: ""`r Sys.Date()`""
output:
  rmarkdown::html_vignette:
    fig_cation: yes
vignette: >
  %\VignetteIndexEntry{apisensr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ""#>""
)
```

The package `apisensr` provides a graphical interface to the package `episensr`.
To run `apisensr`:

```{r eval=FALSE}
library(apisensr)
run_app()
```

The following functions are available in `episensr` and `apisensr`. Please refer
to `episensr` for more details about these functions.

| Functions available in: | `episensr` | `apisensr app` |
|-------------------------|:----------:|:--------------:|
| selection               | x          | x              |
| mbias                   | x          | x              |
| confounders             | x          | x              |
| confounders.poly        | x          | x              |
| confounders.emm         | x          | x              |
| confounders.limit       | x          | x              |
| confounders.array       | x          | x              |
| confounders.ext         | x          | x              |
| confounders.evalue      | x          |                |
| misclassification       | x          | x              |
| misclassification_cov   | x          | x              |
| bootstrap               | x          |                |
| multidimBias            | x          | x              |
| probsens.sel            | x          | x              |
| probsens.conf           | x          | x              |
| probsens                | x          | x              |
| probsens.irr.conf       | x          |                |
| probsens.irr            | x          |                |
| multiple bias           | x          |                |

","['---title: ""apisensr""author: ""Denis Haine""date: ""`r Sys.Date()`""output:  rmarkdown::html_vignette:    fig_cation: yesvignette: >  %\\VignetteIndexEntry{apisensr}  %\\VignetteEngine{knitr::rmarkdown}  %\\VignetteEncoding{UTF-8}---```{r, include = FALSE}knitr::opts_chunk$set(  collapse = TRUE,  comment = "">"")```The package `apisensr` provides a graphical interface to the package `episensr`.To run `apisensr`:```{r eval=FALSE}library(apisensr)run_app()```The following functions are available in `episensr` and `apisensr`.', 'Please referto `episensr` for more details about these functions.| Functions available in: | `episensr` | `apisensr app` ||-------------------------|:----------:|:--------------:|| selection               | x          | x              || mbias                   | x          | x              || confounders             | x          | x              || confounders.poly        | x          | x              || confounders.emm         | x          | x              || confounders.limit       | x          | x              || confounders.array       | x          | x              || confounders.ext         | x          | x              || confounders.evalue      | x          |                || misclassification       | x          | x              || misclassification_cov   | x          | x              || bootstrap               | x          |                || multidimBias            | x          | x              || probsens.sel            | x          | x              || probsens.conf           | x          | x              || probsens                | x          | x              || probsens.irr.conf       | x          |                || probsens.irr            | x          |                || multiple bias           | x          |                |']",1,"---title: ""apisensr""author: ""Denis Haine""date: ""`r Sys.Date()`""output:  rmarkdown::html_vignette:    fig_cation: yesvignette: >  %\VignetteIndexEntry{apisensr}  %\VignetteEngine{knitr::rmarkdown}  %\VignetteEncoding{UTF-8}---```{r, include = FALSE}knitr::opts_chunk$set(  collapse = TRUE,  comment = "">"")```The package `apisensr` provides a graphical interface to the package `episensr`.To run `apisensr`:```{r eval=FALSE}library(apisensr)run_app()```The following functions are available in `episensr` and `apisensr`. Please referto `episensr` for more details about these functions.| Functions available in: | `episensr` | `apisensr app` ||-------------------------|:----------:|:--------------:|| selection               | x          | x              || mbias                   | x          | x              || confounders             | x          | x              || confounders.poly        | x          | x              || confounders.emm         | x          | x              || confounders.limit       | x          | x              || confounders.array       | x          | x              || confounders.ext         | x          | x              || confounders.evalue      | x          |                || misclassification       | x          | x              || misclassification_cov   | x          | x              || bootstrap               | x          |                || multidimBias            | x          | x              || probsens.sel            | x          | x              || probsens.conf           | x          | x              || probsens                | x          | x              || probsens.irr.conf       | x          |                || probsens.irr            | x          |                || multiple bias           | x          |                |",8
Bernadette,aggregate_age_distribution.md,"# Aggregate the age distribution matrix

```r
aggregate_age_distribution(x, lookup_table)
```

## Arguments

- `x`: data.frame; an age distribution matrix. See age_distribution .
- `lookup_table`: data.frame; a user-defined dataframe which maps the sixteen 5-year age bands to a new set of age bands.

## Returns

An object of class **data.frame** that contains the aggregated age distribution.

## Description

Function to aggregate the age distribution according to user-defined age groups.

## Examples

```r
# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                           Mapping = c(rep(""0-39"",  8),
                                       rep(""40-64"", 5),
                                       rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Plot the aggregated age distribution matrix:
plot_age_distribution(aggr_age)
```

## References

United Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.

Prem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['Aggregate the age distribution matrix```raggregate_age_distribution(x, lookup_table)``` Arguments- `x`: data.frame; an age distribution matrix.', 'See age_distribution .- `lookup_table`: data.frame; a user-defined dataframe which maps the sixteen 5-year age bands to a new set of age bands.', 'ReturnsAn object of class data.frame that contains the aggregated age distribution.', 'DescriptionFunction to aggregate the age distribution according to user-defined age groups.', 'Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Plot the aggregated age distribution matrix:plot_age_distribution(aggr_age)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019).', 'World Population Prospects 2019, Online Edition.', '1.Prem, K., van Zandvoort, K., Klepac, P. et al (2020).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," Aggregate the age distribution matrix```raggregate_age_distribution(x, lookup_table)``` Arguments- `x`: data.frame; an age distribution matrix. See age_distribution .- `lookup_table`: data.frame; a user-defined dataframe which maps the sixteen 5-year age bands to a new set of age bands. ReturnsAn object of class data.frame that contains the aggregated age distribution. DescriptionFunction to aggregate the age distribution according to user-defined age groups. Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Plot the aggregated age distribution matrix:plot_age_distribution(aggr_age)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.Prem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",9
Bernadette,posterior_rt.md,"# Estimate the effective reproduction number with the next generation matrix approach

```r
posterior_rt(object, y_data, age_distribution_population, infectious_period)
```

## Arguments

- `object`: An object of class `stanigbm`. See `stan_igbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.
- `age_distribution_population`: data.frame; the age distribution of a given population. See `aggregate_age_distribution`.
- `infectious_period`: integer; length of infectious period in days. Must be >=1.

## Returns

A data.frame which can be visualised using `plot_posterior_rt`.

## Description

Estimate the effective reproduction number with the next generation matrix approach

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_rt_summary <- posterior_rt(object                      = igbm_fit,
                                y_data                      = age_specific_mortality_counts,
                                age_distribution_population = aggr_age,
                                infectious_period            = 4)

# Visualise the posterior distribution of the effective reproduction number:
plot_posterior_rt(post_rt_summary)
```

## References

Diekmann, O., Heesterbeek, J., and Roberts, M. (2010). The construction of next-generation matrices for compartmental epidemic models. **J. R. Soc. Interface**, 7, 873–-885.

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)



","['Estimate the effective reproduction number with the next generation matrix approach```rposterior_rt(object, y_data, age_distribution_population, infectious_period)``` Arguments- `object`: An object of class `stanigbm`.', 'See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time.', 'See `data(age_specific_mortality_counts)`.- `age_distribution_population`: data.frame; the age distribution of a given population.', 'See `aggregate_age_distribution`.- `infectious_period`: integer; length of infectious period in days.', 'ReturnsA data.frame which can be visualised using `plot_posterior_rt`.', 'DescriptionEstimate the effective reproduction number with the next generation matrix approach Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_rt_summary <- posterior_rt(object                      = igbm_fit,                                y_data                      = age_specific_mortality_counts,                                age_distribution_population = aggr_age,                                infectious_period            = 4) Visualise the posterior distribution of the effective reproduction number:plot_posterior_rt(post_rt_summary)``` ReferencesDiekmann, O., Heesterbeek, J., and Roberts, M. (2010).', 'The construction of next-generation matrices for compartmental epidemic models.', 'Interface, 7, 873–-885.Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.']",1," Estimate the effective reproduction number with the next generation matrix approach```rposterior_rt(object, y_data, age_distribution_population, infectious_period)``` Arguments- `object`: An object of class `stanigbm`. See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.- `age_distribution_population`: data.frame; the age distribution of a given population. See `aggregate_age_distribution`.- `infectious_period`: integer; length of infectious period in days. Must be >=1. ReturnsA data.frame which can be visualised using `plot_posterior_rt`. DescriptionEstimate the effective reproduction number with the next generation matrix approach Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_rt_summary <- posterior_rt(object                      = igbm_fit,                                y_data                      = age_specific_mortality_counts,                                age_distribution_population = aggr_age,                                infectious_period            = 4) Visualise the posterior distribution of the effective reproduction number:plot_posterior_rt(post_rt_summary)``` ReferencesDiekmann, O., Heesterbeek, J., and Roberts, M. (2010). The construction of next-generation matrices for compartmental epidemic models. J. R. Soc. Interface, 7, 873–-885.Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)",9
Bernadette,Bernadette-package.md," package

# Bayesian inference and model selection for stochastic epidemics

## Description

`Bernadette` provides Bayesian analysis for stochastic extensions of dynamic non-linear systems using advanced computational algorithms.

## References

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)

Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.3. [https://mc-stan.org](https://mc-stan.org)



","['package Bayesian inference and model selection for stochastic epidemics Description`Bernadette` provides Bayesian analysis for stochastic extensions of dynamic non-linear systems using advanced computational algorithms.', 'ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.', 'arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)Stan Development Team (2020).', 'RStan: the R interface to Stan.']",1," package Bayesian inference and model selection for stochastic epidemics Description`Bernadette` provides Bayesian analysis for stochastic extensions of dynamic non-linear systems using advanced computational algorithms. ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.3. [https://mc-stan.org](https://mc-stan.org)",9
Bernadette,age_distribution.md,"# Country-specific age distribution

```r
age_distribution(country, year)
```

## Arguments

- `country`: character; country identifier, following the List of United Nations Member States. See countries_un .
- `year`: numeric; calendar year.

## Returns

An object of class **data.frame** that contains the age distribution.

## Description

Function to extract the age distribution of a country for a given year, broken down by 5-year age bands and gender, following the United Nations 2019 Revision of World Population Prospects.

## Examples

```r
# Age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)
```

## References

United Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.

Prem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['Country-specific age distribution```rage_distribution(country, year)``` Arguments- `country`: character; country identifier, following the List of United Nations Member States.', 'See countries_un .- `year`: numeric; calendar year.', 'ReturnsAn object of class data.frame that contains the age distribution.', 'DescriptionFunction to extract the age distribution of a country for a given year, broken down by 5-year age bands and gender, following the United Nations 2019 Revision of World Population Prospects.', 'Examples```r Age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019).', 'World Population Prospects 2019, Online Edition.', '1.Prem, K., van Zandvoort, K., Klepac, P. et al (2017).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," Country-specific age distribution```rage_distribution(country, year)``` Arguments- `country`: character; country identifier, following the List of United Nations Member States. See countries_un .- `year`: numeric; calendar year. ReturnsAn object of class data.frame that contains the age distribution. DescriptionFunction to extract the age distribution of a country for a given year, broken down by 5-year age bands and gender, following the United Nations 2019 Revision of World Population Prospects. Examples```r Age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.Prem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",9
Bernadette,contact_matrices.md," data

# Contact matrices per country

## Format

A list of 16 by 16 dataframes for 177 countries.

```r
data(contact_matrices)
```

## Returns

A list object of 16 by 16 dataframes for 177 countries.

## Description

A list of 16 by 16 contact matrices for 177 countries. Row i of a column j of a contact matrix corresponds to the number of contacts made by an individual in group i with an individual in group j.

## References

 Prem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['data Contact matrices per country FormatA list of 16 by 16 dataframes for 177 countries.```rdata(contact_matrices)``` ReturnsA list object of 16 by 16 dataframes for 177 countries.', 'DescriptionA list of 16 by 16 contact matrices for 177 countries.', 'Row i of a column j of a contact matrix corresponds to the number of contacts made by an individual in group i with an individual in group j. References Prem, K., van Zandvoort, K., Klepac, P. et al (2020).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," data Contact matrices per country FormatA list of 16 by 16 dataframes for 177 countries.```rdata(contact_matrices)``` ReturnsA list object of 16 by 16 dataframes for 177 countries. DescriptionA list of 16 by 16 contact matrices for 177 countries. Row i of a column j of a contact matrix corresponds to the number of contacts made by an individual in group i with an individual in group j. References Prem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",9
Bernadette,contact_matrix.md,"# Country-specific contact matrix

```r
contact_matrix(country)
```

## Arguments

- `country`: A character indicating the country identifier. See country_contact_matrices .

## Returns

An object of class ""data.frame"".

## Description

A 16 by 16 contact matrix whose row i of a column j corresponds to the number of contacts made by an individual in group i with an individual in group j.

## Examples

```r
conmat <- contact_matrix(country = ""GRC"")
```

## References

Prem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['Country-specific contact matrix```rcontact_matrix(country)``` Arguments- `country`: A character indicating the country identifier.', 'ReturnsAn object of class ""data.frame"".', 'DescriptionA 16 by 16 contact matrix whose row i of a column j corresponds to the number of contacts made by an individual in group i with an individual in group j. Examples```rconmat <- contact_matrix(country = ""GRC"")``` ReferencesPrem, K., van Zandvoort, K., Klepac, P. et al (2020).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," Country-specific contact matrix```rcontact_matrix(country)``` Arguments- `country`: A character indicating the country identifier. See country_contact_matrices . ReturnsAn object of class ""data.frame"". DescriptionA 16 by 16 contact matrix whose row i of a column j corresponds to the number of contacts made by an individual in group i with an individual in group j. Examples```rconmat <- contact_matrix(country = ""GRC"")``` ReferencesPrem, K., van Zandvoort, K., Klepac, P. et al (2020). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",9
Bernadette,age_specific_infection_counts.md," data

# Age distribution of new reported infections for Greece

## Format

A data frame with 210 rows and 8 variables:

- **Index**: integer; a sequence of integer numbers from 1 to 210
- **Right**: numeric; Index + 1
- **Date**: Date, format; date in the format ""2020-08-31""
- **Week_ID**: numeric; index of the week that each day falls into. A week is assumed to have 7 days
- **Total_Cases**: numeric; count of total reported infections on a given date
- **0-39**: numeric; count of reported infections on a given date for the age group ""0-39""
- **40-64**: numeric; count of reported infections on a given date for the age group ""40-64""
- **65+**: numeric; count of reported infections on a given date for the age group ""65+""

## Source

[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)

```r
data(age_specific_infection_counts)
```

## Returns

A data.frame object with 210 rows and 8 variables.

## Description

A dataset containing the age distribution of new reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database.

## References

 Sandbird (2022). Daily regional statistics for covid19 cases in Greece.



","['data Age distribution of new reported infections for Greece FormatA data frame with 210 rows and 8 variables:- Index: integer; a sequence of integer numbers from 1 to 210- Right: numeric; Index + 1- Date: Date, format; date in the format ""2020-08-31""- Week_ID: numeric; index of the week that each day falls into.', 'A week is assumed to have 7 days- Total_Cases: numeric; count of total reported infections on a given date- 0-39: numeric; count of reported infections on a given date for the age group ""0-39""- 40-64: numeric; count of reported infections on a given date for the age group ""40-64""- 65+: numeric; count of reported infections on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_infection_counts)``` ReturnsA data.frame object with 210 rows and 8 variables.', 'DescriptionA dataset containing the age distribution of new reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks).', 'The dataset has been extracted from the Hellenic National Public Health Organization database.', 'Daily regional statistics for covid19 cases in Greece.']",1," data Age distribution of new reported infections for Greece FormatA data frame with 210 rows and 8 variables:- Index: integer; a sequence of integer numbers from 1 to 210- Right: numeric; Index + 1- Date: Date, format; date in the format ""2020-08-31""- Week_ID: numeric; index of the week that each day falls into. A week is assumed to have 7 days- Total_Cases: numeric; count of total reported infections on a given date- 0-39: numeric; count of reported infections on a given date for the age group ""0-39""- 40-64: numeric; count of reported infections on a given date for the age group ""40-64""- 65+: numeric; count of reported infections on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_infection_counts)``` ReturnsA data.frame object with 210 rows and 8 variables. DescriptionA dataset containing the age distribution of new reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database. References Sandbird (2022). Daily regional statistics for covid19 cases in Greece.",9
Bernadette,stan_igbm.md,"# Bayesian diffusion-driven multi-type epidemic models via Stan

```r
stan_igbm(
  y_data,
  contact_matrix,
  age_distribution_population,
  age_specific_ifr,
  itd_distr,
  incubation_period = 3,
  infectious_period = 4,
  likelihood_variance_type = c(""quadratic"", ""linear""),
  ecr_changes = 1,
  prior_scale_x0 = 1,
  prior_scale_x1 = 1,
  prior_scale_contactmatrix = 0.05,
  pi_perc = 0.1,
  prior_volatility = normal(location = 0, scale = 2.5),
  prior_nb_dispersion = gamma(shape = 2, rate = 1),
  algorithm_inference = c(""sampling"", ""optimizing"", ""meanfield"", ""fullrank""),
  nBurn = 500,
  nPost = 500,
  nThin = 1,
  adapt_delta = 0.8,
  max_treedepth = 14,
  seed = 1,
  ...
)

stan_igbm.fit(
  standata_preprocessed,
  prior_volatility,
  prior_nb_dispersion,
  algorithm,
  nBurn,
  nPost,
  nThin,
  adapt_delta = NULL,
  max_treedepth = NULL,
  seed,
  ...
)
```

## Arguments

- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.
- `contact_matrix`: matrix; a squared matrix representing the the number of contacts between age groups.
- `age_distribution_population`: data.frame; the age distribution of a given population. See `aggregate_age_distribution`.
- `age_specific_ifr`: data.frame; time-varying age-specific infection-fatality ratio. See `aggregate_ifr_react`.
- `itd_distr`: vector; Infection-to-death distribution. A vector of length **ts_length**.
- `incubation_period`: integer; length of incubation period in days. Must be >=1.
- `infectious_period`: integer; length of infectious period in days. Must be >=1.
- `likelihood_variance_type`: integer; If `0`, the variance of the over-dispersed count model is a quadratic function of the mean; if `1`, the variance of the over-dispersed count model is a linear function of the mean.
- `ecr_changes`: integer; between 1 and 7, defaults to 1. Expresses the number of changes of the effective contact rate during the course of 7 days.
- `prior_scale_x0`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 0`.
- `prior_scale_x1`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 1`.
- `prior_scale_contactmatrix`: double; defaults to 0.05. A positive number that scales the informative Normal prior distribution assigned to the random contact matrix.
- `pi_perc`: numeric; between 0 and 1. It represents the proportion of Exposed individuals in each age group of a given population at time `t = 0`. while the rest `100*(1-pi_perc)` remain Susceptible.
- `prior_volatility`: Prior distribution for the volatility parameters of the age-specific diffusion processes. `prior_volatility` can be a call to `exponential` to use an exponential distribution, `gamma` to use a Gamma distribution or one of `normal`, `student_t` or `cauchy` to use a half-normal, half-t, or half-Cauchy prior. See `priors` for details on these functions.
- `prior_nb_dispersion`: Prior distribution for the dispersion parameter `phi` of the over-dispersed count model. Same options as for `prior_volatility`.
- `algorithm_inference`: One of the sampling algorithms that are implemented in Stan. See `stan`.
- `nBurn`: integer; number of burn-in iterations at the beginning of an MCMC run. See `sampling`.
- `nPost`: integer; number of MCMC iterations after burn-in. See `sampling`.
- `nThin`: integer; a positive integer specifying the period for saving samples. The default is 1, which is usually the recommended value. See `sampling`.
- `adapt_delta`: double; between 0 and 1, defaults to 0.8. See `stan`.
- `max_treedepth`: integer; defaults to 14. See `stan`.
- `seed`: integer; seed for the random number generator. See `set.seed`.
- `...`: Additional arguments, to be passed to lower-level functions.
- `standata_preprocessed`: A named list providing the data for the model. See `sampling`.
- `algorithm`: See `algorithm` in stan_igbm .

## Returns

An object of class **stanigbm** representing the fitted results. Slot mode for this object indicates if the sampling is done or not.

An object of S4 class **stanfit** representing the fitted results. Slot mode for this object indicates if the sampling is done or not.

## Description

A Bayesian evidence synthesis approach to model the age-specific transmission dynamics of COVID-19 based on daily age-stratified mortality counts. The temporal evolution of transmission rates in populations containing multiple types of individual is reconstructed via independent diffusion processes assigned to the key epidemiological parameters. A suitably tailored Susceptible-Exposed-Infected-Removed (SEIR) compartmental model is used to capture the latent counts of infections and to account for fluctuations in transmission influenced by phenomena like public health interventions and changes in human behaviour.

## Details

The `stan_igbm` function performs full Bayesian estimation (if `algorithm_inference` is `""sampling""`) via MCMC. The Bayesian model adds priors (i) on the diffusion processes used to express the time-varying transmissibility of the virus, the probability that a contact between an infectious person in age group alpha and a susceptible person in age group alpha leads to transmission at time `t` and (ii) on a random contact matrix which represents the average number of contacts between individuals of age group alpha and age group alpha' The `stan_igbm` function calls the workhorse `stan_igbm.fit` function.

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

# print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary
```

## References

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)



","['Bayesian diffusion-driven multi-type epidemic models via Stan```rstan_igbm(  y_data,  contact_matrix,  age_distribution_population,  age_specific_ifr,  itd_distr,  incubation_period = 3,  infectious_period = 4,  likelihood_variance_type = c(""quadratic"", ""linear""),  ecr_changes = 1,  prior_scale_x0 = 1,  prior_scale_x1 = 1,  prior_scale_contactmatrix = 0.05,  pi_perc = 0.1,  prior_volatility = normal(location = 0, scale = 2.5),  prior_nb_dispersion = gamma(shape = 2, rate = 1),  algorithm_inference = c(""sampling"", ""optimizing"", ""meanfield"", ""fullrank""),  nBurn = 500,  nPost = 500,  nThin = 1,  adapt_delta = 0.8,  max_treedepth = 14,  seed = 1,  ...)stan_igbm.fit(  standata_preprocessed,  prior_volatility,  prior_nb_dispersion,  algorithm,  nBurn,  nPost,  nThin,  adapt_delta = NULL,  max_treedepth = NULL,  seed,  ...)``` Arguments- `y_data`: data.frame; age-specific mortality counts in time.', 'See `data(age_specific_mortality_counts)`.- `contact_matrix`: matrix; a squared matrix representing the the number of contacts between age groups.- `age_distribution_population`: data.frame; the age distribution of a given population.', 'See `aggregate_age_distribution`.- `age_specific_ifr`: data.frame; time-varying age-specific infection-fatality ratio.', 'See `aggregate_ifr_react`.- `itd_distr`: vector; Infection-to-death distribution.', 'A vector of length ts_length.- `incubation_period`: integer; length of incubation period in days.', 'Must be >=1.- `infectious_period`: integer; length of infectious period in days.', 'Must be >=1.- `likelihood_variance_type`: integer; If `0`, the variance of the over-dispersed count model is a quadratic function of the mean; if `1`, the variance of the over-dispersed count model is a linear function of the mean.- `ecr_changes`: integer; between 1 and 7, defaults to 1.', 'Expresses the number of changes of the effective contact rate during the course of 7 days.- `prior_scale_x0`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 0`.- `prior_scale_x1`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 1`.- `prior_scale_contactmatrix`: double; defaults to 0.05.', 'A positive number that scales the informative Normal prior distribution assigned to the random contact matrix.- `pi_perc`: numeric; between 0 and 1.', 'It represents the proportion of Exposed individuals in each age group of a given population at time `t = 0`.', 'while the rest `100(1-pi_perc)` remain Susceptible.- `prior_volatility`: Prior distribution for the volatility parameters of the age-specific diffusion processes.', '`prior_volatility` can be a call to `exponential` to use an exponential distribution, `gamma` to use a Gamma distribution or one of `normal`, `student_t` or `cauchy` to use a half-normal, half-t, or half-Cauchy prior.', 'See `priors` for details on these functions.- `prior_nb_dispersion`: Prior distribution for the dispersion parameter `phi` of the over-dispersed count model.', 'Same options as for `prior_volatility`.- `algorithm_inference`: One of the sampling algorithms that are implemented in Stan.', 'See `stan`.- `nBurn`: integer; number of burn-in iterations at the beginning of an MCMC run.', 'See `sampling`.- `nPost`: integer; number of MCMC iterations after burn-in.', 'See `sampling`.- `nThin`: integer; a positive integer specifying the period for saving samples.', 'The default is 1, which is usually the recommended value.', 'See `sampling`.- `adapt_delta`: double; between 0 and 1, defaults to 0.8.', 'See `stan`.- `max_treedepth`: integer; defaults to 14.', 'See `stan`.- `seed`: integer; seed for the random number generator.', 'See `set.seed`.- `...`: Additional arguments, to be passed to lower-level functions.- `standata_preprocessed`: A named list providing the data for the model.', 'See `sampling`.- `algorithm`: See `algorithm` in stan_igbm .', 'ReturnsAn object of class stanigbm representing the fitted results.', 'Slot mode for this object indicates if the sampling is done or not.An object of S4 class stanfit representing the fitted results.', 'Slot mode for this object indicates if the sampling is done or not.', 'DescriptionA Bayesian evidence synthesis approach to model the age-specific transmission dynamics of COVID-19 based on daily age-stratified mortality counts.', 'The temporal evolution of transmission rates in populations containing multiple types of individual is reconstructed via independent diffusion processes assigned to the key epidemiological parameters.', 'A suitably tailored Susceptible-Exposed-Infected-Removed (SEIR) compartmental model is used to capture the latent counts of infections and to account for fluctuations in transmission influenced by phenomena like public health interventions and changes in human behaviour.', 'DetailsThe `stan_igbm` function performs full Bayesian estimation (if `algorithm_inference` is `""sampling""`) via MCMC.', ""The Bayesian model adds priors (i) on the diffusion processes used to express the time-varying transmissibility of the virus, the probability that a contact between an infectious person in age group alpha and a susceptible person in age group alpha leads to transmission at time `t` and (ii) on a random contact matrix which represents the average number of contacts between individuals of age group alpha and age group alpha' The `stan_igbm` function calls the workhorse `stan_igbm.fit` function."", 'Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.']",1," Bayesian diffusion-driven multi-type epidemic models via Stan```rstan_igbm(  y_data,  contact_matrix,  age_distribution_population,  age_specific_ifr,  itd_distr,  incubation_period = 3,  infectious_period = 4,  likelihood_variance_type = c(""quadratic"", ""linear""),  ecr_changes = 1,  prior_scale_x0 = 1,  prior_scale_x1 = 1,  prior_scale_contactmatrix = 0.05,  pi_perc = 0.1,  prior_volatility = normal(location = 0, scale = 2.5),  prior_nb_dispersion = gamma(shape = 2, rate = 1),  algorithm_inference = c(""sampling"", ""optimizing"", ""meanfield"", ""fullrank""),  nBurn = 500,  nPost = 500,  nThin = 1,  adapt_delta = 0.8,  max_treedepth = 14,  seed = 1,  ...)stan_igbm.fit(  standata_preprocessed,  prior_volatility,  prior_nb_dispersion,  algorithm,  nBurn,  nPost,  nThin,  adapt_delta = NULL,  max_treedepth = NULL,  seed,  ...)``` Arguments- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.- `contact_matrix`: matrix; a squared matrix representing the the number of contacts between age groups.- `age_distribution_population`: data.frame; the age distribution of a given population. See `aggregate_age_distribution`.- `age_specific_ifr`: data.frame; time-varying age-specific infection-fatality ratio. See `aggregate_ifr_react`.- `itd_distr`: vector; Infection-to-death distribution. A vector of length ts_length.- `incubation_period`: integer; length of incubation period in days. Must be >=1.- `infectious_period`: integer; length of infectious period in days. Must be >=1.- `likelihood_variance_type`: integer; If `0`, the variance of the over-dispersed count model is a quadratic function of the mean; if `1`, the variance of the over-dispersed count model is a linear function of the mean.- `ecr_changes`: integer; between 1 and 7, defaults to 1. Expresses the number of changes of the effective contact rate during the course of 7 days.- `prior_scale_x0`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 0`.- `prior_scale_x1`: double; scale parameter of a Normal prior distribution assigned to the age-specific log(transmissibility) at time `t = 1`.- `prior_scale_contactmatrix`: double; defaults to 0.05. A positive number that scales the informative Normal prior distribution assigned to the random contact matrix.- `pi_perc`: numeric; between 0 and 1. It represents the proportion of Exposed individuals in each age group of a given population at time `t = 0`. while the rest `100(1-pi_perc)` remain Susceptible.- `prior_volatility`: Prior distribution for the volatility parameters of the age-specific diffusion processes. `prior_volatility` can be a call to `exponential` to use an exponential distribution, `gamma` to use a Gamma distribution or one of `normal`, `student_t` or `cauchy` to use a half-normal, half-t, or half-Cauchy prior. See `priors` for details on these functions.- `prior_nb_dispersion`: Prior distribution for the dispersion parameter `phi` of the over-dispersed count model. Same options as for `prior_volatility`.- `algorithm_inference`: One of the sampling algorithms that are implemented in Stan. See `stan`.- `nBurn`: integer; number of burn-in iterations at the beginning of an MCMC run. See `sampling`.- `nPost`: integer; number of MCMC iterations after burn-in. See `sampling`.- `nThin`: integer; a positive integer specifying the period for saving samples. The default is 1, which is usually the recommended value. See `sampling`.- `adapt_delta`: double; between 0 and 1, defaults to 0.8. See `stan`.- `max_treedepth`: integer; defaults to 14. See `stan`.- `seed`: integer; seed for the random number generator. See `set.seed`.- `...`: Additional arguments, to be passed to lower-level functions.- `standata_preprocessed`: A named list providing the data for the model. See `sampling`.- `algorithm`: See `algorithm` in stan_igbm . ReturnsAn object of class stanigbm representing the fitted results. Slot mode for this object indicates if the sampling is done or not.An object of S4 class stanfit representing the fitted results. Slot mode for this object indicates if the sampling is done or not. DescriptionA Bayesian evidence synthesis approach to model the age-specific transmission dynamics of COVID-19 based on daily age-stratified mortality counts. The temporal evolution of transmission rates in populations containing multiple types of individual is reconstructed via independent diffusion processes assigned to the key epidemiological parameters. A suitably tailored Susceptible-Exposed-Infected-Removed (SEIR) compartmental model is used to capture the latent counts of infections and to account for fluctuations in transmission influenced by phenomena like public health interventions and changes in human behaviour. DetailsThe `stan_igbm` function performs full Bayesian estimation (if `algorithm_inference` is `""sampling""`) via MCMC. The Bayesian model adds priors (i) on the diffusion processes used to express the time-varying transmissibility of the virus, the probability that a contact between an infectious person in age group alpha and a susceptible person in age group alpha leads to transmission at time `t` and (ii) on a random contact matrix which represents the average number of contacts between individuals of age group alpha and age group alpha' The `stan_igbm` function calls the workhorse `stan_igbm.fit` function. Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)",10
Bernadette,itd_distribution.md,"# Distribution of the time between infection and death

```r
itd_distribution(
  ts_length,
  gamma_mean = 24.19231,
  gamma_cv = 0.3987261,
  gamma_shape = 6.29,
  gamma_rate = 0.26
)
```

## Arguments

- `ts_length`: integer; time from infection to death in days.
- `gamma_mean`: numeric; mean of a gamma distribution, for a given shape and rate. See also `GammaDist`.
- `gamma_cv`: numeric; coefficient of variation of a gamma distribution, for a given shape and rate. See also `GammaDist`.
- `gamma_shape`: numeric; shape parameter of a gamma distribution. See also `GammaDist`.
- `gamma_rate`: numeric; rate parameter of a gamma distribution. See also `GammaDist`.

## Returns

A vector of length **ts_length**.

## Description

Function to discretize the infection-to-death distribution

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)
```

## References

Flaxman et al (2020). Estimating the effects of non-pharmaceutical interventions on COVID-19 in Europe. Nature, 584, 257-261.



","['Distribution of the time between infection and death```ritd_distribution(  ts_length,  gamma_mean = 24.19231,  gamma_cv = 0.3987261,  gamma_shape = 6.29,  gamma_rate = 0.26)``` Arguments- `ts_length`: integer; time from infection to death in days.- `gamma_mean`: numeric; mean of a gamma distribution, for a given shape and rate.', 'See also `GammaDist`.- `gamma_cv`: numeric; coefficient of variation of a gamma distribution, for a given shape and rate.', 'See also `GammaDist`.- `gamma_shape`: numeric; shape parameter of a gamma distribution.', 'See also `GammaDist`.- `gamma_rate`: numeric; rate parameter of a gamma distribution.', 'ReturnsA vector of length ts_length.', 'DescriptionFunction to discretize the infection-to-death distribution Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261)``` ReferencesFlaxman et al (2020).', 'Estimating the effects of non-pharmaceutical interventions on COVID-19 in Europe.']",1," Distribution of the time between infection and death```ritd_distribution(  ts_length,  gamma_mean = 24.19231,  gamma_cv = 0.3987261,  gamma_shape = 6.29,  gamma_rate = 0.26)``` Arguments- `ts_length`: integer; time from infection to death in days.- `gamma_mean`: numeric; mean of a gamma distribution, for a given shape and rate. See also `GammaDist`.- `gamma_cv`: numeric; coefficient of variation of a gamma distribution, for a given shape and rate. See also `GammaDist`.- `gamma_shape`: numeric; shape parameter of a gamma distribution. See also `GammaDist`.- `gamma_rate`: numeric; rate parameter of a gamma distribution. See also `GammaDist`. ReturnsA vector of length ts_length. DescriptionFunction to discretize the infection-to-death distribution Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261)``` ReferencesFlaxman et al (2020). Estimating the effects of non-pharmaceutical interventions on COVID-19 in Europe. Nature, 584, 257-261.",10
Bernadette,plot_posterior_cm.md,"# Plot the posterior contact matrix

```r
plot_posterior_cm(object, y_data, ...)
```

## Arguments

- `object`: An object of class `stanigbm`. See `stan_igbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.
- `...`: Optional arguments passed to `theme`.

## Returns

A `grid.arrange` object which can be further customised using the `gridExtra` package.

## Description

Plot the posterior contact matrix

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

# Visualise the posterior distribution of the random contact matrix:
plot_posterior_cm(object = igbm_fit,
                  y_data = age_specific_mortality_counts)
```

## References

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)



","['Plot the posterior contact matrix```rplot_posterior_cm(object, y_data, ...)``` Arguments- `object`: An object of class `stanigbm`.', 'See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time.', 'See `data(age_specific_mortality_counts)`.- `...`: Optional arguments passed to `theme`.', 'ReturnsA `grid.arrange` object which can be further customised using the `gridExtra` package.', 'DescriptionPlot the posterior contact matrix Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) Visualise the posterior distribution of the random contact matrix:plot_posterior_cm(object = igbm_fit,                  y_data = age_specific_mortality_counts)``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.']",1," Plot the posterior contact matrix```rplot_posterior_cm(object, y_data, ...)``` Arguments- `object`: An object of class `stanigbm`. See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.- `...`: Optional arguments passed to `theme`. ReturnsA `grid.arrange` object which can be further customised using the `gridExtra` package. DescriptionPlot the posterior contact matrix Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) Visualise the posterior distribution of the random contact matrix:plot_posterior_cm(object = igbm_fit,                  y_data = age_specific_mortality_counts)``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)",10
Bernadette,countries_un.md,"# Names of countries with an available age distribution

```r
countries_un()
```

## Returns

A character vector that contains the full names of 201 countries/areas.

## Description

Function to extract the names of the countries whose discrete age distribution is available by the United Nations.

## Examples

```r
countries_un()
```

## References

United Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.

Prem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['Names of countries with an available age distribution```rcountries_un()``` ReturnsA character vector that contains the full names of 201 countries/areas.', 'DescriptionFunction to extract the names of the countries whose discrete age distribution is available by the United Nations.', 'Examples```rcountries_un()``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019).', 'World Population Prospects 2019, Online Edition.', '1.Prem, K., van Zandvoort, K., Klepac, P. et al (2017).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," Names of countries with an available age distribution```rcountries_un()``` ReturnsA character vector that contains the full names of 201 countries/areas. DescriptionFunction to extract the names of the countries whose discrete age distribution is available by the United Nations. Examples```rcountries_un()``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.Prem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",10
Bernadette,plot_posterior_rt.md,"# Plot the estimated effective reproduction number trajectory

```r
plot_posterior_rt(object, xlab = NULL, ylab = NULL, ...)
```

## Arguments

- `object`: A data frame from `posterior_rt`.
- `xlab`: character; Title of x-axis.
- `ylab`: character; Title of y-axis.
- `...`: Optional arguments passed to `scale_x_date` and `theme`.

## Returns

A `ggplot` object which can be further customised using the `ggplot2` package.

## Description

Plot the estimated effective reproduction number trajectory

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_rt_summary <- posterior_rt(object                      = igbm_fit,
                                y_data                      = age_specific_mortality_counts,
                                age_distribution_population = aggr_age,
                                infectious_period            = 4)

# Visualise the posterior distribution of the effective reproduction number:
plot_posterior_rt(post_rt_summary)
```

## See Also

`posterior_rt`.



","['Plot the estimated effective reproduction number trajectory```rplot_posterior_rt(object, xlab = NULL, ylab = NULL, ...)``` Arguments- `object`: A data frame from `posterior_rt`.- `xlab`: character; Title of x-axis.- `ylab`: character; Title of y-axis.- `...`: Optional arguments passed to `scale_x_date` and `theme`.', 'ReturnsA `ggplot` object which can be further customised using the `ggplot2` package.', 'DescriptionPlot the estimated effective reproduction number trajectory Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_rt_summary <- posterior_rt(object                      = igbm_fit,                                y_data                      = age_specific_mortality_counts,                                age_distribution_population = aggr_age,                                infectious_period            = 4) Visualise the posterior distribution of the effective reproduction number:plot_posterior_rt(post_rt_summary)``` See Also`posterior_rt`.']",1," Plot the estimated effective reproduction number trajectory```rplot_posterior_rt(object, xlab = NULL, ylab = NULL, ...)``` Arguments- `object`: A data frame from `posterior_rt`.- `xlab`: character; Title of x-axis.- `ylab`: character; Title of y-axis.- `...`: Optional arguments passed to `scale_x_date` and `theme`. ReturnsA `ggplot` object which can be further customised using the `ggplot2` package. DescriptionPlot the estimated effective reproduction number trajectory Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_rt_summary <- posterior_rt(object                      = igbm_fit,                                y_data                      = age_specific_mortality_counts,                                age_distribution_population = aggr_age,                                infectious_period            = 4) Visualise the posterior distribution of the effective reproduction number:plot_posterior_rt(post_rt_summary)``` See Also`posterior_rt`.",10
Bernadette,aggregate_contact_matrix.md,"# Aggregate a contact matrix

```r
aggregate_contact_matrix(object, lookup_table, age_distr)
```

## Arguments

- `object`: data.frame; a contact matrix. See contact_matrix .
- `lookup_table`: data.frame; a user-defined data.frame which maps the sixteen 5-year age bands to a new set of age bands.
- `age_distr`: data.frame; the aggregated age distribution. See aggregate_contact_matrix .

## Returns

An object of class **data.frame**.

## Description

Function to aggregate a contact matrix according to user-defined age groups.

## Examples

```r
# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                           Mapping = c(rep(""0-39"",  8),
                                       rep(""40-64"", 5),
                                       rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Plot the contact matrix:
plot_contact_matrix(aggr_cm)
```



","['Aggregate a contact matrix```raggregate_contact_matrix(object, lookup_table, age_distr)``` Arguments- `object`: data.frame; a contact matrix.', 'See contact_matrix .- `lookup_table`: data.frame; a user-defined data.frame which maps the sixteen 5-year age bands to a new set of age bands.- `age_distr`: data.frame; the aggregated age distribution.', 'ReturnsAn object of class data.frame.', 'DescriptionFunction to aggregate a contact matrix according to user-defined age groups.', 'Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Plot the contact matrix:plot_contact_matrix(aggr_cm)```']",1," Aggregate a contact matrix```raggregate_contact_matrix(object, lookup_table, age_distr)``` Arguments- `object`: data.frame; a contact matrix. See contact_matrix .- `lookup_table`: data.frame; a user-defined data.frame which maps the sixteen 5-year age bands to a new set of age bands.- `age_distr`: data.frame; the aggregated age distribution. See aggregate_contact_matrix . ReturnsAn object of class data.frame. DescriptionFunction to aggregate a contact matrix according to user-defined age groups. Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Plot the contact matrix:plot_contact_matrix(aggr_cm)```",10
Bernadette,priors.md,"# Prior distributions and options

```r
normal(location = 0, scale = NULL)

student_t(df = 1, location = 0, scale = NULL)

cauchy(location = 0, scale = NULL)

gamma(shape = 2, rate = 1)

exponential(rate = 1)
```

## Arguments

- `location`: Prior location. In most cases, this is the prior mean, but for `cauchy` (which is equivalent to `student_t` with `df=1`), the mean does not exist and `location` is the prior median. The default value is `0`.
- `scale`: Prior scale. The default depends on the family (see Details ).
- `df`: Degrees of freedom.
- `shape`: Prior shape for the gamma distribution. Defaults to `2`.
- `rate`: Prior rate for the exponential distribution. Defaults to `1`. For the exponential distribution, the rate parameter is the **reciprocal** of the mean.

## Returns

A named list to be used internally by the `Bernadette` model fitting functions.

## Description

The functions described on this page are used to specify the prior-related arguments of the modeling functions in the `Bernadette` package.

The default priors used in the `Bernadette` modeling functions are intended to be **weakly informative**. For many applications the defaults will perform well, but prudent use of more informative priors is encouraged. Uniform prior distributions are possible (e.g. by setting `stan_igbm`'s `prior` argument to `NULL`) but, unless the data is very strong, they are not recommended and are **not**

non-informative, giving the same probability mass to implausible values as plausible ones.

## Details

The details depend on the family of the prior being used:

### Student t family

Family members:

 * `normal(location, scale)`
 * `student_t(df, location, scale)`
 * `cauchy(location, scale)`

As the degrees of freedom approaches infinity, the Student t distribution approaches the normal distribution and if the degrees of freedom are one, then the Student t distribution is the Cauchy distribution. If `scale` is not specified it will default to `2.5`.

## Examples

```r
# Age-specific mortality/incidence count time series:
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Can assign priors to names:
N05      <- normal(0, 5)
Gamma22  <- gamma(2,2)
igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      likelihood_variance_type    = ""quadratic"",
                      prior_volatility            = N05,
                      prior_nb_dispersion         = Gamma22,
                      algorithm_inference         = ""optimizing"")
```

## See Also

The vignette for the `Bernadette` package discusses the use of some of the supported prior distributions.



","['Prior distributions and options```rnormal(location = 0, scale = NULL)student_t(df = 1, location = 0, scale = NULL)cauchy(location = 0, scale = NULL)gamma(shape = 2, rate = 1)exponential(rate = 1)``` Arguments- `location`: Prior location.', 'In most cases, this is the prior mean, but for `cauchy` (which is equivalent to `student_t` with `df=1`), the mean does not exist and `location` is the prior median.', 'The default value is `0`.- `scale`: Prior scale.', 'The default depends on the family (see Details ).- `df`: Degrees of freedom.- `shape`: Prior shape for the gamma distribution.', 'Defaults to `2`.- `rate`: Prior rate for the exponential distribution.', 'For the exponential distribution, the rate parameter is the reciprocal of the mean.', 'ReturnsA named list to be used internally by the `Bernadette` model fitting functions.', 'DescriptionThe functions described on this page are used to specify the prior-related arguments of the modeling functions in the `Bernadette` package.The default priors used in the `Bernadette` modeling functions are intended to be weakly informative.', 'For many applications the defaults will perform well, but prudent use of more informative priors is encouraged.', 'Uniform prior distributions are possible (e.g.', ""by setting `stan_igbm`'s `prior` argument to `NULL`) but, unless the data is very strong, they are not recommended and are notnon-informative, giving the same probability mass to implausible values as plausible ones."", 'DetailsThe details depend on the family of the prior being used: Student t familyFamily members:  `normal(location, scale)`  `student_t(df, location, scale)`  `cauchy(location, scale)`As the degrees of freedom approaches infinity, the Student t distribution approaches the normal distribution and if the degrees of freedom are one, then the Student t distribution is the Cauchy distribution.', 'If `scale` is not specified it will default to `2.5`.', 'Examples```r Age-specific mortality/incidence count time series: Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Can assign priors to names:N05      <- normal(0, 5)Gamma22  <- gamma(2,2)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      likelihood_variance_type    = ""quadratic"",                      prior_volatility            = N05,                      prior_nb_dispersion         = Gamma22,                      algorithm_inference         = ""optimizing"")``` See AlsoThe vignette for the `Bernadette` package discusses the use of some of the supported prior distributions.']",1," Prior distributions and options```rnormal(location = 0, scale = NULL)student_t(df = 1, location = 0, scale = NULL)cauchy(location = 0, scale = NULL)gamma(shape = 2, rate = 1)exponential(rate = 1)``` Arguments- `location`: Prior location. In most cases, this is the prior mean, but for `cauchy` (which is equivalent to `student_t` with `df=1`), the mean does not exist and `location` is the prior median. The default value is `0`.- `scale`: Prior scale. The default depends on the family (see Details ).- `df`: Degrees of freedom.- `shape`: Prior shape for the gamma distribution. Defaults to `2`.- `rate`: Prior rate for the exponential distribution. Defaults to `1`. For the exponential distribution, the rate parameter is the reciprocal of the mean. ReturnsA named list to be used internally by the `Bernadette` model fitting functions. DescriptionThe functions described on this page are used to specify the prior-related arguments of the modeling functions in the `Bernadette` package.The default priors used in the `Bernadette` modeling functions are intended to be weakly informative. For many applications the defaults will perform well, but prudent use of more informative priors is encouraged. Uniform prior distributions are possible (e.g. by setting `stan_igbm`'s `prior` argument to `NULL`) but, unless the data is very strong, they are not recommended and are notnon-informative, giving the same probability mass to implausible values as plausible ones. DetailsThe details depend on the family of the prior being used: Student t familyFamily members:  `normal(location, scale)`  `student_t(df, location, scale)`  `cauchy(location, scale)`As the degrees of freedom approaches infinity, the Student t distribution approaches the normal distribution and if the degrees of freedom are one, then the Student t distribution is the Cauchy distribution. If `scale` is not specified it will default to `2.5`. Examples```r Age-specific mortality/incidence count time series: Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Can assign priors to names:N05      <- normal(0, 5)Gamma22  <- gamma(2,2)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      likelihood_variance_type    = ""quadratic"",                      prior_volatility            = N05,                      prior_nb_dispersion         = Gamma22,                      algorithm_inference         = ""optimizing"")``` See AlsoThe vignette for the `Bernadette` package discusses the use of some of the supported prior distributions.",10
Bernadette,posterior_transmrate.md,"# Estimate the age-specific transmission rate

```r
posterior_transmrate(object, y_data)
```

## Arguments

- `object`: An object of class `stanigbm`. See `stan_igbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.

## Returns

A data.frame which can be visualised using `plot_posterior_transmrate`.

## Description

Estimate the age-specific transmission rate

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_transmrate_summary <- posterior_transmrate(object = igbm_fit,
                                                y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the age-specific transmission rate:
plot_posterior_transmrate(post_transmrate_summary)
```



","['Estimate the age-specific transmission rate```rposterior_transmrate(object, y_data)``` Arguments- `object`: An object of class `stanigbm`.', 'See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time.', 'ReturnsA data.frame which can be visualised using `plot_posterior_transmrate`.', 'DescriptionEstimate the age-specific transmission rate Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_transmrate_summary <- posterior_transmrate(object = igbm_fit,                                                y_data = age_specific_mortality_counts) Visualise the posterior distribution of the age-specific transmission rate:plot_posterior_transmrate(post_transmrate_summary)```']",1," Estimate the age-specific transmission rate```rposterior_transmrate(object, y_data)``` Arguments- `object`: An object of class `stanigbm`. See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`. ReturnsA data.frame which can be visualised using `plot_posterior_transmrate`. DescriptionEstimate the age-specific transmission rate Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_transmrate_summary <- posterior_transmrate(object = igbm_fit,                                                y_data = age_specific_mortality_counts) Visualise the posterior distribution of the age-specific transmission rate:plot_posterior_transmrate(post_transmrate_summary)```",11
Bernadette,plot_posterior_infections.md,"# Plot the posterior distribution of the infection counts

```r
plot_posterior_infections(
  object,
  type = c(""age-specific"", ""aggregated""),
  xlab = NULL,
  ylab = NULL,
  ...
)
```

## Arguments

- `object`: A dataframe from `posterior_infections`.
- `type`: character; Plot the output for the 'age-specific' infection counts or the 'aggregated' infections.
- `xlab`: character; title of x-axis.
- `ylab`: character; title of y-axis.
- `...`: Optional arguments passed to `scale_x_date`.

## Returns

A `ggplot` object which can be further customised using the `ggplot2` package.

## Description

Plot the posterior distribution of the infection counts

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_inf_summary <- posterior_infections(object = igbm_fit,
                                         y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the infection counts:
plot_posterior_infections(post_inf_summary, type = ""age-specific"")
plot_posterior_infections(post_inf_summary, type = ""aggregated"")
```

## See Also

`posterior_infections`.



","['Plot the posterior distribution of the infection counts```rplot_posterior_infections(  object,  type = c(""age-specific"", ""aggregated""),  xlab = NULL,  ylab = NULL,  ...)``` Arguments- `object`: A dataframe from `posterior_infections`.- `type`: character; Plot the output for the \'age-specific\' infection counts or the \'aggregated\' infections.- `xlab`: character; title of x-axis.- `ylab`: character; title of y-axis.- `...`: Optional arguments passed to `scale_x_date`.', 'ReturnsA `ggplot` object which can be further customised using the `ggplot2` package.', 'DescriptionPlot the posterior distribution of the infection counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_inf_summary <- posterior_infections(object = igbm_fit,                                         y_data = age_specific_mortality_counts) Visualise the posterior distribution of the infection counts:plot_posterior_infections(post_inf_summary, type = ""age-specific"")plot_posterior_infections(post_inf_summary, type = ""aggregated"")``` See Also`posterior_infections`.']",1," Plot the posterior distribution of the infection counts```rplot_posterior_infections(  object,  type = c(""age-specific"", ""aggregated""),  xlab = NULL,  ylab = NULL,  ...)``` Arguments- `object`: A dataframe from `posterior_infections`.- `type`: character; Plot the output for the 'age-specific' infection counts or the 'aggregated' infections.- `xlab`: character; title of x-axis.- `ylab`: character; title of y-axis.- `...`: Optional arguments passed to `scale_x_date`. ReturnsA `ggplot` object which can be further customised using the `ggplot2` package. DescriptionPlot the posterior distribution of the infection counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_inf_summary <- posterior_infections(object = igbm_fit,                                         y_data = age_specific_mortality_counts) Visualise the posterior distribution of the infection counts:plot_posterior_infections(post_inf_summary, type = ""age-specific"")plot_posterior_infections(post_inf_summary, type = ""aggregated"")``` See Also`posterior_infections`.",11
Bernadette,plot_contact_matrix.md,"# Contact matrix heatmap

```r
plot_contact_matrix(x)
```

## Arguments

- `x`: data.frame; a contact matrix. See contact_matrix .

## Returns

A ggplot object that can be further customized using the `ggplot2` package.

## Description

Contact matrix heatmap

## Examples

```r
# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

plot_contact_matrix(conmat)
```



","['Contact matrix heatmap```rplot_contact_matrix(x)``` Arguments- `x`: data.frame; a contact matrix.', 'ReturnsA ggplot object that can be further customized using the `ggplot2` package.', 'DescriptionContact matrix heatmap Examples```r Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"")plot_contact_matrix(conmat)```']",1," Contact matrix heatmap```rplot_contact_matrix(x)``` Arguments- `x`: data.frame; a contact matrix. See contact_matrix . ReturnsA ggplot object that can be further customized using the `ggplot2` package. DescriptionContact matrix heatmap Examples```r Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"")plot_contact_matrix(conmat)```",11
Bernadette,posterior_infections.md,"# Summarize the posterior distribution of the infection counts

```r
posterior_infections(object, y_data)
```

## Arguments

- `object`: An object of class `stanigbm`. See `stan_igbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.

## Returns

A named list with elements `Age_specific` and `Aggregated` which can be visualized using `plot_posterior_infections`.

## Description

Summarize the posterior distribution of the infection counts

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_inf_summary <- posterior_infections(object = igbm_fit,
                                         y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the infection counts:
plot_posterior_infections(post_inf_summary, type = ""age-specific"")
plot_posterior_infections(post_inf_summary, type = ""aggregated"")
```

## References

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)



","['Summarize the posterior distribution of the infection counts```rposterior_infections(object, y_data)``` Arguments- `object`: An object of class `stanigbm`.', 'See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time.', 'ReturnsA named list with elements `Age_specific` and `Aggregated` which can be visualized using `plot_posterior_infections`.', 'DescriptionSummarize the posterior distribution of the infection counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_inf_summary <- posterior_infections(object = igbm_fit,                                         y_data = age_specific_mortality_counts) Visualise the posterior distribution of the infection counts:plot_posterior_infections(post_inf_summary, type = ""age-specific"")plot_posterior_infections(post_inf_summary, type = ""aggregated"")``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.']",1," Summarize the posterior distribution of the infection counts```rposterior_infections(object, y_data)``` Arguments- `object`: An object of class `stanigbm`. See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`. ReturnsA named list with elements `Age_specific` and `Aggregated` which can be visualized using `plot_posterior_infections`. DescriptionSummarize the posterior distribution of the infection counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_inf_summary <- posterior_infections(object = igbm_fit,                                         y_data = age_specific_mortality_counts) Visualise the posterior distribution of the infection counts:plot_posterior_infections(post_inf_summary, type = ""age-specific"")plot_posterior_infections(post_inf_summary, type = ""aggregated"")``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)",11
Bernadette,country_contact_matrices.md,"# Names of countries for which a contact matrix is available

```r
country_contact_matrices()
```

## Returns

A character vector of length 177 with the IDs of each of the 177 geographical regions.

## Description

Function to extract the names of the countries whose projected contact matrix is available.

## Examples

```r
country_contact_matrices()
```

## References

Prem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772



","['Names of countries for which a contact matrix is available```rcountry_contact_matrices()``` ReturnsA character vector of length 177 with the IDs of each of the 177 geographical regions.', 'DescriptionFunction to extract the names of the countries whose projected contact matrix is available.', 'Examples```rcountry_contact_matrices()``` ReferencesPrem, K., van Zandvoort, K., Klepac, P. et al (2017).', 'Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era.']",1," Names of countries for which a contact matrix is available```rcountry_contact_matrices()``` ReturnsA character vector of length 177 with the IDs of each of the 177 geographical regions. DescriptionFunction to extract the names of the countries whose projected contact matrix is available. Examples```rcountry_contact_matrices()``` ReferencesPrem, K., van Zandvoort, K., Klepac, P. et al (2017). Projecting contact matrices in 177 geographical regions: an update and comparison with empirical data for the COVID-19 era. medRxiv 2020.07.22.20159772; doi: https://doi.org/10.1101/2020.07.22.20159772",11
Bernadette,plot_posterior_transmrate.md,"# Plot the estimated age-specific transmission rate

```r
plot_posterior_transmrate(object, xlab = NULL, ylab = NULL, ...)
```

## Arguments

- `object`: A dataframe from `posterior_transmrate`.
- `xlab`: character; Title of x-axis.
- `ylab`: character; Title of y-axis.
- `...`: Optional arguments passed to `scale_x_date`.

## Returns

A `ggplot` object which can be further customised using the `ggplot2` package.

## Description

Plot the estimated age-specific transmission rate

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_transmrate_summary <- posterior_transmrate(object = igbm_fit,
                                                y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the age-specific transmission rate:
plot_posterior_transmrate(post_transmrate_summary)
```

## See Also

`posterior_transmrate`.



","['Plot the estimated age-specific transmission rate```rplot_posterior_transmrate(object, xlab = NULL, ylab = NULL, ...)``` Arguments- `object`: A dataframe from `posterior_transmrate`.- `xlab`: character; Title of x-axis.- `ylab`: character; Title of y-axis.- `...`: Optional arguments passed to `scale_x_date`.', 'ReturnsA `ggplot` object which can be further customised using the `ggplot2` package.', 'DescriptionPlot the estimated age-specific transmission rate Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_transmrate_summary <- posterior_transmrate(object = igbm_fit,                                                y_data = age_specific_mortality_counts) Visualise the posterior distribution of the age-specific transmission rate:plot_posterior_transmrate(post_transmrate_summary)``` See Also`posterior_transmrate`.']",1," Plot the estimated age-specific transmission rate```rplot_posterior_transmrate(object, xlab = NULL, ylab = NULL, ...)``` Arguments- `object`: A dataframe from `posterior_transmrate`.- `xlab`: character; Title of x-axis.- `ylab`: character; Title of y-axis.- `...`: Optional arguments passed to `scale_x_date`. ReturnsA `ggplot` object which can be further customised using the `ggplot2` package. DescriptionPlot the estimated age-specific transmission rate Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_transmrate_summary <- posterior_transmrate(object = igbm_fit,                                                y_data = age_specific_mortality_counts) Visualise the posterior distribution of the age-specific transmission rate:plot_posterior_transmrate(post_transmrate_summary)``` See Also`posterior_transmrate`.",11
Bernadette,age_specific_cusum_infection_counts.md," data

# Age distribution of cumulative reported infections for Greece

## Format

A data frame with 210 rows and 5 variables:

- **Date**: Date, format; date in the format ""2020-08-31""
- **Total_Cases**: numeric; count of total cumulative reported infections on a given date
- **0-39**: numeric; count of cumulative reported infections on a given date for the age group ""0-39""
- **40-64**: numeric; count of cumulative reported infections on a given date for the age group ""40-64""
- **65+**: numeric; count of cumulative reported infections on a given date for the age group ""65+""

## Source

[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)

```r
data(age_specific_cusum_infection_counts)
```

## Returns

A data.frame object with 210 rows and 5 variables.

## Description

A dataset containing the age distribution of cumulative reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database.

## References

 Sandbird (2022). Daily regional statistics for covid19 cases in Greece.



","['data Age distribution of cumulative reported infections for Greece FormatA data frame with 210 rows and 5 variables:- Date: Date, format; date in the format ""2020-08-31""- Total_Cases: numeric; count of total cumulative reported infections on a given date- 0-39: numeric; count of cumulative reported infections on a given date for the age group ""0-39""- 40-64: numeric; count of cumulative reported infections on a given date for the age group ""40-64""- 65+: numeric; count of cumulative reported infections on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_cusum_infection_counts)``` ReturnsA data.frame object with 210 rows and 5 variables.', 'DescriptionA dataset containing the age distribution of cumulative reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks).', 'The dataset has been extracted from the Hellenic National Public Health Organization database.', 'Daily regional statistics for covid19 cases in Greece.']",1," data Age distribution of cumulative reported infections for Greece FormatA data frame with 210 rows and 5 variables:- Date: Date, format; date in the format ""2020-08-31""- Total_Cases: numeric; count of total cumulative reported infections on a given date- 0-39: numeric; count of cumulative reported infections on a given date for the age group ""0-39""- 40-64: numeric; count of cumulative reported infections on a given date for the age group ""40-64""- 65+: numeric; count of cumulative reported infections on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_cusum_infection_counts)``` ReturnsA data.frame object with 210 rows and 5 variables. DescriptionA dataset containing the age distribution of cumulative reported infections in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database. References Sandbird (2022). Daily regional statistics for covid19 cases in Greece.",11
Bernadette,posterior_mortality.md,"# Summarize the posterior distribution of the mortality counts

```r
posterior_mortality(object, y_data)
```

## Arguments

- `object`: An object of class `stanigbm`. See `stan_igbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.

## Returns

#' A named list with elements `Age_specific` and `Aggregated` which can be visualised using `plot_posterior_mortality`.

## Description

Summarize the posterior distribution of the mortality counts

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_mortality_summary <- posterior_mortality(object = igbm_fit,
                                              y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the mortality counts:
plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")
plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")
```

## References

Bouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)



","['Summarize the posterior distribution of the mortality counts```rposterior_mortality(object, y_data)``` Arguments- `object`: An object of class `stanigbm`.', 'See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time.', ""Returns' A named list with elements `Age_specific` and `Aggregated` which can be visualised using `plot_posterior_mortality`."", 'DescriptionSummarize the posterior distribution of the mortality counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_mortality_summary <- posterior_mortality(object = igbm_fit,                                              y_data = age_specific_mortality_counts) Visualise the posterior distribution of the mortality counts:plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I.', 'Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19.']",1," Summarize the posterior distribution of the mortality counts```rposterior_mortality(object, y_data)``` Arguments- `object`: An object of class `stanigbm`. See `stan_igbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`. Returns' A named list with elements `Age_specific` and `Aggregated` which can be visualised using `plot_posterior_mortality`. DescriptionSummarize the posterior distribution of the mortality counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_mortality_summary <- posterior_mortality(object = igbm_fit,                                              y_data = age_specific_mortality_counts) Visualise the posterior distribution of the mortality counts:plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")``` ReferencesBouranis, L., Demiris, N. Kalogeropoulos, K. and Ntzoufras, I. (2022). Bayesian analysis of diffusion-driven multi-type epidemic models with application to COVID-19. arXiv: [https://arxiv.org/abs/2211.15229](https://arxiv.org/abs/2211.15229)",12
Bernadette,aggregate_ifr_react.md,"# Aggregate the Infection Fatality Ratio

```r
aggregate_ifr_react(x, user_AgeGrp, data_cases)
```

## Arguments

- `x`: data.frame; an age distribution matrix. See age_distribution .
- `user_AgeGrp`: vector; a user-defined vector which maps the four age groups considered in REACT-2 to a new set of age groups.
- `data_cases`: data.frame; time series dataset containing the age-stratified infection counts. See age_specific_infection_counts .

## Returns

A list of two data frames that contains the aggregated IFR estimates.

## Description

Function to aggregate the age-specific Infection Fatality Ratio (IFR) estimates reported by the REACT-2 large-scale community study of SARS-CoV-2 seroprevalence in England according to user-defined age groups.

## Examples

```r
# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

age_mapping <- c(rep(""0-39"",  8),
                 rep(""40-64"", 5),
                 rep(""65+"",   3))

data(age_specific_infection_counts)

# Aggregate the IFR:
aggr_age_ifr <- aggregate_ifr_react(age_distr, age_mapping, age_specific_infection_counts)
```

## References

Ward, H., Atchison, C., Whitaker, M. et al. (2021). SARS-CoV-2 antibody prevalence in England following the first peak of the pandemic. Nature Communications 12, 905



","['Aggregate the Infection Fatality Ratio```raggregate_ifr_react(x, user_AgeGrp, data_cases)``` Arguments- `x`: data.frame; an age distribution matrix.', 'See age_distribution .- `user_AgeGrp`: vector; a user-defined vector which maps the four age groups considered in REACT-2 to a new set of age groups.- `data_cases`: data.frame; time series dataset containing the age-stratified infection counts.', 'ReturnsA list of two data frames that contains the aggregated IFR estimates.', 'DescriptionFunction to aggregate the age-specific Infection Fatality Ratio (IFR) estimates reported by the REACT-2 large-scale community study of SARS-CoV-2 seroprevalence in England according to user-defined age groups.', 'Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)age_mapping <- c(rep(""0-39"",  8),                 rep(""40-64"", 5),                 rep(""65+"",   3))data(age_specific_infection_counts) Aggregate the IFR:aggr_age_ifr <- aggregate_ifr_react(age_distr, age_mapping, age_specific_infection_counts)``` ReferencesWard, H., Atchison, C., Whitaker, M. et al.', 'SARS-CoV-2 antibody prevalence in England following the first peak of the pandemic.']",1," Aggregate the Infection Fatality Ratio```raggregate_ifr_react(x, user_AgeGrp, data_cases)``` Arguments- `x`: data.frame; an age distribution matrix. See age_distribution .- `user_AgeGrp`: vector; a user-defined vector which maps the four age groups considered in REACT-2 to a new set of age groups.- `data_cases`: data.frame; time series dataset containing the age-stratified infection counts. See age_specific_infection_counts . ReturnsA list of two data frames that contains the aggregated IFR estimates. DescriptionFunction to aggregate the age-specific Infection Fatality Ratio (IFR) estimates reported by the REACT-2 large-scale community study of SARS-CoV-2 seroprevalence in England according to user-defined age groups. Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)age_mapping <- c(rep(""0-39"",  8),                 rep(""40-64"", 5),                 rep(""65+"",   3))data(age_specific_infection_counts) Aggregate the IFR:aggr_age_ifr <- aggregate_ifr_react(age_distr, age_mapping, age_specific_infection_counts)``` ReferencesWard, H., Atchison, C., Whitaker, M. et al. (2021). SARS-CoV-2 antibody prevalence in England following the first peak of the pandemic. Nature Communications 12, 905",12
Bernadette,age_specific_mortality_counts.md," data

# Age distribution of new reported deaths for Greece

## Format

A data frame with 210 rows and 8 variables:

- **Index**: integer; a sequence of integer numbers from 1 to 210
- **Right**: numeric; Index + 1
- **Date**: Date, format; date in the format ""2020-08-31""
- **Week_ID**: numeric; index of the week that each day falls into. A week is assumed to have 7 days
- **New_Deaths**: numeric; count of new total reported deaths on a given date
- **0-39**: numeric; count of new reported deaths on a given date for the age group ""0-39""
- **40-64**: numeric; count of new reported deaths on a given date for the age group ""40-64""
- **65+**: numeric; count of new reported deaths on a given date for the age group ""65+""

## Source

[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)

```r
data(age_specific_mortality_counts)
```

## Returns

A data.frame object with 210 rows and 8 variables.

## Description

A dataset containing the age distribution of reported deaths in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database.

## References

 Sandbird (2022). Daily regional statistics for covid19 cases in Greece.



","['data Age distribution of new reported deaths for Greece FormatA data frame with 210 rows and 8 variables:- Index: integer; a sequence of integer numbers from 1 to 210- Right: numeric; Index + 1- Date: Date, format; date in the format ""2020-08-31""- Week_ID: numeric; index of the week that each day falls into.', 'A week is assumed to have 7 days- New_Deaths: numeric; count of new total reported deaths on a given date- 0-39: numeric; count of new reported deaths on a given date for the age group ""0-39""- 40-64: numeric; count of new reported deaths on a given date for the age group ""40-64""- 65+: numeric; count of new reported deaths on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_mortality_counts)``` ReturnsA data.frame object with 210 rows and 8 variables.', 'DescriptionA dataset containing the age distribution of reported deaths in Greece from 2020-08-31 to 2021-03-28 (30 weeks).', 'The dataset has been extracted from the Hellenic National Public Health Organization database.', 'Daily regional statistics for covid19 cases in Greece.']",1," data Age distribution of new reported deaths for Greece FormatA data frame with 210 rows and 8 variables:- Index: integer; a sequence of integer numbers from 1 to 210- Right: numeric; Index + 1- Date: Date, format; date in the format ""2020-08-31""- Week_ID: numeric; index of the week that each day falls into. A week is assumed to have 7 days- New_Deaths: numeric; count of new total reported deaths on a given date- 0-39: numeric; count of new reported deaths on a given date for the age group ""0-39""- 40-64: numeric; count of new reported deaths on a given date for the age group ""40-64""- 65+: numeric; count of new reported deaths on a given date for the age group ""65+"" Source[https://github.com/Sandbird/covid19-Greece/](https://github.com/Sandbird/covid19-Greece/)```rdata(age_specific_mortality_counts)``` ReturnsA data.frame object with 210 rows and 8 variables. DescriptionA dataset containing the age distribution of reported deaths in Greece from 2020-08-31 to 2021-03-28 (30 weeks). The dataset has been extracted from the Hellenic National Public Health Organization database. References Sandbird (2022). Daily regional statistics for covid19 cases in Greece.",12
Bernadette,plot_posterior_mortality.md,"# Plot the posterior distribution of the mortality counts

```r
plot_posterior_mortality(
  object,
  type = c(""age-specific"", ""aggregated""),
  xlab = NULL,
  ylab = NULL,
  ...
)
```

## Arguments

- `object`: A dataframe from `posterior_mortality`.
- `type`: character; Plot the output for the 'age-specific' mortality counts or the 'aggregated' mortality counts.
- `xlab`: character; title of x-axis.
- `ylab`: character; title of y-axis.
- `...`: Optional arguments passed to `scale_x_date`.

## Returns

A `ggplot` object which can be further customised using the `ggplot2` package.

## Description

Plot the posterior distribution of the mortality counts

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

post_mortality_summary <- posterior_mortality(object = igbm_fit,
                                              y_data = age_specific_mortality_counts)

# Visualise the posterior distribution of the mortality counts:
plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")
plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")
```

## See Also

`posterior_mortality`.



","['Plot the posterior distribution of the mortality counts```rplot_posterior_mortality(  object,  type = c(""age-specific"", ""aggregated""),  xlab = NULL,  ylab = NULL,  ...)``` Arguments- `object`: A dataframe from `posterior_mortality`.- `type`: character; Plot the output for the \'age-specific\' mortality counts or the \'aggregated\' mortality counts.- `xlab`: character; title of x-axis.- `ylab`: character; title of y-axis.- `...`: Optional arguments passed to `scale_x_date`.', 'ReturnsA `ggplot` object which can be further customised using the `ggplot2` package.', 'DescriptionPlot the posterior distribution of the mortality counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_mortality_summary <- posterior_mortality(object = igbm_fit,                                              y_data = age_specific_mortality_counts) Visualise the posterior distribution of the mortality counts:plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")``` See Also`posterior_mortality`.']",1," Plot the posterior distribution of the mortality counts```rplot_posterior_mortality(  object,  type = c(""age-specific"", ""aggregated""),  xlab = NULL,  ylab = NULL,  ...)``` Arguments- `object`: A dataframe from `posterior_mortality`.- `type`: character; Plot the output for the 'age-specific' mortality counts or the 'aggregated' mortality counts.- `xlab`: character; title of x-axis.- `ylab`: character; title of y-axis.- `...`: Optional arguments passed to `scale_x_date`. ReturnsA `ggplot` object which can be further customised using the `ggplot2` package. DescriptionPlot the posterior distribution of the mortality counts Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1)post_mortality_summary <- posterior_mortality(object = igbm_fit,                                              y_data = age_specific_mortality_counts) Visualise the posterior distribution of the mortality counts:plot_posterior_mortality(post_mortality_summary, type = ""age-specific"")plot_posterior_mortality(post_mortality_summary, type = ""aggregated"")``` See Also`posterior_mortality`.",12
Bernadette,plot_age_distribution.md,"# Bar plot of the age distribution

```r
plot_age_distribution(x)
```

## Arguments

- `x`: data.frame; the age distribution matrix. See age_distribution and aggregate_age_distribution .

## Returns

A ggplot object that can be further customized using the `ggplot2` package.

## Description

Bar plot of the age distribution

## Examples

```r
# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

plot_age_distribution(age_distr)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                           Mapping = c(rep(""0-39"",  8),
                                       rep(""40-64"", 5),
                                       rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Plot the aggregated age distribution matrix:
plot_age_distribution(aggr_age)
```

## References

United Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.



","['Bar plot of the age distribution```rplot_age_distribution(x)``` Arguments- `x`: data.frame; the age distribution matrix.', 'See age_distribution and aggregate_age_distribution .', 'ReturnsA ggplot object that can be further customized using the `ggplot2` package.', 'DescriptionBar plot of the age distribution Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)plot_age_distribution(age_distr) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Plot the aggregated age distribution matrix:plot_age_distribution(aggr_age)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019).', 'World Population Prospects 2019, Online Edition.']",1," Bar plot of the age distribution```rplot_age_distribution(x)``` Arguments- `x`: data.frame; the age distribution matrix. See age_distribution and aggregate_age_distribution . ReturnsA ggplot object that can be further customized using the `ggplot2` package. DescriptionBar plot of the age distribution Examples```r Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020)plot_age_distribution(age_distr) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                           Mapping = c(rep(""0-39"",  8),                                       rep(""40-64"", 5),                                       rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Plot the aggregated age distribution matrix:plot_age_distribution(aggr_age)``` ReferencesUnited Nations, Department of Economic and Social Affairs, Population Division (2019). World Population Prospects 2019, Online Edition. Rev. 1.",12
Bernadette,summary.stanigbm.md,"# Summary of stanigbm posterior output

```r
## S3 method for class 'stanigbm'
summary(object, y_data, ...)
```

## Arguments

- `object`: An `R` object of class `stanigbm`.
- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.
- `...`: Additional arguments, to be passed to lower-level functions.

## Returns

A named list with elements `summary` and `c_summary`, which contain summaries for for all Markov chains merged and individual chains, respectively. See `stanfit-method-summary`.

## Description

This function summarizes the MCMC output for `stanigbm` objects.

## Examples

```r
# Age-specific mortality/incidence count time series:
data(age_specific_mortality_counts)
data(age_specific_cusum_infection_counts)

# Import the age distribution for Greece in 2020:
age_distr <- age_distribution(country = ""Greece"", year = 2020)

# Lookup table:
lookup_table <- data.frame(Initial = age_distr$AgeGrp,
                          Mapping = c(rep(""0-39"",  8),
                                      rep(""40-64"", 5),
                                      rep(""65+""  , 3)))

# Aggregate the age distribution table:
aggr_age <- aggregate_age_distribution(age_distr, lookup_table)

# Import the projected contact matrix for Greece:
conmat <- contact_matrix(country = ""GRC"")

# Aggregate the contact matrix:
aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age)

# Aggregate the IFR:
ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))

aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts)

# Infection-to-death distribution:
ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),
                         gamma_mean = 24.19231,
                         gamma_cv   = 0.3987261)

# Posterior sampling:

rstan::rstan_options(auto_write = TRUE)
chains <- 1
options(mc.cores = chains)

igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,
                      contact_matrix              = aggr_cm,
                      age_distribution_population = aggr_age,
                      age_specific_ifr            = aggr_age_ifr[[3]],
                      itd_distr                   = ditd,
                      incubation_period           = 3,
                      infectious_period           = 4,
                      likelihood_variance_type    = ""linear"",
                      ecr_changes                 = 7,
                      prior_scale_x0              = 1,
                      prior_scale_x1              = 1,
                      prior_scale_contactmatrix   = 0.05,
                      pi_perc                     = 0.1,
                      prior_volatility            = normal(location = 0, scale = 1),
                      prior_nb_dispersion         = exponential(rate = 1/5),
                      algorithm_inference         = ""sampling"",
                      nBurn                       = 10,
                      nPost                       = 30,
                      nThin                       = 1,
                      chains                      = chains,
                      adapt_delta                 = 0.6,
                      max_treedepth               = 14,
                      seed                        = 1)

# print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary
```



","[""Summary of stanigbm posterior output```r S3 method for class 'stanigbm'summary(object, y_data, ...)``` Arguments- `object`: An `R` object of class `stanigbm`.- `y_data`: data.frame; age-specific mortality counts in time."", 'See `data(age_specific_mortality_counts)`.- `...`: Additional arguments, to be passed to lower-level functions.', 'ReturnsA named list with elements `summary` and `c_summary`, which contain summaries for for all Markov chains merged and individual chains, respectively.', 'DescriptionThis function summarizes the MCMC output for `stanigbm` objects.', 'Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary```']",1," Summary of stanigbm posterior output```r S3 method for class 'stanigbm'summary(object, y_data, ...)``` Arguments- `object`: An `R` object of class `stanigbm`.- `y_data`: data.frame; age-specific mortality counts in time. See `data(age_specific_mortality_counts)`.- `...`: Additional arguments, to be passed to lower-level functions. ReturnsA named list with elements `summary` and `c_summary`, which contain summaries for for all Markov chains merged and individual chains, respectively. See `stanfit-method-summary`. DescriptionThis function summarizes the MCMC output for `stanigbm` objects. Examples```r Age-specific mortality/incidence count time series:data(age_specific_mortality_counts)data(age_specific_cusum_infection_counts) Import the age distribution for Greece in 2020:age_distr <- age_distribution(country = ""Greece"", year = 2020) Lookup table:lookup_table <- data.frame(Initial = age_distr$AgeGrp,                          Mapping = c(rep(""0-39"",  8),                                      rep(""40-64"", 5),                                      rep(""65+""  , 3))) Aggregate the age distribution table:aggr_age <- aggregate_age_distribution(age_distr, lookup_table) Import the projected contact matrix for Greece:conmat <- contact_matrix(country = ""GRC"") Aggregate the contact matrix:aggr_cm <- aggregate_contact_matrix(conmat, lookup_table, aggr_age) Aggregate the IFR:ifr_mapping <- c(rep(""0-39"", 8), rep(""40-64"", 5), rep(""65+"", 3))aggr_age_ifr <- aggregate_ifr_react(age_distr, ifr_mapping, age_specific_cusum_infection_counts) Infection-to-death distribution:ditd <- itd_distribution(ts_length  = nrow(age_specific_mortality_counts),                         gamma_mean = 24.19231,                         gamma_cv   = 0.3987261) Posterior sampling:rstan::rstan_options(auto_write = TRUE)chains <- 1options(mc.cores = chains)igbm_fit <- stan_igbm(y_data                      = age_specific_mortality_counts,                      contact_matrix              = aggr_cm,                      age_distribution_population = aggr_age,                      age_specific_ifr            = aggr_age_ifr[[3]],                      itd_distr                   = ditd,                      incubation_period           = 3,                      infectious_period           = 4,                      likelihood_variance_type    = ""linear"",                      ecr_changes                 = 7,                      prior_scale_x0              = 1,                      prior_scale_x1              = 1,                      prior_scale_contactmatrix   = 0.05,                      pi_perc                     = 0.1,                      prior_volatility            = normal(location = 0, scale = 1),                      prior_nb_dispersion         = exponential(rate = 1/5),                      algorithm_inference         = ""sampling"",                      nBurn                       = 10,                      nPost                       = 30,                      nThin                       = 1,                      chains                      = chains,                      adapt_delta                 = 0.6,                      max_treedepth               = 14,                      seed                        = 1) print_summary <- summary(object = igbm_fit, y_data = age_specific_mortality_counts)$summary```",12
Bernadette,Bernadette.md,"---
title: ""Bernadette""
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bernadette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ""#>""
)
```

```{r setup}
library(Bernadette)
```

","['---title: ""Bernadette""output: rmarkdown::html_vignettevignette: >  %\\VignetteIndexEntry{Bernadette}  %\\VignetteEngine{knitr::rmarkdown}  %\\VignetteEncoding{UTF-8}---```{r, include = FALSE}knitr::opts_chunk$set(  collapse = TRUE,  comment = "">"")``````{r setup}library(Bernadette)```']",1,"---title: ""Bernadette""output: rmarkdown::html_vignettevignette: >  %\VignetteIndexEntry{Bernadette}  %\VignetteEngine{knitr::rmarkdown}  %\VignetteEncoding{UTF-8}---```{r, include = FALSE}knitr::opts_chunk$set(  collapse = TRUE,  comment = "">"")``````{r setup}library(Bernadette)```",12
adegenet,read.PLINK.md,"# Reading PLINK Single Nucleotide Polymorphism data

```r
extract.PLINKmap(file, x = NULL)

read.PLINK(
  file,
  map.file = NULL,
  quiet = FALSE,
  chunkSize = 1000,
  parallel = FALSE,
  n.cores = NULL,
  ...
)
```

## Arguments

- `file`: for `read.PLINK` a character string giving the path to the file to convert, with the extension "".raw""; for `extract.PLINKmap`, a character string giving the path to a file with extension "".map"".
- `x`: an optional object of the class `""genlight""`, in which the information read is stored; if provided, information is matched against the names of the loci in `x`, as returned by `locNames(x)`; if not provided, a list of two components is returned, containing chromosome and position information.
- `map.file`: an optional character string indicating the path to a "".map"" file, which contains information about the SNPs (chromosome, position). If provided, this information is processed by `extract.PLINKmap` and stored in the `@other` slot.
- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).
- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.
- ``...``: other arguments to be passed to other functions - currently not used.

## Returns

- read.PLINK: an object of the class `""genlight""`

- extract.PLINKmap: if a `""genlight""` is provided as argument `x`, this object incorporating the new information about SNPs in the `@other` slot (with new components 'chromosome' and 'position'); otherwise, a list with two components containing chromosome and position information.

## Description

The function `read.PLINK` reads a data file exported by the PLINK software with extension '.raw' and converts it into a `""genlight""` object. Optionally, information about SNPs can be read from a "".map"" file, either by specifying the argument `map.file` in `read.PLINK`, or using `extract.PLINKmap` to add information to an existing `""genlight""` object.

## Details

The function reads data by chunks of several genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.

See details for the documentation about how to export data using PLINK to the '.raw' format.

=== Exporting data from PLINK ===

Data need to be exported from PLINK using the option ""--recodeA"" (and NOT ""--recodeAD""). The PLINK command should therefore look like: `plink --file data --recodeA`. For more information on this topic, please look at this webpage: [http://zzz.bwh.harvard.edu/plink/](http://zzz.bwh.harvard.edu/plink/)

## See Also

- `?genlight` for a description of the class `""genlight""`.

- `read.snp`: read SNPs in adegenet's '.snp' format.

- `fasta2genlight`: extract SNPs from alignments with fasta format.

- other import function in adegenet: `import2genind`, `df2genind`, `read.genetix` `read.fstat`, `read.structure`, `read.genepop`.

- another function `read.plink` is available in the package `snpMatrix`.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading PLINK Single Nucleotide Polymorphism data```rextract.PLINKmap(file, x = NULL)read.PLINK(  file,  map.file = NULL,  quiet = FALSE,  chunkSize = 1000,  parallel = FALSE,  n.cores = NULL,  ...)``` Arguments- `file`: for `read.PLINK` a character string giving the path to the file to convert, with the extension "".raw""; for `extract.PLINKmap`, a character string giving the path to a file with extension "".map"".- `x`: an optional object of the class `""genlight""`, in which the information read is stored; if provided, information is matched against the names of the loci in `x`, as returned by `locNames(x)`; if not provided, a list of two components is returned, containing chromosome and position information.- `map.file`: an optional character string indicating the path to a "".map"" file, which contains information about the SNPs (chromosome, position).', 'If provided, this information is processed by `extract.PLINKmap` and stored in the `@other` slot.- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used.', 'Returns- read.PLINK: an object of the class `""genlight""`- extract.PLINKmap: if a `""genlight""` is provided as argument `x`, this object incorporating the new information about SNPs in the `@other` slot (with new components \'chromosome\' and \'position\'); otherwise, a list with two components containing chromosome and position information.', 'DescriptionThe function `read.PLINK` reads a data file exported by the PLINK software with extension \'.raw\' and converts it into a `""genlight""` object.', 'Optionally, information about SNPs can be read from a "".map"" file, either by specifying the argument `map.file` in `read.PLINK`, or using `extract.PLINKmap` to add information to an existing `""genlight""` object.', 'DetailsThe function reads data by chunks of several genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time).', 'The argument `chunkSize` indicates the number of genomes read at a time.', 'Increasing this value decreases the computational time required to read data in, while increasing memory requirements.See details for the documentation about how to export data using PLINK to the \'.raw\' format.=== Exporting data from PLINK ===Data need to be exported from PLINK using the option ""--recodeA"" (and NOT ""--recodeAD"").', 'The PLINK command should therefore look like: `plink --file data --recodeA`.', 'For more information on this topic, please look at this webpage: [http://zzz.bwh.harvard.edu/plink/](http://zzz.bwh.harvard.edu/plink/) See Also- `?genlight` for a description of the class `""genlight""`.- `read.snp`: read SNPs in adegenet\'s \'.snp\' format.- `fasta2genlight`: extract SNPs from alignments with fasta format.- other import function in adegenet: `import2genind`, `df2genind`, `read.genetix` `read.fstat`, `read.structure`, `read.genepop`.- another function `read.plink` is available in the package `snpMatrix`.']",1," Reading PLINK Single Nucleotide Polymorphism data```rextract.PLINKmap(file, x = NULL)read.PLINK(  file,  map.file = NULL,  quiet = FALSE,  chunkSize = 1000,  parallel = FALSE,  n.cores = NULL,  ...)``` Arguments- `file`: for `read.PLINK` a character string giving the path to the file to convert, with the extension "".raw""; for `extract.PLINKmap`, a character string giving the path to a file with extension "".map"".- `x`: an optional object of the class `""genlight""`, in which the information read is stored; if provided, information is matched against the names of the loci in `x`, as returned by `locNames(x)`; if not provided, a list of two components is returned, containing chromosome and position information.- `map.file`: an optional character string indicating the path to a "".map"" file, which contains information about the SNPs (chromosome, position). If provided, this information is processed by `extract.PLINKmap` and stored in the `@other` slot.- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used. Returns- read.PLINK: an object of the class `""genlight""`- extract.PLINKmap: if a `""genlight""` is provided as argument `x`, this object incorporating the new information about SNPs in the `@other` slot (with new components 'chromosome' and 'position'); otherwise, a list with two components containing chromosome and position information. DescriptionThe function `read.PLINK` reads a data file exported by the PLINK software with extension '.raw' and converts it into a `""genlight""` object. Optionally, information about SNPs can be read from a "".map"" file, either by specifying the argument `map.file` in `read.PLINK`, or using `extract.PLINKmap` to add information to an existing `""genlight""` object. DetailsThe function reads data by chunks of several genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.See details for the documentation about how to export data using PLINK to the '.raw' format.=== Exporting data from PLINK ===Data need to be exported from PLINK using the option ""--recodeA"" (and NOT ""--recodeAD""). The PLINK command should therefore look like: `plink --file data --recodeA`. For more information on this topic, please look at this webpage: [http://zzz.bwh.harvard.edu/plink/](http://zzz.bwh.harvard.edu/plink/) See Also- `?genlight` for a description of the class `""genlight""`.- `read.snp`: read SNPs in adegenet's '.snp' format.- `fasta2genlight`: extract SNPs from alignments with fasta format.- other import function in adegenet: `import2genind`, `df2genind`, `read.genetix` `read.fstat`, `read.structure`, `read.genepop`.- another function `read.plink` is available in the package `snpMatrix`. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,import2genind.md,"# Importing data from several softwares to a genind object

```r
import2genind(file, quiet = FALSE, ...)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the appropriate extension.
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).
- ``...``: other arguments passed to the appropriate 'read' function (currently passed to `read.structure`)

## Returns

an object of the class `genind`

## Description

Their are several ways to import genotype data to a genind

object: i) from a data.frame with a given format (see `df2genind`), ii) from a file with a recognized extension, or iii) from an alignement of sequences (see `DNAbin2genind`).

## Details

The function `import2genind` detects the extension of the file given in argument and seeks for an appropriate import function to create a `genind` object.

Current recognized formats are :

- GENETIX files (.gtx)

- Genepop files (.gen)

- Fstat files (.dat)

- STRUCTURE files (.str or .stru)

Beware: same data in different formats are not expected to produce exactly the same `genind` objects.

For instance, conversions made by GENETIX to Fstat may change the the sorting of the genotypes; GENETIX stores individual names whereas Fstat does not; Genepop chooses a sample's name from the name of its last genotype; etc.

## Examples

```r
import2genind(system.file(""files/nancycats.gtx"",
package=""adegenet""))

import2genind(system.file(""files/nancycats.dat"",
package=""adegenet""))

import2genind(system.file(""files/nancycats.gen"",
package=""adegenet""))

import2genind(system.file(""files/nancycats.str"",
package=""adegenet""), onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)
```

## References

Belkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France).

Pritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data. **Genetics**, 155 : 945-959

Raymond M. & Rousset F, (1995). GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism. **J. Heredity**, 86 :248-249

Fstat (version 2.9.3). Software by Jerome Goudet. http://www2.unil.ch/popgen/softwares/fstat.htm

Excoffier L. & Heckel G.(2006) Computer programs for population genetics data analysis: a survival guide **Nature**, 7 : 745-758

## See Also

`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","[""Importing data from several softwares to a genind object```rimport2genind(file, quiet = FALSE, ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- ``...``: other arguments passed to the appropriate 'read' function (currently passed to `read.structure`) Returnsan object of the class `genind` DescriptionTheir are several ways to import genotype data to a genindobject: i) from a data.frame with a given format (see `df2genind`), ii) from a file with a recognized extension, or iii) from an alignement of sequences (see `DNAbin2genind`)."", ""DetailsThe function `import2genind` detects the extension of the file given in argument and seeks for an appropriate import function to create a `genind` object.Current recognized formats are :- GENETIX files (.gtx)- Genepop files (.gen)- Fstat files (.dat)- STRUCTURE files (.str or .stru)Beware: same data in different formats are not expected to produce exactly the same `genind` objects.For instance, conversions made by GENETIX to Fstat may change the the sorting of the genotypes; GENETIX stores individual names whereas Fstat does not; Genepop chooses a sample's name from the name of its last genotype; etc."", 'Examples```rimport2genind(system.file(""files/nancycats.gtx"",package=""adegenet""))import2genind(system.file(""files/nancycats.dat"",package=""adegenet""))import2genind(system.file(""files/nancycats.gen"",package=""adegenet""))import2genind(system.file(""files/nancycats.str"",package=""adegenet""), onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)``` ReferencesBelkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations.', 'Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France).Pritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data.', 'Genetics, 155 : 945-959Raymond M. & Rousset F, (1995).', 'GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism.', 'J. Heredity, 86 :248-249Fstat (version 2.9.3).', 'http://www2.unil.ch/popgen/softwares/fstat.htmExcoffier L. & Heckel G.(2006) Computer programs for population genetics data analysis: a survival guide Nature, 7 : 745-758 See Also`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Importing data from several softwares to a genind object```rimport2genind(file, quiet = FALSE, ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- ``...``: other arguments passed to the appropriate 'read' function (currently passed to `read.structure`) Returnsan object of the class `genind` DescriptionTheir are several ways to import genotype data to a genindobject: i) from a data.frame with a given format (see `df2genind`), ii) from a file with a recognized extension, or iii) from an alignement of sequences (see `DNAbin2genind`). DetailsThe function `import2genind` detects the extension of the file given in argument and seeks for an appropriate import function to create a `genind` object.Current recognized formats are :- GENETIX files (.gtx)- Genepop files (.gen)- Fstat files (.dat)- STRUCTURE files (.str or .stru)Beware: same data in different formats are not expected to produce exactly the same `genind` objects.For instance, conversions made by GENETIX to Fstat may change the the sorting of the genotypes; GENETIX stores individual names whereas Fstat does not; Genepop chooses a sample's name from the name of its last genotype; etc. Examples```rimport2genind(system.file(""files/nancycats.gtx"",package=""adegenet""))import2genind(system.file(""files/nancycats.dat"",package=""adegenet""))import2genind(system.file(""files/nancycats.gen"",package=""adegenet""))import2genind(system.file(""files/nancycats.str"",package=""adegenet""), onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)``` ReferencesBelkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France).Pritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data. Genetics, 155 : 945-959Raymond M. & Rousset F, (1995). GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism. J. Heredity, 86 :248-249Fstat (version 2.9.3). Software by Jerome Goudet. http://www2.unil.ch/popgen/softwares/fstat.htmExcoffier L. & Heckel G.(2006) Computer programs for population genetics data analysis: a survival guide Nature, 7 : 745-758 See Also`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,dapcIllus.md," data

# Simulated data illustrating the DAPC

## Format

`dapcIllus` is list of 4 components being all genind objects.

## Source

Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to **BMC genetics**.

## Description

Datasets illustrating the Discriminant Analysis of Principal Components (DAPC, Jombart et al. submitted).

## Details

These data were simulated using various models using Easypop (2.0.1). The `dapcIllus` is a list containing the following genind

objects:

- ""a"": island model with 6 populations

- ""b"": hierarchical island model with 6 populations (3,2,1)

- ""c"": one-dimensional stepping stone with 2x6 populations, and a boundary between the two sets of 6 populations

- ""d"": one-dimensional stepping stone with 24 populations

See ""source"" for a reference providing simulation details.

## Examples

```r
## Not run:


data(dapcIllus)
attach(dapcIllus)
a # this is a genind object, like b, c, and d.


## FINS CLUSTERS EX NIHILO
clust.a <- find.clusters(a, n.pca=100, n.clust=6)
clust.b <- find.clusters(b, n.pca=100, n.clust=6)
clust.c <- find.clusters(c, n.pca=100, n.clust=12)
clust.d <- find.clusters(d, n.pca=100, n.clust=24)

## examin outputs
names(clust.a)
lapply(clust.a, head)


## PERFORM DAPCs
dapc.a <- dapc(a, pop=clust.a$grp, n.pca=100, n.da=5)
dapc.b <- dapc(b, pop=clust.b$grp, n.pca=100, n.da=5)
dapc.c <- dapc(c, pop=clust.c$grp, n.pca=100, n.da=11)
dapc.d <- dapc(d, pop=clust.d$grp, n.pca=100, n.da=23)


## LOOK AT ONE RESULT
dapc.a
summary(dapc.a)

## FORM A LIST OF RESULTS FOR THE 4 DATASETS
lres <- list(dapc.a, dapc.b, dapc.c, dapc.d)


## DRAW 4 SCATTERPLOTS
par(mfrow=c(2,2))
lapply(lres, scatter)


# detach data
detach(dapcIllus)
## End(Not run)
```

## References

Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to **Genetics**.

## See Also

- `dapc`: implements the DAPC.

- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.

- `H3N2`: dataset illustrating the DAPC.

- `find.clusters`: to identify clusters without prior.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['data Simulated data illustrating the DAPC Format`dapcIllus` is list of 4 components being all genind objects.', 'SourceJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'DescriptionDatasets illustrating the Discriminant Analysis of Principal Components (DAPC, Jombart et al.', 'DetailsThese data were simulated using various models using Easypop (2.0.1).', 'The `dapcIllus` is a list containing the following genindobjects:- ""a"": island model with 6 populations- ""b"": hierarchical island model with 6 populations (3,2,1)- ""c"": one-dimensional stepping stone with 2x6 populations, and a boundary between the two sets of 6 populations- ""d"": one-dimensional stepping stone with 24 populationsSee ""source"" for a reference providing simulation details.', 'Examples```r Not run:data(dapcIllus)attach(dapcIllus)a  this is a genind object, like b, c, and d. FINS CLUSTERS EX NIHILOclust.a <- find.clusters(a, n.pca=100, n.clust=6)clust.b <- find.clusters(b, n.pca=100, n.clust=6)clust.c <- find.clusters(c, n.pca=100, n.clust=12)clust.d <- find.clusters(d, n.pca=100, n.clust=24) examin outputsnames(clust.a)lapply(clust.a, head) PERFORM DAPCsdapc.a <- dapc(a, pop=clust.a$grp, n.pca=100, n.da=5)dapc.b <- dapc(b, pop=clust.b$grp, n.pca=100, n.da=5)dapc.c <- dapc(c, pop=clust.c$grp, n.pca=100, n.da=11)dapc.d <- dapc(d, pop=clust.d$grp, n.pca=100, n.da=23) LOOK AT ONE RESULTdapc.asummary(dapc.a) FORM A LIST OF RESULTS FOR THE 4 DATASETSlres <- list(dapc.a, dapc.b, dapc.c, dapc.d) DRAW 4 SCATTERPLOTSpar(mfrow=c(2,2))lapply(lres, scatter) detach datadetach(dapcIllus) End(Not run)``` ReferencesJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'See Also- `dapc`: implements the DAPC.- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.- `H3N2`: dataset illustrating the DAPC.- `find.clusters`: to identify clusters without prior.']",1," data Simulated data illustrating the DAPC Format`dapcIllus` is list of 4 components being all genind objects. SourceJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to BMC genetics. DescriptionDatasets illustrating the Discriminant Analysis of Principal Components (DAPC, Jombart et al. submitted). DetailsThese data were simulated using various models using Easypop (2.0.1). The `dapcIllus` is a list containing the following genindobjects:- ""a"": island model with 6 populations- ""b"": hierarchical island model with 6 populations (3,2,1)- ""c"": one-dimensional stepping stone with 2x6 populations, and a boundary between the two sets of 6 populations- ""d"": one-dimensional stepping stone with 24 populationsSee ""source"" for a reference providing simulation details. Examples```r Not run:data(dapcIllus)attach(dapcIllus)a  this is a genind object, like b, c, and d. FINS CLUSTERS EX NIHILOclust.a <- find.clusters(a, n.pca=100, n.clust=6)clust.b <- find.clusters(b, n.pca=100, n.clust=6)clust.c <- find.clusters(c, n.pca=100, n.clust=12)clust.d <- find.clusters(d, n.pca=100, n.clust=24) examin outputsnames(clust.a)lapply(clust.a, head) PERFORM DAPCsdapc.a <- dapc(a, pop=clust.a$grp, n.pca=100, n.da=5)dapc.b <- dapc(b, pop=clust.b$grp, n.pca=100, n.da=5)dapc.c <- dapc(c, pop=clust.c$grp, n.pca=100, n.da=11)dapc.d <- dapc(d, pop=clust.d$grp, n.pca=100, n.da=23) LOOK AT ONE RESULTdapc.asummary(dapc.a) FORM A LIST OF RESULTS FOR THE 4 DATASETSlres <- list(dapc.a, dapc.b, dapc.c, dapc.d) DRAW 4 SCATTERPLOTSpar(mfrow=c(2,2))lapply(lres, scatter) detach datadetach(dapcIllus) End(Not run)``` ReferencesJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to Genetics. See Also- `dapc`: implements the DAPC.- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.- `H3N2`: dataset illustrating the DAPC.- `find.clusters`: to identify clusters without prior. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,genind2df.md,"# Convert a genind object to a data.frame.

```r
genind2df(x, pop = NULL, sep = """", usepop = TRUE, oneColPerAll = FALSE)
```

## Arguments

- `x`: a genind object
- `pop`: an optional factor giving the population of each individual.
- `sep`: a character string separating alleles. See details.
- `usepop`: a logical stating whether the population (argument `pop` or `x@pop` should be used (TRUE, default) or not (FALSE)).
- `oneColPerAll`: a logical stating whether or not alleles should be split into columns (defaults to `FALSE`). This will only work with data with consistent ploidies.

## Returns

a data.frame of raw allelic data, with individuals in rows and loci in column

## Description

The function `genind2df` converts a genind back to a data.frame of raw allelic data.

## Examples

```r
## simple example
df <- data.frame(locusA=c(""11"",""11"",""12"",""32""),
locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))
row.names(df) <- .genlab(""genotype"",4)
df

obj <- df2genind(df, ploidy=2, ncode=1)
obj
obj@tab


## converting a genind as data.frame
genind2df(obj)
genind2df(obj, sep=""/"")
```

## See Also

`df2genind`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Convert a genind object to a data.frame.```rgenind2df(x, pop = NULL, sep = """", usepop = TRUE, oneColPerAll = FALSE)``` Arguments- `x`: a genind object- `pop`: an optional factor giving the population of each individual.- `sep`: a character string separating alleles.', 'See details.- `usepop`: a logical stating whether the population (argument `pop` or `x@pop` should be used (TRUE, default) or not (FALSE)).- `oneColPerAll`: a logical stating whether or not alleles should be split into columns (defaults to `FALSE`).', 'This will only work with data with consistent ploidies.', 'Returnsa data.frame of raw allelic data, with individuals in rows and loci in column DescriptionThe function `genind2df` converts a genind back to a data.frame of raw allelic data.', 'Examples```r simple exampledf <- data.frame(locusA=c(""11"",""11"",""12"",""32""),locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))row.names(df) <- .genlab(""genotype"",4)dfobj <- df2genind(df, ploidy=2, ncode=1)objobj@tab converting a genind as data.framegenind2df(obj)genind2df(obj, sep=""/"")``` See Also`df2genind`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Convert a genind object to a data.frame.```rgenind2df(x, pop = NULL, sep = """", usepop = TRUE, oneColPerAll = FALSE)``` Arguments- `x`: a genind object- `pop`: an optional factor giving the population of each individual.- `sep`: a character string separating alleles. See details.- `usepop`: a logical stating whether the population (argument `pop` or `x@pop` should be used (TRUE, default) or not (FALSE)).- `oneColPerAll`: a logical stating whether or not alleles should be split into columns (defaults to `FALSE`). This will only work with data with consistent ploidies. Returnsa data.frame of raw allelic data, with individuals in rows and loci in column DescriptionThe function `genind2df` converts a genind back to a data.frame of raw allelic data. Examples```r simple exampledf <- data.frame(locusA=c(""11"",""11"",""12"",""32""),locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))row.names(df) <- .genlab(""genotype"",4)dfobj <- df2genind(df, ploidy=2, ncode=1)objobj@tab converting a genind as data.framegenind2df(obj)genind2df(obj, sep=""/"")``` See Also`df2genind`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,strata-methods.md," methods

# Access and manipulate the population strata for genind or genlight objects.

```r
strata(x, formula = NULL, combine = TRUE, value)

strata(x) <- value

nameStrata(x, value)

nameStrata(x) <- value

splitStrata(x, value, sep = ""_"")

splitStrata(x, sep = ""_"") <- value

addStrata(x, value, name = ""NEW"")

addStrata(x, name = ""NEW"") <- value
```

## Arguments

- `x`: a genind or genlight object
- `formula`: a nested formula indicating the order of the population strata.
- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument. If it is `FALSE`, the levels will not be combined.
- `value`: a data frame OR vector OR formula (see details).
- `sep`: a `character` indicating the character used to separate hierarchical levels. This defaults to ""_"".
- `name`: an optional name argument for use with addStrata if supplying a vector. Defaults to ""NEW"".

## Description

The following methods allow the user to quickly change the strata of a genind or genlight object.

## Details

### Function Specifics

 * strata() - Use this function to view or define population stratification of a genind or genlight object.
 * nameStrata() - View or rename the different levels of strata.
 * splitStrata() - Split strata that are combined with a common separator. This function should only be used once during a workflow.
   
    * **Rationale:** It is often difficult to import files with several levels of strata as most data formats do not allow unlimited population levels. This is circumvented by collapsing all population strata into a single population factor with a common separator for each observation.
 * addStrata() - Add levels to your population strata. This is ideal for adding groups defined by `find.clusters`. You can input a data frame or a vector, but if you put in a vector, you have the option to name it.

 

### Argument Specifics

 These functions allow the user to seamlessly carry all possible population stratification with their genind or genlight

object. Note that there are two ways of performing all methods:

 * modifying: `strata(myData) \<- myStrata`
 * preserving: `myNewData \<- strata(myData, value = myStrata)`

They essentially do the same thing except that the modifying assignment method (the one with the ""`<-`"") will modify the object in place whereas the non-assignment method will preserve the original object (unless you overwrite it). Due to convention, everything right of the assignment is termed `value`. To avoid confusion, here is a guide to the argument ‘value’ for each function:

 * strata() `value =`a `data.frame` that defines the strata for each individual in the rows.
 * nameStrata() `value =`a `vector` or a `formula` that will define the names.
 * splitStrata() `value =`a `formula` argument with the same number of levels as the strata you wish to split.
 * addStrata() `value =`a `vector` or `data.frame` with the same length as the number of individuals in your data.

 

### Details on Formulas

 The preferred use of these functions is with a `formula` object. Specifically, a hierarchical formula argument is used to assign the levels of the strata. An example of a hierarchical formula would be:

||
|--:|
|`~Country/City/Neighborhood`|

This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy. Note: it is important to use hiearchical formulas when specifying hierarchies as other types of formulas (eg. `~Country*City*Neighborhood`) will give incorrect results.

## Examples

```r
# let's look at the microbov data set:
data(microbov)
microbov

# We see that we have three vectors of different names in the 'other' slot. 
# ?microbov
# These are Country, Breed, and Species
names(other(microbov))

# Let's set the strata
strata(microbov) <- data.frame(other(microbov))
microbov

# And change the names so we know what they are
nameStrata(microbov) <- ~Country/Breed/Species

## Not run:

# let's see what the strata looks like by Species and Breed:
head(strata(microbov, ~Breed/Species))

# If we didn't want the last column combined with the first, we can set
# combine = FALSE
head(strata(microbov, ~Breed/Species, combine = FALSE))

#### USING splitStrata ####

# For the sake of example, we'll imagine that we have imported our data set
# with all of the stratifications combined. 
setPop(microbov) <- ~Country/Breed/Species
strata(microbov) <- NULL

# This is what our data would look like after import.
microbov

# To set our strata here, we need to use the functions strata and splitStrata
strata(microbov) <- data.frame(x = pop(microbov))
microbov # shows us that we have ""one"" level of stratification
head(strata(microbov)) # all strata are separated by ""_""

splitStrata(microbov) <- ~Country/Breed/Species
microbov # Now we have all of our strata named and split
head(strata(microbov)) # all strata are appropriately named and split.
## End(Not run)
```

## See Also

`setPop` `genind` `as.genind`

## Author(s)

Zhian N. Kamvar



","['methods Access and manipulate the population strata for genind or genlight objects.```rstrata(x, formula = NULL, combine = TRUE, value)strata(x) <- valuenameStrata(x, value)nameStrata(x) <- valuesplitStrata(x, value, sep = ""_"")splitStrata(x, sep = ""_"") <- valueaddStrata(x, value, name = ""NEW"")addStrata(x, name = ""NEW"") <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population strata.- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument.', 'If it is `FALSE`, the levels will not be combined.- `value`: a data frame OR vector OR formula (see details).- `sep`: a `character` indicating the character used to separate hierarchical levels.', 'This defaults to ""_"".- `name`: an optional name argument for use with addStrata if supplying a vector.', 'DescriptionThe following methods allow the user to quickly change the strata of a genind or genlight object.', 'Details Function Specifics  strata() - Use this function to view or define population stratification of a genind or genlight object.', 'nameStrata() - View or rename the different levels of strata.', 'splitStrata() - Split strata that are combined with a common separator.', 'This function should only be used once during a workflow.', 'Rationale: It is often difficult to import files with several levels of strata as most data formats do not allow unlimited population levels.', 'This is circumvented by collapsing all population strata into a single population factor with a common separator for each observation.', 'addStrata() - Add levels to your population strata.', 'This is ideal for adding groups defined by `find.clusters`.', 'You can input a data frame or a vector, but if you put in a vector, you have the option to name it.', 'Argument Specifics These functions allow the user to seamlessly carry all possible population stratification with their genind or genlightobject.', 'Note that there are two ways of performing all methods:  modifying: `strata(myData) \\<- myStrata`  preserving: `myNewData \\<- strata(myData, value = myStrata)`They essentially do the same thing except that the modifying assignment method (the one with the ""`<-`"") will modify the object in place whereas the non-assignment method will preserve the original object (unless you overwrite it).', 'Due to convention, everything right of the assignment is termed `value`.', 'To avoid confusion, here is a guide to the argument ‘value’ for each function:  strata() `value =`a `data.frame` that defines the strata for each individual in the rows.', 'nameStrata() `value =`a `vector` or a `formula` that will define the names.', 'splitStrata() `value =`a `formula` argument with the same number of levels as the strata you wish to split.', 'addStrata() `value =`a `vector` or `data.frame` with the same length as the number of individuals in your data.', 'Details on Formulas The preferred use of these functions is with a `formula` object.', 'Specifically, a hierarchical formula argument is used to assign the levels of the strata.', 'An example of a hierarchical formula would be:|||--:||`~Country/City/Neighborhood`|This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy.', 'Note: it is important to use hiearchical formulas when specifying hierarchies as other types of formulas (eg.', '`~CountryCityNeighborhood`) will give incorrect results.', ""Examples```r let's look at the microbov data set:data(microbov)microbov We see that we have three vectors of different names in the 'other' slot."", ""?microbov These are Country, Breed, and Speciesnames(other(microbov)) Let's set the stratastrata(microbov) <- data.frame(other(microbov))microbov And change the names so we know what they arenameStrata(microbov) <- ~Country/Breed/Species Not run: let's see what the strata looks like by Species and Breed:head(strata(microbov, ~Breed/Species)) If we didn't want the last column combined with the first, we can set combine = FALSEhead(strata(microbov, ~Breed/Species, combine = FALSE)) USING splitStrata  For the sake of example, we'll imagine that we have imported our data set with all of the stratifications combined."", 'setPop(microbov) <- ~Country/Breed/Speciesstrata(microbov) <- NULL This is what our data would look like after import.microbov To set our strata here, we need to use the functions strata and splitStratastrata(microbov) <- data.frame(x = pop(microbov))microbov  shows us that we have ""one"" level of stratificationhead(strata(microbov))  all strata are separated by ""_""splitStrata(microbov) <- ~Country/Breed/Speciesmicrobov  Now we have all of our strata named and splithead(strata(microbov))  all strata are appropriately named and split.', 'End(Not run)``` See Also`setPop` `genind` `as.genind` Author(s)Zhian N. Kamvar']",1," methods Access and manipulate the population strata for genind or genlight objects.```rstrata(x, formula = NULL, combine = TRUE, value)strata(x) <- valuenameStrata(x, value)nameStrata(x) <- valuesplitStrata(x, value, sep = ""_"")splitStrata(x, sep = ""_"") <- valueaddStrata(x, value, name = ""NEW"")addStrata(x, name = ""NEW"") <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population strata.- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument. If it is `FALSE`, the levels will not be combined.- `value`: a data frame OR vector OR formula (see details).- `sep`: a `character` indicating the character used to separate hierarchical levels. This defaults to ""_"".- `name`: an optional name argument for use with addStrata if supplying a vector. Defaults to ""NEW"". DescriptionThe following methods allow the user to quickly change the strata of a genind or genlight object. Details Function Specifics  strata() - Use this function to view or define population stratification of a genind or genlight object.  nameStrata() - View or rename the different levels of strata.  splitStrata() - Split strata that are combined with a common separator. This function should only be used once during a workflow.        Rationale: It is often difficult to import files with several levels of strata as most data formats do not allow unlimited population levels. This is circumvented by collapsing all population strata into a single population factor with a common separator for each observation.  addStrata() - Add levels to your population strata. This is ideal for adding groups defined by `find.clusters`. You can input a data frame or a vector, but if you put in a vector, you have the option to name it.  Argument Specifics These functions allow the user to seamlessly carry all possible population stratification with their genind or genlightobject. Note that there are two ways of performing all methods:  modifying: `strata(myData) \<- myStrata`  preserving: `myNewData \<- strata(myData, value = myStrata)`They essentially do the same thing except that the modifying assignment method (the one with the ""`<-`"") will modify the object in place whereas the non-assignment method will preserve the original object (unless you overwrite it). Due to convention, everything right of the assignment is termed `value`. To avoid confusion, here is a guide to the argument ‘value’ for each function:  strata() `value =`a `data.frame` that defines the strata for each individual in the rows.  nameStrata() `value =`a `vector` or a `formula` that will define the names.  splitStrata() `value =`a `formula` argument with the same number of levels as the strata you wish to split.  addStrata() `value =`a `vector` or `data.frame` with the same length as the number of individuals in your data.  Details on Formulas The preferred use of these functions is with a `formula` object. Specifically, a hierarchical formula argument is used to assign the levels of the strata. An example of a hierarchical formula would be:|||--:||`~Country/City/Neighborhood`|This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy. Note: it is important to use hiearchical formulas when specifying hierarchies as other types of formulas (eg. `~CountryCityNeighborhood`) will give incorrect results. Examples```r let's look at the microbov data set:data(microbov)microbov We see that we have three vectors of different names in the 'other' slot.  ?microbov These are Country, Breed, and Speciesnames(other(microbov)) Let's set the stratastrata(microbov) <- data.frame(other(microbov))microbov And change the names so we know what they arenameStrata(microbov) <- ~Country/Breed/Species Not run: let's see what the strata looks like by Species and Breed:head(strata(microbov, ~Breed/Species)) If we didn't want the last column combined with the first, we can set combine = FALSEhead(strata(microbov, ~Breed/Species, combine = FALSE)) USING splitStrata  For the sake of example, we'll imagine that we have imported our data set with all of the stratifications combined. setPop(microbov) <- ~Country/Breed/Speciesstrata(microbov) <- NULL This is what our data would look like after import.microbov To set our strata here, we need to use the functions strata and splitStratastrata(microbov) <- data.frame(x = pop(microbov))microbov  shows us that we have ""one"" level of stratificationhead(strata(microbov))  all strata are separated by ""_""splitStrata(microbov) <- ~Country/Breed/Speciesmicrobov  Now we have all of our strata named and splithead(strata(microbov))  all strata are appropriately named and split. End(Not run)``` See Also`setPop` `genind` `as.genind` Author(s)Zhian N. Kamvar",13
adegenet,spcaIllus.md," data

# Simulated data illustrating the sPCA

## Format

`spcaIllus` is list of 5 components being either genind or genpop objects.

## Source

Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. **Heredity**, 101 , 92--103.

## Description

Datasets illustrating the spatial Principal Component Analysis (Jombart et al. 2009). These data were simulated using various models using Easypop (2.0.1). Spatial coordinates were defined so that different spatial patterns existed in the data. The `spca-illus` is a list containing the following genind or genpop objects:

- dat2A: 2 patches

- dat2B: cline between two pop

- dat2C: repulsion among individuals from the same gene pool

- dat3: cline and repulsion

- dat4: patches and local alternance

## Details

See ""source"" for a reference providing simulation details.

## Examples

```r
required_packages <- require(adespatial) && require(spdep)
if (required_packages) {
data(spcaIllus)
attach(spcaIllus)
opar <- par(no.readonly=TRUE)
## comparison PCA vs sPCA

# PCA
pca2A <- dudi.pca(dat2A$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca2B <- dudi.pca(dat2B$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca2C <- dudi.pca(dat2C$tab,center=TRUE,scale=FALSE,scannf=FALSE)
pca3 <- dudi.pca(dat3$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)
pca4 <- dudi.pca(dat4$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)

# sPCA
spca2A <-spca(dat2A,xy=dat2A$other$xy,ask=FALSE,type=1,
plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)

spca2B <- spca(dat2B,xy=dat2B$other$xy,ask=FALSE,type=1,
plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)

spca2C <- spca(dat2C,xy=dat2C$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=0,nfnega=1)

spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)

spca4 <- spca(dat4,xy=dat4$other$xy,ask=FALSE,
type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)

# an auxiliary function for graphics
plotaux <- function(x,analysis,axis=1,lab=NULL,...){
neig <- NULL
if(inherits(analysis,""spca"")) neig <- nb2neig(analysis$lw$neighbours)
xrange <- range(x$other$xy[,1])
xlim <- xrange + c(-diff(xrange)*.1 , diff(xrange)*.45)
yrange <- range(x$other$xy[,2])
ylim <- yrange + c(-diff(yrange)*.45 , diff(yrange)*.1)

s.value(x$other$xy,analysis$li[,axis],include.ori=FALSE,addaxes=FALSE,
cgrid=0,grid=FALSE,neig=neig,cleg=0,xlim=xlim,ylim=ylim,...)

par(mar=rep(.1,4))
if(is.null(lab)) lab = gsub(""[P]"","""",x$pop)
text(x$other$xy, lab=lab, col=""blue"", cex=1.2, font=2)
add.scatter({barplot(analysis$eig,col=""grey"");box();
title(""Eigenvalues"",line=-1)},posi=""bottomright"",ratio=.3)
}

# plots
plotaux(dat2A,pca2A,sub=""dat2A - PCA"",pos=""bottomleft"",csub=2)
plotaux(dat2A,spca2A,sub=""dat2A - sPCA glob1"",pos=""bottomleft"",csub=2)

plotaux(dat2B,pca2B,sub=""dat2B - PCA"",pos=""bottomleft"",csub=2)
plotaux(dat2B,spca2B,sub=""dat2B - sPCA glob1"",pos=""bottomleft"",csub=2)

plotaux(dat2C,pca2C,sub=""dat2C - PCA"",pos=""bottomleft"",csub=2)
plotaux(dat2C,spca2C,sub=""dat2C - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)

par(mfrow=c(2,2))
plotaux(dat3,pca3,sub=""dat3 - PCA axis1"",pos=""bottomleft"",csub=2)
plotaux(dat3,spca3,sub=""dat3 - sPCA glob1"",pos=""bottomleft"",csub=2)
plotaux(dat3,pca3,sub=""dat3 - PCA axis2"",pos=""bottomleft"",csub=2,axis=2)
plotaux(dat3,spca3,sub=""dat3 - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)

plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis1"",
pos=""bottomleft"",csub=2)
plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA glob1"",
pos=""bottomleft"",csub=2)
plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis2"",
pos=""bottomleft"",csub=2,axis=2)
plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA loc1"",
pos=""bottomleft"",csub=2,axis=2)

# color plot
par(opar)
colorplot(spca3, cex=4, main=""colorplot sPCA dat3"")
text(spca3$xy[,1], spca3$xy[,2], dat3$pop)

colorplot(spca4, cex=4, main=""colorplot sPCA dat4"")
text(spca4$xy[,1], spca4$xy[,2], dat4$other$sup.pop)

# detach data
detach(spcaIllus)
}
```

## References

Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. **Heredity**, 101 , 92--103.

Balloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations **Journal of Heredity**, 92 : 301-302

## See Also

`spca`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['data Simulated data illustrating the sPCA Format`spcaIllus` is list of 5 components being either genind or genpop objects.', 'SourceJombart, T., Devillard, S., Dufour, A.-B.', 'and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method.', 'DescriptionDatasets illustrating the spatial Principal Component Analysis (Jombart et al.', 'These data were simulated using various models using Easypop (2.0.1).', 'Spatial coordinates were defined so that different spatial patterns existed in the data.', 'The `spca-illus` is a list containing the following genind or genpop objects:- dat2A: 2 patches- dat2B: cline between two pop- dat2C: repulsion among individuals from the same gene pool- dat3: cline and repulsion- dat4: patches and local alternance DetailsSee ""source"" for a reference providing simulation details.', 'Examples```rrequired_packages <- require(adespatial) && require(spdep)if (required_packages) {data(spcaIllus)attach(spcaIllus)opar <- par(no.readonly=TRUE) comparison PCA vs sPCA PCApca2A <- dudi.pca(dat2A$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca2B <- dudi.pca(dat2B$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca2C <- dudi.pca(dat2C$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca3 <- dudi.pca(dat3$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)pca4 <- dudi.pca(dat4$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2) sPCAspca2A <-spca(dat2A,xy=dat2A$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)spca2B <- spca(dat2B,xy=dat2B$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)spca2C <- spca(dat2C,xy=dat2C$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=0,nfnega=1)spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)spca4 <- spca(dat4,xy=dat4$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1) an auxiliary function for graphicsplotaux <- function(x,analysis,axis=1,lab=NULL,...){neig <- NULLif(inherits(analysis,""spca"")) neig <- nb2neig(analysis$lw$neighbours)xrange <- range(x$other$xy[,1])xlim <- xrange + c(-diff(xrange).1 , diff(xrange).45)yrange <- range(x$other$xy[,2])ylim <- yrange + c(-diff(yrange).45 , diff(yrange).1)s.value(x$other$xy,analysis$li[,axis],include.ori=FALSE,addaxes=FALSE,cgrid=0,grid=FALSE,neig=neig,cleg=0,xlim=xlim,ylim=ylim,...)par(mar=rep(.1,4))if(is.null(lab)) lab = gsub(""[P]"","""",x$pop)text(x$other$xy, lab=lab, col=""blue"", cex=1.2, font=2)add.scatter({barplot(analysis$eig,col=""grey"");box();title(""Eigenvalues"",line=-1)},posi=""bottomright"",ratio=.3)} plotsplotaux(dat2A,pca2A,sub=""dat2A - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2A,spca2A,sub=""dat2A - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat2B,pca2B,sub=""dat2B - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2B,spca2B,sub=""dat2B - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat2C,pca2C,sub=""dat2C - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2C,spca2C,sub=""dat2C - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)par(mfrow=c(2,2))plotaux(dat3,pca3,sub=""dat3 - PCA axis1"",pos=""bottomleft"",csub=2)plotaux(dat3,spca3,sub=""dat3 - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat3,pca3,sub=""dat3 - PCA axis2"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat3,spca3,sub=""dat3 - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis1"",pos=""bottomleft"",csub=2)plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis2"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2) color plotpar(opar)colorplot(spca3, cex=4, main=""colorplot sPCA dat3"")text(spca3$xy[,1], spca3$xy[,2], dat3$pop)colorplot(spca4, cex=4, main=""colorplot sPCA dat4"")text(spca4$xy[,1], spca4$xy[,2], dat4$other$sup.pop) detach datadetach(spcaIllus)}``` ReferencesJombart, T., Devillard, S., Dufour, A.-B.', 'and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method.', 'Heredity, 101 , 92--103.Balloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations Journal of Heredity, 92 : 301-302 See Also`spca` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," data Simulated data illustrating the sPCA Format`spcaIllus` is list of 5 components being either genind or genpop objects. SourceJombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. Heredity, 101 , 92--103. DescriptionDatasets illustrating the spatial Principal Component Analysis (Jombart et al. 2009). These data were simulated using various models using Easypop (2.0.1). Spatial coordinates were defined so that different spatial patterns existed in the data. The `spca-illus` is a list containing the following genind or genpop objects:- dat2A: 2 patches- dat2B: cline between two pop- dat2C: repulsion among individuals from the same gene pool- dat3: cline and repulsion- dat4: patches and local alternance DetailsSee ""source"" for a reference providing simulation details. Examples```rrequired_packages <- require(adespatial) && require(spdep)if (required_packages) {data(spcaIllus)attach(spcaIllus)opar <- par(no.readonly=TRUE) comparison PCA vs sPCA PCApca2A <- dudi.pca(dat2A$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca2B <- dudi.pca(dat2B$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca2C <- dudi.pca(dat2C$tab,center=TRUE,scale=FALSE,scannf=FALSE)pca3 <- dudi.pca(dat3$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2)pca4 <- dudi.pca(dat4$tab,center=TRUE,scale=FALSE,scannf=FALSE,nf=2) sPCAspca2A <-spca(dat2A,xy=dat2A$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)spca2B <- spca(dat2B,xy=dat2B$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=0)spca2C <- spca(dat2C,xy=dat2C$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=0,nfnega=1)spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)spca4 <- spca(dat4,xy=dat4$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1) an auxiliary function for graphicsplotaux <- function(x,analysis,axis=1,lab=NULL,...){neig <- NULLif(inherits(analysis,""spca"")) neig <- nb2neig(analysis$lw$neighbours)xrange <- range(x$other$xy[,1])xlim <- xrange + c(-diff(xrange).1 , diff(xrange).45)yrange <- range(x$other$xy[,2])ylim <- yrange + c(-diff(yrange).45 , diff(yrange).1)s.value(x$other$xy,analysis$li[,axis],include.ori=FALSE,addaxes=FALSE,cgrid=0,grid=FALSE,neig=neig,cleg=0,xlim=xlim,ylim=ylim,...)par(mar=rep(.1,4))if(is.null(lab)) lab = gsub(""[P]"","""",x$pop)text(x$other$xy, lab=lab, col=""blue"", cex=1.2, font=2)add.scatter({barplot(analysis$eig,col=""grey"");box();title(""Eigenvalues"",line=-1)},posi=""bottomright"",ratio=.3)} plotsplotaux(dat2A,pca2A,sub=""dat2A - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2A,spca2A,sub=""dat2A - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat2B,pca2B,sub=""dat2B - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2B,spca2B,sub=""dat2B - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat2C,pca2C,sub=""dat2C - PCA"",pos=""bottomleft"",csub=2)plotaux(dat2C,spca2C,sub=""dat2C - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)par(mfrow=c(2,2))plotaux(dat3,pca3,sub=""dat3 - PCA axis1"",pos=""bottomleft"",csub=2)plotaux(dat3,spca3,sub=""dat3 - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat3,pca3,sub=""dat3 - PCA axis2"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat3,spca3,sub=""dat3 - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis1"",pos=""bottomleft"",csub=2)plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA glob1"",pos=""bottomleft"",csub=2)plotaux(dat4,pca4,lab=dat4$other$sup.pop,sub=""dat4 - PCA axis2"",pos=""bottomleft"",csub=2,axis=2)plotaux(dat4,spca4,lab=dat4$other$sup.pop,sub=""dat4 - sPCA loc1"",pos=""bottomleft"",csub=2,axis=2) color plotpar(opar)colorplot(spca3, cex=4, main=""colorplot sPCA dat3"")text(spca3$xy[,1], spca3$xy[,2], dat3$pop)colorplot(spca4, cex=4, main=""colorplot sPCA dat4"")text(spca4$xy[,1], spca4$xy[,2], dat4$other$sup.pop) detach datadetach(spcaIllus)}``` ReferencesJombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. Heredity, 101 , 92--103.Balloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations Journal of Heredity, 92 : 301-302 See Also`spca` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,scaleGen.md," methods

# Compute scaled allele frequencies

```r
scaleGen(x, ...)

## S4 method for signature 'genind'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c(""asis"", ""mean"", ""zero""),
  truenames = TRUE
)

## S4 method for signature 'genpop'
scaleGen(
  x,
  center = TRUE,
  scale = TRUE,
  NA.method = c(""asis"", ""mean"", ""zero""),
  truenames = TRUE
)
```

## Arguments

- `x`: a genind and genpop object
- `...`: further arguments passed to other methods.
- `center`: a logical stating whether alleles frequencies should be centred to mean zero (default to TRUE). Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.
- `scale`: a logical stating whether alleles frequencies should be scaled (default to TRUE). Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.
- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero
- `truenames`: no longer used; kept for backward compatibility

## Returns

A matrix of scaled allele frequencies with genotypes (genind ) or populations in (genpop ) in rows and alleles in columns.

## Description

The generic function `scaleGen` is an analogue to the `scale` function, but is designed with further arguments giving scaling options.

## Details

Methods are defined for genind and genpop

objects. Both return data.frames of scaled allele frequencies.

## Examples

```r
## Not run:

## load data
data(microbov)
obj <- genind2genpop(microbov)

## apply scaling
X1 <- scaleGen(obj)

## compute PCAs with and without scaling
pcaObj <- dudi.pca(obj, scale = FALSE, scannf = FALSE) # pca with no scaling
pcaX1  <- dudi.pca(X1, scale = FALSE, scannf = FALSE, nf = 100) # pca scaled using scaleGen()
pcaX2  <- dudi.pca(obj, scale = TRUE, scannf = FALSE, nf = 100) # pca scaled in-PCA

## get the loadings of alleles for the two scalings
U1 <- pcaObj$c1
U2 <- pcaX1$c1
U3 <- pcaX2$c1

## find an optimal plane to compare loadings
## use a procustean rotation of loadings tables
pro1 <- procuste(U1, U2, nf = 2)
pro2 <- procuste(U2, U3, nf = 2)
pro3 <- procuste(U1, U3, nf = 2)

## graphics
par(mfrow=c(2, 3))
# eigenvalues
barplot(pcaObj$eig, main = ""Eigenvalues\n no scaling"")
barplot(pcaX1$eig, main = ""Eigenvalues\n scaleGen scaling"")
barplot(pcaX2$eig, main = ""Eigenvalues\n in-PCA scaling"")
# differences between loadings of alleles
s.match(pro1$scorX, pro1$scorY, clab = 0,
        sub = ""no scaling -> scaling (procustean rotation)"")
s.match(pro2$scorX, pro2$scorY, clab = 0,
        sub = ""scaling scaleGen -> in-PCA scaling"")
s.match(pro3$scorX, pro3$scorY, clab = 0,
        sub = ""no scaling -> in-PCA scaling"")
## End(Not run)
```

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['methods Compute scaled allele frequencies```rscaleGen(x, ...) S4 method for signature \'genind\'scaleGen(  x,  center = TRUE,  scale = TRUE,  NA.method = c(""asis"", ""mean"", ""zero""),  truenames = TRUE) S4 method for signature \'genpop\'scaleGen(  x,  center = TRUE,  scale = TRUE,  NA.method = c(""asis"", ""mean"", ""zero""),  truenames = TRUE)``` Arguments- `x`: a genind and genpop object- `...`: further arguments passed to other methods.- `center`: a logical stating whether alleles frequencies should be centred to mean zero (default to TRUE).', 'Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.- `scale`: a logical stating whether alleles frequencies should be scaled (default to TRUE).', 'Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero- `truenames`: no longer used; kept for backward compatibility ReturnsA matrix of scaled allele frequencies with genotypes (genind ) or populations in (genpop ) in rows and alleles in columns.', 'DescriptionThe generic function `scaleGen` is an analogue to the `scale` function, but is designed with further arguments giving scaling options.', 'DetailsMethods are defined for genind and genpopobjects.', 'Both return data.frames of scaled allele frequencies.', 'Examples```r Not run: load datadata(microbov)obj <- genind2genpop(microbov) apply scalingX1 <- scaleGen(obj) compute PCAs with and without scalingpcaObj <- dudi.pca(obj, scale = FALSE, scannf = FALSE)  pca with no scalingpcaX1  <- dudi.pca(X1, scale = FALSE, scannf = FALSE, nf = 100)  pca scaled using scaleGen()pcaX2  <- dudi.pca(obj, scale = TRUE, scannf = FALSE, nf = 100)  pca scaled in-PCA get the loadings of alleles for the two scalingsU1 <- pcaObj$c1U2 <- pcaX1$c1U3 <- pcaX2$c1 find an optimal plane to compare loadings use a procustean rotation of loadings tablespro1 <- procuste(U1, U2, nf = 2)pro2 <- procuste(U2, U3, nf = 2)pro3 <- procuste(U1, U3, nf = 2) graphicspar(mfrow=c(2, 3)) eigenvaluesbarplot(pcaObj$eig, main = ""Eigenvalues\\n no scaling"")barplot(pcaX1$eig, main = ""Eigenvalues\\n scaleGen scaling"")barplot(pcaX2$eig, main = ""Eigenvalues\\n in-PCA scaling"") differences between loadings of alleless.match(pro1$scorX, pro1$scorY, clab = 0,        sub = ""no scaling -> scaling (procustean rotation)"")s.match(pro2$scorX, pro2$scorY, clab = 0,        sub = ""scaling scaleGen -> in-PCA scaling"")s.match(pro3$scorX, pro3$scorY, clab = 0,        sub = ""no scaling -> in-PCA scaling"") End(Not run)``` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," methods Compute scaled allele frequencies```rscaleGen(x, ...) S4 method for signature 'genind'scaleGen(  x,  center = TRUE,  scale = TRUE,  NA.method = c(""asis"", ""mean"", ""zero""),  truenames = TRUE) S4 method for signature 'genpop'scaleGen(  x,  center = TRUE,  scale = TRUE,  NA.method = c(""asis"", ""mean"", ""zero""),  truenames = TRUE)``` Arguments- `x`: a genind and genpop object- `...`: further arguments passed to other methods.- `center`: a logical stating whether alleles frequencies should be centred to mean zero (default to TRUE). Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.- `scale`: a logical stating whether alleles frequencies should be scaled (default to TRUE). Alternatively, a vector of numeric values, one per allele, can be supplied: these values will be substracted from the allele frequencies.- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero- `truenames`: no longer used; kept for backward compatibility ReturnsA matrix of scaled allele frequencies with genotypes (genind ) or populations in (genpop ) in rows and alleles in columns. DescriptionThe generic function `scaleGen` is an analogue to the `scale` function, but is designed with further arguments giving scaling options. DetailsMethods are defined for genind and genpopobjects. Both return data.frames of scaled allele frequencies. Examples```r Not run: load datadata(microbov)obj <- genind2genpop(microbov) apply scalingX1 <- scaleGen(obj) compute PCAs with and without scalingpcaObj <- dudi.pca(obj, scale = FALSE, scannf = FALSE)  pca with no scalingpcaX1  <- dudi.pca(X1, scale = FALSE, scannf = FALSE, nf = 100)  pca scaled using scaleGen()pcaX2  <- dudi.pca(obj, scale = TRUE, scannf = FALSE, nf = 100)  pca scaled in-PCA get the loadings of alleles for the two scalingsU1 <- pcaObj$c1U2 <- pcaX1$c1U3 <- pcaX2$c1 find an optimal plane to compare loadings use a procustean rotation of loadings tablespro1 <- procuste(U1, U2, nf = 2)pro2 <- procuste(U2, U3, nf = 2)pro3 <- procuste(U1, U3, nf = 2) graphicspar(mfrow=c(2, 3)) eigenvaluesbarplot(pcaObj$eig, main = ""Eigenvalues\n no scaling"")barplot(pcaX1$eig, main = ""Eigenvalues\n scaleGen scaling"")barplot(pcaX2$eig, main = ""Eigenvalues\n in-PCA scaling"") differences between loadings of alleless.match(pro1$scorX, pro1$scorY, clab = 0,        sub = ""no scaling -> scaling (procustean rotation)"")s.match(pro2$scorX, pro2$scorY, clab = 0,        sub = ""scaling scaleGen -> in-PCA scaling"")s.match(pro3$scorX, pro3$scorY, clab = 0,        sub = ""no scaling -> in-PCA scaling"") End(Not run)``` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",13
adegenet,virClasses.md,"class

# Virtual classes for adegenet

## Description

These virtual classes are only for internal use in adegenet

## Objects from the Class

A virtual Class: No objects may be created from it.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



",['class Virtual classes for adegenet DescriptionThese virtual classes are only for internal use in adegenet Objects from the ClassA virtual Class: No objects may be created from it.'],1,class Virtual classes for adegenet DescriptionThese virtual classes are only for internal use in adegenet Objects from the ClassA virtual Class: No objects may be created from it. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk,14
adegenet,monmonier.md,"UTF-8

# Boundary detection using Monmonier algorithm

## Description

The Monmonier's algorithm detects boundaries among vertices of a valuated graph. This is achieved by finding the path exhibiting the largest distances between connected vertices.

The highest distance between two connected vertices (i.e. neighbours) is found, giving the starting point of the path. Then, the algorithm seeks the highest distance between immediate neighbours, and so on until a threshold value is attained. This threshold can be chosen from the plot of sorted distances between connected vertices: a boundary will likely result in an abrupt decrease of these values.

When several paths are looked for, the previous paths are taken into account, and cannot be either crossed or redrawn. Monmonier's algorithm can be used to assess the boundaries between patches of homogeneous observations.

Although Monmonier algorithm was initially designed for Voronoi tesselation, this implementation generalizes this algorithm to different connection networks. The `optimize.monmonier` function produces a `monmonier` object by trying several starting points, and returning the best boundary (i.e. largest sum of local distances). This is designed to avoid the algorithm to be trapped by a single strong local difference inside an homogeneous patch.

```r
monmonier(xy, dist, cn, threshold=NULL, bd.length=NULL, nrun=1,
skip.local.diff=rep(0,nrun),scanthres=is.null(threshold), allowLoop=TRUE)

optimize.monmonier(xy, dist, cn, ntry=10, bd.length=NULL, return.best=TRUE,
display.graph=TRUE, threshold=NULL, scanthres=is.null(threshold), allowLoop=TRUE)

## S3 method for class 'monmonier'
plot(x, variable=NULL,
displayed.runs=1:x$nrun, add.arrows=TRUE,
col='blue', lty=1, bwd=4, clegend=1, csize=0.7,
method=c('squaresize','greylevel'), sub='', csub=1, possub='topleft',
cneig=1, pixmap=NULL, contour=NULL, area=NULL, add.plot=FALSE, ...)

## S3 method for class 'monmonier'
print(x, ...)
```

## Arguments

- `xy`: a matrix yielding the spatial coordinates of the objects, with two columns respectively giving X and Y
- `dist`: an object of class `dist`, giving the distances between the objects
- `cn`: a connection network of class `nb` (package `spdep`)
- `threshold`: a number giving the minimal distance between two neighbours crossed by the path; by default, this is the third quartile of all the distances between neighbours
- `bd.length`: an optional integer giving the requested length of the boundaries (in number of local differences)
- `nrun`: is a integer giving the number of runs of the algorithm, that is, the number of paths to search, being one by default
- `skip.local.diff`: is a vector of integers, whose length is the number of paths (`nrun`); each integer gives the number of starting point to skip, to avoid being stuck in a local difference between two neighbours into an homogeneous patch; none are skipped by default
- `scanthres`: a logical stating whether the threshold sould be chosen from the barplot of sorted distances between neighbours
- `allowLoop`: a logical specifying whether the boundary can loop (TRUE, default) or not (FALSE)
- `ntry`: an integer giving the number of different starting points tried.
- `return.best`: a logical stating whether the best monmonier object should be returned (TRUE, default) or not (FALSE)
- `display.graph`: a logical whether the scores of each try should be plotted (TRUE, default) or not
- `x`: a monmonier object
- `variable`: a variable to be plotted using `s.value` (package `ade4`)
- `displayed.runs`: an integer vector giving the rank of the paths to represent
- `add.arrows`: a logical, stating whether arrows should indicate the direction of the path (TRUE) or not (FALSE, used by default)
- `col`: a characters vector giving the colors to be used for each boundary; recycled is needed; 'blue' is used by default
- `lty`: a characters vector giving the type of line to be used for each boundary; 1 is used by default
- `bwd`: a number giving the boundary width factor, applying to every segments of the paths; 4 is used by default
- `clegend`: like in `s.value`, the size factor of the legend if a variable is represented
- `csize`: like in `s.value`, the size factor of the squares used to represent a variable
- `method`: like in `s.value`, a character giving the method to be used to represent the variable, either 'squaresize' (by default) or 'greylevel'
- `sub`: a string of characters giving the subtitle of the plot
- `csub`: the size factor of the subtitle
- `possub`: the position of the subtitle; available choices are 'topleft' (by default), 'topright', 'bottomleft', and 'bottomright'
- `cneig`: the size factor of the connection network
- `pixmap`: an object of the class `pixmap` displayed in the map background
- `contour`: a data frame with 4 columns to plot the contour of the map: each row gives a segment (x1,y1,x2,y2)
- `area`: a data frame of class 'area' to plot a set of surface units in contour
- `add.plot`: a logical stating whether the plot should be added to the current one (TRUE), or displayed in a new window (FALSE, by default)
- ``...``: further arguments passed to other methods

## Details

The function `monmonier` returns a list of the class `monmonier`, which contains the general informations about the algorithm, and about each run. When displayed, the width of the boundaries reflects their 'strength'. Let a segment MN be part of the path, M being the middle of AB, N of CD. Then the boundary width for MN is proportionnal to (d(AB)+d(CD))/2.

As there is no perfect method to display graphically a quantitative variable (see for instance the differences between the two methods of `s.value`), the boundaries provided by this algorithm seem sometimes more reliable than the boundaries our eyes perceive (or miss).

## Returns

Returns an object of class `monmonier`, which contains the following elements : - **run1 (run2, `...`)**: for each run, a list containing a dataframe giving the path coordinates, and a vector of the distances between neighbours of the path

 - **nrun**: the number of runs performed, i.e. the number of boundaries in the monmonier object

 - **threshold**: the threshold value, minimal distance between neighbours accounted for by the algorithm

 - **xy**: the matrix of spatial coordinates

 - **cn**: the connection network of class `nb`

 - **call**: the call of the function

## References

Monmonier, M. (1973) Maximum-difference barriers: an alternative numerical regionalization method. **Geographic Analysis**, 3 , 245--261.

Manni, F., Guerard, E. and Heyer, E. (2004) Geographic patterns of (genetic, morphologic, linguistic) variation: how barriers can be detected by ""Monmonier's algorithm"". **Human Biology**, 76 , 173--190

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`spca`,`edit.nb`

## Examples

```r
if(require(spdep)){

### non-interactive example

# est-west separation
load(system.file(""files/mondata1.rda"",package=""adegenet""))
cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)
mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2)
plot(mon1,mondata1$x1)
plot(mon1,mondata1$x1,met=""greylevel"",add.arr=FALSE,col=""red"",bwd=6,lty=2)

# square in the middle
load(system.file(""files/mondata2.rda"",package=""adegenet""))
cn2 <- chooseCN(mondata2$xy,type=1,ask=FALSE)
mon2 <- monmonier(mondata2$xy,dist(mondata2$x2),cn2,threshold=2)
plot(mon2,mondata2$x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5)

### genetic data example
## Not run:

data(sim2pop)

if(require(hierfstat)){
## try and find the Fst
fstat(sim2pop,fst=TRUE)
# Fst = 0.038
}

## run monmonier algorithm

# build connection network
gab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2)

# filter random noise 
pca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1)

# run the algorithm
mon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab,scanthres=FALSE)

# graphical display 
plot(mon1,var=pca1$l1[,1])
temp <- sim2pop@pop
levels(temp) <- c(17,19)
temp <- as.numeric(as.character(temp))
plot(mon1)
points(sim2pop@other$xy,pch=temp,cex=2)
legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19))


### interactive example

# north-south separation
xy <- matrix(runif(120,0,10), ncol=2)
x1 <- rnorm(60)
x1[xy[,2] > 5] <- x1[xy[,2] > 5]+3
cn1 <- chooseCN(xy,type=1,ask=FALSE)
mon1 <- optimize.monmonier(xy,dist(x1)^2,cn1,ntry=10)

# graphics
plot(mon1,x1,met=""greylevel"",csize=.6)

# island in the middle
x2 <- rnorm(60)
sel <- (xy[,1]>3.5 & xy[,2]>3.5 & xy[,1]<6.5 & xy[,2]<6.5)
x2[sel] <- x2[sel]+4
cn2 <- chooseCN(xy,type=1,ask=FALSE)
mon2 <- optimize.monmonier(xy,dist(x2)^2,cn2,ntry=10)

# graphics
plot(mon2,x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5)
## End(Not run)

}
```



","[""UTF-8 Boundary detection using Monmonier algorithm DescriptionThe Monmonier's algorithm detects boundaries among vertices of a valuated graph."", 'This is achieved by finding the path exhibiting the largest distances between connected vertices.The highest distance between two connected vertices (i.e.', 'neighbours) is found, giving the starting point of the path.', 'Then, the algorithm seeks the highest distance between immediate neighbours, and so on until a threshold value is attained.', 'This threshold can be chosen from the plot of sorted distances between connected vertices: a boundary will likely result in an abrupt decrease of these values.When several paths are looked for, the previous paths are taken into account, and cannot be either crossed or redrawn.', ""Monmonier's algorithm can be used to assess the boundaries between patches of homogeneous observations.Although Monmonier algorithm was initially designed for Voronoi tesselation, this implementation generalizes this algorithm to different connection networks."", 'The `optimize.monmonier` function produces a `monmonier` object by trying several starting points, and returning the best boundary (i.e.', 'largest sum of local distances).', ""This is designed to avoid the algorithm to be trapped by a single strong local difference inside an homogeneous patch.```rmonmonier(xy, dist, cn, threshold=NULL, bd.length=NULL, nrun=1,skip.local.diff=rep(0,nrun),scanthres=is.null(threshold), allowLoop=TRUE)optimize.monmonier(xy, dist, cn, ntry=10, bd.length=NULL, return.best=TRUE,display.graph=TRUE, threshold=NULL, scanthres=is.null(threshold), allowLoop=TRUE) S3 method for class 'monmonier'plot(x, variable=NULL,displayed.runs=1:x$nrun, add.arrows=TRUE,col='blue', lty=1, bwd=4, clegend=1, csize=0.7,method=c('squaresize','greylevel'), sub='', csub=1, possub='topleft',cneig=1, pixmap=NULL, contour=NULL, area=NULL, add.plot=FALSE, ...) S3 method for class 'monmonier'print(x, ...)``` Arguments- `xy`: a matrix yielding the spatial coordinates of the objects, with two columns respectively giving X and Y- `dist`: an object of class `dist`, giving the distances between the objects- `cn`: a connection network of class `nb` (package `spdep`)- `threshold`: a number giving the minimal distance between two neighbours crossed by the path; by default, this is the third quartile of all the distances between neighbours- `bd.length`: an optional integer giving the requested length of the boundaries (in number of local differences)- `nrun`: is a integer giving the number of runs of the algorithm, that is, the number of paths to search, being one by default- `skip.local.diff`: is a vector of integers, whose length is the number of paths (`nrun`); each integer gives the number of starting point to skip, to avoid being stuck in a local difference between two neighbours into an homogeneous patch; none are skipped by default- `scanthres`: a logical stating whether the threshold sould be chosen from the barplot of sorted distances between neighbours- `allowLoop`: a logical specifying whether the boundary can loop (TRUE, default) or not (FALSE)- `ntry`: an integer giving the number of different starting points tried.- `return.best`: a logical stating whether the best monmonier object should be returned (TRUE, default) or not (FALSE)- `display.graph`: a logical whether the scores of each try should be plotted (TRUE, default) or not- `x`: a monmonier object- `variable`: a variable to be plotted using `s.value` (package `ade4`)- `displayed.runs`: an integer vector giving the rank of the paths to represent- `add.arrows`: a logical, stating whether arrows should indicate the direction of the path (TRUE) or not (FALSE, used by default)- `col`: a characters vector giving the colors to be used for each boundary; recycled is needed; 'blue' is used by default- `lty`: a characters vector giving the type of line to be used for each boundary; 1 is used by default- `bwd`: a number giving the boundary width factor, applying to every segments of the paths; 4 is used by default- `clegend`: like in `s.value`, the size factor of the legend if a variable is represented- `csize`: like in `s.value`, the size factor of the squares used to represent a variable- `method`: like in `s.value`, a character giving the method to be used to represent the variable, either 'squaresize' (by default) or 'greylevel'- `sub`: a string of characters giving the subtitle of the plot- `csub`: the size factor of the subtitle- `possub`: the position of the subtitle; available choices are 'topleft' (by default), 'topright', 'bottomleft', and 'bottomright'- `cneig`: the size factor of the connection network- `pixmap`: an object of the class `pixmap` displayed in the map background- `contour`: a data frame with 4 columns to plot the contour of the map: each row gives a segment (x1,y1,x2,y2)- `area`: a data frame of class 'area' to plot a set of surface units in contour- `add.plot`: a logical stating whether the plot should be added to the current one (TRUE), or displayed in a new window (FALSE, by default)- ``...``: further arguments passed to other methods DetailsThe function `monmonier` returns a list of the class `monmonier`, which contains the general informations about the algorithm, and about each run."", ""When displayed, the width of the boundaries reflects their 'strength'."", 'Let a segment MN be part of the path, M being the middle of AB, N of CD.', 'Then the boundary width for MN is proportionnal to (d(AB)+d(CD))/2.As there is no perfect method to display graphically a quantitative variable (see for instance the differences between the two methods of `s.value`), the boundaries provided by this algorithm seem sometimes more reliable than the boundaries our eyes perceive (or miss).', 'ReturnsReturns an object of class `monmonier`, which contains the following elements : - run1 (run2, `...`): for each run, a list containing a dataframe giving the path coordinates, and a vector of the distances between neighbours of the path - nrun: the number of runs performed, i.e.', 'the number of boundaries in the monmonier object - threshold: the threshold value, minimal distance between neighbours accounted for by the algorithm - xy: the matrix of spatial coordinates - cn: the connection network of class `nb` - call: the call of the function ReferencesMonmonier, M. (1973) Maximum-difference barriers: an alternative numerical regionalization method.', 'Geographic Analysis, 3 , 245--261.Manni, F., Guerard, E. and Heyer, E. (2004) Geographic patterns of (genetic, morphologic, linguistic) variation: how barriers can be detected by ""Monmonier\'s algorithm"".', 'Human Biology, 76 , 173--190 Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`spca`,`edit.nb` Examples```rif(require(spdep)){ non-interactive example est-west separationload(system.file(""files/mondata1.rda"",package=""adegenet""))cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2)plot(mon1,mondata1$x1)plot(mon1,mondata1$x1,met=""greylevel"",add.arr=FALSE,col=""red"",bwd=6,lty=2) square in the middleload(system.file(""files/mondata2.rda"",package=""adegenet""))cn2 <- chooseCN(mondata2$xy,type=1,ask=FALSE)mon2 <- monmonier(mondata2$xy,dist(mondata2$x2),cn2,threshold=2)plot(mon2,mondata2$x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5) genetic data example Not run:data(sim2pop)if(require(hierfstat)){ try and find the Fstfstat(sim2pop,fst=TRUE) Fst = 0.038} run monmonier algorithm build connection networkgab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2) filter random noise pca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1) run the algorithmmon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab,scanthres=FALSE) graphical display plot(mon1,var=pca1$l1[,1])temp <- sim2pop@poplevels(temp) <- c(17,19)temp <- as.numeric(as.character(temp))plot(mon1)points(sim2pop@other$xy,pch=temp,cex=2)legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19)) interactive example north-south separationxy <- matrix(runif(120,0,10), ncol=2)x1 <- rnorm(60)x1[xy[,2] > 5] <- x1[xy[,2] > 5]+3cn1 <- chooseCN(xy,type=1,ask=FALSE)mon1 <- optimize.monmonier(xy,dist(x1)^2,cn1,ntry=10) graphicsplot(mon1,x1,met=""greylevel"",csize=.6) island in the middlex2 <- rnorm(60)sel <- (xy[,1]>3.5 & xy[,2]>3.5 & xy[,1]<6.5 & xy[,2]<6.5)x2[sel] <- x2[sel]+4cn2 <- chooseCN(xy,type=1,ask=FALSE)mon2 <- optimize.monmonier(xy,dist(x2)^2,cn2,ntry=10) graphicsplot(mon2,x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5) End(Not run)}```']",1,"UTF-8 Boundary detection using Monmonier algorithm DescriptionThe Monmonier's algorithm detects boundaries among vertices of a valuated graph. This is achieved by finding the path exhibiting the largest distances between connected vertices.The highest distance between two connected vertices (i.e. neighbours) is found, giving the starting point of the path. Then, the algorithm seeks the highest distance between immediate neighbours, and so on until a threshold value is attained. This threshold can be chosen from the plot of sorted distances between connected vertices: a boundary will likely result in an abrupt decrease of these values.When several paths are looked for, the previous paths are taken into account, and cannot be either crossed or redrawn. Monmonier's algorithm can be used to assess the boundaries between patches of homogeneous observations.Although Monmonier algorithm was initially designed for Voronoi tesselation, this implementation generalizes this algorithm to different connection networks. The `optimize.monmonier` function produces a `monmonier` object by trying several starting points, and returning the best boundary (i.e. largest sum of local distances). This is designed to avoid the algorithm to be trapped by a single strong local difference inside an homogeneous patch.```rmonmonier(xy, dist, cn, threshold=NULL, bd.length=NULL, nrun=1,skip.local.diff=rep(0,nrun),scanthres=is.null(threshold), allowLoop=TRUE)optimize.monmonier(xy, dist, cn, ntry=10, bd.length=NULL, return.best=TRUE,display.graph=TRUE, threshold=NULL, scanthres=is.null(threshold), allowLoop=TRUE) S3 method for class 'monmonier'plot(x, variable=NULL,displayed.runs=1:x$nrun, add.arrows=TRUE,col='blue', lty=1, bwd=4, clegend=1, csize=0.7,method=c('squaresize','greylevel'), sub='', csub=1, possub='topleft',cneig=1, pixmap=NULL, contour=NULL, area=NULL, add.plot=FALSE, ...) S3 method for class 'monmonier'print(x, ...)``` Arguments- `xy`: a matrix yielding the spatial coordinates of the objects, with two columns respectively giving X and Y- `dist`: an object of class `dist`, giving the distances between the objects- `cn`: a connection network of class `nb` (package `spdep`)- `threshold`: a number giving the minimal distance between two neighbours crossed by the path; by default, this is the third quartile of all the distances between neighbours- `bd.length`: an optional integer giving the requested length of the boundaries (in number of local differences)- `nrun`: is a integer giving the number of runs of the algorithm, that is, the number of paths to search, being one by default- `skip.local.diff`: is a vector of integers, whose length is the number of paths (`nrun`); each integer gives the number of starting point to skip, to avoid being stuck in a local difference between two neighbours into an homogeneous patch; none are skipped by default- `scanthres`: a logical stating whether the threshold sould be chosen from the barplot of sorted distances between neighbours- `allowLoop`: a logical specifying whether the boundary can loop (TRUE, default) or not (FALSE)- `ntry`: an integer giving the number of different starting points tried.- `return.best`: a logical stating whether the best monmonier object should be returned (TRUE, default) or not (FALSE)- `display.graph`: a logical whether the scores of each try should be plotted (TRUE, default) or not- `x`: a monmonier object- `variable`: a variable to be plotted using `s.value` (package `ade4`)- `displayed.runs`: an integer vector giving the rank of the paths to represent- `add.arrows`: a logical, stating whether arrows should indicate the direction of the path (TRUE) or not (FALSE, used by default)- `col`: a characters vector giving the colors to be used for each boundary; recycled is needed; 'blue' is used by default- `lty`: a characters vector giving the type of line to be used for each boundary; 1 is used by default- `bwd`: a number giving the boundary width factor, applying to every segments of the paths; 4 is used by default- `clegend`: like in `s.value`, the size factor of the legend if a variable is represented- `csize`: like in `s.value`, the size factor of the squares used to represent a variable- `method`: like in `s.value`, a character giving the method to be used to represent the variable, either 'squaresize' (by default) or 'greylevel'- `sub`: a string of characters giving the subtitle of the plot- `csub`: the size factor of the subtitle- `possub`: the position of the subtitle; available choices are 'topleft' (by default), 'topright', 'bottomleft', and 'bottomright'- `cneig`: the size factor of the connection network- `pixmap`: an object of the class `pixmap` displayed in the map background- `contour`: a data frame with 4 columns to plot the contour of the map: each row gives a segment (x1,y1,x2,y2)- `area`: a data frame of class 'area' to plot a set of surface units in contour- `add.plot`: a logical stating whether the plot should be added to the current one (TRUE), or displayed in a new window (FALSE, by default)- ``...``: further arguments passed to other methods DetailsThe function `monmonier` returns a list of the class `monmonier`, which contains the general informations about the algorithm, and about each run. When displayed, the width of the boundaries reflects their 'strength'. Let a segment MN be part of the path, M being the middle of AB, N of CD. Then the boundary width for MN is proportionnal to (d(AB)+d(CD))/2.As there is no perfect method to display graphically a quantitative variable (see for instance the differences between the two methods of `s.value`), the boundaries provided by this algorithm seem sometimes more reliable than the boundaries our eyes perceive (or miss). ReturnsReturns an object of class `monmonier`, which contains the following elements : - run1 (run2, `...`): for each run, a list containing a dataframe giving the path coordinates, and a vector of the distances between neighbours of the path - nrun: the number of runs performed, i.e. the number of boundaries in the monmonier object - threshold: the threshold value, minimal distance between neighbours accounted for by the algorithm - xy: the matrix of spatial coordinates - cn: the connection network of class `nb` - call: the call of the function ReferencesMonmonier, M. (1973) Maximum-difference barriers: an alternative numerical regionalization method. Geographic Analysis, 3 , 245--261.Manni, F., Guerard, E. and Heyer, E. (2004) Geographic patterns of (genetic, morphologic, linguistic) variation: how barriers can be detected by ""Monmonier's algorithm"". Human Biology, 76 , 173--190 Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`spca`,`edit.nb` Examples```rif(require(spdep)){ non-interactive example est-west separationload(system.file(""files/mondata1.rda"",package=""adegenet""))cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2)plot(mon1,mondata1$x1)plot(mon1,mondata1$x1,met=""greylevel"",add.arr=FALSE,col=""red"",bwd=6,lty=2) square in the middleload(system.file(""files/mondata2.rda"",package=""adegenet""))cn2 <- chooseCN(mondata2$xy,type=1,ask=FALSE)mon2 <- monmonier(mondata2$xy,dist(mondata2$x2),cn2,threshold=2)plot(mon2,mondata2$x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5) genetic data example Not run:data(sim2pop)if(require(hierfstat)){ try and find the Fstfstat(sim2pop,fst=TRUE) Fst = 0.038} run monmonier algorithm build connection networkgab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2) filter random noise pca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1) run the algorithmmon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab,scanthres=FALSE) graphical display plot(mon1,var=pca1$l1[,1])temp <- sim2pop@poplevels(temp) <- c(17,19)temp <- as.numeric(as.character(temp))plot(mon1)points(sim2pop@other$xy,pch=temp,cex=2)legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19)) interactive example north-south separationxy <- matrix(runif(120,0,10), ncol=2)x1 <- rnorm(60)x1[xy[,2] > 5] <- x1[xy[,2] > 5]+3cn1 <- chooseCN(xy,type=1,ask=FALSE)mon1 <- optimize.monmonier(xy,dist(x1)^2,cn1,ntry=10) graphicsplot(mon1,x1,met=""greylevel"",csize=.6) island in the middlex2 <- rnorm(60)sel <- (xy[,1]>3.5 & xy[,2]>3.5 & xy[,1]<6.5 & xy[,2]<6.5)x2[sel] <- x2[sel]+4cn2 <- chooseCN(xy,type=1,ask=FALSE)mon2 <- optimize.monmonier(xy,dist(x2)^2,cn2,ntry=10) graphicsplot(mon2,x2,method=""greylevel"",add.arr=FALSE,bwd=6,col=""red"",csize=.5) End(Not run)}```",14
adegenet,df2genind.md,"# Convert a data.frame of allele data to a genind object.

```r
df2genind(
  X,
  sep = NULL,
  ncode = NULL,
  ind.names = NULL,
  loc.names = NULL,
  pop = NULL,
  NA.char = """",
  ploidy = 2,
  type = c(""codom"", ""PA""),
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption(""adegenet.check.ploidy"")
)
```

## Arguments

- `X`: a matrix or a data.frame containing allelle data only (see decription)
- `sep`: a character string separating alleles. See details.
- `ncode`: an optional integer giving the number of characters used for coding one genotype at one locus. If not provided, this is determined from data.
- `ind.names`: optinal, a vector giving the individuals names; if NULL, taken from rownames of X. If factor or numeric, vector is converted to character.
- `loc.names`: an optional character vector giving the markers names; if NULL, taken from colnames of X.
- `pop`: an optional factor giving the population of each individual.
- `NA.char`: a character string corresponding to missing allele (to be treated as NA)
- `ploidy`: an integer indicating the degree of ploidy of the genotypes.
- `type`: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' markers (e.g. AFLP, RAPD).
- `strata`: an optional data frame that defines population stratifications for your samples. This is especially useful if you have a hierarchical or factorial sampling design.
- `hierarchy`: a hierarchical formula that explicitely defines hierarchical levels in your strata.
- `check.ploidy`: a boolean indicating if the ploidy should be checked (TRUE, default) or not (FALSE). Not checking the ploidy makes the import much faster, but might result in bugs/problems if the input file is misread or the ploidy is wrong. It is therefore advised to first import and check a subset of data to see if everything works as expected before setting this option to false.

## Returns

an object of the class genind for `df2genind`; a matrix of biallelic genotypes for `genind2df`

## Description

The function `df2genind` converts a data.frame (or a matrix) into a genind object. The data.frame must meet the following requirements:

 * genotypes are in row (one row per genotype)
 * markers/loci are in columns
 * each element is a string of characters coding alleles, ideally separated by a character string (argument `sep`); if no separator is used, the number of characters coding alleles must be indicated (argument `ncode`).

## Details

See `genind2df` to convert genind objects back to such a data.frame.

=== Details for the `sep` argument ===

this character is directly used in reguar expressions like `gsub`, and thus require some characters to be preceeded by double backslashes. For instance, ""/"" works but ""|"" must be coded as ""\|"".

## Examples

```r
## simple example
df <- data.frame(locusA=c(""11"",""11"",""12"",""32""),
locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))
row.names(df) <- .genlab(""genotype"",4)
df

obj <- df2genind(df, ploidy=2, ncode=1)
obj
tab(obj)


## converting a genind as data.frame
genind2df(obj)
genind2df(obj, sep=""/"")
```

## See Also

`genind2df`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu



","['Convert a data.frame of allele data to a genind object.```rdf2genind(  X,  sep = NULL,  ncode = NULL,  ind.names = NULL,  loc.names = NULL,  pop = NULL,  NA.char = """",  ploidy = 2,  type = c(""codom"", ""PA""),  strata = NULL,  hierarchy = NULL,  check.ploidy = getOption(""adegenet.check.ploidy""))``` Arguments- `X`: a matrix or a data.frame containing allelle data only (see decription)- `sep`: a character string separating alleles.', 'See details.- `ncode`: an optional integer giving the number of characters used for coding one genotype at one locus.', 'If not provided, this is determined from data.- `ind.names`: optinal, a vector giving the individuals names; if NULL, taken from rownames of X.', ""If factor or numeric, vector is converted to character.- `loc.names`: an optional character vector giving the markers names; if NULL, taken from colnames of X.- `pop`: an optional factor giving the population of each individual.- `NA.char`: a character string corresponding to missing allele (to be treated as NA)- `ploidy`: an integer indicating the degree of ploidy of the genotypes.- `type`: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g."", ""microstallites, allozymes); 'PA' stands for 'presence/absence' markers (e.g."", 'AFLP, RAPD).- `strata`: an optional data frame that defines population stratifications for your samples.', 'This is especially useful if you have a hierarchical or factorial sampling design.- `hierarchy`: a hierarchical formula that explicitely defines hierarchical levels in your strata.- `check.ploidy`: a boolean indicating if the ploidy should be checked (TRUE, default) or not (FALSE).', 'Not checking the ploidy makes the import much faster, but might result in bugs/problems if the input file is misread or the ploidy is wrong.', 'It is therefore advised to first import and check a subset of data to see if everything works as expected before setting this option to false.', 'Returnsan object of the class genind for `df2genind`; a matrix of biallelic genotypes for `genind2df` DescriptionThe function `df2genind` converts a data.frame (or a matrix) into a genind object.', 'The data.frame must meet the following requirements:  genotypes are in row (one row per genotype)  markers/loci are in columns  each element is a string of characters coding alleles, ideally separated by a character string (argument `sep`); if no separator is used, the number of characters coding alleles must be indicated (argument `ncode`).', 'DetailsSee `genind2df` to convert genind objects back to such a data.frame.=== Details for the `sep` argument ===this character is directly used in reguar expressions like `gsub`, and thus require some characters to be preceeded by double backslashes.', 'For instance, ""/"" works but ""|"" must be coded as ""\\|"".', 'Examples```r simple exampledf <- data.frame(locusA=c(""11"",""11"",""12"",""32""),locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))row.names(df) <- .genlab(""genotype"",4)dfobj <- df2genind(df, ploidy=2, ncode=1)objtab(obj) converting a genind as data.framegenind2df(obj)genind2df(obj, sep=""/"")``` See Also`genind2df`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu']",1," Convert a data.frame of allele data to a genind object.```rdf2genind(  X,  sep = NULL,  ncode = NULL,  ind.names = NULL,  loc.names = NULL,  pop = NULL,  NA.char = """",  ploidy = 2,  type = c(""codom"", ""PA""),  strata = NULL,  hierarchy = NULL,  check.ploidy = getOption(""adegenet.check.ploidy""))``` Arguments- `X`: a matrix or a data.frame containing allelle data only (see decription)- `sep`: a character string separating alleles. See details.- `ncode`: an optional integer giving the number of characters used for coding one genotype at one locus. If not provided, this is determined from data.- `ind.names`: optinal, a vector giving the individuals names; if NULL, taken from rownames of X. If factor or numeric, vector is converted to character.- `loc.names`: an optional character vector giving the markers names; if NULL, taken from colnames of X.- `pop`: an optional factor giving the population of each individual.- `NA.char`: a character string corresponding to missing allele (to be treated as NA)- `ploidy`: an integer indicating the degree of ploidy of the genotypes.- `type`: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' markers (e.g. AFLP, RAPD).- `strata`: an optional data frame that defines population stratifications for your samples. This is especially useful if you have a hierarchical or factorial sampling design.- `hierarchy`: a hierarchical formula that explicitely defines hierarchical levels in your strata.- `check.ploidy`: a boolean indicating if the ploidy should be checked (TRUE, default) or not (FALSE). Not checking the ploidy makes the import much faster, but might result in bugs/problems if the input file is misread or the ploidy is wrong. It is therefore advised to first import and check a subset of data to see if everything works as expected before setting this option to false. Returnsan object of the class genind for `df2genind`; a matrix of biallelic genotypes for `genind2df` DescriptionThe function `df2genind` converts a data.frame (or a matrix) into a genind object. The data.frame must meet the following requirements:  genotypes are in row (one row per genotype)  markers/loci are in columns  each element is a string of characters coding alleles, ideally separated by a character string (argument `sep`); if no separator is used, the number of characters coding alleles must be indicated (argument `ncode`). DetailsSee `genind2df` to convert genind objects back to such a data.frame.=== Details for the `sep` argument ===this character is directly used in reguar expressions like `gsub`, and thus require some characters to be preceeded by double backslashes. For instance, ""/"" works but ""|"" must be coded as ""\|"". Examples```r simple exampledf <- data.frame(locusA=c(""11"",""11"",""12"",""32""),locusB=c(NA,""34"",""55"",""15""),locusC=c(""22"",""22"",""21"",""22""))row.names(df) <- .genlab(""genotype"",4)dfobj <- df2genind(df, ploidy=2, ncode=1)objtab(obj) converting a genind as data.framegenind2df(obj)genind2df(obj, sep=""/"")``` See Also`genind2df`, `import2genind`, `read.genetix`, `read.fstat`, `read.structure` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu",14
adegenet,new.genpop.md," methods

# genpop constructor

```r
## S4 method for signature 'genpop'
initialize(
  .Object,
  tab,
  prevcall = NULL,
  ploidy = 2L,
  type = c(""codom"", ""PA""),
  ...
)

genpop(...)

as.genpop(...)
```

## Arguments

- `.Object`: prototyped object (generated automatically when calling 'new')
- `tab`: A matrix of integers corresponding to the @tab slot of a genpop object, with individuals in rows and alleles in columns, and containing either allele counts
- `prevcall`: an optional call to be stored in the object
- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.
- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")
- `...`: further arguments passed to other methods (currently not used)

## Returns

a genpop object

## Description

The function `new` has a method for building genpop objects. See the class description of genpop for more information on this data structure. The functions `genpop` and `as.genpop` are aliases for `new(""genpop"", ...)`.

## Details

Most users do not need using the constructor, but merely to convert raw allele data using `genind2genpop`.

## See Also

the description of the genpop class; `df2genind` and related functions for reading raw allele data



","['methods genpop constructor```r S4 method for signature \'genpop\'initialize(  .Object,  tab,  prevcall = NULL,  ploidy = 2L,  type = c(""codom"", ""PA""),  ...)genpop(...)as.genpop(...)``` Arguments- `.Object`: prototyped object (generated automatically when calling \'new\')- `tab`: A matrix of integers corresponding to the @tab slot of a genpop object, with individuals in rows and alleles in columns, and containing either allele counts- `prevcall`: an optional call to be stored in the object- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")- `...`: further arguments passed to other methods (currently not used) Returnsa genpop object DescriptionThe function `new` has a method for building genpop objects.', 'See the class description of genpop for more information on this data structure.', 'The functions `genpop` and `as.genpop` are aliases for `new(""genpop"", ...)`.', 'DetailsMost users do not need using the constructor, but merely to convert raw allele data using `genind2genpop`.', 'See Alsothe description of the genpop class; `df2genind` and related functions for reading raw allele data']",1," methods genpop constructor```r S4 method for signature 'genpop'initialize(  .Object,  tab,  prevcall = NULL,  ploidy = 2L,  type = c(""codom"", ""PA""),  ...)genpop(...)as.genpop(...)``` Arguments- `.Object`: prototyped object (generated automatically when calling 'new')- `tab`: A matrix of integers corresponding to the @tab slot of a genpop object, with individuals in rows and alleles in columns, and containing either allele counts- `prevcall`: an optional call to be stored in the object- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")- `...`: further arguments passed to other methods (currently not used) Returnsa genpop object DescriptionThe function `new` has a method for building genpop objects. See the class description of genpop for more information on this data structure. The functions `genpop` and `as.genpop` are aliases for `new(""genpop"", ...)`. DetailsMost users do not need using the constructor, but merely to convert raw allele data using `genind2genpop`. See Alsothe description of the genpop class; `df2genind` and related functions for reading raw allele data",14
adegenet,colorplot.md,"# Represents a cloud of points with colors

## Description

The `colorplot` function represents a cloud of points with colors corresponding to a combination of 1,2 or 3 quantitative variables, assigned to RGB (Red, Green, Blue) channels. For instance, this can be useful to represent up to 3 principal components in space. Note that the property of such representation to convey multidimensional information has not been investigated.

 `colorplot` is a S3 generic function. Methods are defined for particular objects, like `spca` objects.

```r
colorplot(...)

## Default S3 method:
colorplot(xy, X, axes=NULL, add.plot=FALSE, defaultLevel=0, transp=FALSE, alpha=.5, ...)
```

## Arguments

- `xy`: a numeric matrix with two columns (e.g. a matrix of spatial coordinates.
- `X`: a matrix-like containing numeric values that are translated into the RGB system. Variables are considered to be in columns.
- `axes`: the index of the columns of X to be represented. Up to three axes can be chosen. If null, up to the first three columns of X are used.
- `add.plot`: a logical stating whether the colorplot should be added to the existing plot (defaults to FALSE).
- `defaultLevel`: a numeric value between 0 and 1, giving the default level in a color for which values are not specified. Used whenever less than three axes are specified.
- `transp`: a logical stating whether the produced colors should be transparent (TRUE) or not (FALSE, default).
- `alpha`: the alpha level for transparency, between 0 (fully transparent) and 1 (not transparent); see `?rgb` for more details.
- ``...``: further arguments to be passed to other methods. In `colorplot.default`, these arguments are passed to plot/points functions. See `?plot.default` and `?points`.

## Returns

Invisibly returns a vector of colours used in the plot.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
# a toy example
xy <- expand.grid(1:10,1:10)
df <- data.frame(x=1:100, y=100:1, z=runif(100,0,100))
colorplot(xy,df,cex=10,main=""colorplot: toy example"")

## Not run:

# a genetic example using a sPCA
if(require(spdep)){
data(spcaIllus)
dat3 <- spcaIllus$dat3
spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)
colorplot(spca3, cex=4, main=""colorplot: a sPCA example"")
text(spca3$xy[,1], spca3$xy[,2], dat3$pop)
mtext(""P1-P2 in cline\tP3 random \tP4 local repulsion"")
}
## End(Not run)
```



","['Represents a cloud of points with colors DescriptionThe `colorplot` function represents a cloud of points with colors corresponding to a combination of 1,2 or 3 quantitative variables, assigned to RGB (Red, Green, Blue) channels.', 'For instance, this can be useful to represent up to 3 principal components in space.', 'Note that the property of such representation to convey multidimensional information has not been investigated.', '`colorplot` is a S3 generic function.', 'Methods are defined for particular objects, like `spca` objects.```rcolorplot(...) Default S3 method:colorplot(xy, X, axes=NULL, add.plot=FALSE, defaultLevel=0, transp=FALSE, alpha=.5, ...)``` Arguments- `xy`: a numeric matrix with two columns (e.g.', 'a matrix of spatial coordinates.- `X`: a matrix-like containing numeric values that are translated into the RGB system.', 'Variables are considered to be in columns.- `axes`: the index of the columns of X to be represented.', 'Up to three axes can be chosen.', 'If null, up to the first three columns of X are used.- `add.plot`: a logical stating whether the colorplot should be added to the existing plot (defaults to FALSE).- `defaultLevel`: a numeric value between 0 and 1, giving the default level in a color for which values are not specified.', 'Used whenever less than three axes are specified.- `transp`: a logical stating whether the produced colors should be transparent (TRUE) or not (FALSE, default).- `alpha`: the alpha level for transparency, between 0 (fully transparent) and 1 (not transparent); see `?rgb` for more details.- ``...``: further arguments to be passed to other methods.', 'In `colorplot.default`, these arguments are passed to plot/points functions.', 'ReturnsInvisibly returns a vector of colours used in the plot.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r a toy examplexy <- expand.grid(1:10,1:10)df <- data.frame(x=1:100, y=100:1, z=runif(100,0,100))colorplot(xy,df,cex=10,main=""colorplot: toy example"") Not run: a genetic example using a sPCAif(require(spdep)){data(spcaIllus)dat3 <- spcaIllus$dat3spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)colorplot(spca3, cex=4, main=""colorplot: a sPCA example"")text(spca3$xy[,1], spca3$xy[,2], dat3$pop)mtext(""P1-P2 in cline\\tP3 random \\tP4 local repulsion"")} End(Not run)```']",1," Represents a cloud of points with colors DescriptionThe `colorplot` function represents a cloud of points with colors corresponding to a combination of 1,2 or 3 quantitative variables, assigned to RGB (Red, Green, Blue) channels. For instance, this can be useful to represent up to 3 principal components in space. Note that the property of such representation to convey multidimensional information has not been investigated. `colorplot` is a S3 generic function. Methods are defined for particular objects, like `spca` objects.```rcolorplot(...) Default S3 method:colorplot(xy, X, axes=NULL, add.plot=FALSE, defaultLevel=0, transp=FALSE, alpha=.5, ...)``` Arguments- `xy`: a numeric matrix with two columns (e.g. a matrix of spatial coordinates.- `X`: a matrix-like containing numeric values that are translated into the RGB system. Variables are considered to be in columns.- `axes`: the index of the columns of X to be represented. Up to three axes can be chosen. If null, up to the first three columns of X are used.- `add.plot`: a logical stating whether the colorplot should be added to the existing plot (defaults to FALSE).- `defaultLevel`: a numeric value between 0 and 1, giving the default level in a color for which values are not specified. Used whenever less than three axes are specified.- `transp`: a logical stating whether the produced colors should be transparent (TRUE) or not (FALSE, default).- `alpha`: the alpha level for transparency, between 0 (fully transparent) and 1 (not transparent); see `?rgb` for more details.- ``...``: further arguments to be passed to other methods. In `colorplot.default`, these arguments are passed to plot/points functions. See `?plot.default` and `?points`. ReturnsInvisibly returns a vector of colours used in the plot. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r a toy examplexy <- expand.grid(1:10,1:10)df <- data.frame(x=1:100, y=100:1, z=runif(100,0,100))colorplot(xy,df,cex=10,main=""colorplot: toy example"") Not run: a genetic example using a sPCAif(require(spdep)){data(spcaIllus)dat3 <- spcaIllus$dat3spca3 <- spca(dat3,xy=dat3$other$xy,ask=FALSE,type=1,plot=FALSE,scannf=FALSE,nfposi=1,nfnega=1)colorplot(spca3, cex=4, main=""colorplot: a sPCA example"")text(spca3$xy[,1], spca3$xy[,2], dat3$pop)mtext(""P1-P2 in cline\tP3 random \tP4 local repulsion"")} End(Not run)```",14
adegenet,dist.genpop.md,"UTF-8

# Genetic distances between populations

## Description

This function computes measures of genetic distances between populations using a `genpop` object.

Currently, five distances are available, some of which are euclidian (see details).

A non-euclidian distance can be transformed into an Euclidean one using `cailliez` in order to perform a Principal Coordinate Analysis `dudi.pco` (both functions in `ade4`).

The function `dist.genpop` is based on former `dist.genet` function of `ade4` package.

```r
dist.genpop(x, method = 1, diag = FALSE, upper = FALSE)
```

## Arguments

- `x`: a list of class `genpop`
- `method`: an integer between 1 and 5. See details
- `diag`: a logical value indicating whether the diagonal of the distance matrix should be printed by `print.dist`
- `upper`: a logical value indicating whether the upper triangle of the distance matrix should be printed by `print.dist`

## Details

Let A a table containing allelic frequencies with **t** populations (rows) and **m** alleles (columns).

Let `\nu` the number of loci. The locus **j** gets **m(j)** alleles. `m=\sum_{j=1}^{\nu} m(j)`

For the row **i** and the modality **k** of the variable **j**, notice the value `a_{ij}^k` (`1 \leq i \leq t`, `1 \leq j \leq \nu`, `1 \leq k \leq m(j)`) the value of the initial table.

`a_{ij}^+=\sum_{k=1}^{m(j)}a_{ij}^k` and `p_{ij}^k=\frac{a_{ij}^k}{a_{ij}^+}`

Let P the table of general term `p_{ij}^k`

`p_{ij}^+=\sum_{k=1}^{m(j)}p_{ij}^k=1`, `p_{i+}^+=\sum_{j=1}^{\nu}p_{ij}^+=\nu`, `p_{++}^+=\sum_{j=1}^{\nu}p_{i+}^+=t\nu`

The option `method` computes the distance matrices between populations using the frequencies `p_{ij}^k`.

1. Nei's distance (not Euclidean):

c(""`D_1(a,b)=- \\ln(\\frac{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`p_{aj}^k p_{bj}^k}{\\sqrt{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`{(p_{aj}^k) }^2}\\sqrt{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`{(p_{bj}^k)}^2}})`"")

2. Angular distance or Edwards' distance (Euclidean):

c(""`D_2(a,b)=\\sqrt{1-\\frac{1}{\\nu} \\sum_{k=1}^{\\nu}\n`"", ""`\\sum_{j=1}^{m(k)} \\sqrt{p_{aj}^k  p_{bj}^k}}`"")

3. Coancestrality coefficient or Reynolds' distance (Eucledian):

c(""`D_3(a,b)=\\sqrt{\\frac{\\sum_{k=1}^{\\nu}\n`"", ""`\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}{2 \\sum_{k=1}^{\\nu} (1-\n`"", ""`\\sum_{j=1}^{m(k)}p_{aj}^k p_{bj}^k)}}`"")

4. Classical Euclidean distance or Rogers' distance (Eucledian):

c(""`D_4(a,b)=\\frac{1}{\\nu} \\sum_{k=1}^{\\nu} \\sqrt{\\frac{1}{2}\n`"", ""`\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}`"")

5. Absolute genetics distance or Provesti 's distance (not Euclidean):

c(""`D_5(a,b)=\\frac{1}{2{\\nu}} \\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`|p_{aj}^k - p_{bj}^k|`"")

## Returns

returns a distance matrix of class `dist` between the rows of the data frame

## References

To complete informations about distances:

Distance 1:

Nei, M. (1972) Genetic distances between populations. **American Naturalist**, 106 , 283--292.

Nei M. (1978) Estimation of average heterozygosity and genetic distance from a small number of individuals. **Genetics**, 23 , 341--369.

Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman & Hall, London.

Distance 2:

Edwards, A.W.F. (1971) Distance between populations on the basis of gene frequencies. **Biometrics**, 27 , 873--881.

Cavalli-Sforza L.L. and Edwards A.W.F. (1967) Phylogenetic analysis: models and estimation procedures. **Evolution**, 32 , 550--570.

Hartl, D.L. and Clark, A.G. (1989) Principles of population genetics. Sinauer Associates, Sunderland, Massachussetts (p. 303).

Distance 3:

Reynolds, J. B., B. S. Weir, and C. C. Cockerham. (1983) Estimation of the coancestry coefficient: basis for a short-term genetic distance. **Genetics**, 105 , 767--779.

Distance 4:

Rogers, J.S. (1972) Measures of genetic similarity and genetic distances. **Studies in Genetics**, Univ. Texas Publ., 7213 , 145--153.

Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman & Hall, London.

Distance 5:

Prevosti A. (1974) La distancia genetica entre poblaciones. **Miscellanea Alcobe**, 68 , 109--118.

Prevosti A., Ocaña J. and Alonso G. (1975) Distances between populations of Drosophila subobscura, based on chromosome arrangements frequencies. **Theoretical and Applied Genetics**, 45 , 231--241.

For more information on dissimilarity indexes:

Gower J. and Legendre P. (1986) Metric and Euclidean properties of dissimilarity coefficients. **Journal of Classification**, 3 , 5--48

Legendre P. and Legendre L. (1998) **Numerical Ecology**, Elsevier Science B.V. 20, pp274--288.

 

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

Former dist.genet code by Daniel Chessel chessel@biomserv.univ-lyon1.fr

and documentation by Anne B. Dufour dufour@biomserv.univ-lyon1.fr

## See Also

`cailliez`,`dudi.pco`

## Examples

```r
## Not run:

data(microsatt)
obj <- as.genpop(microsatt$tab)

listDist <- lapply(1:5, function(i) cailliez(dist.genpop(obj,met=i)))
for(i in 1:5) {attr(listDist[[i]],""Labels"") <- popNames(obj)}
listPco <- lapply(listDist, dudi.pco,scannf=FALSE)

par(mfrow=c(2,3))
for(i in 1:5) {scatter(listPco[[i]],sub=paste(""Dist:"", i))}
## End(Not run)
```



","['UTF-8 Genetic distances between populations DescriptionThis function computes measures of genetic distances between populations using a `genpop` object.Currently, five distances are available, some of which are euclidian (see details).A non-euclidian distance can be transformed into an Euclidean one using `cailliez` in order to perform a Principal Coordinate Analysis `dudi.pco` (both functions in `ade4`).The function `dist.genpop` is based on former `dist.genet` function of `ade4` package.```rdist.genpop(x, method = 1, diag = FALSE, upper = FALSE)``` Arguments- `x`: a list of class `genpop`- `method`: an integer between 1 and 5.', 'See details- `diag`: a logical value indicating whether the diagonal of the distance matrix should be printed by `print.dist`- `upper`: a logical value indicating whether the upper triangle of the distance matrix should be printed by `print.dist` DetailsLet A a table containing allelic frequencies with t populations (rows) and m alleles (columns).Let `\\nu` the number of loci.', 'The locus j gets m(j) alleles.', '`m=\\sum_{j=1}^{\\nu} m(j)`For the row i and the modality k of the variable j, notice the value `a_{ij}^k` (`1 \\leq i \\leq t`, `1 \\leq j \\leq \\nu`, `1 \\leq k \\leq m(j)`) the value of the initial table.`a_{ij}^+=\\sum_{k=1}^{m(j)}a_{ij}^k` and `p_{ij}^k=\\frac{a_{ij}^k}{a_{ij}^+}`Let P the table of general term `p_{ij}^k``p_{ij}^+=\\sum_{k=1}^{m(j)}p_{ij}^k=1`, `p_{i+}^+=\\sum_{j=1}^{\\nu}p_{ij}^+=\\nu`, `p_{++}^+=\\sum_{j=1}^{\\nu}p_{i+}^+=t\\nu`The option `method` computes the distance matrices between populations using the frequencies `p_{ij}^k`.1.', 'Nei\'s distance (not Euclidean):c(""`D_1(a,b)=- \\\\ln(\\\\frac{\\\\sum_{k=1}^{\\\\nu} \\\\sum_{j=1}^{m(k)}\\n`"", ""`p_{aj}^k p_{bj}^k}{\\\\sqrt{\\\\sum_{k=1}^{\\\\nu} \\\\sum_{j=1}^{m(k)}\\n`"", ""`{(p_{aj}^k) }^2}\\\\sqrt{\\\\sum_{k=1}^{\\\\nu} \\\\sum_{j=1}^{m(k)}\\n`"", ""`{(p_{bj}^k)}^2}})`"")2.', 'Angular distance or Edwards\' distance (Euclidean):c(""`D_2(a,b)=\\\\sqrt{1-\\\\frac{1}{\\\\nu} \\\\sum_{k=1}^{\\\\nu}\\n`"", ""`\\\\sum_{j=1}^{m(k)} \\\\sqrt{p_{aj}^k  p_{bj}^k}}`"")3.', 'Coancestrality coefficient or Reynolds\' distance (Eucledian):c(""`D_3(a,b)=\\\\sqrt{\\\\frac{\\\\sum_{k=1}^{\\\\nu}\\n`"", ""`\\\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}{2 \\\\sum_{k=1}^{\\\\nu} (1-\\n`"", ""`\\\\sum_{j=1}^{m(k)}p_{aj}^k p_{bj}^k)}}`"")4.', 'Classical Euclidean distance or Rogers\' distance (Eucledian):c(""`D_4(a,b)=\\\\frac{1}{\\\\nu} \\\\sum_{k=1}^{\\\\nu} \\\\sqrt{\\\\frac{1}{2}\\n`"", ""`\\\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}`"")5.', 'Absolute genetics distance or Provesti \'s distance (not Euclidean):c(""`D_5(a,b)=\\\\frac{1}{2{\\\\nu}} \\\\sum_{k=1}^{\\\\nu} \\\\sum_{j=1}^{m(k)}\\n`"", ""`|p_{aj}^k - p_{bj}^k|`"") Returnsreturns a distance matrix of class `dist` between the rows of the data frame ReferencesTo complete informations about distances:Distance 1:Nei, M. (1972) Genetic distances between populations.', 'American Naturalist, 106 , 283--292.Nei M. (1978) Estimation of average heterozygosity and genetic distance from a small number of individuals.', 'Genetics, 23 , 341--369.Avise, J. C. (1994) Molecular markers, natural history and evolution.', 'Chapman & Hall, London.Distance 2:Edwards, A.W.F.', '(1971) Distance between populations on the basis of gene frequencies.', 'Biometrics, 27 , 873--881.Cavalli-Sforza L.L.', '(1967) Phylogenetic analysis: models and estimation procedures.', 'Evolution, 32 , 550--570.Hartl, D.L.', 'and Clark, A.G. (1989) Principles of population genetics.', 'Sinauer Associates, Sunderland, Massachussetts (p. 303).Distance 3:Reynolds, J.', 'B., B. S. Weir, and C. C. Cockerham.', '(1983) Estimation of the coancestry coefficient: basis for a short-term genetic distance.', 'Genetics, 105 , 767--779.Distance 4:Rogers, J.S.', '(1972) Measures of genetic similarity and genetic distances.', 'Texas Publ., 7213 , 145--153.Avise, J. C. (1994) Molecular markers, natural history and evolution.', 'Chapman & Hall, London.Distance 5:Prevosti A.', '(1974) La distancia genetica entre poblaciones.', 'Miscellanea Alcobe, 68 , 109--118.Prevosti A., Ocaña J. and Alonso G. (1975) Distances between populations of Drosophila subobscura, based on chromosome arrangements frequencies.', 'Theoretical and Applied Genetics, 45 , 231--241.For more information on dissimilarity indexes:Gower J. and Legendre P. (1986) Metric and Euclidean properties of dissimilarity coefficients.', 'Journal of Classification, 3 , 5--48Legendre P. and Legendre L. (1998) Numerical Ecology, Elsevier Science B.V. 20, pp274--288.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.ukFormer dist.genet code by Daniel Chessel chessel@biomserv.univ-lyon1.frand documentation by Anne B. Dufour dufour@biomserv.univ-lyon1.fr See Also`cailliez`,`dudi.pco` Examples```r Not run:data(microsatt)obj <- as.genpop(microsatt$tab)listDist <- lapply(1:5, function(i) cailliez(dist.genpop(obj,met=i)))for(i in 1:5) {attr(listDist[[i]],""Labels"") <- popNames(obj)}listPco <- lapply(listDist, dudi.pco,scannf=FALSE)par(mfrow=c(2,3))for(i in 1:5) {scatter(listPco[[i]],sub=paste(""Dist:"", i))} End(Not run)```']",1,"UTF-8 Genetic distances between populations DescriptionThis function computes measures of genetic distances between populations using a `genpop` object.Currently, five distances are available, some of which are euclidian (see details).A non-euclidian distance can be transformed into an Euclidean one using `cailliez` in order to perform a Principal Coordinate Analysis `dudi.pco` (both functions in `ade4`).The function `dist.genpop` is based on former `dist.genet` function of `ade4` package.```rdist.genpop(x, method = 1, diag = FALSE, upper = FALSE)``` Arguments- `x`: a list of class `genpop`- `method`: an integer between 1 and 5. See details- `diag`: a logical value indicating whether the diagonal of the distance matrix should be printed by `print.dist`- `upper`: a logical value indicating whether the upper triangle of the distance matrix should be printed by `print.dist` DetailsLet A a table containing allelic frequencies with t populations (rows) and m alleles (columns).Let `\nu` the number of loci. The locus j gets m(j) alleles. `m=\sum_{j=1}^{\nu} m(j)`For the row i and the modality k of the variable j, notice the value `a_{ij}^k` (`1 \leq i \leq t`, `1 \leq j \leq \nu`, `1 \leq k \leq m(j)`) the value of the initial table.`a_{ij}^+=\sum_{k=1}^{m(j)}a_{ij}^k` and `p_{ij}^k=\frac{a_{ij}^k}{a_{ij}^+}`Let P the table of general term `p_{ij}^k``p_{ij}^+=\sum_{k=1}^{m(j)}p_{ij}^k=1`, `p_{i+}^+=\sum_{j=1}^{\nu}p_{ij}^+=\nu`, `p_{++}^+=\sum_{j=1}^{\nu}p_{i+}^+=t\nu`The option `method` computes the distance matrices between populations using the frequencies `p_{ij}^k`.1. Nei's distance (not Euclidean):c(""`D_1(a,b)=- \\ln(\\frac{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`p_{aj}^k p_{bj}^k}{\\sqrt{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`{(p_{aj}^k) }^2}\\sqrt{\\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`{(p_{bj}^k)}^2}})`"")2. Angular distance or Edwards' distance (Euclidean):c(""`D_2(a,b)=\\sqrt{1-\\frac{1}{\\nu} \\sum_{k=1}^{\\nu}\n`"", ""`\\sum_{j=1}^{m(k)} \\sqrt{p_{aj}^k  p_{bj}^k}}`"")3. Coancestrality coefficient or Reynolds' distance (Eucledian):c(""`D_3(a,b)=\\sqrt{\\frac{\\sum_{k=1}^{\\nu}\n`"", ""`\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}{2 \\sum_{k=1}^{\\nu} (1-\n`"", ""`\\sum_{j=1}^{m(k)}p_{aj}^k p_{bj}^k)}}`"")4. Classical Euclidean distance or Rogers' distance (Eucledian):c(""`D_4(a,b)=\\frac{1}{\\nu} \\sum_{k=1}^{\\nu} \\sqrt{\\frac{1}{2}\n`"", ""`\\sum_{j=1}^{m(k)}{(p_{aj}^k - p_{bj}^k)}^2}`"")5. Absolute genetics distance or Provesti 's distance (not Euclidean):c(""`D_5(a,b)=\\frac{1}{2{\\nu}} \\sum_{k=1}^{\\nu} \\sum_{j=1}^{m(k)}\n`"", ""`|p_{aj}^k - p_{bj}^k|`"") Returnsreturns a distance matrix of class `dist` between the rows of the data frame ReferencesTo complete informations about distances:Distance 1:Nei, M. (1972) Genetic distances between populations. American Naturalist, 106 , 283--292.Nei M. (1978) Estimation of average heterozygosity and genetic distance from a small number of individuals. Genetics, 23 , 341--369.Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman & Hall, London.Distance 2:Edwards, A.W.F. (1971) Distance between populations on the basis of gene frequencies. Biometrics, 27 , 873--881.Cavalli-Sforza L.L. and Edwards A.W.F. (1967) Phylogenetic analysis: models and estimation procedures. Evolution, 32 , 550--570.Hartl, D.L. and Clark, A.G. (1989) Principles of population genetics. Sinauer Associates, Sunderland, Massachussetts (p. 303).Distance 3:Reynolds, J. B., B. S. Weir, and C. C. Cockerham. (1983) Estimation of the coancestry coefficient: basis for a short-term genetic distance. Genetics, 105 , 767--779.Distance 4:Rogers, J.S. (1972) Measures of genetic similarity and genetic distances. Studies in Genetics, Univ. Texas Publ., 7213 , 145--153.Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman & Hall, London.Distance 5:Prevosti A. (1974) La distancia genetica entre poblaciones. Miscellanea Alcobe, 68 , 109--118.Prevosti A., Ocaña J. and Alonso G. (1975) Distances between populations of Drosophila subobscura, based on chromosome arrangements frequencies. Theoretical and Applied Genetics, 45 , 231--241.For more information on dissimilarity indexes:Gower J. and Legendre P. (1986) Metric and Euclidean properties of dissimilarity coefficients. Journal of Classification, 3 , 5--48Legendre P. and Legendre L. (1998) Numerical Ecology, Elsevier Science B.V. 20, pp274--288.  Author(s)Thibaut Jombart t.jombart@imperial.ac.ukFormer dist.genet code by Daniel Chessel chessel@biomserv.univ-lyon1.frand documentation by Anne B. Dufour dufour@biomserv.univ-lyon1.fr See Also`cailliez`,`dudi.pco` Examples```r Not run:data(microsatt)obj <- as.genpop(microsatt$tab)listDist <- lapply(1:5, function(i) cailliez(dist.genpop(obj,met=i)))for(i in 1:5) {attr(listDist[[i]],""Labels"") <- popNames(obj)}listPco <- lapply(listDist, dudi.pco,scannf=FALSE)par(mfrow=c(2,3))for(i in 1:5) {scatter(listPco[[i]],sub=paste(""Dist:"", i))} End(Not run)```",14
adegenet,old2new.md,"# Convert objects with obsolete classes into new objects

```r
old2new_genind(object, donor = new(""genind""))

old2new_genlight(object, donor = new(""genlight""))

old2new_genpop(object, donor = new(""genpop""))
```

## Arguments

- `object`: a genind or genlight object from version 1.4 or earlier.
- `donor`: a new object to place all the data into.

## Description

The genind and genlight objects have changed in Adegenet version 2.0. They have each gained strata and hierarchy slots. What's more is that the genind objects have been optimized for storage and now store the tab slot as integers instead of numerics. This function will convert old genind or genlight objects to new ones seamlessly.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

Zhian N. Kamvar kamvarz@science.oregonstate.edu



","['Convert objects with obsolete classes into new objects```rold2new_genind(object, donor = new(""genind""))old2new_genlight(object, donor = new(""genlight""))old2new_genpop(object, donor = new(""genpop""))``` Arguments- `object`: a genind or genlight object from version 1.4 or earlier.- `donor`: a new object to place all the data into.', 'DescriptionThe genind and genlight objects have changed in Adegenet version 2.0.', 'They have each gained strata and hierarchy slots.', ""What's more is that the genind objects have been optimized for storage and now store the tab slot as integers instead of numerics."", 'This function will convert old genind or genlight objects to new ones seamlessly.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.ukZhian N. Kamvar kamvarz@science.oregonstate.edu']",1," Convert objects with obsolete classes into new objects```rold2new_genind(object, donor = new(""genind""))old2new_genlight(object, donor = new(""genlight""))old2new_genpop(object, donor = new(""genpop""))``` Arguments- `object`: a genind or genlight object from version 1.4 or earlier.- `donor`: a new object to place all the data into. DescriptionThe genind and genlight objects have changed in Adegenet version 2.0. They have each gained strata and hierarchy slots. What's more is that the genind objects have been optimized for storage and now store the tab slot as integers instead of numerics. This function will convert old genind or genlight objects to new ones seamlessly. Author(s)Thibaut Jombart t.jombart@imperial.ac.ukZhian N. Kamvar kamvarz@science.oregonstate.edu",14
adegenet,read.genetix.md,"# Reading data from GENETIX

```r
read.genetix(file = NULL, quiet = FALSE)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the appropriate extension.
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).

## Returns

an object of the class `genind`

## Description

The function `read.genetix` reads GENETIX data files (.gtx) and convert them into a genind object.

## Details

Note: `read.genetix` is meant for DIPLOID DATA ONLY. Haploid data with the GENETIX format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`.

## Examples

```r
obj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))
obj
```

## References

Belkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France).

## See Also

`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genepop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading data from GENETIX```rread.genetix(file = NULL, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).', 'Returnsan object of the class `genind` DescriptionThe function `read.genetix` reads GENETIX data files (.gtx) and convert them into a genind object.', 'DetailsNote: `read.genetix` is meant for DIPLOID DATA ONLY.', ""Haploid data with the GENETIX format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`."", 'Examples```robj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))obj``` ReferencesBelkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations.', 'Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France).', 'See Also`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Reading data from GENETIX```rread.genetix(file = NULL, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE). Returnsan object of the class `genind` DescriptionThe function `read.genetix` reads GENETIX data files (.gtx) and convert them into a genind object. DetailsNote: `read.genetix` is meant for DIPLOID DATA ONLY. Haploid data with the GENETIX format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`. Examples```robj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))obj``` ReferencesBelkhir K., Borsa P., Chikhi L., Raufaste N. & Bonhomme F. (1996-2004) GENETIX 4.05, logiciel sous Windows TM pour la genetique des populations. Laboratoire Genome, Populations, Interactions, CNRS UMR 5000, Universite de Montpellier II, Montpellier (France). See Also`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",15
adegenet,as-methods.md,"methods

# Converting genind/genpop objects to other classes

## Description

These S3 and S4 methods are used to coerce genind and genpop objects to matrix-like objects. In most cases, this is equivalent to calling the `@tab` slot. An exception to this is the convertion to `ktab` objects used in the ade4 package as inputs for K-tables methods (e.g. Multiple Coinertia Analysis).

## Usage

`as(object, Class)`

## Arguments

- **`object`**: a genind or a genpop object.
- **`Class`**: the name of the class to which the object should be coerced, for instance `""data.frame""` or `""matrix""`.

## Methods

- **coerce**: from one object class to another using `as(object,""Class"")`, where the `object` is of the old class and the returned object is of the new class `""Class""`.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(microbov)
x <- tab(microbov,NA.method=""mean"")
as(x[1:3],""data.frame"")

## dudi functions attempt to convert their first argument
## to a data.frame; so they can be used on genind/genpop objects.
## perform a PCA
pca1 <- dudi.pca(x, scale=FALSE, scannf=FALSE)
pca1

x <- genind2genpop(microbov,miss=""chi2"")
x <- as(x,""ktab"")
class(x)
## perform a STATIS analysis
statis1 <- statis(x, scannf=FALSE)
statis1
plot(statis1)
## End(Not run)
```



","['methods Converting genind/genpop objects to other classes DescriptionThese S3 and S4 methods are used to coerce genind and genpop objects to matrix-like objects.', 'In most cases, this is equivalent to calling the `@tab` slot.', 'An exception to this is the convertion to `ktab` objects used in the ade4 package as inputs for K-tables methods (e.g.', 'Usage`as(object, Class)` Arguments- `object`: a genind or a genpop object.- `Class`: the name of the class to which the object should be coerced, for instance `""data.frame""` or `""matrix""`.', 'Methods- coerce: from one object class to another using `as(object,""Class"")`, where the `object` is of the old class and the returned object is of the new class `""Class""`.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(microbov)x <- tab(microbov,NA.method=""mean"")as(x[1:3],""data.frame"") dudi functions attempt to convert their first argument to a data.frame; so they can be used on genind/genpop objects.', 'perform a PCApca1 <- dudi.pca(x, scale=FALSE, scannf=FALSE)pca1x <- genind2genpop(microbov,miss=""chi2"")x <- as(x,""ktab"")class(x) perform a STATIS analysisstatis1 <- statis(x, scannf=FALSE)statis1plot(statis1) End(Not run)```']",1,"methods Converting genind/genpop objects to other classes DescriptionThese S3 and S4 methods are used to coerce genind and genpop objects to matrix-like objects. In most cases, this is equivalent to calling the `@tab` slot. An exception to this is the convertion to `ktab` objects used in the ade4 package as inputs for K-tables methods (e.g. Multiple Coinertia Analysis). Usage`as(object, Class)` Arguments- `object`: a genind or a genpop object.- `Class`: the name of the class to which the object should be coerced, for instance `""data.frame""` or `""matrix""`. Methods- coerce: from one object class to another using `as(object,""Class"")`, where the `object` is of the old class and the returned object is of the new class `""Class""`. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(microbov)x <- tab(microbov,NA.method=""mean"")as(x[1:3],""data.frame"") dudi functions attempt to convert their first argument to a data.frame; so they can be used on genind/genpop objects. perform a PCApca1 <- dudi.pca(x, scale=FALSE, scannf=FALSE)pca1x <- genind2genpop(microbov,miss=""chi2"")x <- as(x,""ktab"")class(x) perform a STATIS analysisstatis1 <- statis(x, scannf=FALSE)statis1plot(statis1) End(Not run)```",15
adegenet,snpposi.md,"UTF-8

# Analyse the position of polymorphic sites

## Description

These functions are used to describe the distribution of polymorphic sites (SNPs) in an alignment.

The function `snpposi.plot` plots the positions and density of SNPs in the alignment.

The function `snpposi.test` tests whether SNPs are randomly distributed in the genome, the alternative hypothesis being that they are clustered. This test is based on the distances of each SNP to the closest SNP. This provides one measure of clustering for each SNP. Different statistics can be used to summarise these values (argument `stat`), but by default the statistics used is the median.

 `snpposi.plot` and `snpposi.test` are generic functions with methods for vectors of integers or numeric (indicating SNP position), and for `DNAbin` objects.

```r
snpposi.plot(...)

## S3 method for class 'integer'
snpposi.plot(x, genome.size, smooth=0.1,
              col=""royalblue"", alpha=.2, codon=TRUE, start.at=1, ...)

## S3 method for class 'numeric'
snpposi.plot(x, ...)

## S3 method for class 'DNAbin'
snpposi.plot(x, ...)


snpposi.test(...)

## S3 method for class 'integer'
snpposi.test(x, genome.size, n.sim=999, stat=median, ...)

## S3 method for class 'numeric'
snpposi.test(x, ...)

## S3 method for class 'DNAbin'
snpposi.test(x, ...)
```

## Arguments

- `x`: a vector of integers or numerics containing SNP positions, or a set of aligned sequences in a `DNAbin` object.
- `genome.size`: an integer indicating the length of genomes.
- `smooth`: a smoothing parameter for the density estimation; smaller values will give more local peaks; values have to be positive but can be less than 1.
- `col`: the color to be used for the plot; ignored if codon positions are represented.
- `alpha`: the alpha level to be used for transparency (density curve).
- `codon`: a logical indicating if codon position should be indicated (TRUE, default) or not.
- `start.at`: an integer indicating at which base of a codon the alignment starts (defaults to 1); values other than 1, 2 and 3 will be ignored.
- `n.sim`: an integer indicating the number of randomizations to be used in the Monte Carlo test.
- `stat`: a function used to summarize the measure of physical proximity between SNPs; by default, the median is used.
- ``...``: further arguments to be passed to the `integer` method.

## Returns

A Monte Carlo test of the class `randtest`.

## See Also

The `fasta2DNAbin` to read fasta alignments with minimum RAM use.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk .

## Examples

```r
if(require(ape)){
data(woodmouse)
snpposi.plot(woodmouse, codon=FALSE)
snpposi.plot(woodmouse)

## Not run:

snpposi.test(c(1,3,4,5), 100)
snpposi.test(woodmouse)
## End(Not run)

}
```



","['UTF-8 Analyse the position of polymorphic sites DescriptionThese functions are used to describe the distribution of polymorphic sites (SNPs) in an alignment.The function `snpposi.plot` plots the positions and density of SNPs in the alignment.The function `snpposi.test` tests whether SNPs are randomly distributed in the genome, the alternative hypothesis being that they are clustered.', 'This test is based on the distances of each SNP to the closest SNP.', 'This provides one measure of clustering for each SNP.', 'Different statistics can be used to summarise these values (argument `stat`), but by default the statistics used is the median.', '`snpposi.plot` and `snpposi.test` are generic functions with methods for vectors of integers or numeric (indicating SNP position), and for `DNAbin` objects.```rsnpposi.plot(...) S3 method for class \'integer\'snpposi.plot(x, genome.size, smooth=0.1,              col=""royalblue"", alpha=.2, codon=TRUE, start.at=1, ...) S3 method for class \'numeric\'snpposi.plot(x, ...) S3 method for class \'DNAbin\'snpposi.plot(x, ...)snpposi.test(...) S3 method for class \'integer\'snpposi.test(x, genome.size, n.sim=999, stat=median, ...) S3 method for class \'numeric\'snpposi.test(x, ...) S3 method for class \'DNAbin\'snpposi.test(x, ...)``` Arguments- `x`: a vector of integers or numerics containing SNP positions, or a set of aligned sequences in a `DNAbin` object.- `genome.size`: an integer indicating the length of genomes.- `smooth`: a smoothing parameter for the density estimation; smaller values will give more local peaks; values have to be positive but can be less than 1.- `col`: the color to be used for the plot; ignored if codon positions are represented.- `alpha`: the alpha level to be used for transparency (density curve).- `codon`: a logical indicating if codon position should be indicated (TRUE, default) or not.- `start.at`: an integer indicating at which base of a codon the alignment starts (defaults to 1); values other than 1, 2 and 3 will be ignored.- `n.sim`: an integer indicating the number of randomizations to be used in the Monte Carlo test.- `stat`: a function used to summarize the measure of physical proximity between SNPs; by default, the median is used.- ``...``: further arguments to be passed to the `integer` method.', 'ReturnsA Monte Carlo test of the class `randtest`.', 'See AlsoThe `fasta2DNAbin` to read fasta alignments with minimum RAM use.', 'Examples```rif(require(ape)){data(woodmouse)snpposi.plot(woodmouse, codon=FALSE)snpposi.plot(woodmouse) Not run:snpposi.test(c(1,3,4,5), 100)snpposi.test(woodmouse) End(Not run)}```']",1,"UTF-8 Analyse the position of polymorphic sites DescriptionThese functions are used to describe the distribution of polymorphic sites (SNPs) in an alignment.The function `snpposi.plot` plots the positions and density of SNPs in the alignment.The function `snpposi.test` tests whether SNPs are randomly distributed in the genome, the alternative hypothesis being that they are clustered. This test is based on the distances of each SNP to the closest SNP. This provides one measure of clustering for each SNP. Different statistics can be used to summarise these values (argument `stat`), but by default the statistics used is the median. `snpposi.plot` and `snpposi.test` are generic functions with methods for vectors of integers or numeric (indicating SNP position), and for `DNAbin` objects.```rsnpposi.plot(...) S3 method for class 'integer'snpposi.plot(x, genome.size, smooth=0.1,              col=""royalblue"", alpha=.2, codon=TRUE, start.at=1, ...) S3 method for class 'numeric'snpposi.plot(x, ...) S3 method for class 'DNAbin'snpposi.plot(x, ...)snpposi.test(...) S3 method for class 'integer'snpposi.test(x, genome.size, n.sim=999, stat=median, ...) S3 method for class 'numeric'snpposi.test(x, ...) S3 method for class 'DNAbin'snpposi.test(x, ...)``` Arguments- `x`: a vector of integers or numerics containing SNP positions, or a set of aligned sequences in a `DNAbin` object.- `genome.size`: an integer indicating the length of genomes.- `smooth`: a smoothing parameter for the density estimation; smaller values will give more local peaks; values have to be positive but can be less than 1.- `col`: the color to be used for the plot; ignored if codon positions are represented.- `alpha`: the alpha level to be used for transparency (density curve).- `codon`: a logical indicating if codon position should be indicated (TRUE, default) or not.- `start.at`: an integer indicating at which base of a codon the alignment starts (defaults to 1); values other than 1, 2 and 3 will be ignored.- `n.sim`: an integer indicating the number of randomizations to be used in the Monte Carlo test.- `stat`: a function used to summarize the measure of physical proximity between SNPs; by default, the median is used.- ``...``: further arguments to be passed to the `integer` method. ReturnsA Monte Carlo test of the class `randtest`. See AlsoThe `fasta2DNAbin` to read fasta alignments with minimum RAM use. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk . Examples```rif(require(ape)){data(woodmouse)snpposi.plot(woodmouse, codon=FALSE)snpposi.plot(woodmouse) Not run:snpposi.test(c(1,3,4,5), 100)snpposi.test(woodmouse) End(Not run)}```",15
adegenet,gengraph.md,"UTF-8

# Genetic transitive graphs

## Description

These functions are under development. Please email the author before using them for published work.

The function `gengraph` generates graphs based on genetic distances, so that pairs of entities (individuals or populations) are connected if and only if they are distant by less than a given threshold distance. Graph algorithms and classes from the `igraph` package are used.

 `gengraph` is a generic function with methods for the following types of objects:

- `matrix` (only numeric data)

- `dist`

- `genind` objects (genetic markers, individuals)

- `genpop` objects (genetic markers, populations)

- `DNAbin` objects (DNA sequences)

```r
gengraph(x, ...)

## S3 method for class 'matrix'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'dist'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'genind'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)

## S3 method for class 'genpop'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, method=1,
           truenames=TRUE, nbreaks=10, ...)

## S3 method for class 'DNAbin'
gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,
           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,
           nbreaks=10, ...)
```

## Arguments

- `x`: a `matrix`, `dist`, `genind`, `genpop`, or `DNAbin` object. For `matrix` and `dist`, the object represents pairwise (by default, Hamming) distances between considered individuals.
- `cutoff`: a `numeric` value indicating the cutoff point, i.e. the distance at which two entities are no longer connected in the garph produced by the method.
- `ngrp`: an `integer` indicating the number of groups to be looked for. A message is issued if this exact number could not be found.
- `computeAll`: a `logical` stating whether to investigate solutions for every (integer) cutoff point; defaults to FALSE.
- `plot`: a `logical` indicating whether plots should be drawn; defaults to TRUE; this operation can take time for large, highly-connected graphs.
- `show.graph`: a `logical` indicating whether the found graph should be drawn, only used in the interactive mode; this operation can take time for large, highly-connected graphs; defaults to FALSE.
- `col.pal`: a color palette used to define group colors.
- `method`: an `integer` ranging from 1 to 6 indicating the type of method to be used to derive a matrix of pairwise distances between populations; values from 1 to 5 are passed to the function `dist.genpop`; other values are not supported.
- `truenames`: a logical indicating whether original labels should be used for plotting (TRUE), as opposed to indices of sequences (FALSE).
- `nbreaks`: an integer indicating the number of breaks used by the heuristic when seeking an exact number of groups.
- ``...``: further arguments to be used by other functions; currently not used.

## Returns

The class `gengraph` is a list with the following components:

 - **graph**: a graph of class `igraph`.

 - **clust**: a list containing group information: `$membership`: an integer giving group membership; `$csize`: the size of each cluster; `$no`: the number of clusters

 - **cutoff**: the value used as a cutoff point

 - **col**: the color used to plot each group.

## See Also

The `igraph` package.

## Author(s)

Original idea by Anne Cori and Christophe Fraser. Implementation by Thibaut Jombart t.jombart@imperial.ac.uk .

## Examples

```r
if(require(ape)){
    data(woodmouse)
    g <- gengraph(woodmouse, cutoff=5)
    g
    plot(g$graph)

}
```



","['UTF-8 Genetic transitive graphs DescriptionThese functions are under development.', 'Please email the author before using them for published work.The function `gengraph` generates graphs based on genetic distances, so that pairs of entities (individuals or populations) are connected if and only if they are distant by less than a given threshold distance.', 'Graph algorithms and classes from the `igraph` package are used.', ""`gengraph` is a generic function with methods for the following types of objects:- `matrix` (only numeric data)- `dist`- `genind` objects (genetic markers, individuals)- `genpop` objects (genetic markers, populations)- `DNAbin` objects (DNA sequences)```rgengraph(x, ...) S3 method for class 'matrix'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'dist'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'genind'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'genpop'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, method=1,           truenames=TRUE, nbreaks=10, ...) S3 method for class 'DNAbin'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...)``` Arguments- `x`: a `matrix`, `dist`, `genind`, `genpop`, or `DNAbin` object."", 'For `matrix` and `dist`, the object represents pairwise (by default, Hamming) distances between considered individuals.- `cutoff`: a `numeric` value indicating the cutoff point, i.e.', 'the distance at which two entities are no longer connected in the garph produced by the method.- `ngrp`: an `integer` indicating the number of groups to be looked for.', 'A message is issued if this exact number could not be found.- `computeAll`: a `logical` stating whether to investigate solutions for every (integer) cutoff point; defaults to FALSE.- `plot`: a `logical` indicating whether plots should be drawn; defaults to TRUE; this operation can take time for large, highly-connected graphs.- `show.graph`: a `logical` indicating whether the found graph should be drawn, only used in the interactive mode; this operation can take time for large, highly-connected graphs; defaults to FALSE.- `col.pal`: a color palette used to define group colors.- `method`: an `integer` ranging from 1 to 6 indicating the type of method to be used to derive a matrix of pairwise distances between populations; values from 1 to 5 are passed to the function `dist.genpop`; other values are not supported.- `truenames`: a logical indicating whether original labels should be used for plotting (TRUE), as opposed to indices of sequences (FALSE).- `nbreaks`: an integer indicating the number of breaks used by the heuristic when seeking an exact number of groups.- ``...``: further arguments to be used by other functions; currently not used.', 'ReturnsThe class `gengraph` is a list with the following components: - graph: a graph of class `igraph`.', '- clust: a list containing group information: `$membership`: an integer giving group membership; `$csize`: the size of each cluster; `$no`: the number of clusters - cutoff: the value used as a cutoff point - col: the color used to plot each group.', 'Author(s)Original idea by Anne Cori and Christophe Fraser.', 'Implementation by Thibaut Jombart t.jombart@imperial.ac.uk .', 'Examples```rif(require(ape)){    data(woodmouse)    g <- gengraph(woodmouse, cutoff=5)    g    plot(g$graph)}```']",1,"UTF-8 Genetic transitive graphs DescriptionThese functions are under development. Please email the author before using them for published work.The function `gengraph` generates graphs based on genetic distances, so that pairs of entities (individuals or populations) are connected if and only if they are distant by less than a given threshold distance. Graph algorithms and classes from the `igraph` package are used. `gengraph` is a generic function with methods for the following types of objects:- `matrix` (only numeric data)- `dist`- `genind` objects (genetic markers, individuals)- `genpop` objects (genetic markers, populations)- `DNAbin` objects (DNA sequences)```rgengraph(x, ...) S3 method for class 'matrix'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'dist'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'genind'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...) S3 method for class 'genpop'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, method=1,           truenames=TRUE, nbreaks=10, ...) S3 method for class 'DNAbin'gengraph(x, cutoff=NULL, ngrp=NULL, computeAll=FALSE,           plot=TRUE, show.graph=TRUE, col.pal=funky, truenames=TRUE,           nbreaks=10, ...)``` Arguments- `x`: a `matrix`, `dist`, `genind`, `genpop`, or `DNAbin` object. For `matrix` and `dist`, the object represents pairwise (by default, Hamming) distances between considered individuals.- `cutoff`: a `numeric` value indicating the cutoff point, i.e. the distance at which two entities are no longer connected in the garph produced by the method.- `ngrp`: an `integer` indicating the number of groups to be looked for. A message is issued if this exact number could not be found.- `computeAll`: a `logical` stating whether to investigate solutions for every (integer) cutoff point; defaults to FALSE.- `plot`: a `logical` indicating whether plots should be drawn; defaults to TRUE; this operation can take time for large, highly-connected graphs.- `show.graph`: a `logical` indicating whether the found graph should be drawn, only used in the interactive mode; this operation can take time for large, highly-connected graphs; defaults to FALSE.- `col.pal`: a color palette used to define group colors.- `method`: an `integer` ranging from 1 to 6 indicating the type of method to be used to derive a matrix of pairwise distances between populations; values from 1 to 5 are passed to the function `dist.genpop`; other values are not supported.- `truenames`: a logical indicating whether original labels should be used for plotting (TRUE), as opposed to indices of sequences (FALSE).- `nbreaks`: an integer indicating the number of breaks used by the heuristic when seeking an exact number of groups.- ``...``: further arguments to be used by other functions; currently not used. ReturnsThe class `gengraph` is a list with the following components: - graph: a graph of class `igraph`. - clust: a list containing group information: `$membership`: an integer giving group membership; `$csize`: the size of each cluster; `$no`: the number of clusters - cutoff: the value used as a cutoff point - col: the color used to plot each group. See AlsoThe `igraph` package. Author(s)Original idea by Anne Cori and Christophe Fraser. Implementation by Thibaut Jombart t.jombart@imperial.ac.uk . Examples```rif(require(ape)){    data(woodmouse)    g <- gengraph(woodmouse, cutoff=5)    g    plot(g$graph)}```",15
adegenet,as.SNPbin.md,"# Conversion to class ""SNPbin""

## Description

The class SNPbin is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme. New instances of this class are best created using `new`; see the manpage of SNPbin for more information on this point.

As a shortcut, conversion methods can be used to convert various objects into a SNPbin object. Conversions can be achieved using S3-style (`as.SNPbin(x)`) or S4-style (`as(x,""SNPbin""`) procedures. All of them call upon the constructor (`new`) of SNPbin objects.

Conversion is currently available from the following objects: - integer vectors - numeric vectors

## Author(s)

Thibaut Jombart (t.jombart@imperial.ac.uk )

## See Also

Related class:

- `SNPbin` - `genlight`, for storing multiple binary SNP genotypes.

## Examples

```r
## Not run:

## data to be converted
dat <- c(1,0,0,2,1,1,1,2,2,1,1,0,0,1)

## using the constructor
x1 <- new(""SNPbin"", dat)
x1

## using 'as' methods
x2 <- as.SNPbin(dat)
x3 <- as(dat, ""SNPbin"")

identical(x1,x2)
identical(x1,x3)
## End(Not run)
```



","['Conversion to class ""SNPbin"" DescriptionThe class SNPbin is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme.', 'New instances of this class are best created using `new`; see the manpage of SNPbin for more information on this point.As a shortcut, conversion methods can be used to convert various objects into a SNPbin object.', 'Conversions can be achieved using S3-style (`as.SNPbin(x)`) or S4-style (`as(x,""SNPbin""`) procedures.', 'All of them call upon the constructor (`new`) of SNPbin objects.Conversion is currently available from the following objects: - integer vectors - numeric vectors Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `SNPbin` - `genlight`, for storing multiple binary SNP genotypes.', 'Examples```r Not run: data to be converteddat <- c(1,0,0,2,1,1,1,2,2,1,1,0,0,1) using the constructorx1 <- new(""SNPbin"", dat)x1 using \'as\' methodsx2 <- as.SNPbin(dat)x3 <- as(dat, ""SNPbin"")identical(x1,x2)identical(x1,x3) End(Not run)```']",1," Conversion to class ""SNPbin"" DescriptionThe class SNPbin is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme. New instances of this class are best created using `new`; see the manpage of SNPbin for more information on this point.As a shortcut, conversion methods can be used to convert various objects into a SNPbin object. Conversions can be achieved using S3-style (`as.SNPbin(x)`) or S4-style (`as(x,""SNPbin""`) procedures. All of them call upon the constructor (`new`) of SNPbin objects.Conversion is currently available from the following objects: - integer vectors - numeric vectors Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `SNPbin` - `genlight`, for storing multiple binary SNP genotypes. Examples```r Not run: data to be converteddat <- c(1,0,0,2,1,1,1,2,2,1,1,0,0,1) using the constructorx1 <- new(""SNPbin"", dat)x1 using 'as' methodsx2 <- as.SNPbin(dat)x3 <- as(dat, ""SNPbin"")identical(x1,x2)identical(x1,x3) End(Not run)```",15
adegenet,auxil.md,"UTF-8

methods

# Auxiliary functions for adegenet

## Description

adegenet implements a number of auxiliary procedures that might be of interest for users. These include graphical tools to translate variables (numeric or factors) onto a color scale, adding transparency to existing colors, pre-defined color palettes, extra functions to access documentation, and low-level treatment of character vectors.

These functions are mostly auxiliary procedures used internally in adegenet.

These items include:

 * `num2col`: translates a numeric vector into colors.
 * `fac2col`: translates a factor into colors.
 * `any2col`: translates a vector of type numeric, character or factor into colors.
 * `transp`: adds transparency to a vector of colors. Note that transparent colors are not supported on some graphical devices.
 * `corner`: adds text to a corner of a figure.
 * `checkType`: checks the type of markers being used in a function and issues an error if appropriate.
 * `.rmspaces`: remove peripheric spaces in a character string.
 * `.genlab`: generate labels in a correct alphanumeric ordering.
 * `.readExt`: read the extension of a given file.
 * `.render.server.info` used to display session information for the dapcServer

Color palettes include:

 * `bluepal`: white -\> dark blue
 * `redpal`: white -\> dark red
 * `greenpal`: white -\> dark green
 * `greypal`: white -\> dark grey
 * `flame`: gold -\> red
 * `azur`: gold -\> blue
 * `seasun`: blue -\> gold -\> red
 * `lightseasun`: blue -\> gold -\> red (light variant)
 * `deepseasun`: blue -\> gold -\> red (deep variant)
 * `spectral`: red -\> yellow -\> blue (RColorBrewer variant)
 * `wasp`: gold -\> brown -\> black
 * `funky`: many colors
 * `virid`: adaptation of the `viridis` palette, from the `viridis` package.
 * `hybridpal`: reorder a color palette (`virid` by default) to display sharp contrast between the first two colors, and interpolated colors after; ideal for datasets where two parental populations are provided first, followed by various degrees of hybrids.

## See Also

The R package RColorBrewer, proposing a nice selection of color palettes. The `viridis` package, with many excellent palettes.

```r
.genlab(base, n)
corner(text, posi=""topleft"",  inset=0.1, ...)
num2col(x, col.pal=heat.colors, reverse=FALSE,
        x.min=min(x,na.rm=TRUE), x.max=max(x,na.rm=TRUE),
        na.col=""transparent"")
fac2col(x, col.pal=funky, na.col=""transparent"", seed=NULL)
any2col(x, col.pal=seasun, na.col=""transparent"")
transp(col, alpha=.5)
hybridpal(col.pal = virid)
```

## Arguments

- `base`: a character string forming the base of the labels
- `n`: the number of labels to generate
- `text`: a character string to be added to the plot
- `posi`: a character matching any combinations of ""top/bottom"" and ""left/right"".
- `inset`: a vector of two numeric values (recycled if needed) indicating the inset, as a fraction of the plotting region.
- ``...``: further arguments to be passed to `text`
- `x`: a numeric vector (for `num2col`) or a vector converted to a factor (for `fac2col`).
- `col.pal`: a function generating colors according to a given palette.
- `reverse`: a logical stating whether the palette should be inverted (TRUE), or not (FALSE, default).
- `x.min`: the minimal value from which to start the color scale
- `x.max`: the maximal value from which to start the color scale
- `na.col`: the color to be used for missing values (NAs)
- `seed`: a seed for R's random number generated, used to fix the random permutation of colors in the palette used; if NULL, no randomization is used and the colors are taken from the palette according to the ordering of the levels.
- `col`: a vector of colors
- `alpha`: a numeric value between 0 and 1 representing the alpha coefficient; 0: total transparency; 1: no transparency.

## Returns

For `.genlab`, a character vector of size ""n"". `num2col` and `fac2col` return a vector of colors. `any2col` returns a list with the following components: `$col` (a vector of colors), `$leg.col` (colors for the legend), and `$leg.txt` (text for the legend).

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
.genlab(""Locus-"",11)

## transparent colors using ""transp""
plot(rnorm(1000), rnorm(1000), col=transp(""blue"",.3), pch=20, cex=4)


## numeric values to color using num2col
plot(1:100, col=num2col(1:100), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=bluepal), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=flame), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=wasp), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=azur,rev=TRUE), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=spectral), pch=20, cex=4)
plot(1:100, col=num2col(1:100, col.pal=virid), pch=20, cex=4)

## factor as colors using fac2col
dat <- cbind(c(rnorm(50,8), rnorm(100), rnorm(150,3),
rnorm(50,10)),c(rnorm(50,1),rnorm(100),rnorm(150,3), rnorm(50,5)))
fac <- rep(letters[1:4], c(50,100,150,50))
plot(dat, col=fac2col(fac), pch=19, cex=4)
plot(dat, col=transp(fac2col(fac)), pch=19, cex=4)
plot(dat, col=transp(fac2col(fac,seed=2)), pch=19, cex=4)

## use of any2col
x <- factor(1:10)
col.info <- any2col(x, col.pal=funky)
plot(x, col=col.info$col, main=""Use of any2col on a factor"")
legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")

x <- 100:1
col.info <- any2col(x, col.pal=wasp)
barplot(x, col=col.info$col, main=""Use of any2col on a numeric"")
legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")
```



","['UTF-8methods Auxiliary functions for adegenet Descriptionadegenet implements a number of auxiliary procedures that might be of interest for users.', 'These include graphical tools to translate variables (numeric or factors) onto a color scale, adding transparency to existing colors, pre-defined color palettes, extra functions to access documentation, and low-level treatment of character vectors.These functions are mostly auxiliary procedures used internally in adegenet.These items include:  `num2col`: translates a numeric vector into colors.', '`fac2col`: translates a factor into colors.', '`any2col`: translates a vector of type numeric, character or factor into colors.', '`transp`: adds transparency to a vector of colors.', 'Note that transparent colors are not supported on some graphical devices.', '`corner`: adds text to a corner of a figure.', '`checkType`: checks the type of markers being used in a function and issues an error if appropriate.', '`.rmspaces`: remove peripheric spaces in a character string.', '`.genlab`: generate labels in a correct alphanumeric ordering.', '`.readExt`: read the extension of a given file.', '`.render.server.info` used to display session information for the dapcServerColor palettes include:  `bluepal`: white -\\> dark blue  `redpal`: white -\\> dark red  `greenpal`: white -\\> dark green  `greypal`: white -\\> dark grey  `flame`: gold -\\> red  `azur`: gold -\\> blue  `seasun`: blue -\\> gold -\\> red  `lightseasun`: blue -\\> gold -\\> red (light variant)  `deepseasun`: blue -\\> gold -\\> red (deep variant)  `spectral`: red -\\> yellow -\\> blue (RColorBrewer variant)  `wasp`: gold -\\> brown -\\> black  `funky`: many colors  `virid`: adaptation of the `viridis` palette, from the `viridis` package.', '`hybridpal`: reorder a color palette (`virid` by default) to display sharp contrast between the first two colors, and interpolated colors after; ideal for datasets where two parental populations are provided first, followed by various degrees of hybrids.', 'See AlsoThe R package RColorBrewer, proposing a nice selection of color palettes.', 'The `viridis` package, with many excellent palettes.```r.genlab(base, n)corner(text, posi=""topleft"",  inset=0.1, ...)num2col(x, col.pal=heat.colors, reverse=FALSE,        x.min=min(x,na.rm=TRUE), x.max=max(x,na.rm=TRUE),        na.col=""transparent"")fac2col(x, col.pal=funky, na.col=""transparent"", seed=NULL)any2col(x, col.pal=seasun, na.col=""transparent"")transp(col, alpha=.5)hybridpal(col.pal = virid)``` Arguments- `base`: a character string forming the base of the labels- `n`: the number of labels to generate- `text`: a character string to be added to the plot- `posi`: a character matching any combinations of ""top/bottom"" and ""left/right"".- `inset`: a vector of two numeric values (recycled if needed) indicating the inset, as a fraction of the plotting region.- ``...``: further arguments to be passed to `text`- `x`: a numeric vector (for `num2col`) or a vector converted to a factor (for `fac2col`).- `col.pal`: a function generating colors according to a given palette.- `reverse`: a logical stating whether the palette should be inverted (TRUE), or not (FALSE, default).- `x.min`: the minimal value from which to start the color scale- `x.max`: the maximal value from which to start the color scale- `na.col`: the color to be used for missing values (NAs)- `seed`: a seed for R\'s random number generated, used to fix the random permutation of colors in the palette used; if NULL, no randomization is used and the colors are taken from the palette according to the ordering of the levels.- `col`: a vector of colors- `alpha`: a numeric value between 0 and 1 representing the alpha coefficient; 0: total transparency; 1: no transparency.', 'ReturnsFor `.genlab`, a character vector of size ""n"".', '`num2col` and `fac2col` return a vector of colors.', '`any2col` returns a list with the following components: `$col` (a vector of colors), `$leg.col` (colors for the legend), and `$leg.txt` (text for the legend).', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r.genlab(""Locus-"",11) transparent colors using ""transp""plot(rnorm(1000), rnorm(1000), col=transp(""blue"",.3), pch=20, cex=4) numeric values to color using num2colplot(1:100, col=num2col(1:100), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=bluepal), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=flame), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=wasp), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=azur,rev=TRUE), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=spectral), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=virid), pch=20, cex=4) factor as colors using fac2coldat <- cbind(c(rnorm(50,8), rnorm(100), rnorm(150,3),rnorm(50,10)),c(rnorm(50,1),rnorm(100),rnorm(150,3), rnorm(50,5)))fac <- rep(letters[1:4], c(50,100,150,50))plot(dat, col=fac2col(fac), pch=19, cex=4)plot(dat, col=transp(fac2col(fac)), pch=19, cex=4)plot(dat, col=transp(fac2col(fac,seed=2)), pch=19, cex=4) use of any2colx <- factor(1:10)col.info <- any2col(x, col.pal=funky)plot(x, col=col.info$col, main=""Use of any2col on a factor"")legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")x <- 100:1col.info <- any2col(x, col.pal=wasp)barplot(x, col=col.info$col, main=""Use of any2col on a numeric"")legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")```']",1,"UTF-8methods Auxiliary functions for adegenet Descriptionadegenet implements a number of auxiliary procedures that might be of interest for users. These include graphical tools to translate variables (numeric or factors) onto a color scale, adding transparency to existing colors, pre-defined color palettes, extra functions to access documentation, and low-level treatment of character vectors.These functions are mostly auxiliary procedures used internally in adegenet.These items include:  `num2col`: translates a numeric vector into colors.  `fac2col`: translates a factor into colors.  `any2col`: translates a vector of type numeric, character or factor into colors.  `transp`: adds transparency to a vector of colors. Note that transparent colors are not supported on some graphical devices.  `corner`: adds text to a corner of a figure.  `checkType`: checks the type of markers being used in a function and issues an error if appropriate.  `.rmspaces`: remove peripheric spaces in a character string.  `.genlab`: generate labels in a correct alphanumeric ordering.  `.readExt`: read the extension of a given file.  `.render.server.info` used to display session information for the dapcServerColor palettes include:  `bluepal`: white -\> dark blue  `redpal`: white -\> dark red  `greenpal`: white -\> dark green  `greypal`: white -\> dark grey  `flame`: gold -\> red  `azur`: gold -\> blue  `seasun`: blue -\> gold -\> red  `lightseasun`: blue -\> gold -\> red (light variant)  `deepseasun`: blue -\> gold -\> red (deep variant)  `spectral`: red -\> yellow -\> blue (RColorBrewer variant)  `wasp`: gold -\> brown -\> black  `funky`: many colors  `virid`: adaptation of the `viridis` palette, from the `viridis` package.  `hybridpal`: reorder a color palette (`virid` by default) to display sharp contrast between the first two colors, and interpolated colors after; ideal for datasets where two parental populations are provided first, followed by various degrees of hybrids. See AlsoThe R package RColorBrewer, proposing a nice selection of color palettes. The `viridis` package, with many excellent palettes.```r.genlab(base, n)corner(text, posi=""topleft"",  inset=0.1, ...)num2col(x, col.pal=heat.colors, reverse=FALSE,        x.min=min(x,na.rm=TRUE), x.max=max(x,na.rm=TRUE),        na.col=""transparent"")fac2col(x, col.pal=funky, na.col=""transparent"", seed=NULL)any2col(x, col.pal=seasun, na.col=""transparent"")transp(col, alpha=.5)hybridpal(col.pal = virid)``` Arguments- `base`: a character string forming the base of the labels- `n`: the number of labels to generate- `text`: a character string to be added to the plot- `posi`: a character matching any combinations of ""top/bottom"" and ""left/right"".- `inset`: a vector of two numeric values (recycled if needed) indicating the inset, as a fraction of the plotting region.- ``...``: further arguments to be passed to `text`- `x`: a numeric vector (for `num2col`) or a vector converted to a factor (for `fac2col`).- `col.pal`: a function generating colors according to a given palette.- `reverse`: a logical stating whether the palette should be inverted (TRUE), or not (FALSE, default).- `x.min`: the minimal value from which to start the color scale- `x.max`: the maximal value from which to start the color scale- `na.col`: the color to be used for missing values (NAs)- `seed`: a seed for R's random number generated, used to fix the random permutation of colors in the palette used; if NULL, no randomization is used and the colors are taken from the palette according to the ordering of the levels.- `col`: a vector of colors- `alpha`: a numeric value between 0 and 1 representing the alpha coefficient; 0: total transparency; 1: no transparency. ReturnsFor `.genlab`, a character vector of size ""n"". `num2col` and `fac2col` return a vector of colors. `any2col` returns a list with the following components: `$col` (a vector of colors), `$leg.col` (colors for the legend), and `$leg.txt` (text for the legend). Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r.genlab(""Locus-"",11) transparent colors using ""transp""plot(rnorm(1000), rnorm(1000), col=transp(""blue"",.3), pch=20, cex=4) numeric values to color using num2colplot(1:100, col=num2col(1:100), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=bluepal), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=flame), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=wasp), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=azur,rev=TRUE), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=spectral), pch=20, cex=4)plot(1:100, col=num2col(1:100, col.pal=virid), pch=20, cex=4) factor as colors using fac2coldat <- cbind(c(rnorm(50,8), rnorm(100), rnorm(150,3),rnorm(50,10)),c(rnorm(50,1),rnorm(100),rnorm(150,3), rnorm(50,5)))fac <- rep(letters[1:4], c(50,100,150,50))plot(dat, col=fac2col(fac), pch=19, cex=4)plot(dat, col=transp(fac2col(fac)), pch=19, cex=4)plot(dat, col=transp(fac2col(fac,seed=2)), pch=19, cex=4) use of any2colx <- factor(1:10)col.info <- any2col(x, col.pal=funky)plot(x, col=col.info$col, main=""Use of any2col on a factor"")legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")x <- 100:1col.info <- any2col(x, col.pal=wasp)barplot(x, col=col.info$col, main=""Use of any2col on a numeric"")legend(""bottomleft"", fill=col.info$leg.col, legend=col.info$leg.txt, bg=""white"")```",15
adegenet,spca.md,"UTF-8

# Spatial principal component analysis

## Description

 These functions implement the spatial principal component analysis (sPCA). The function `spca` is a generic with methods for:

 * `matrix`: only numeric values are accepted
 * `data.frame`: same as for matrices
 * `genind`: any genind object is accepted
 * `genpop`: any genpop object is accepted

The core computation use `multispati` from the `adespatial` package.

Besides the set of `spca` functions, other functions include:

 * `print.spca`: prints the spca content
 * `summary.spca`: gives variance and autocorrelation statistics
 * `plot.spca`: usefull graphics (connection network, 3 different representations of map of scores, eigenvalues barplot and decomposition)
 * `screeplot.spca`: decomposes spca eigenvalues into variance and autocorrelation
 * `colorplot.spca`: represents principal components of sPCA in space using the RGB system.

 A tutorial on sPCA can be opened using:

 `adegenetTutorial(which=""spca"")`.

```r
spca(...)

## Default S3 method:
spca(x, ...)

## S3 method for class 'matrix'
spca(x, xy = NULL, cn = NULL, matWeight = NULL,
            center = TRUE, scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'data.frame'
spca(x, xy = NULL, cn = NULL, matWeight = NULL,
            center = TRUE, scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'genind'
spca(obj, xy = NULL, cn = NULL, matWeight = NULL,
            scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)

## S3 method for class 'genpop'
spca(obj, xy = NULL, cn = NULL, matWeight = NULL,
            scale = FALSE, scannf = TRUE,
            nfposi = 1, nfnega = 1,
            type = NULL, ask = TRUE,
            plot.nb = TRUE, edit.nb = FALSE,
            truenames = TRUE,
            d1 = NULL, d2 = NULL, k = NULL,
            a = NULL, dmin = NULL, ...)


## S3 method for class 'spca'
print(x, ...)

## S3 method for class 'spca'
summary(object, ..., printres=TRUE)

## S3 method for class 'spca'
plot(x, axis = 1, useLag=FALSE, ...)

## S3 method for class 'spca'
screeplot(x, ..., main=NULL)

## S3 method for class 'spca'
colorplot(x, axes=1:ncol(x$li), useLag=FALSE, ...)
```

## Arguments

- `x`: a `matrix` or a `data.frame` of numeric values, with individuals in rows and variables in columns; categorical variables with a binary coding are acceptable too; for `print` and plotting functions, a spca object.
- `obj`: a `genind` or `genpop` object.
- `xy`: a matrix or data.frame with two columns for x and y coordinates. Seeked from obj$other$xy if it exists when xy is not provided. Can be NULL if a `nb` object is provided in `cn`.
    
    Longitude/latitude coordinates should be converted first by a given projection (see 'See Also' section).
- `cn`: a connection network of the class 'nb' (package spdep). Can be NULL if xy is provided. Can be easily obtained using the function chooseCN (see details).
- `matWeight`: a square matrix of spatial weights, indicating the spatial proximities between entities. If provided, this argument prevails over `cn` (see details).
- `center`: a logical indicating whether data should be centred to a mean of zero; used implicitely for genind or genpop objects.
- `scale`: a logical indicating whether data should be scaled to unit variance (TRUE) or not (FALSE, default).
- `scannf`: a logical stating whether eigenvalues should be chosen interactively (TRUE, default) or not (FALSE).
- `nfposi`: an integer giving the number of positive eigenvalues retained ('global structures').
- `nfnega`: an integer giving the number of negative eigenvalues retained ('local structures').
- `type`: an integer giving the type of graph (see details in `chooseCN` help page). If provided, `ask` is set to FALSE.
- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE).
- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).
- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).
- `truenames`: a logical stating whether true names should be used for 'obj' (TRUE, default) instead of generic labels (FALSE)
- `d1`: the minimum distance between any two neighbours. Used if `type=5.`
- `d2`: the maximum distance between any two neighbours. Used if `type=5`.
- `k`: the number of neighbours per point. Used if `type=6`.
- `a`: the exponent of the inverse distance matrix. Used if `type=7`.
- `dmin`: the minimum distance between any two distinct points. Used to avoid infinite spatial proximities (defined as the inversed spatial distances). Used if `type=7`.
- `object`: a `spca` object.
- `printres`: a logical stating whether results should be printed on the screen (TRUE, default) or not (FALSE).
- `axis`: an integer between 1 and (nfposi+nfnega) indicating which axis should be plotted.
- `main`: a title for the screeplot; if NULL, a default one is used.
- ``...``: further arguments passed to other methods.
- `axes`: the index of the columns of X to be represented. Up to three axes can be chosen.
- `useLag`: a logical stating whether the lagged components (`x$ls`) should be used instead of the components (`x$li`).

## Details

The spatial principal component analysis (sPCA) is designed to investigate spatial patterns in the genetic variability. Given multilocus genotypes (individual level) or allelic frequency (population level) and spatial coordinates, it finds individuals (or population) scores maximizing the product of variance and spatial autocorrelation (Moran's I). Large positive and negative eigenvalues correspond to global and local structures.

Spatial weights can be obtained in several ways, depending how the arguments `xy`, `cn`, and `matWeight` are set.

When several acceptable ways are used at the same time, priority is as follows:

 `matWeight` > `cn` > `xy`

## Returns

The class `spca` are given to lists with the following components:

 - **eig**: a numeric vector of eigenvalues.

 - **nfposi**: an integer giving the number of global structures retained.

 - **nfnega**: an integer giving the number of local structures retained.

 - **c1**: a data.frame of alleles loadings for each axis.

 - **li**: a data.frame of row (individuals or populations) coordinates onto the sPCA axes.

 - **ls**: a data.frame of lag vectors of the row coordinates; useful to clarify maps of global scores .

 - **as**: a data.frame giving the coordinates of the PCA axes onto the sPCA axes.

 - **call**: the matched call.

 - **xy**: a matrix of spatial coordinates.

 - **lw**: a list of spatial weights of class `listw`.

Other functions have different outputs:

- `summary.spca` returns a list with 3 components: `Istat` giving the null, minimum and maximum Moran's I values; `pca` gives variance and I statistics for the principal component analysis; `spca` gives variance and I statistics for the sPCA.

- `plot.spca` returns the matched call.

- `screeplot.spca` returns the matched call.

## References

Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. **Heredity**, 101 , 92--103.

Wartenberg, D. E. (1985) Multivariate spatial correlation: a method for exploratory geographical analysis. **Geographical Analysis**, 17 , 263--283.

Moran, P.A.P. (1948) The interpretation of statistical maps. **Journal of the Royal Statistical Society, B**

10 , 243--251.

Moran, P.A.P. (1950) Notes on continuous stochastic phenomena. **Biometrika**, 37 , 17--23.

de Jong, P. and Sprenger, C. and van Veen, F. (1984) On extreme values of Moran's I and Geary's c. **Geographical Analysis**, 16 , 17--24.

## See Also

`spcaIllus` and `rupica` for datasets illustrating the sPCA

 `global.rtest` and `local.rtest`

 `chooseCN`, `multispati`

 `convUL`, from the package 'PBSmapping' to convert longitude/latitude to UTM coordinates.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## data(spcaIllus) illustrates the sPCA
## see ?spcaIllus
##
## Not run:

example(spcaIllus)
example(rupica)
## End(Not run)
```



","['UTF-8 Spatial principal component analysis Description These functions implement the spatial principal component analysis (sPCA).', 'The function `spca` is a generic with methods for:  `matrix`: only numeric values are accepted  `data.frame`: same as for matrices  `genind`: any genind object is accepted  `genpop`: any genpop object is acceptedThe core computation use `multispati` from the `adespatial` package.Besides the set of `spca` functions, other functions include:  `print.spca`: prints the spca content  `summary.spca`: gives variance and autocorrelation statistics  `plot.spca`: usefull graphics (connection network, 3 different representations of map of scores, eigenvalues barplot and decomposition)  `screeplot.spca`: decomposes spca eigenvalues into variance and autocorrelation  `colorplot.spca`: represents principal components of sPCA in space using the RGB system.', 'A tutorial on sPCA can be opened using: `adegenetTutorial(which=""spca"")`.```rspca(...) Default S3 method:spca(x, ...) S3 method for class \'matrix\'spca(x, xy = NULL, cn = NULL, matWeight = NULL,            center = TRUE, scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class \'data.frame\'spca(x, xy = NULL, cn = NULL, matWeight = NULL,            center = TRUE, scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class \'genind\'spca(obj, xy = NULL, cn = NULL, matWeight = NULL,            scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class \'genpop\'spca(obj, xy = NULL, cn = NULL, matWeight = NULL,            scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class \'spca\'print(x, ...) S3 method for class \'spca\'summary(object, ..., printres=TRUE) S3 method for class \'spca\'plot(x, axis = 1, useLag=FALSE, ...) S3 method for class \'spca\'screeplot(x, ..., main=NULL) S3 method for class \'spca\'colorplot(x, axes=1:ncol(x$li), useLag=FALSE, ...)``` Arguments- `x`: a `matrix` or a `data.frame` of numeric values, with individuals in rows and variables in columns; categorical variables with a binary coding are acceptable too; for `print` and plotting functions, a spca object.- `obj`: a `genind` or `genpop` object.- `xy`: a matrix or data.frame with two columns for x and y coordinates.', 'Seeked from obj$other$xy if it exists when xy is not provided.', 'Can be NULL if a `nb` object is provided in `cn`.', ""Longitude/latitude coordinates should be converted first by a given projection (see 'See Also' section).- `cn`: a connection network of the class 'nb' (package spdep)."", 'Can be NULL if xy is provided.', 'Can be easily obtained using the function chooseCN (see details).- `matWeight`: a square matrix of spatial weights, indicating the spatial proximities between entities.', ""If provided, this argument prevails over `cn` (see details).- `center`: a logical indicating whether data should be centred to a mean of zero; used implicitely for genind or genpop objects.- `scale`: a logical indicating whether data should be scaled to unit variance (TRUE) or not (FALSE, default).- `scannf`: a logical stating whether eigenvalues should be chosen interactively (TRUE, default) or not (FALSE).- `nfposi`: an integer giving the number of positive eigenvalues retained ('global structures').- `nfnega`: an integer giving the number of negative eigenvalues retained ('local structures').- `type`: an integer giving the type of graph (see details in `chooseCN` help page)."", ""If provided, `ask` is set to FALSE.- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE).- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).- `truenames`: a logical stating whether true names should be used for 'obj' (TRUE, default) instead of generic labels (FALSE)- `d1`: the minimum distance between any two neighbours."", 'Used if `type=5.`- `d2`: the maximum distance between any two neighbours.', 'Used if `type=5`.- `k`: the number of neighbours per point.', 'Used if `type=6`.- `a`: the exponent of the inverse distance matrix.', 'Used if `type=7`.- `dmin`: the minimum distance between any two distinct points.', 'Used to avoid infinite spatial proximities (defined as the inversed spatial distances).', 'Used if `type=7`.- `object`: a `spca` object.- `printres`: a logical stating whether results should be printed on the screen (TRUE, default) or not (FALSE).- `axis`: an integer between 1 and (nfposi+nfnega) indicating which axis should be plotted.- `main`: a title for the screeplot; if NULL, a default one is used.- ``...``: further arguments passed to other methods.- `axes`: the index of the columns of X to be represented.', 'Up to three axes can be chosen.- `useLag`: a logical stating whether the lagged components (`x$ls`) should be used instead of the components (`x$li`).', 'DetailsThe spatial principal component analysis (sPCA) is designed to investigate spatial patterns in the genetic variability.', ""Given multilocus genotypes (individual level) or allelic frequency (population level) and spatial coordinates, it finds individuals (or population) scores maximizing the product of variance and spatial autocorrelation (Moran's I)."", 'Large positive and negative eigenvalues correspond to global and local structures.Spatial weights can be obtained in several ways, depending how the arguments `xy`, `cn`, and `matWeight` are set.When several acceptable ways are used at the same time, priority is as follows: `matWeight` > `cn` > `xy` ReturnsThe class `spca` are given to lists with the following components: - eig: a numeric vector of eigenvalues.', '- nfposi: an integer giving the number of global structures retained.', '- nfnega: an integer giving the number of local structures retained.', '- c1: a data.frame of alleles loadings for each axis.', '- li: a data.frame of row (individuals or populations) coordinates onto the sPCA axes.', '- ls: a data.frame of lag vectors of the row coordinates; useful to clarify maps of global scores .', '- as: a data.frame giving the coordinates of the PCA axes onto the sPCA axes.', '- call: the matched call.', '- xy: a matrix of spatial coordinates.', ""- lw: a list of spatial weights of class `listw`.Other functions have different outputs:- `summary.spca` returns a list with 3 components: `Istat` giving the null, minimum and maximum Moran's I values; `pca` gives variance and I statistics for the principal component analysis; `spca` gives variance and I statistics for the sPCA.- `plot.spca` returns the matched call.- `screeplot.spca` returns the matched call."", 'ReferencesJombart, T., Devillard, S., Dufour, A.-B.', 'and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method.', 'Heredity, 101 , 92--103.Wartenberg, D. E. (1985) Multivariate spatial correlation: a method for exploratory geographical analysis.', 'Geographical Analysis, 17 , 263--283.Moran, P.A.P.', '(1948) The interpretation of statistical maps.', 'Journal of the Royal Statistical Society, B10 , 243--251.Moran, P.A.P.', '(1950) Notes on continuous stochastic phenomena.', ""Biometrika, 37 , 17--23.de Jong, P. and Sprenger, C. and van Veen, F. (1984) On extreme values of Moran's I and Geary's c. Geographical Analysis, 16 , 17--24."", ""See Also`spcaIllus` and `rupica` for datasets illustrating the sPCA `global.rtest` and `local.rtest` `chooseCN`, `multispati` `convUL`, from the package 'PBSmapping' to convert longitude/latitude to UTM coordinates."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r data(spcaIllus) illustrates the sPCA see ?spcaIllus Not run:example(spcaIllus)example(rupica) End(Not run)```']",1,"UTF-8 Spatial principal component analysis Description These functions implement the spatial principal component analysis (sPCA). The function `spca` is a generic with methods for:  `matrix`: only numeric values are accepted  `data.frame`: same as for matrices  `genind`: any genind object is accepted  `genpop`: any genpop object is acceptedThe core computation use `multispati` from the `adespatial` package.Besides the set of `spca` functions, other functions include:  `print.spca`: prints the spca content  `summary.spca`: gives variance and autocorrelation statistics  `plot.spca`: usefull graphics (connection network, 3 different representations of map of scores, eigenvalues barplot and decomposition)  `screeplot.spca`: decomposes spca eigenvalues into variance and autocorrelation  `colorplot.spca`: represents principal components of sPCA in space using the RGB system. A tutorial on sPCA can be opened using: `adegenetTutorial(which=""spca"")`.```rspca(...) Default S3 method:spca(x, ...) S3 method for class 'matrix'spca(x, xy = NULL, cn = NULL, matWeight = NULL,            center = TRUE, scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class 'data.frame'spca(x, xy = NULL, cn = NULL, matWeight = NULL,            center = TRUE, scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class 'genind'spca(obj, xy = NULL, cn = NULL, matWeight = NULL,            scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class 'genpop'spca(obj, xy = NULL, cn = NULL, matWeight = NULL,            scale = FALSE, scannf = TRUE,            nfposi = 1, nfnega = 1,            type = NULL, ask = TRUE,            plot.nb = TRUE, edit.nb = FALSE,            truenames = TRUE,            d1 = NULL, d2 = NULL, k = NULL,            a = NULL, dmin = NULL, ...) S3 method for class 'spca'print(x, ...) S3 method for class 'spca'summary(object, ..., printres=TRUE) S3 method for class 'spca'plot(x, axis = 1, useLag=FALSE, ...) S3 method for class 'spca'screeplot(x, ..., main=NULL) S3 method for class 'spca'colorplot(x, axes=1:ncol(x$li), useLag=FALSE, ...)``` Arguments- `x`: a `matrix` or a `data.frame` of numeric values, with individuals in rows and variables in columns; categorical variables with a binary coding are acceptable too; for `print` and plotting functions, a spca object.- `obj`: a `genind` or `genpop` object.- `xy`: a matrix or data.frame with two columns for x and y coordinates. Seeked from obj$other$xy if it exists when xy is not provided. Can be NULL if a `nb` object is provided in `cn`.        Longitude/latitude coordinates should be converted first by a given projection (see 'See Also' section).- `cn`: a connection network of the class 'nb' (package spdep). Can be NULL if xy is provided. Can be easily obtained using the function chooseCN (see details).- `matWeight`: a square matrix of spatial weights, indicating the spatial proximities between entities. If provided, this argument prevails over `cn` (see details).- `center`: a logical indicating whether data should be centred to a mean of zero; used implicitely for genind or genpop objects.- `scale`: a logical indicating whether data should be scaled to unit variance (TRUE) or not (FALSE, default).- `scannf`: a logical stating whether eigenvalues should be chosen interactively (TRUE, default) or not (FALSE).- `nfposi`: an integer giving the number of positive eigenvalues retained ('global structures').- `nfnega`: an integer giving the number of negative eigenvalues retained ('local structures').- `type`: an integer giving the type of graph (see details in `chooseCN` help page). If provided, `ask` is set to FALSE.- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE).- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).- `truenames`: a logical stating whether true names should be used for 'obj' (TRUE, default) instead of generic labels (FALSE)- `d1`: the minimum distance between any two neighbours. Used if `type=5.`- `d2`: the maximum distance between any two neighbours. Used if `type=5`.- `k`: the number of neighbours per point. Used if `type=6`.- `a`: the exponent of the inverse distance matrix. Used if `type=7`.- `dmin`: the minimum distance between any two distinct points. Used to avoid infinite spatial proximities (defined as the inversed spatial distances). Used if `type=7`.- `object`: a `spca` object.- `printres`: a logical stating whether results should be printed on the screen (TRUE, default) or not (FALSE).- `axis`: an integer between 1 and (nfposi+nfnega) indicating which axis should be plotted.- `main`: a title for the screeplot; if NULL, a default one is used.- ``...``: further arguments passed to other methods.- `axes`: the index of the columns of X to be represented. Up to three axes can be chosen.- `useLag`: a logical stating whether the lagged components (`x$ls`) should be used instead of the components (`x$li`). DetailsThe spatial principal component analysis (sPCA) is designed to investigate spatial patterns in the genetic variability. Given multilocus genotypes (individual level) or allelic frequency (population level) and spatial coordinates, it finds individuals (or population) scores maximizing the product of variance and spatial autocorrelation (Moran's I). Large positive and negative eigenvalues correspond to global and local structures.Spatial weights can be obtained in several ways, depending how the arguments `xy`, `cn`, and `matWeight` are set.When several acceptable ways are used at the same time, priority is as follows: `matWeight` > `cn` > `xy` ReturnsThe class `spca` are given to lists with the following components: - eig: a numeric vector of eigenvalues. - nfposi: an integer giving the number of global structures retained. - nfnega: an integer giving the number of local structures retained. - c1: a data.frame of alleles loadings for each axis. - li: a data.frame of row (individuals or populations) coordinates onto the sPCA axes. - ls: a data.frame of lag vectors of the row coordinates; useful to clarify maps of global scores . - as: a data.frame giving the coordinates of the PCA axes onto the sPCA axes. - call: the matched call. - xy: a matrix of spatial coordinates. - lw: a list of spatial weights of class `listw`.Other functions have different outputs:- `summary.spca` returns a list with 3 components: `Istat` giving the null, minimum and maximum Moran's I values; `pca` gives variance and I statistics for the principal component analysis; `spca` gives variance and I statistics for the sPCA.- `plot.spca` returns the matched call.- `screeplot.spca` returns the matched call. ReferencesJombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. Heredity, 101 , 92--103.Wartenberg, D. E. (1985) Multivariate spatial correlation: a method for exploratory geographical analysis. Geographical Analysis, 17 , 263--283.Moran, P.A.P. (1948) The interpretation of statistical maps. Journal of the Royal Statistical Society, B10 , 243--251.Moran, P.A.P. (1950) Notes on continuous stochastic phenomena. Biometrika, 37 , 17--23.de Jong, P. and Sprenger, C. and van Veen, F. (1984) On extreme values of Moran's I and Geary's c. Geographical Analysis, 16 , 17--24. See Also`spcaIllus` and `rupica` for datasets illustrating the sPCA `global.rtest` and `local.rtest` `chooseCN`, `multispati` `convUL`, from the package 'PBSmapping' to convert longitude/latitude to UTM coordinates. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r data(spcaIllus) illustrates the sPCA see ?spcaIllus Not run:example(spcaIllus)example(rupica) End(Not run)```",15
adegenet,seqTrack.md,"# SeqTrack algorithm for reconstructing genealogies

## Description

The SeqTrack algorithm [1] aims at reconstructing genealogies of sampled haplotypes or genotypes for which a collection date is available. Contrary to phylogenetic methods which aims at reconstructing hypothetical ancestors for observed sequences, SeqTrack considers that ancestors and descendents are sampled together, and therefore infers ancestry relationships among the sampled sequences.

This approach proved more efficient than phylogenetic approaches for reconstructing transmission trees in densely sampled disease outbreaks [1]. This implementation defines a generic function `seqTrack` with methods for specific object classes.

```r
seqTrack(...)

## S3 method for class 'matrix'
seqTrack(x, x.names, x.dates, best = c(""min"", ""max""),
    prox.mat = NULL, mu = NULL, haplo.length = NULL, ...)

## S3 method for class 'seqTrack'
as.igraph(x, col.pal=redpal, ...)

## S3 method for class 'seqTrack'
plot(x, y=NULL, col.pal=redpal, ...)

plotSeqTrack(x, xy, use.arrows=TRUE, annot=TRUE, labels=NULL, col=NULL,
                         bg=""grey"", add=FALSE, quiet=FALSE,
                         date.range=NULL, jitter.arrows=0, plot=TRUE, ...)

get.likelihood(...)

## S3 method for class 'seqTrack'
get.likelihood(x, mu, haplo.length, ...)
```

## Arguments

- `x`: for seqTrack, a matrix giving weights to pairs of ancestries such that x[i,j] is the weight of 'i ancestor of j'. For plotSeqTrack and get.likelihood. seqTrack, a `seqTrack` object.
- `x.names`: a character vector giving the labels of the haplotypes/genotypes
- `x.dates`: a vector of collection dates for the sampled haplotypes/genotypes. Dates must have the POSIXct format. See `details` or `?as.POSIXct` for more information.
- `best`: a character string matching 'min' or 'max', indicating whether genealogies should minimize or maximize the sum of weights of ancestries.
- `prox.mat`: an optional matrix of proximities between haplotypes/genotypes used to resolve ties in the choice of ancestors, by picking up the 'closest' ancestor amongst possible ancestors, in the sense of `prox.mat`. `prox.mat[i,j]` must indicate a proximity for the relationship 'i ancestor to j'. For instance, if `prox.mat` contains spatial proximities, then `prox.mat[i,j]` gives a measure of how easy it is to migrate from location 'i' to 'j'.
- `mu`: (optional) a mutation rate, per site and per day. When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `haplo.length` to be provided).
- `haplo.length`: (optional) the length of analysed sequences in number of nucleotides. When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `mu` to be provided).
- `y`: unused argument, for compatibility with 'plot'.
- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph. See `?num2col`. Note that the palette is inversed by default.
- `xy`: spatial coordinates of the sampled haplotypes/genotypes.
- `use.arrows`: a logical indicating whether arrows should be used to represented ancestries (pointing from ancestor to descendent, TRUE), or whether segments shall be used (FALSE).
- `annot`: a logical indicating whether arrows or segments representing ancestries should be annotated (TRUE) or not (FALSE).
- `labels`: a character vector containing annotations of the ancestries. If left empty, ancestries are annotated by the descendent.
- `col`: a vector of colors to be used for plotting ancestries.
- `bg`: a color to be used as background.
- `add`: a logical stating whether the plot should be added to current figure (TRUE), or drawn as a new plot (FALSE, default).
- `quiet`: a logical stating whether messages other than errors should be displayed (FALSE, default), or hidden (TRUE).
- `date.range`: a vector of length two with POSIXct format indicating the time window for which ancestries should be displayed.
- `jitter.arrows`: a positive number indicating the amount of noise to be added to coordinates of arrows; useful when several arrows overlap. See `jitter`.
- `plot`: a logical stating whether a plot should be drawn (TRUE, default), or not (FALSE). In all cases, the function invisibly returns plotting information.
- ``: further arguments to be passed to other methods

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## References

Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. Heredity. doi: 10.1038/hdy.2010.78.

## Returns

=== output of seqTrack ===

seqTrack function returns data.frame with the class `seqTrack`, in which each row is an inferred ancestry described by the following columns: - id: indices identifying haplotypes/genotypes

- ances: index of the inferred ancestor

- weight: weight of the inferred ancestries

- date: date of the haplotype/genotype

- ances.date: date of the ancestor

=== output of plotSeqTrack ===

This graphical function invisibly returns the coordinates of the arrows/segments drawn and their colors, as a data.frame.

## Details

=== Maximum parsimony genealogies ===

Maximum parsimony genealogies can be obtained easily using this implementation of seqTrack. One has to provide in `x` a matrix of genetic distances. The most straightforward distance is the number of differing nucleotides. See `dist.dna` in the ape package for a wide range of genetic distances between aligned sequences. The argument `best` should be set to ""min"" (its default value), so that the identified genealogy minimizes the total number of mutations. If `x` contains number of mutations, then `mu` and `haplo.length` should also be provided for resolving ties in equally parsimonious ancestors using maximum likelihood.

=== Likelihood of observed genetic differentiation ===

The probability of oberving a given number of mutations between a sequence and its ancestor can be computed using `get.likelihood.seqTrack`. Note that this is only possible if `x` contained number of mutations.

=== Plotting/converting seqTrack objects to graphs ===

seqTrack objects are best plotted as graphs. From adegenet_1.3-5 onwards, seqTrack objects can be converted to `igraph` objects (from the package `igraph`), which can in turn be plotted and manipulated using classical graph tools. The plot method does this operation automatically, using colors to represent edge weights, and using time-ordering of the data from top (ancient) to bottom (recent).

## See Also

`dist.dna` in the ape package to compute pairwise genetic distances in aligned sequences.

## Examples

```r
## Not run:

if(require(ape && require(igraph))){
## ANALYSIS OF SIMULATED DATA ##
## SIMULATE A GENEALOGY
dat <- haploGen(seq.l=1e4, repro=function(){sample(1:4,1)}, gen.time=1, t.max=3)
plot(dat, main=""Simulated data"")

## SEQTRACK ANALYSIS
res <- seqTrack(dat, mu=0.0001, haplo.length=1e4) 
plot(res, main=""seqTrack reconstruction"")

## PROPORTION OF CORRECT RECONSTRUCTION
mean(dat$ances==res$ances,na.rm=TRUE)


## ANALYSIS OF PANDEMIC A/H1N1 INFLUENZA DATA ##
## note:
## this is for reproduction purpose only
## seqTrack is best kept for the analysis
## of densely sampled outbreaks, which
## is not the case of this dataset.
## 
dat <- read.csv(system.file(""files/pdH1N1-data.csv"",package=""adegenet""))
ha <-  read.dna(system.file(""files/pdH1N1-HA.fasta"",package=""adegenet""), format=""fa"")
na <- read.dna(system.file(""files/pdH1N1-NA.fasta"",package=""adegenet""), format=""fa"")


## COMPUTE NUCLEOTIDIC DISTANCES
nbNucl <- ncol(as.matrix(ha)) + ncol(as.matrix(na))
D <- dist.dna(ha,model=""raw"")*ncol(as.matrix(ha)) +
dist.dna(na,model=""raw"")*ncol(as.matrix(na))
D <- round(as.matrix(D))


## MATRIX OF SPATIAL CONNECTIVITY
## (to promote local transmissions)
xy <- cbind(dat$lon, dat$lat)
temp <- as.matrix(dist(xy))
M <- 1* (temp < 1e-10)


## SEQTRACK ANALYSIS
dat$date <- as.POSIXct(dat$date)
res <- seqTrack(D, rownames(dat), dat$date, prox.mat=M, mu=.00502/365, haplo.le=nbNucl)


## COMPUTE GENETIC LIKELIHOOD
p <- get.likelihood(res, mu=.00502/365, haplo.length=nbNucl)
# (these could be shown as colors when plotting results)
# (but mutations will be used instead)


## EXAMINE RESULTS
head(res)
tail(res)
range(res$weight, na.rm=TRUE)
barplot(table(res$weight)/sum(!is.na(res$weight)), ylab=""Frequency"",
xlab=""Mutations between inferred ancestor and descendent"", col=""orange"")


## DISPLAY SPATIO-TEMPORAL DYNAMICS 
if(require(maps)){
myDates <- as.integer(difftime(dat$date, as.POSIXct(""2009-01-21""), unit=""day""))
myMonth <- as.POSIXct(
c(""2009-02-01"", ""2009-03-01"",""2009-04-01"",""2009-05-01"",""2009-06-01"",""2009-07-01""))
x.month <-  as.integer(difftime(myMonth, as.POSIXct(""2009-01-21""), unit=""day""))


## FIRST STAGE:
## SPREAD TO THE USA AND CANADA
curRange <- as.POSIXct(c(""2009-03-29"",""2009-04-25""))
par(bg=""deepskyblue"")
map(""world"", fill=TRUE, col=""grey"")
opal <- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange,
col=res$weight+1)
title(paste(curRange, collapse="" to ""))
legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"", col=1:9,
lwd=2, horiz=TRUE)


## SECOND STAGE:
## SPREAD WITHIN AMERICA, FIRST SEEDING OUTSIDE AMERICA
curRange <- as.POSIXct(c(""2009-04-30"",""2009-05-07""))
par(bg=""deepskyblue"")
map(""world"", fill=TRUE, col=""grey"")
opal <- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,
date.range=curRange, col=res$weight+1)
title(paste(curRange, collapse="" to ""))
legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",
col=1:9,lwd=2, horiz=TRUE)


## THIRD STAGE:
## PANDEMIC
curRange <- as.POSIXct(c(""2009-05-15"",""2009-05-25""))
par(bg=""deepskyblue"")
map(""world"", fill=TRUE, col=""grey"")
opal <- palette()
palette(rev(heat.colors(10)))
plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2, date.range=curRange,
col=res$weight+1)
title(paste(curRange, collapse="" to ""))
legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",
col=1:9,lwd=2, horiz=TRUE)

}
}
## End(Not run)
```



","['SeqTrack algorithm for reconstructing genealogies DescriptionThe SeqTrack algorithm [1] aims at reconstructing genealogies of sampled haplotypes or genotypes for which a collection date is available.', 'Contrary to phylogenetic methods which aims at reconstructing hypothetical ancestors for observed sequences, SeqTrack considers that ancestors and descendents are sampled together, and therefore infers ancestry relationships among the sampled sequences.This approach proved more efficient than phylogenetic approaches for reconstructing transmission trees in densely sampled disease outbreaks [1].', 'This implementation defines a generic function `seqTrack` with methods for specific object classes.```rseqTrack(...) S3 method for class \'matrix\'seqTrack(x, x.names, x.dates, best = c(""min"", ""max""),    prox.mat = NULL, mu = NULL, haplo.length = NULL, ...) S3 method for class \'seqTrack\'as.igraph(x, col.pal=redpal, ...) S3 method for class \'seqTrack\'plot(x, y=NULL, col.pal=redpal, ...)plotSeqTrack(x, xy, use.arrows=TRUE, annot=TRUE, labels=NULL, col=NULL,                         bg=""grey"", add=FALSE, quiet=FALSE,                         date.range=NULL, jitter.arrows=0, plot=TRUE, ...)get.likelihood(...) S3 method for class \'seqTrack\'get.likelihood(x, mu, haplo.length, ...)``` Arguments- `x`: for seqTrack, a matrix giving weights to pairs of ancestries such that x[i,j] is the weight of \'i ancestor of j\'.', 'seqTrack, a `seqTrack` object.- `x.names`: a character vector giving the labels of the haplotypes/genotypes- `x.dates`: a vector of collection dates for the sampled haplotypes/genotypes.', 'Dates must have the POSIXct format.', ""See `details` or `?as.POSIXct` for more information.- `best`: a character string matching 'min' or 'max', indicating whether genealogies should minimize or maximize the sum of weights of ancestries.- `prox.mat`: an optional matrix of proximities between haplotypes/genotypes used to resolve ties in the choice of ancestors, by picking up the 'closest' ancestor amongst possible ancestors, in the sense of `prox.mat`."", ""`prox.mat[i,j]` must indicate a proximity for the relationship 'i ancestor to j'."", ""For instance, if `prox.mat` contains spatial proximities, then `prox.mat[i,j]` gives a measure of how easy it is to migrate from location 'i' to 'j'.- `mu`: (optional) a mutation rate, per site and per day."", ""When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `haplo.length` to be provided).- `haplo.length`: (optional) the length of analysed sequences in number of nucleotides."", ""When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `mu` to be provided).- `y`: unused argument, for compatibility with 'plot'.- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph."", 'Note that the palette is inversed by default.- `xy`: spatial coordinates of the sampled haplotypes/genotypes.- `use.arrows`: a logical indicating whether arrows should be used to represented ancestries (pointing from ancestor to descendent, TRUE), or whether segments shall be used (FALSE).- `annot`: a logical indicating whether arrows or segments representing ancestries should be annotated (TRUE) or not (FALSE).- `labels`: a character vector containing annotations of the ancestries.', 'If left empty, ancestries are annotated by the descendent.- `col`: a vector of colors to be used for plotting ancestries.- `bg`: a color to be used as background.- `add`: a logical stating whether the plot should be added to current figure (TRUE), or drawn as a new plot (FALSE, default).- `quiet`: a logical stating whether messages other than errors should be displayed (FALSE, default), or hidden (TRUE).- `date.range`: a vector of length two with POSIXct format indicating the time window for which ancestries should be displayed.- `jitter.arrows`: a positive number indicating the amount of noise to be added to coordinates of arrows; useful when several arrows overlap.', 'See `jitter`.- `plot`: a logical stating whether a plot should be drawn (TRUE, default), or not (FALSE).', 'In all cases, the function invisibly returns plotting information.- ``: further arguments to be passed to other methods Author(s)Thibaut Jombart t.jombart@imperial.ac.uk ReferencesJombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach.', 'Returns=== output of seqTrack ===seqTrack function returns data.frame with the class `seqTrack`, in which each row is an inferred ancestry described by the following columns: - id: indices identifying haplotypes/genotypes- ances: index of the inferred ancestor- weight: weight of the inferred ancestries- date: date of the haplotype/genotype- ances.date: date of the ancestor=== output of plotSeqTrack ===This graphical function invisibly returns the coordinates of the arrows/segments drawn and their colors, as a data.frame.', 'Details=== Maximum parsimony genealogies ===Maximum parsimony genealogies can be obtained easily using this implementation of seqTrack.', 'One has to provide in `x` a matrix of genetic distances.', 'The most straightforward distance is the number of differing nucleotides.', 'See `dist.dna` in the ape package for a wide range of genetic distances between aligned sequences.', 'The argument `best` should be set to ""min"" (its default value), so that the identified genealogy minimizes the total number of mutations.', 'If `x` contains number of mutations, then `mu` and `haplo.length` should also be provided for resolving ties in equally parsimonious ancestors using maximum likelihood.=== Likelihood of observed genetic differentiation ===The probability of oberving a given number of mutations between a sequence and its ancestor can be computed using `get.likelihood.seqTrack`.', 'Note that this is only possible if `x` contained number of mutations.=== Plotting/converting seqTrack objects to graphs ===seqTrack objects are best plotted as graphs.', 'From adegenet_1.3-5 onwards, seqTrack objects can be converted to `igraph` objects (from the package `igraph`), which can in turn be plotted and manipulated using classical graph tools.', 'The plot method does this operation automatically, using colors to represent edge weights, and using time-ordering of the data from top (ancient) to bottom (recent).', 'See Also`dist.dna` in the ape package to compute pairwise genetic distances in aligned sequences.', 'Examples```r Not run:if(require(ape && require(igraph))){ ANALYSIS OF SIMULATED DATA  SIMULATE A GENEALOGYdat <- haploGen(seq.l=1e4, repro=function(){sample(1:4,1)}, gen.time=1, t.max=3)plot(dat, main=""Simulated data"") SEQTRACK ANALYSISres <- seqTrack(dat, mu=0.0001, haplo.length=1e4) plot(res, main=""seqTrack reconstruction"") PROPORTION OF CORRECT RECONSTRUCTIONmean(dat$ances==res$ances,na.rm=TRUE) ANALYSIS OF PANDEMIC A/H1N1 INFLUENZA DATA  note: this is for reproduction purpose only seqTrack is best kept for the analysis of densely sampled outbreaks, which is not the case of this dataset.', 'dat <- read.csv(system.file(""files/pdH1N1-data.csv"",package=""adegenet""))ha <-  read.dna(system.file(""files/pdH1N1-HA.fasta"",package=""adegenet""), format=""fa"")na <- read.dna(system.file(""files/pdH1N1-NA.fasta"",package=""adegenet""), format=""fa"") COMPUTE NUCLEOTIDIC DISTANCESnbNucl <- ncol(as.matrix(ha)) + ncol(as.matrix(na))D <- dist.dna(ha,model=""raw"")ncol(as.matrix(ha)) +dist.dna(na,model=""raw"")ncol(as.matrix(na))D <- round(as.matrix(D)) MATRIX OF SPATIAL CONNECTIVITY (to promote local transmissions)xy <- cbind(dat$lon, dat$lat)temp <- as.matrix(dist(xy))M <- 1 (temp < 1e-10) SEQTRACK ANALYSISdat$date <- as.POSIXct(dat$date)res <- seqTrack(D, rownames(dat), dat$date, prox.mat=M, mu=.00502/365, haplo.le=nbNucl) COMPUTE GENETIC LIKELIHOODp <- get.likelihood(res, mu=.00502/365, haplo.length=nbNucl) (these could be shown as colors when plotting results) (but mutations will be used instead) EXAMINE RESULTShead(res)tail(res)range(res$weight, na.rm=TRUE)barplot(table(res$weight)/sum(!is.na(res$weight)), ylab=""Frequency"",xlab=""Mutations between inferred ancestor and descendent"", col=""orange"") DISPLAY SPATIO-TEMPORAL DYNAMICS if(require(maps)){myDates <- as.integer(difftime(dat$date, as.POSIXct(""2009-01-21""), unit=""day""))myMonth <- as.POSIXct(c(""2009-02-01"", ""2009-03-01"",""2009-04-01"",""2009-05-01"",""2009-06-01"",""2009-07-01""))x.month <-  as.integer(difftime(myMonth, as.POSIXct(""2009-01-21""), unit=""day"")) FIRST STAGE: SPREAD TO THE USA AND CANADAcurRange <- as.POSIXct(c(""2009-03-29"",""2009-04-25""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange,col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"", col=1:9,lwd=2, horiz=TRUE) SECOND STAGE: SPREAD WITHIN AMERICA, FIRST SEEDING OUTSIDE AMERICAcurRange <- as.POSIXct(c(""2009-04-30"",""2009-05-07""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange, col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",col=1:9,lwd=2, horiz=TRUE) THIRD STAGE: PANDEMICcurRange <- as.POSIXct(c(""2009-05-15"",""2009-05-25""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2, date.range=curRange,col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",col=1:9,lwd=2, horiz=TRUE)}} End(Not run)```']",1," SeqTrack algorithm for reconstructing genealogies DescriptionThe SeqTrack algorithm [1] aims at reconstructing genealogies of sampled haplotypes or genotypes for which a collection date is available. Contrary to phylogenetic methods which aims at reconstructing hypothetical ancestors for observed sequences, SeqTrack considers that ancestors and descendents are sampled together, and therefore infers ancestry relationships among the sampled sequences.This approach proved more efficient than phylogenetic approaches for reconstructing transmission trees in densely sampled disease outbreaks [1]. This implementation defines a generic function `seqTrack` with methods for specific object classes.```rseqTrack(...) S3 method for class 'matrix'seqTrack(x, x.names, x.dates, best = c(""min"", ""max""),    prox.mat = NULL, mu = NULL, haplo.length = NULL, ...) S3 method for class 'seqTrack'as.igraph(x, col.pal=redpal, ...) S3 method for class 'seqTrack'plot(x, y=NULL, col.pal=redpal, ...)plotSeqTrack(x, xy, use.arrows=TRUE, annot=TRUE, labels=NULL, col=NULL,                         bg=""grey"", add=FALSE, quiet=FALSE,                         date.range=NULL, jitter.arrows=0, plot=TRUE, ...)get.likelihood(...) S3 method for class 'seqTrack'get.likelihood(x, mu, haplo.length, ...)``` Arguments- `x`: for seqTrack, a matrix giving weights to pairs of ancestries such that x[i,j] is the weight of 'i ancestor of j'. For plotSeqTrack and get.likelihood. seqTrack, a `seqTrack` object.- `x.names`: a character vector giving the labels of the haplotypes/genotypes- `x.dates`: a vector of collection dates for the sampled haplotypes/genotypes. Dates must have the POSIXct format. See `details` or `?as.POSIXct` for more information.- `best`: a character string matching 'min' or 'max', indicating whether genealogies should minimize or maximize the sum of weights of ancestries.- `prox.mat`: an optional matrix of proximities between haplotypes/genotypes used to resolve ties in the choice of ancestors, by picking up the 'closest' ancestor amongst possible ancestors, in the sense of `prox.mat`. `prox.mat[i,j]` must indicate a proximity for the relationship 'i ancestor to j'. For instance, if `prox.mat` contains spatial proximities, then `prox.mat[i,j]` gives a measure of how easy it is to migrate from location 'i' to 'j'.- `mu`: (optional) a mutation rate, per site and per day. When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `haplo.length` to be provided).- `haplo.length`: (optional) the length of analysed sequences in number of nucleotides. When 'x' contains numbers of mutations, used to resolve ties using a maximum likelihood approach (requires `mu` to be provided).- `y`: unused argument, for compatibility with 'plot'.- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph. See `?num2col`. Note that the palette is inversed by default.- `xy`: spatial coordinates of the sampled haplotypes/genotypes.- `use.arrows`: a logical indicating whether arrows should be used to represented ancestries (pointing from ancestor to descendent, TRUE), or whether segments shall be used (FALSE).- `annot`: a logical indicating whether arrows or segments representing ancestries should be annotated (TRUE) or not (FALSE).- `labels`: a character vector containing annotations of the ancestries. If left empty, ancestries are annotated by the descendent.- `col`: a vector of colors to be used for plotting ancestries.- `bg`: a color to be used as background.- `add`: a logical stating whether the plot should be added to current figure (TRUE), or drawn as a new plot (FALSE, default).- `quiet`: a logical stating whether messages other than errors should be displayed (FALSE, default), or hidden (TRUE).- `date.range`: a vector of length two with POSIXct format indicating the time window for which ancestries should be displayed.- `jitter.arrows`: a positive number indicating the amount of noise to be added to coordinates of arrows; useful when several arrows overlap. See `jitter`.- `plot`: a logical stating whether a plot should be drawn (TRUE, default), or not (FALSE). In all cases, the function invisibly returns plotting information.- ``: further arguments to be passed to other methods Author(s)Thibaut Jombart t.jombart@imperial.ac.uk ReferencesJombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. Heredity. doi: 10.1038/hdy.2010.78. Returns=== output of seqTrack ===seqTrack function returns data.frame with the class `seqTrack`, in which each row is an inferred ancestry described by the following columns: - id: indices identifying haplotypes/genotypes- ances: index of the inferred ancestor- weight: weight of the inferred ancestries- date: date of the haplotype/genotype- ances.date: date of the ancestor=== output of plotSeqTrack ===This graphical function invisibly returns the coordinates of the arrows/segments drawn and their colors, as a data.frame. Details=== Maximum parsimony genealogies ===Maximum parsimony genealogies can be obtained easily using this implementation of seqTrack. One has to provide in `x` a matrix of genetic distances. The most straightforward distance is the number of differing nucleotides. See `dist.dna` in the ape package for a wide range of genetic distances between aligned sequences. The argument `best` should be set to ""min"" (its default value), so that the identified genealogy minimizes the total number of mutations. If `x` contains number of mutations, then `mu` and `haplo.length` should also be provided for resolving ties in equally parsimonious ancestors using maximum likelihood.=== Likelihood of observed genetic differentiation ===The probability of oberving a given number of mutations between a sequence and its ancestor can be computed using `get.likelihood.seqTrack`. Note that this is only possible if `x` contained number of mutations.=== Plotting/converting seqTrack objects to graphs ===seqTrack objects are best plotted as graphs. From adegenet_1.3-5 onwards, seqTrack objects can be converted to `igraph` objects (from the package `igraph`), which can in turn be plotted and manipulated using classical graph tools. The plot method does this operation automatically, using colors to represent edge weights, and using time-ordering of the data from top (ancient) to bottom (recent). See Also`dist.dna` in the ape package to compute pairwise genetic distances in aligned sequences. Examples```r Not run:if(require(ape && require(igraph))){ ANALYSIS OF SIMULATED DATA  SIMULATE A GENEALOGYdat <- haploGen(seq.l=1e4, repro=function(){sample(1:4,1)}, gen.time=1, t.max=3)plot(dat, main=""Simulated data"") SEQTRACK ANALYSISres <- seqTrack(dat, mu=0.0001, haplo.length=1e4) plot(res, main=""seqTrack reconstruction"") PROPORTION OF CORRECT RECONSTRUCTIONmean(dat$ances==res$ances,na.rm=TRUE) ANALYSIS OF PANDEMIC A/H1N1 INFLUENZA DATA  note: this is for reproduction purpose only seqTrack is best kept for the analysis of densely sampled outbreaks, which is not the case of this dataset. dat <- read.csv(system.file(""files/pdH1N1-data.csv"",package=""adegenet""))ha <-  read.dna(system.file(""files/pdH1N1-HA.fasta"",package=""adegenet""), format=""fa"")na <- read.dna(system.file(""files/pdH1N1-NA.fasta"",package=""adegenet""), format=""fa"") COMPUTE NUCLEOTIDIC DISTANCESnbNucl <- ncol(as.matrix(ha)) + ncol(as.matrix(na))D <- dist.dna(ha,model=""raw"")ncol(as.matrix(ha)) +dist.dna(na,model=""raw"")ncol(as.matrix(na))D <- round(as.matrix(D)) MATRIX OF SPATIAL CONNECTIVITY (to promote local transmissions)xy <- cbind(dat$lon, dat$lat)temp <- as.matrix(dist(xy))M <- 1 (temp < 1e-10) SEQTRACK ANALYSISdat$date <- as.POSIXct(dat$date)res <- seqTrack(D, rownames(dat), dat$date, prox.mat=M, mu=.00502/365, haplo.le=nbNucl) COMPUTE GENETIC LIKELIHOODp <- get.likelihood(res, mu=.00502/365, haplo.length=nbNucl) (these could be shown as colors when plotting results) (but mutations will be used instead) EXAMINE RESULTShead(res)tail(res)range(res$weight, na.rm=TRUE)barplot(table(res$weight)/sum(!is.na(res$weight)), ylab=""Frequency"",xlab=""Mutations between inferred ancestor and descendent"", col=""orange"") DISPLAY SPATIO-TEMPORAL DYNAMICS if(require(maps)){myDates <- as.integer(difftime(dat$date, as.POSIXct(""2009-01-21""), unit=""day""))myMonth <- as.POSIXct(c(""2009-02-01"", ""2009-03-01"",""2009-04-01"",""2009-05-01"",""2009-06-01"",""2009-07-01""))x.month <-  as.integer(difftime(myMonth, as.POSIXct(""2009-01-21""), unit=""day"")) FIRST STAGE: SPREAD TO THE USA AND CANADAcurRange <- as.POSIXct(c(""2009-03-29"",""2009-04-25""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange,col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"", col=1:9,lwd=2, horiz=TRUE) SECOND STAGE: SPREAD WITHIN AMERICA, FIRST SEEDING OUTSIDE AMERICAcurRange <- as.POSIXct(c(""2009-04-30"",""2009-05-07""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2,date.range=curRange, col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",col=1:9,lwd=2, horiz=TRUE) THIRD STAGE: PANDEMICcurRange <- as.POSIXct(c(""2009-05-15"",""2009-05-25""))par(bg=""deepskyblue"")map(""world"", fill=TRUE, col=""grey"")opal <- palette()palette(rev(heat.colors(10)))plotSeqTrack(res, round(xy), add=TRUE,annot=FALSE,lwd=2, date.range=curRange,col=res$weight+1)title(paste(curRange, collapse="" to ""))legend(""bottom"", lty=1, leg=0:8, title=""number of mutations"",col=1:9,lwd=2, horiz=TRUE)}} End(Not run)```",16
adegenet,propTyped.md,"methods

# Compute the proportion of typed elements

## Description

The generic function `propTyped` is devoted to investigating the structure of missing data in adegenet objects.

Methods are defined for genind and genpop

objects. They can return the proportion of available (i.e. non-missing) data per individual/population, locus, or the combination of both in with case the matrix indicates which entity (individual or population) was typed on which locus.

```r
## S4 method for signature 'genind'
propTyped(x,  by=c(""ind"",""loc"",""both""))
## S4 method for signature 'genpop'
propTyped(x,  by=c(""pop"",""loc"",""both""))
```

## Arguments

- `x`: a genind and genpop object
- `by`: a character being ""ind"",""loc"", or ""both"" for genind object and ""pop"",""loc"", or ""both"" for genpop object. It specifies whether proportion of typed data are provided by entity (""ind""/""pop""), by locus (""loc"") or both (""both""). See details.

 

## Returns

A vector of proportion (when `by` equals ""ind"", ""pop"", or ""loc""), or a matrix of binary data (when `by` equals ""both"")

## Details

When `by` is set to ""both"", the result is a matrix of binary data with entities in rows (individuals or populations) and markers in columns. The values of the matrix are 1 for typed data, and 0 for NA.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(nancycats)
propTyped(nancycats,by=""loc"")
propTyped(genind2genpop(nancycats),by=""both"")
## End(Not run)
```



","['methods Compute the proportion of typed elements DescriptionThe generic function `propTyped` is devoted to investigating the structure of missing data in adegenet objects.Methods are defined for genind and genpopobjects.', 'They can return the proportion of available (i.e.', 'non-missing) data per individual/population, locus, or the combination of both in with case the matrix indicates which entity (individual or population) was typed on which locus.```r S4 method for signature \'genind\'propTyped(x,  by=c(""ind"",""loc"",""both"")) S4 method for signature \'genpop\'propTyped(x,  by=c(""pop"",""loc"",""both""))``` Arguments- `x`: a genind and genpop object- `by`: a character being ""ind"",""loc"", or ""both"" for genind object and ""pop"",""loc"", or ""both"" for genpop object.', 'It specifies whether proportion of typed data are provided by entity (""ind""/""pop""), by locus (""loc"") or both (""both"").', 'ReturnsA vector of proportion (when `by` equals ""ind"", ""pop"", or ""loc""), or a matrix of binary data (when `by` equals ""both"") DetailsWhen `by` is set to ""both"", the result is a matrix of binary data with entities in rows (individuals or populations) and markers in columns.', 'The values of the matrix are 1 for typed data, and 0 for NA.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)propTyped(nancycats,by=""loc"")propTyped(genind2genpop(nancycats),by=""both"") End(Not run)```']",1,"methods Compute the proportion of typed elements DescriptionThe generic function `propTyped` is devoted to investigating the structure of missing data in adegenet objects.Methods are defined for genind and genpopobjects. They can return the proportion of available (i.e. non-missing) data per individual/population, locus, or the combination of both in with case the matrix indicates which entity (individual or population) was typed on which locus.```r S4 method for signature 'genind'propTyped(x,  by=c(""ind"",""loc"",""both"")) S4 method for signature 'genpop'propTyped(x,  by=c(""pop"",""loc"",""both""))``` Arguments- `x`: a genind and genpop object- `by`: a character being ""ind"",""loc"", or ""both"" for genind object and ""pop"",""loc"", or ""both"" for genpop object. It specifies whether proportion of typed data are provided by entity (""ind""/""pop""), by locus (""loc"") or both (""both""). See details.  ReturnsA vector of proportion (when `by` equals ""ind"", ""pop"", or ""loc""), or a matrix of binary data (when `by` equals ""both"") DetailsWhen `by` is set to ""both"", the result is a matrix of binary data with entities in rows (individuals or populations) and markers in columns. The values of the matrix are 1 for typed data, and 0 for NA. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)propTyped(nancycats,by=""loc"")propTyped(genind2genpop(nancycats),by=""both"") End(Not run)```",16
adegenet,read.genepop.md,"# Reading data from Genepop

```r
read.genepop(file, ncode = 2L, quiet = FALSE)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the appropriate extension.
- `ncode`: an integer indicating the number of characters used to code an allele.
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).

## Returns

an object of the class `genind`

## Description

The function `read.genepop` reads Genepop data files (.gen) and convert them into a genind object.

## Details

Note: `read.genepop` is meant for DIPLOID DATA ONLY. Haploid data with the Genepop format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`.

## Examples

```r
obj <- read.genepop(system.file(""files/nancycats.gen"",package=""adegenet""))
obj
```

## References

Raymond M. & Rousset F, (1995). GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism. **J. Heredity**, 86 :248-249

## See Also

`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genetix`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading data from Genepop```rread.genepop(file, ncode = 2L, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `ncode`: an integer indicating the number of characters used to code an allele.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).', 'Returnsan object of the class `genind` DescriptionThe function `read.genepop` reads Genepop data files (.gen) and convert them into a genind object.', 'DetailsNote: `read.genepop` is meant for DIPLOID DATA ONLY.', ""Haploid data with the Genepop format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`."", 'Examples```robj <- read.genepop(system.file(""files/nancycats.gen"",package=""adegenet""))obj``` ReferencesRaymond M. & Rousset F, (1995).', 'GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism.', 'J. Heredity, 86 :248-249 See Also`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genetix` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Reading data from Genepop```rread.genepop(file, ncode = 2L, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `ncode`: an integer indicating the number of characters used to code an allele.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE). Returnsan object of the class `genind` DescriptionThe function `read.genepop` reads Genepop data files (.gen) and convert them into a genind object. DetailsNote: `read.genepop` is meant for DIPLOID DATA ONLY. Haploid data with the Genepop format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`. Examples```robj <- read.genepop(system.file(""files/nancycats.gen"",package=""adegenet""))obj``` ReferencesRaymond M. & Rousset F, (1995). GENEPOP (version 1.2): population genetics software for exact tests and ecumenicism. J. Heredity, 86 :248-249 See Also`import2genind`, `df2genind`, `read.fstat`, `read.structure`, `read.genetix` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",16
adegenet,glSim.md,"UTF-8

# Simulation of simple genlight objects

## Description

The function `glSim` simulates simple SNP data with the possibility of contrasted structures between two groups as well as background ancestral population structure. Returned objects are instances of the class genlight .

```r
glSim(n.ind, n.snp.nonstruc, n.snp.struc = 0, grp.size = c(0.5, 0.5), k = NULL,
                    pop.freq = NULL, ploidy = 1, alpha = 0, parallel = FALSE,
                    LD = TRUE, block.minsize = 10, block.maxsize = 1000, theta = NULL,
                    sort.pop = FALSE, ...)
```

## Arguments

- `n.ind`: an integer indicating the number of individuals to be simulated.
- `n.snp.nonstruc`: an integer indicating the number of non-structured SNPs to be simulated; for these SNPs, all individuals are drawn from the same binomial distribution.
- `n.snp.struc`: an integer indicating the number of structured SNPs to be simulated; for these SNPs, different binomial distributions are used for the two simulated groups; frequencies of the derived alleles in groups A and B are built to differ (see details).
- `grp.size`: a vector of length 2 specifying the proportions of the two phenotypic groups (must sum to 1). By default, both groups have the same size.
- `k`: an integer specifying the number of ancestral populations to be generated.
- `pop.freq`: a vector of length `k` specifying the proportions of the k ancestral populations (must sum to 1). If, as by default, `pop.freq` is null, and `k` is non-null, `pop.freq` will be the result of random sampling into k population groups.
- `ploidy`: an integer indicating the ploidy of the simulated genotypes.
- `alpha`: asymmetry parameter: a numeric value between 0 and 0.5, used to enforce allelic differences between the groups. Differences between groups are strongest when alpha = 0.5 and weakest when alpha = 0 (see details).
- `parallel`: a logical indicating whether multiple cores should be used in generating the simulated data (TRUE). This option can reduce the amount of computational time required to simulate the data, but is not supported on Windows.
- `LD`: a logical indicating whether loci should be displaying linkage disequilibrium (TRUE) or be generated independently (FALSE, default). When set to TRUE, data are generated by blocks of correlated SNPs (see details).
- `block.minsize`: an optional integer indicating the minimum number of SNPs to be handled at a time during the simulation of linked SNPs (when `LD=TRUE`. Increasing the minimum block size will increase the RAM requirement but decrease the amount of computational time required to simulate the genotypes.
- `block.maxsize`: an optional integer indicating the maximum number of SNPs to be handled at a time during the simulation of linked SNPs. Note: if LD blocks of equal size are desired, set block.minsize = block.maxsize.
- `theta`: an optional numeric value between 0 and 0.5 specifying the extent to which linkage should be diluted. Linkage is strongest when theta = 0 and weakest when theta = 0.5.
- `sort.pop`: a logical specifying whether individuals should be ordered by ancestral population (`sort.pop=TRUE`) or phenotypic population (`sort.pop=FALSE`).
- ``...``: arguments to be passed to the genlight constructor.

## Details

=== Allele frequencies in contrasted groups ===

When `n.snp.struc` is greater than 0, some SNPs are simulated in order to differ between groups (noted 'A' and 'B'). Different patterns between groups are achieved by using different frequencies of the second allele for A and B, denoted `p_A` and `p_B`. For a given SNP, `p_A` is drawn from a uniform distribution between 0 and (0.5 - alpha). `p_B` is then computed as 1 - `p_A`. Therefore, differences between groups are mild for alpha=0, and total for alpha = 0.5.

=== Linked or independent loci ===

Independent loci (`LD=FALSE`) are simulated using the standard binomial distribution, with randomly generated allele frequencies. Linked loci (`LD=FALSE`) are trickier towe need to simulate discrete variables with pre-defined correlation structure.

Here, we first generate deviates from multivariate normal distributions with randomly generated correlation structures. These variables are then discretized using the quantiles of the distribution. Further improvement of the procedure will aim at i) specifying the strength of the correlations between blocks of alleles and ii) enforce contrasted structures between groups.

## Returns

A genlight object.

## See Also

- `genlight`: class of object for storing massive binary SNP data.

- `glPlot`: plotting genlight objects.

- `glPca`: PCA for genlight objects.

## Author(s)

Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## no structure
x <- glSim(100, 1e3, ploid=2)
plot(x)

## 1,000 non structured SNPs, 100 structured SNPs
x <- glSim(100, 1e3, n.snp.struc=100, ploid=2)
plot(x)

## 1,000 non structured SNPs, 100 structured SNPs, ploidy=4
x <- glSim(100, 1e3, n.snp.struc=100, ploid=4)
plot(x)

## same thing, stronger differences between groups
x <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4)
plot(x)

##  same thing, loci with LD structures
x <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4, LD=TRUE, block.minsize=100)
plot(x)
## End(Not run)
```



","['UTF-8 Simulation of simple genlight objects DescriptionThe function `glSim` simulates simple SNP data with the possibility of contrasted structures between two groups as well as background ancestral population structure.', 'Returned objects are instances of the class genlight .```rglSim(n.ind, n.snp.nonstruc, n.snp.struc = 0, grp.size = c(0.5, 0.5), k = NULL,                    pop.freq = NULL, ploidy = 1, alpha = 0, parallel = FALSE,                    LD = TRUE, block.minsize = 10, block.maxsize = 1000, theta = NULL,                    sort.pop = FALSE, ...)``` Arguments- `n.ind`: an integer indicating the number of individuals to be simulated.- `n.snp.nonstruc`: an integer indicating the number of non-structured SNPs to be simulated; for these SNPs, all individuals are drawn from the same binomial distribution.- `n.snp.struc`: an integer indicating the number of structured SNPs to be simulated; for these SNPs, different binomial distributions are used for the two simulated groups; frequencies of the derived alleles in groups A and B are built to differ (see details).- `grp.size`: a vector of length 2 specifying the proportions of the two phenotypic groups (must sum to 1).', 'By default, both groups have the same size.- `k`: an integer specifying the number of ancestral populations to be generated.- `pop.freq`: a vector of length `k` specifying the proportions of the k ancestral populations (must sum to 1).', 'If, as by default, `pop.freq` is null, and `k` is non-null, `pop.freq` will be the result of random sampling into k population groups.- `ploidy`: an integer indicating the ploidy of the simulated genotypes.- `alpha`: asymmetry parameter: a numeric value between 0 and 0.5, used to enforce allelic differences between the groups.', 'Differences between groups are strongest when alpha = 0.5 and weakest when alpha = 0 (see details).- `parallel`: a logical indicating whether multiple cores should be used in generating the simulated data (TRUE).', 'This option can reduce the amount of computational time required to simulate the data, but is not supported on Windows.- `LD`: a logical indicating whether loci should be displaying linkage disequilibrium (TRUE) or be generated independently (FALSE, default).', 'When set to TRUE, data are generated by blocks of correlated SNPs (see details).- `block.minsize`: an optional integer indicating the minimum number of SNPs to be handled at a time during the simulation of linked SNPs (when `LD=TRUE`.', 'Increasing the minimum block size will increase the RAM requirement but decrease the amount of computational time required to simulate the genotypes.- `block.maxsize`: an optional integer indicating the maximum number of SNPs to be handled at a time during the simulation of linked SNPs.', 'Note: if LD blocks of equal size are desired, set block.minsize = block.maxsize.- `theta`: an optional numeric value between 0 and 0.5 specifying the extent to which linkage should be diluted.', 'Linkage is strongest when theta = 0 and weakest when theta = 0.5.- `sort.pop`: a logical specifying whether individuals should be ordered by ancestral population (`sort.pop=TRUE`) or phenotypic population (`sort.pop=FALSE`).- ``...``: arguments to be passed to the genlight constructor.', ""Details=== Allele frequencies in contrasted groups ===When `n.snp.struc` is greater than 0, some SNPs are simulated in order to differ between groups (noted 'A' and 'B')."", 'Different patterns between groups are achieved by using different frequencies of the second allele for A and B, denoted `p_A` and `p_B`.', 'For a given SNP, `p_A` is drawn from a uniform distribution between 0 and (0.5 - alpha).', '`p_B` is then computed as 1 - `p_A`.', 'Therefore, differences between groups are mild for alpha=0, and total for alpha = 0.5.=== Linked or independent loci ===Independent loci (`LD=FALSE`) are simulated using the standard binomial distribution, with randomly generated allele frequencies.', 'Linked loci (`LD=FALSE`) are trickier towe need to simulate discrete variables with pre-defined correlation structure.Here, we first generate deviates from multivariate normal distributions with randomly generated correlation structures.', 'These variables are then discretized using the quantiles of the distribution.', 'Further improvement of the procedure will aim at i) specifying the strength of the correlations between blocks of alleles and ii) enforce contrasted structures between groups.', 'See Also- `genlight`: class of object for storing massive binary SNP data.- `glPlot`: plotting genlight objects.- `glPca`: PCA for genlight objects.', 'Author(s)Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: no structurex <- glSim(100, 1e3, ploid=2)plot(x) 1,000 non structured SNPs, 100 structured SNPsx <- glSim(100, 1e3, n.snp.struc=100, ploid=2)plot(x) 1,000 non structured SNPs, 100 structured SNPs, ploidy=4x <- glSim(100, 1e3, n.snp.struc=100, ploid=4)plot(x) same thing, stronger differences between groupsx <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4)plot(x)  same thing, loci with LD structuresx <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4, LD=TRUE, block.minsize=100)plot(x) End(Not run)```']",1,"UTF-8 Simulation of simple genlight objects DescriptionThe function `glSim` simulates simple SNP data with the possibility of contrasted structures between two groups as well as background ancestral population structure. Returned objects are instances of the class genlight .```rglSim(n.ind, n.snp.nonstruc, n.snp.struc = 0, grp.size = c(0.5, 0.5), k = NULL,                    pop.freq = NULL, ploidy = 1, alpha = 0, parallel = FALSE,                    LD = TRUE, block.minsize = 10, block.maxsize = 1000, theta = NULL,                    sort.pop = FALSE, ...)``` Arguments- `n.ind`: an integer indicating the number of individuals to be simulated.- `n.snp.nonstruc`: an integer indicating the number of non-structured SNPs to be simulated; for these SNPs, all individuals are drawn from the same binomial distribution.- `n.snp.struc`: an integer indicating the number of structured SNPs to be simulated; for these SNPs, different binomial distributions are used for the two simulated groups; frequencies of the derived alleles in groups A and B are built to differ (see details).- `grp.size`: a vector of length 2 specifying the proportions of the two phenotypic groups (must sum to 1). By default, both groups have the same size.- `k`: an integer specifying the number of ancestral populations to be generated.- `pop.freq`: a vector of length `k` specifying the proportions of the k ancestral populations (must sum to 1). If, as by default, `pop.freq` is null, and `k` is non-null, `pop.freq` will be the result of random sampling into k population groups.- `ploidy`: an integer indicating the ploidy of the simulated genotypes.- `alpha`: asymmetry parameter: a numeric value between 0 and 0.5, used to enforce allelic differences between the groups. Differences between groups are strongest when alpha = 0.5 and weakest when alpha = 0 (see details).- `parallel`: a logical indicating whether multiple cores should be used in generating the simulated data (TRUE). This option can reduce the amount of computational time required to simulate the data, but is not supported on Windows.- `LD`: a logical indicating whether loci should be displaying linkage disequilibrium (TRUE) or be generated independently (FALSE, default). When set to TRUE, data are generated by blocks of correlated SNPs (see details).- `block.minsize`: an optional integer indicating the minimum number of SNPs to be handled at a time during the simulation of linked SNPs (when `LD=TRUE`. Increasing the minimum block size will increase the RAM requirement but decrease the amount of computational time required to simulate the genotypes.- `block.maxsize`: an optional integer indicating the maximum number of SNPs to be handled at a time during the simulation of linked SNPs. Note: if LD blocks of equal size are desired, set block.minsize = block.maxsize.- `theta`: an optional numeric value between 0 and 0.5 specifying the extent to which linkage should be diluted. Linkage is strongest when theta = 0 and weakest when theta = 0.5.- `sort.pop`: a logical specifying whether individuals should be ordered by ancestral population (`sort.pop=TRUE`) or phenotypic population (`sort.pop=FALSE`).- ``...``: arguments to be passed to the genlight constructor. Details=== Allele frequencies in contrasted groups ===When `n.snp.struc` is greater than 0, some SNPs are simulated in order to differ between groups (noted 'A' and 'B'). Different patterns between groups are achieved by using different frequencies of the second allele for A and B, denoted `p_A` and `p_B`. For a given SNP, `p_A` is drawn from a uniform distribution between 0 and (0.5 - alpha). `p_B` is then computed as 1 - `p_A`. Therefore, differences between groups are mild for alpha=0, and total for alpha = 0.5.=== Linked or independent loci ===Independent loci (`LD=FALSE`) are simulated using the standard binomial distribution, with randomly generated allele frequencies. Linked loci (`LD=FALSE`) are trickier towe need to simulate discrete variables with pre-defined correlation structure.Here, we first generate deviates from multivariate normal distributions with randomly generated correlation structures. These variables are then discretized using the quantiles of the distribution. Further improvement of the procedure will aim at i) specifying the strength of the correlations between blocks of alleles and ii) enforce contrasted structures between groups. ReturnsA genlight object. See Also- `genlight`: class of object for storing massive binary SNP data.- `glPlot`: plotting genlight objects.- `glPca`: PCA for genlight objects. Author(s)Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: no structurex <- glSim(100, 1e3, ploid=2)plot(x) 1,000 non structured SNPs, 100 structured SNPsx <- glSim(100, 1e3, n.snp.struc=100, ploid=2)plot(x) 1,000 non structured SNPs, 100 structured SNPs, ploidy=4x <- glSim(100, 1e3, n.snp.struc=100, ploid=4)plot(x) same thing, stronger differences between groupsx <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4)plot(x)  same thing, loci with LD structuresx <- glSim(100, 1e3, n.snp.struc=100, ploid=2, alpha=0.4, LD=TRUE, block.minsize=100)plot(x) End(Not run)```",16
adegenet,seploc.md,"UTF-8

methods

# Separate data per locus

## Description

The function `seploc` splits an object (genind , genpop or genlight ) by marker. For genind and genpop objects, the method returns a list of objects whose components each correspond to a marker. For genlight objects, the methods returns blocks of SNPs.

```r
## S4 method for signature 'genind'
seploc(x,truenames=TRUE,res.type=c(""genind"",""matrix""))
## S4 method for signature 'genpop'
seploc(x,truenames=TRUE,res.type=c(""genpop"",""matrix""))
## S4 method for signature 'genlight'
seploc(x, n.block=NULL, block.size=NULL, random=FALSE,
       parallel=FALSE, n.cores=NULL)
```

## Arguments

- `x`: a genind or a genpop object.
- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE).
- `res.type`: a character indicating the type of returned results, a genind or genpop object (default) or a matrix of data corresponding to the 'tab' slot.
- `n.block`: an integer indicating the number of blocks of SNPs to be returned.
- `block.size`: an integer indicating the size (in number of SNPs) of the blocks to be returned.
- `random`: should blocks be formed of contiguous SNPs, or should they be made or randomly chosen SNPs.
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed.
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.

## Returns

The function `seploc` returns an list of objects of the same class as the initial object, or a list of matrices similar to x$tab.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`seppop`, `repool`

## Examples

```r
## Not run:

## example on genind objects
data(microbov)

# separate all markers
obj <- seploc(microbov)
names(obj)

obj$INRA5


## example on genlight objects
x <- glSim(100, 1000, 0, ploidy=2) # simulate data
x <- x[,order(glSum(x))] # reorder loci by frequency of 2nd allele
glPlot(x, main=""All data"") # plot data
foo <- seploc(x, n.block=3) # form 3 blocks
foo
glPlot(foo[[1]], main=""1st block"") # plot 1st block
glPlot(foo[[2]], main=""2nd block"") # plot 2nd block
glPlot(foo[[3]], main=""3rd block"") # plot 3rd block

foo <- seploc(x, block.size=600, random=TRUE) # split data, randomize loci
foo # note the different block sizes
glPlot(foo[[1]])
## End(Not run)
```



","['UTF-8methods Separate data per locus DescriptionThe function `seploc` splits an object (genind , genpop or genlight ) by marker.', 'For genind and genpop objects, the method returns a list of objects whose components each correspond to a marker.', 'For genlight objects, the methods returns blocks of SNPs.```r S4 method for signature \'genind\'seploc(x,truenames=TRUE,res.type=c(""genind"",""matrix"")) S4 method for signature \'genpop\'seploc(x,truenames=TRUE,res.type=c(""genpop"",""matrix"")) S4 method for signature \'genlight\'seploc(x, n.block=NULL, block.size=NULL, random=FALSE,       parallel=FALSE, n.cores=NULL)``` Arguments- `x`: a genind or a genpop object.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE).- `res.type`: a character indicating the type of returned results, a genind or genpop object (default) or a matrix of data corresponding to the \'tab\' slot.- `n.block`: an integer indicating the number of blocks of SNPs to be returned.- `block.size`: an integer indicating the size (in number of SNPs) of the blocks to be returned.- `random`: should blocks be formed of contiguous SNPs, or should they be made or randomly chosen SNPs.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.', 'ReturnsThe function `seploc` returns an list of objects of the same class as the initial object, or a list of matrices similar to x$tab.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seppop`, `repool` Examples```r Not run: example on genind objectsdata(microbov) separate all markersobj <- seploc(microbov)names(obj)obj$INRA5 example on genlight objectsx <- glSim(100, 1000, 0, ploidy=2)  simulate datax <- x[,order(glSum(x))]  reorder loci by frequency of 2nd alleleglPlot(x, main=""All data"")  plot datafoo <- seploc(x, n.block=3)  form 3 blocksfooglPlot(foo[[1]], main=""1st block"")  plot 1st blockglPlot(foo[[2]], main=""2nd block"")  plot 2nd blockglPlot(foo[[3]], main=""3rd block"")  plot 3rd blockfoo <- seploc(x, block.size=600, random=TRUE)  split data, randomize locifoo  note the different block sizesglPlot(foo[[1]]) End(Not run)```']",1,"UTF-8methods Separate data per locus DescriptionThe function `seploc` splits an object (genind , genpop or genlight ) by marker. For genind and genpop objects, the method returns a list of objects whose components each correspond to a marker. For genlight objects, the methods returns blocks of SNPs.```r S4 method for signature 'genind'seploc(x,truenames=TRUE,res.type=c(""genind"",""matrix"")) S4 method for signature 'genpop'seploc(x,truenames=TRUE,res.type=c(""genpop"",""matrix"")) S4 method for signature 'genlight'seploc(x, n.block=NULL, block.size=NULL, random=FALSE,       parallel=FALSE, n.cores=NULL)``` Arguments- `x`: a genind or a genpop object.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE).- `res.type`: a character indicating the type of returned results, a genind or genpop object (default) or a matrix of data corresponding to the 'tab' slot.- `n.block`: an integer indicating the number of blocks of SNPs to be returned.- `block.size`: an integer indicating the size (in number of SNPs) of the blocks to be returned.- `random`: should blocks be formed of contiguous SNPs, or should they be made or randomly chosen SNPs.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used. ReturnsThe function `seploc` returns an list of objects of the same class as the initial object, or a list of matrices similar to x$tab. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seppop`, `repool` Examples```r Not run: example on genind objectsdata(microbov) separate all markersobj <- seploc(microbov)names(obj)obj$INRA5 example on genlight objectsx <- glSim(100, 1000, 0, ploidy=2)  simulate datax <- x[,order(glSum(x))]  reorder loci by frequency of 2nd alleleglPlot(x, main=""All data"")  plot datafoo <- seploc(x, n.block=3)  form 3 blocksfooglPlot(foo[[1]], main=""1st block"")  plot 1st blockglPlot(foo[[2]], main=""2nd block"")  plot 2nd blockglPlot(foo[[3]], main=""3rd block"")  plot 3rd blockfoo <- seploc(x, block.size=600, random=TRUE)  split data, randomize locifoo  note the different block sizesglPlot(foo[[1]]) End(Not run)```",16
adegenet,selpopsize.md,"UTF-8

methods

# Select genotypes of well-represented populations

## Description

The function `selPopSize` checks the sample size of each population in a genind object and keeps only genotypes of populations having a given minimum size.

```r
## S4 method for signature 'genind'
selPopSize(x,pop=NULL,nMin=10)
```

## Arguments

- `x`: a genind object
- `pop`: a vector of characters or a factor giving the population of each genotype in 'x'. If not provided, seeked from x$pop.
- `nMin`: the minimum sample size for a population to be retained. Samples sizes strictly less than `nMin` will be discarded, those equal to or greater than `nMin` are kept.

## Returns

A genind object.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`seploc`, `repool`

## Examples

```r
## Not run:

data(microbov)

table(pop(microbov))
obj <- selPopSize(microbov, n=50)

obj
table(pop(obj))
## End(Not run)
```



","[""UTF-8methods Select genotypes of well-represented populations DescriptionThe function `selPopSize` checks the sample size of each population in a genind object and keeps only genotypes of populations having a given minimum size.```r S4 method for signature 'genind'selPopSize(x,pop=NULL,nMin=10)``` Arguments- `x`: a genind object- `pop`: a vector of characters or a factor giving the population of each genotype in 'x'."", 'If not provided, seeked from x$pop.- `nMin`: the minimum sample size for a population to be retained.', 'Samples sizes strictly less than `nMin` will be discarded, those equal to or greater than `nMin` are kept.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seploc`, `repool` Examples```r Not run:data(microbov)table(pop(microbov))obj <- selPopSize(microbov, n=50)objtable(pop(obj)) End(Not run)```']",1,"UTF-8methods Select genotypes of well-represented populations DescriptionThe function `selPopSize` checks the sample size of each population in a genind object and keeps only genotypes of populations having a given minimum size.```r S4 method for signature 'genind'selPopSize(x,pop=NULL,nMin=10)``` Arguments- `x`: a genind object- `pop`: a vector of characters or a factor giving the population of each genotype in 'x'. If not provided, seeked from x$pop.- `nMin`: the minimum sample size for a population to be retained. Samples sizes strictly less than `nMin` will be discarded, those equal to or greater than `nMin` are kept. ReturnsA genind object. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seploc`, `repool` Examples```r Not run:data(microbov)table(pop(microbov))obj <- selPopSize(microbov, n=50)objtable(pop(obj)) End(Not run)```",16
adegenet,loadingplot.md,"# Represents a cloud of points with colors

## Description

The `loadingplot` function represents positive values of a vector and identifies the values above a given threshold. It can also indicate groups of observations provided as a factor.

Such graphics can be used, for instance, to assess the weight of each variable (loadings) in a given analysis.

```r
loadingplot(x, ...)

## Default S3 method:
loadingplot(x, at=NULL, threshold=quantile(x,0.75),
            axis=1, fac=NULL, byfac=FALSE,
            lab=NULL, cex.lab=0.7, cex.fac=1, lab.jitter=0,
            main=""Loading plot"", xlab=""Variables"", ylab=""Loadings"",
            srt = 0, adj = NULL, ...)
```

## Arguments

- `x`: either a vector with numeric values to be plotted, or a matrix-like object containing numeric values. In such case, the `x[,axis]` is used as vector of values to be plotted.
- `at`: an optional numeric vector giving the abscissa at which loadings are plotted. Useful when variates are SNPs with a known position in an alignement.
- `threshold`: a threshold value above which values of x are identified. By default, this is the third quartile of x.
- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.
- `fac`: a factor defining groups of observations.
- `byfac`: a logical stating whether loadings should be averaged by groups of observations, as defined by `fac`.
- `lab`: a character vector giving the labels used to annotate values above the threshold; if NULL, names are taken from the object.
- `cex.lab`: a numeric value indicating the size of annotations.
- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.
- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations. Set to 0 (by default) implies no randomisation.
- `main`: the main title of the figure.
- `xlab`: the title of the x axis.
- `ylab`: the title of the y axis.
- `srt`: rotation of the labels; see ?text.
- `adj`: adjustment of the labels; see ?text.
- ``...``: further arguments to be passed to the plot function.

 

## Returns

Invisibly returns a list with the following components:

- threshold: the threshold used

- var.names: the names of observations above the threshold

- var.idx: the indices of observations above the threshold

- var.values: the values above the threshold

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
x <- runif(20)
names(x) <- letters[1:20]
grp <- factor(paste(""group"", rep(1:4,each=5)))

## basic plot
loadingplot(x)

## adding groups
loadingplot(x,fac=grp,main=""My title"",cex.lab=1)
```



","['Represents a cloud of points with colors DescriptionThe `loadingplot` function represents positive values of a vector and identifies the values above a given threshold.', 'It can also indicate groups of observations provided as a factor.Such graphics can be used, for instance, to assess the weight of each variable (loadings) in a given analysis.```rloadingplot(x, ...) Default S3 method:loadingplot(x, at=NULL, threshold=quantile(x,0.75),            axis=1, fac=NULL, byfac=FALSE,            lab=NULL, cex.lab=0.7, cex.fac=1, lab.jitter=0,            main=""Loading plot"", xlab=""Variables"", ylab=""Loadings"",            srt = 0, adj = NULL, ...)``` Arguments- `x`: either a vector with numeric values to be plotted, or a matrix-like object containing numeric values.', 'In such case, the `x[,axis]` is used as vector of values to be plotted.- `at`: an optional numeric vector giving the abscissa at which loadings are plotted.', 'Useful when variates are SNPs with a known position in an alignement.- `threshold`: a threshold value above which values of x are identified.', 'By default, this is the third quartile of x.- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.- `fac`: a factor defining groups of observations.- `byfac`: a logical stating whether loadings should be averaged by groups of observations, as defined by `fac`.- `lab`: a character vector giving the labels used to annotate values above the threshold; if NULL, names are taken from the object.- `cex.lab`: a numeric value indicating the size of annotations.- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations.', 'Set to 0 (by default) implies no randomisation.- `main`: the main title of the figure.- `xlab`: the title of the x axis.- `ylab`: the title of the y axis.- `srt`: rotation of the labels; see ?text.- `adj`: adjustment of the labels; see ?text.- ``...``: further arguments to be passed to the plot function.', 'ReturnsInvisibly returns a list with the following components:- threshold: the threshold used- var.names: the names of observations above the threshold- var.idx: the indices of observations above the threshold- var.values: the values above the threshold Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```rx <- runif(20)names(x) <- letters[1:20]grp <- factor(paste(""group"", rep(1:4,each=5))) basic plotloadingplot(x) adding groupsloadingplot(x,fac=grp,main=""My title"",cex.lab=1)```']",1," Represents a cloud of points with colors DescriptionThe `loadingplot` function represents positive values of a vector and identifies the values above a given threshold. It can also indicate groups of observations provided as a factor.Such graphics can be used, for instance, to assess the weight of each variable (loadings) in a given analysis.```rloadingplot(x, ...) Default S3 method:loadingplot(x, at=NULL, threshold=quantile(x,0.75),            axis=1, fac=NULL, byfac=FALSE,            lab=NULL, cex.lab=0.7, cex.fac=1, lab.jitter=0,            main=""Loading plot"", xlab=""Variables"", ylab=""Loadings"",            srt = 0, adj = NULL, ...)``` Arguments- `x`: either a vector with numeric values to be plotted, or a matrix-like object containing numeric values. In such case, the `x[,axis]` is used as vector of values to be plotted.- `at`: an optional numeric vector giving the abscissa at which loadings are plotted. Useful when variates are SNPs with a known position in an alignement.- `threshold`: a threshold value above which values of x are identified. By default, this is the third quartile of x.- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.- `fac`: a factor defining groups of observations.- `byfac`: a logical stating whether loadings should be averaged by groups of observations, as defined by `fac`.- `lab`: a character vector giving the labels used to annotate values above the threshold; if NULL, names are taken from the object.- `cex.lab`: a numeric value indicating the size of annotations.- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations. Set to 0 (by default) implies no randomisation.- `main`: the main title of the figure.- `xlab`: the title of the x axis.- `ylab`: the title of the y axis.- `srt`: rotation of the labels; see ?text.- `adj`: adjustment of the labels; see ?text.- ``...``: further arguments to be passed to the plot function.  ReturnsInvisibly returns a list with the following components:- threshold: the threshold used- var.names: the names of observations above the threshold- var.idx: the indices of observations above the threshold- var.values: the values above the threshold Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```rx <- runif(20)names(x) <- letters[1:20]grp <- factor(paste(""group"", rep(1:4,each=5))) basic plotloadingplot(x) adding groupsloadingplot(x,fac=grp,main=""My title"",cex.lab=1)```",16
adegenet,genind.md,"UTF-8

# adegenet formal class (S4) for individual genotypes

## Description

The S4 class `genind` is used to store individual genotypes.

It contains several components described in the 'slots' section).

The `summary` of a `genind` object invisibly returns a list of component. The function `.valid.genind` is for internal use. The function `genind` creates a genind object from a valid table of alleles corresponding to the `@tab` slot. Note that as in other S4 classes, slots are accessed using @ instead of $.

## Slots

- **`tab`:**: (accessor: ‘tab’)
       
       matrix integers containing genotypes data for individuals (in rows) for all alleles (in columns). The table differs depending on the `@type` slot:
       
       - 'codom': values are numbers of alleles, summing up to the individuals' ploidies.
       
       - 'PA': values are presence/absence of alleles.
       
       In all cases, rows and columns are given generic names.
- **`loc.fac`:**: (accessor: ‘locFac’) locus factor for the columns of `tab`
- **`loc.n.all`:**: (accessor: ‘nAll’) integer vector giving the number of observed alleles per locus (see note)
- **`all.names`:**: (accessor: ‘alleles’) list having one component per locus, each containing a character vector of allele names
- **`ploidy`:**: (accessor: ‘ploidy’) an integer vector indicating the degree of ploidy of the genotypes. Beware: 2 is not an integer, but 2L or as.integer(2) is.
- **`type`:**: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).
- **`call`:**: the matched call
- **`strata`:**: (accessor: ‘strata’) (optional) data frame giving levels of population stratification for each individual
- **`hierarchy`:**: (accessor: ‘hier’) (optional, currently unused) a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.
- **`pop`:**: (accessor: ‘pop’) (optional) factor giving the population of each individual
- **`other`:**: (accessor: ‘other’) (optional) a list containing other information

## Note:

The `loc.n.all` slot will reflect the number of columns per locus that contain at least one observation. This means that the sum of the this vector will not necessarily equal the number of columns in the data unless you use `drop = TRUE` when subsetting.

## Extends

Class `""gen""`, directly. Class `""indInfo""`, directly.

## Methods

- **names**: `signature(x = ""genind"")`: give the names of the components of a genind object
- **print**: `signature(x = ""genind"")`: prints a genind object
- **show**: `signature(object = ""genind"")`: shows a genind object (same as print)
- **summary**: `signature(object = ""genind"")`: summarizes a genind object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE`

## See Also

`as.genind`, `genind2genpop`, `genpop`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat`

Related classes:

- genpop for storing data per populations

- genlight for an efficient storage of binary SNPs genotypes

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
showClass(""genind"")

obj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))
obj
validObject(obj)
summary(obj)

## Not run:

# test inter-colonies structuration
if(require(hierfstat)){
gtest <- gstat.randtest(obj,nsim=99)
gtest
plot(gtest)
}

# perform a between-class PCA
pca1 <- dudi.pca(scaleGen(obj, NA.method=""mean""),scannf=FALSE,scale=FALSE)
pcabet1 <- between(pca1,obj@pop,scannf=FALSE)
pcabet1

s.class(pcabet1$ls,obj@pop,sub=""Inter-class PCA"",possub=""topleft"",csub=2)
add.scatter.eig(pcabet1$eig,2,xax=1,yax=2)
## End(Not run)
```



","[""UTF-8 adegenet formal class (S4) for individual genotypes DescriptionThe S4 class `genind` is used to store individual genotypes.It contains several components described in the 'slots' section).The `summary` of a `genind` object invisibly returns a list of component."", 'The function `.valid.genind` is for internal use.', 'The function `genind` creates a genind object from a valid table of alleles corresponding to the `@tab` slot.', 'Note that as in other S4 classes, slots are accessed using @ instead of $.', 'Slots- `tab`:: (accessor: ‘tab’)              matrix integers containing genotypes data for individuals (in rows) for all alleles (in columns).', ""The table differs depending on the `@type` slot:              - 'codom': values are numbers of alleles, summing up to the individuals' ploidies."", ""- 'PA': values are presence/absence of alleles."", 'In all cases, rows and columns are given generic names.- `loc.fac`:: (accessor: ‘locFac’) locus factor for the columns of `tab`- `loc.n.all`:: (accessor: ‘nAll’) integer vector giving the number of observed alleles per locus (see note)- `all.names`:: (accessor: ‘alleles’) list having one component per locus, each containing a character vector of allele names- `ploidy`:: (accessor: ‘ploidy’) an integer vector indicating the degree of ploidy of the genotypes.', ""Beware: 2 is not an integer, but 2L or as.integer(2) is.- `type`:: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g."", ""microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g."", 'AFLP).- `call`:: the matched call- `strata`:: (accessor: ‘strata’) (optional) data frame giving levels of population stratification for each individual- `hierarchy`:: (accessor: ‘hier’) (optional, currently unused) a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.- `pop`:: (accessor: ‘pop’) (optional) factor giving the population of each individual- `other`:: (accessor: ‘other’) (optional) a list containing other information Note:The `loc.n.all` slot will reflect the number of columns per locus that contain at least one observation.', 'This means that the sum of the this vector will not necessarily equal the number of columns in the data unless you use `drop = TRUE` when subsetting.', 'Methods- names: `signature(x = ""genind"")`: give the names of the components of a genind object- print: `signature(x = ""genind"")`: prints a genind object- show: `signature(object = ""genind"")`: shows a genind object (same as print)- summary: `signature(object = ""genind"")`: summarizes a genind object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE` See Also`as.genind`, `genind2genpop`, `genpop`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat`Related classes:- genpop for storing data per populations- genlight for an efficient storage of binary SNPs genotypes Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```rshowClass(""genind"")obj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))objvalidObject(obj)summary(obj) Not run: test inter-colonies structurationif(require(hierfstat)){gtest <- gstat.randtest(obj,nsim=99)gtestplot(gtest)} perform a between-class PCApca1 <- dudi.pca(scaleGen(obj, NA.method=""mean""),scannf=FALSE,scale=FALSE)pcabet1 <- between(pca1,obj@pop,scannf=FALSE)pcabet1s.class(pcabet1$ls,obj@pop,sub=""Inter-class PCA"",possub=""topleft"",csub=2)add.scatter.eig(pcabet1$eig,2,xax=1,yax=2) End(Not run)```']",1,"UTF-8 adegenet formal class (S4) for individual genotypes DescriptionThe S4 class `genind` is used to store individual genotypes.It contains several components described in the 'slots' section).The `summary` of a `genind` object invisibly returns a list of component. The function `.valid.genind` is for internal use. The function `genind` creates a genind object from a valid table of alleles corresponding to the `@tab` slot. Note that as in other S4 classes, slots are accessed using @ instead of $. Slots- `tab`:: (accessor: ‘tab’)              matrix integers containing genotypes data for individuals (in rows) for all alleles (in columns). The table differs depending on the `@type` slot:              - 'codom': values are numbers of alleles, summing up to the individuals' ploidies.              - 'PA': values are presence/absence of alleles.              In all cases, rows and columns are given generic names.- `loc.fac`:: (accessor: ‘locFac’) locus factor for the columns of `tab`- `loc.n.all`:: (accessor: ‘nAll’) integer vector giving the number of observed alleles per locus (see note)- `all.names`:: (accessor: ‘alleles’) list having one component per locus, each containing a character vector of allele names- `ploidy`:: (accessor: ‘ploidy’) an integer vector indicating the degree of ploidy of the genotypes. Beware: 2 is not an integer, but 2L or as.integer(2) is.- `type`:: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).- `call`:: the matched call- `strata`:: (accessor: ‘strata’) (optional) data frame giving levels of population stratification for each individual- `hierarchy`:: (accessor: ‘hier’) (optional, currently unused) a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.- `pop`:: (accessor: ‘pop’) (optional) factor giving the population of each individual- `other`:: (accessor: ‘other’) (optional) a list containing other information Note:The `loc.n.all` slot will reflect the number of columns per locus that contain at least one observation. This means that the sum of the this vector will not necessarily equal the number of columns in the data unless you use `drop = TRUE` when subsetting. ExtendsClass `""gen""`, directly. Class `""indInfo""`, directly. Methods- names: `signature(x = ""genind"")`: give the names of the components of a genind object- print: `signature(x = ""genind"")`: prints a genind object- show: `signature(object = ""genind"")`: shows a genind object (same as print)- summary: `signature(object = ""genind"")`: summarizes a genind object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE` See Also`as.genind`, `genind2genpop`, `genpop`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat`Related classes:- genpop for storing data per populations- genlight for an efficient storage of binary SNPs genotypes Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```rshowClass(""genind"")obj <- read.genetix(system.file(""files/nancycats.gtx"",package=""adegenet""))objvalidObject(obj)summary(obj) Not run: test inter-colonies structurationif(require(hierfstat)){gtest <- gstat.randtest(obj,nsim=99)gtestplot(gtest)} perform a between-class PCApca1 <- dudi.pca(scaleGen(obj, NA.method=""mean""),scannf=FALSE,scale=FALSE)pcabet1 <- between(pca1,obj@pop,scannf=FALSE)pcabet1s.class(pcabet1$ls,obj@pop,sub=""Inter-class PCA"",possub=""topleft"",csub=2)add.scatter.eig(pcabet1$eig,2,xax=1,yax=2) End(Not run)```",17
adegenet,HWE.md,"UTF-8

# Hardy-Weinberg Equilibrium test for multilocus data

## Description

The function `HWE.test` is a generic function to perform Hardy-Weinberg Equilibrium tests defined by the `genetics` package. adegenet proposes a method for `genind` objects.

The output can be of two forms:

- a list of tests (class `htest`) for each locus-population combinaison

- a population x locus matrix containing p-values of the tests

```r
## S3 method for class 'genind'
HWE.test(x,pop=NULL,permut=FALSE,nsim=1999,hide.NA=TRUE,res.type=c(""full"",""matrix""))
```

## Arguments

- `x`: an object of class `genind`.
- `pop`: a factor giving the population of each individual. If NULL, pop is seeked from x$pop.
- `permut`: a logical passed to `HWE.test` stating whether Monte Carlo version (TRUE) should be used or not (FALSE, default).
- `nsim`: number of simulations if Monte Carlo is used (passed to `HWE.test`).
- `hide.NA`: a logical stating whether non-tested loci (e.g., when an allele is fixed) should be hidden in the results (TRUE, default) or not (FALSE).
- `res.type`: a character or a character vector whose only first argument is considered giving the type of result to display. If ""full"", then a list of complete tests is returned. If ""matrix"", then a matrix of p-values is returned.

## Details

Monte Carlo procedure is quiet computer-intensive when large datasets are involved. For more precision on the performed test, read `HWE.test` documentation (`genetics` package).

## Returns

Returns either a list of tests or a matrix of p-values. In the first case, each test is designated by locus first and then by population. For instance if `res` is the ""full"" output of the function, then the test for population ""PopA"" at locus ""Myloc"" is given by res$Myloc$PopA. If `res` is a matrix of p-values, populations are in rows and loci in columns. P-values are given for the upper-tail: they correspond to the probability that an oberved chi-square statistic as high as or higher than the one observed occured under H0 (HWE).

In all cases, NA values are likely to appear in fixed loci, or entirely non-typed loci.

## See Also

`HWE.test` in the `genetics` package, `chisq.test`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(nancycats)
obj <- nancycats
if(require(genetics)){
obj.test <- HWE.test(obj)

# pvalues matrix to have a preview
HWE.test(obj,res.type=""matrix"")

#more precise view to...
obj.test$fca90$P10
}
## End(Not run)
```



","['UTF-8 Hardy-Weinberg Equilibrium test for multilocus data DescriptionThe function `HWE.test` is a generic function to perform Hardy-Weinberg Equilibrium tests defined by the `genetics` package.', 'adegenet proposes a method for `genind` objects.The output can be of two forms:- a list of tests (class `htest`) for each locus-population combinaison- a population x locus matrix containing p-values of the tests```r S3 method for class \'genind\'HWE.test(x,pop=NULL,permut=FALSE,nsim=1999,hide.NA=TRUE,res.type=c(""full"",""matrix""))``` Arguments- `x`: an object of class `genind`.- `pop`: a factor giving the population of each individual.', 'If NULL, pop is seeked from x$pop.- `permut`: a logical passed to `HWE.test` stating whether Monte Carlo version (TRUE) should be used or not (FALSE, default).- `nsim`: number of simulations if Monte Carlo is used (passed to `HWE.test`).- `hide.NA`: a logical stating whether non-tested loci (e.g., when an allele is fixed) should be hidden in the results (TRUE, default) or not (FALSE).- `res.type`: a character or a character vector whose only first argument is considered giving the type of result to display.', 'If ""full"", then a list of complete tests is returned.', 'If ""matrix"", then a matrix of p-values is returned.', 'DetailsMonte Carlo procedure is quiet computer-intensive when large datasets are involved.', 'For more precision on the performed test, read `HWE.test` documentation (`genetics` package).', 'ReturnsReturns either a list of tests or a matrix of p-values.', 'In the first case, each test is designated by locus first and then by population.', 'For instance if `res` is the ""full"" output of the function, then the test for population ""PopA"" at locus ""Myloc"" is given by res$Myloc$PopA.', 'If `res` is a matrix of p-values, populations are in rows and loci in columns.', 'P-values are given for the upper-tail: they correspond to the probability that an oberved chi-square statistic as high as or higher than the one observed occured under H0 (HWE).In all cases, NA values are likely to appear in fixed loci, or entirely non-typed loci.', 'See Also`HWE.test` in the `genetics` package, `chisq.test` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)obj <- nancycatsif(require(genetics)){obj.test <- HWE.test(obj) pvalues matrix to have a previewHWE.test(obj,res.type=""matrix"")more precise view to...obj.test$fca90$P10} End(Not run)```']",1,"UTF-8 Hardy-Weinberg Equilibrium test for multilocus data DescriptionThe function `HWE.test` is a generic function to perform Hardy-Weinberg Equilibrium tests defined by the `genetics` package. adegenet proposes a method for `genind` objects.The output can be of two forms:- a list of tests (class `htest`) for each locus-population combinaison- a population x locus matrix containing p-values of the tests```r S3 method for class 'genind'HWE.test(x,pop=NULL,permut=FALSE,nsim=1999,hide.NA=TRUE,res.type=c(""full"",""matrix""))``` Arguments- `x`: an object of class `genind`.- `pop`: a factor giving the population of each individual. If NULL, pop is seeked from x$pop.- `permut`: a logical passed to `HWE.test` stating whether Monte Carlo version (TRUE) should be used or not (FALSE, default).- `nsim`: number of simulations if Monte Carlo is used (passed to `HWE.test`).- `hide.NA`: a logical stating whether non-tested loci (e.g., when an allele is fixed) should be hidden in the results (TRUE, default) or not (FALSE).- `res.type`: a character or a character vector whose only first argument is considered giving the type of result to display. If ""full"", then a list of complete tests is returned. If ""matrix"", then a matrix of p-values is returned. DetailsMonte Carlo procedure is quiet computer-intensive when large datasets are involved. For more precision on the performed test, read `HWE.test` documentation (`genetics` package). ReturnsReturns either a list of tests or a matrix of p-values. In the first case, each test is designated by locus first and then by population. For instance if `res` is the ""full"" output of the function, then the test for population ""PopA"" at locus ""Myloc"" is given by res$Myloc$PopA. If `res` is a matrix of p-values, populations are in rows and loci in columns. P-values are given for the upper-tail: they correspond to the probability that an oberved chi-square statistic as high as or higher than the one observed occured under H0 (HWE).In all cases, NA values are likely to appear in fixed loci, or entirely non-typed loci. See Also`HWE.test` in the `genetics` package, `chisq.test` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)obj <- nancycatsif(require(genetics)){obj.test <- HWE.test(obj) pvalues matrix to have a previewHWE.test(obj,res.type=""matrix"")more precise view to...obj.test$fca90$P10} End(Not run)```",17
adegenet,glAux.md,"UTF-8

# Auxiliary functions for genlight objects

## Description

These functions provide facilities for usual computations using genlight objects. When ploidy varies across individuals, the outputs of these functions depend on whether the information units are individuals, or alleles within individuals (see details).

These functions are:

- `glSum`: computes the sum of the number of second allele in each SNP.

- `glNA`: computes the number of missing values in each SNP.

- `glMean`: computes the mean number of second allele in each SNP.

- `glVar`: computes the variance of the number of second allele in each SNP.

- `glDotProd`: computes dot products between (possibly centred/scaled) vectors of individuals - uses compiled C code - used by glPca.

```r
glSum(x, alleleAsUnit = TRUE, useC = FALSE)
glNA(x, alleleAsUnit = TRUE)
glMean(x, alleleAsUnit = TRUE)
glVar(x, alleleAsUnit = TRUE)
glDotProd(x, center = FALSE, scale = FALSE, alleleAsUnit = FALSE,
                parallel = FALSE, n.cores = NULL)
```

## Arguments

- `x`: a genlight object
- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.) or whether individuals are considered as units of information.
- `center`: a logical indicating whether SNPs should be centred to mean zero.
- `scale`: a logical indicating whether SNPs should be scaled to unit variance.
- `useC`: a logical indicating whether compiled C code should be used (TRUE) or not (FALSE, default).
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.

## Details

=== On the unit of information ===

In the cases where individuals can have different ploidy, computation of sums, means, etc. of allelic data depends on what we consider as a unit of information.

To estimate e.g. allele frequencies, unit of information can be considered as the allele, so that a diploid genotype contains two samples, a triploid individual, three samples, etc. In such a case, all computations are done directly on the number of alleles. This corresponds to `alleleAsUnit = TRUE`.

However, when the focus is put on studying differences/similarities between individuals, the unit of information is the individual, and all genotypes possess the same information no matter what their ploidy is. In this case, computations are made after standardizing individual genotypes to relative allele frequencies. This corresponds to `alleleAsUnit = FALSE`.

Note that when all individuals have the same ploidy, this distinction does not hold any more.

## Returns

A numeric vector containing the requested information.

## See Also

- `genlight`: class of object for storing massive binary SNP data.

- `dapc`: Discriminant Analysis of Principal Components.

- `glPca`: PCA for genlight objects.

- `glSim`: a simple simulator for genlight objects.

- `glPlot`: plotting genlight objects.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

x <- new(""genlight"", list(c(0,0,1,1,0), c(1,1,1,0,0,1), c(2,1,1,1,1,NA)))
x
as.matrix(x)
ploidy(x)

## compute statistics - allele as unit ##
glNA(x)
glSum(x)
glMean(x)

## compute statistics - individual as unit ##
glNA(x, FALSE)
glSum(x, FALSE)
glMean(x, FALSE)

## explanation: data are taken as relative frequencies
temp <- as.matrix(x)/ploidy(x)
apply(temp,2, function(e) sum(is.na(e))) # NAs
apply(temp,2,sum, na.rm=TRUE) # sum
apply(temp,2,mean, na.rm=TRUE) # mean
## End(Not run)
```



","['UTF-8 Auxiliary functions for genlight objects DescriptionThese functions provide facilities for usual computations using genlight objects.', 'When ploidy varies across individuals, the outputs of these functions depend on whether the information units are individuals, or alleles within individuals (see details).These functions are:- `glSum`: computes the sum of the number of second allele in each SNP.- `glNA`: computes the number of missing values in each SNP.- `glMean`: computes the mean number of second allele in each SNP.- `glVar`: computes the variance of the number of second allele in each SNP.- `glDotProd`: computes dot products between (possibly centred/scaled) vectors of individuals - uses compiled C code - used by glPca.```rglSum(x, alleleAsUnit = TRUE, useC = FALSE)glNA(x, alleleAsUnit = TRUE)glMean(x, alleleAsUnit = TRUE)glVar(x, alleleAsUnit = TRUE)glDotProd(x, center = FALSE, scale = FALSE, alleleAsUnit = FALSE,                parallel = FALSE, n.cores = NULL)``` Arguments- `x`: a genlight object- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.)', 'or whether individuals are considered as units of information.- `center`: a logical indicating whether SNPs should be centred to mean zero.- `scale`: a logical indicating whether SNPs should be scaled to unit variance.- `useC`: a logical indicating whether compiled C code should be used (TRUE) or not (FALSE, default).- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.', 'Details=== On the unit of information ===In the cases where individuals can have different ploidy, computation of sums, means, etc.', 'of allelic data depends on what we consider as a unit of information.To estimate e.g.', 'allele frequencies, unit of information can be considered as the allele, so that a diploid genotype contains two samples, a triploid individual, three samples, etc.', 'In such a case, all computations are done directly on the number of alleles.', 'This corresponds to `alleleAsUnit = TRUE`.However, when the focus is put on studying differences/similarities between individuals, the unit of information is the individual, and all genotypes possess the same information no matter what their ploidy is.', 'In this case, computations are made after standardizing individual genotypes to relative allele frequencies.', 'This corresponds to `alleleAsUnit = FALSE`.Note that when all individuals have the same ploidy, this distinction does not hold any more.', 'ReturnsA numeric vector containing the requested information.', 'See Also- `genlight`: class of object for storing massive binary SNP data.- `dapc`: Discriminant Analysis of Principal Components.- `glPca`: PCA for genlight objects.- `glSim`: a simple simulator for genlight objects.- `glPlot`: plotting genlight objects.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:x <- new(""genlight"", list(c(0,0,1,1,0), c(1,1,1,0,0,1), c(2,1,1,1,1,NA)))xas.matrix(x)ploidy(x) compute statistics - allele as unit glNA(x)glSum(x)glMean(x) compute statistics - individual as unit glNA(x, FALSE)glSum(x, FALSE)glMean(x, FALSE) explanation: data are taken as relative frequenciestemp <- as.matrix(x)/ploidy(x)apply(temp,2, function(e) sum(is.na(e)))  NAsapply(temp,2,sum, na.rm=TRUE)  sumapply(temp,2,mean, na.rm=TRUE)  mean End(Not run)```']",1,"UTF-8 Auxiliary functions for genlight objects DescriptionThese functions provide facilities for usual computations using genlight objects. When ploidy varies across individuals, the outputs of these functions depend on whether the information units are individuals, or alleles within individuals (see details).These functions are:- `glSum`: computes the sum of the number of second allele in each SNP.- `glNA`: computes the number of missing values in each SNP.- `glMean`: computes the mean number of second allele in each SNP.- `glVar`: computes the variance of the number of second allele in each SNP.- `glDotProd`: computes dot products between (possibly centred/scaled) vectors of individuals - uses compiled C code - used by glPca.```rglSum(x, alleleAsUnit = TRUE, useC = FALSE)glNA(x, alleleAsUnit = TRUE)glMean(x, alleleAsUnit = TRUE)glVar(x, alleleAsUnit = TRUE)glDotProd(x, center = FALSE, scale = FALSE, alleleAsUnit = FALSE,                parallel = FALSE, n.cores = NULL)``` Arguments- `x`: a genlight object- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.) or whether individuals are considered as units of information.- `center`: a logical indicating whether SNPs should be centred to mean zero.- `scale`: a logical indicating whether SNPs should be scaled to unit variance.- `useC`: a logical indicating whether compiled C code should be used (TRUE) or not (FALSE, default).- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used. Details=== On the unit of information ===In the cases where individuals can have different ploidy, computation of sums, means, etc. of allelic data depends on what we consider as a unit of information.To estimate e.g. allele frequencies, unit of information can be considered as the allele, so that a diploid genotype contains two samples, a triploid individual, three samples, etc. In such a case, all computations are done directly on the number of alleles. This corresponds to `alleleAsUnit = TRUE`.However, when the focus is put on studying differences/similarities between individuals, the unit of information is the individual, and all genotypes possess the same information no matter what their ploidy is. In this case, computations are made after standardizing individual genotypes to relative allele frequencies. This corresponds to `alleleAsUnit = FALSE`.Note that when all individuals have the same ploidy, this distinction does not hold any more. ReturnsA numeric vector containing the requested information. See Also- `genlight`: class of object for storing massive binary SNP data.- `dapc`: Discriminant Analysis of Principal Components.- `glPca`: PCA for genlight objects.- `glSim`: a simple simulator for genlight objects.- `glPlot`: plotting genlight objects. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:x <- new(""genlight"", list(c(0,0,1,1,0), c(1,1,1,0,0,1), c(2,1,1,1,1,NA)))xas.matrix(x)ploidy(x) compute statistics - allele as unit glNA(x)glSum(x)glMean(x) compute statistics - individual as unit glNA(x, FALSE)glSum(x, FALSE)glMean(x, FALSE) explanation: data are taken as relative frequenciestemp <- as.matrix(x)/ploidy(x)apply(temp,2, function(e) sum(is.na(e)))  NAsapply(temp,2,sum, na.rm=TRUE)  sumapply(temp,2,mean, na.rm=TRUE)  mean End(Not run)```",17
adegenet,genlight.md,"class

# Formal class ""genlight""

## Description

The class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme. This storage is most efficient with haploid data, where the memory taken to represent data can be reduced more than 50 times. However, `genlight` can be used for any level of ploidy, and still remain an efficient storage mode.

A `genlight` object can be constructed from vectors of integers giving the number of the second allele for each locus and each individual (see 'Objects of the class genlight' below).

 `genlight` stores multiple genotypes. Each genotype is stored as a SNPbin object.

## Objects from the class genlight

`genlight` objects can be created by calls to `new(""genlight"", ...)`, where '...' can be the following arguments:

- **`gen`**: input genotypes, where each genotype is coded as a vector of numbers of the second allele. If a list, each slot of the list correspond to an individual; if a matrix or a data.frame, rows correspond to individuals and columns to SNPs. If individuals or loci are named in the input, these names will we stored in the produced object. All individuals are expected to have the same number of SNPs. Shorter genotypes are completed with NAs, issuing a warning.
- **`ploidy`**: an optional vector of integers indicating the ploidy of the genotypes. Genotypes can therefore have different ploidy. If not provided, ploidy will be guessed from the data (as the maximum number of second alleles in each individual).
- **`ind.names`**: an optional vector of characters giving the labels of the genotypes.
- **`loc.names`**: an optional vector of characters giving the labels of the SNPs.
- **`loc.all`**: an optional vector of characters indicating the alleles of each SNP; for each SNP, alleles must be coded by two letters separated by '/', e.g. 'a/t' is valid, but 'a t' or 'a |t' are not.
- **`chromosome`**: an optional factor indicating the chromosome to which each SNP belongs.
- **`position`**: an optional vector of integers indicating the position of the SNPs.
- **`other`**: an optional list storing miscellaneous information.

## Slots

The following slots are the content of instances of the class `genlight`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.

- **`gen`:**: a list of genotypes stored as SNPbin objects.
- **`n.loc`:**: an integer indicating the number of SNPs of the genotype.
- **`ind.names`:**: a vector of characters indicating the names of genotypes.
- **`loc.names`:**: a vector of characters indicating the names of SNPs.
- **`loc.all`:**: a vector of characters indicating the alleles of each SNP.
- **`chromosome`:**: an optional factor indicating the chromosome to which each SNP belongs.
- **`position`:**: an optional vector of integers indicating the position of the SNPs.
- **`ploidy`:**: a vector of integers indicating the ploidy of each individual.
- **`pop`:**: a factor indicating the population of each individual.
- **`strata`:**: a data frame containing different levels of population definition. (For methods, see `addStrata` and `setPop`)
- **`hierarchy`:**: a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.
- **`other`:**: a list containing other miscellaneous information.

## Methods

Here is a list of methods available for `genlight` objects. Most of these methods are accessors, that is, functions which are used to retrieve the content of the object. Specific manpages can exist for accessors with more than one argument. These are indicated by a '*' symbol next to the method's name. This list also contains methods for conversion from `genlight` to other classes.

- **[**: `signature(x = ""genlight"")`: usual method to subset objects in R. Is to be applied as if the object was a matrix where genotypes were rows and SNPs were columns. Indexing can be done via vectors of signed integers or of logicals. See details for extra supported arguments.
- **show**: `signature(x = ""genlight"")`: printing of the object.
- **$**: `signature(x = ""genlight"")`: similar to the @ operator; used to access the content of slots of the object.
- **$<-**: `signature(x = ""genlight"")`: similar to the @ operator; used to replace the content of slots of the object.
- **tab**: `signature(x = ""genlight"")`: returns a table of allele counts (see `tab`; additional arguments are `freq`, a logical stating if relative frequencies should be returned (use for varying ploidy), and `NA.method`, a character indicating if missing values should be replaced by the mean frequency(""mean""), or left as is (""asis"").
- **nInd**: `signature(x = ""genlight"")`: returns the number of individuals in the object.
- **nPop**: `signature(x = ""genlight"")`: returns the number of populations in the object.
- **nLoc**: `signature(x = ""genlight"")`: returns the number of SNPs in the object.
- **dim**: `signature(x = ""genlight"")`: returns the number of individuals and SNPs in the object, respectively.
- **names**: `signature(x = ""genlight"")`: returns the names of the slots of the object.
- **indNames**: `signature(x = ""genlight"")`: returns the names of the individuals, if provided when the object was constructed.
- **indNames<-**: `signature(x = ""genlight"")`: sets the names of the individuals using a character vector of length `nInd(x)`.
- **popNames**: `signature(x = ""genlight"")`: returns the names of the populations, if provided when the object was constructed.
- **popNames<-**: `signature(x = ""genlight"")`: sets the names of the populations using a character vector of length `nPop(x)`.
- **locNames**: `signature(x = ""genlight"")`: returns the names of the loci, if provided when the object was constructed.
- **locNames<-**: `signature(x = ""genlight"")`: sets the names of the SNPs using a character vector of length `nLoc(x)`.
- **ploidy**: `signature(x = ""genlight"")`: returns the ploidy of the genotypes.
- **ploidy<-**: `signature(x = ""genlight"")`: sets the ploidy of the individuals using a vector of integers of size `nInd(x)`; if a single value is provided, the same ploidy is assumed for all individuals.
- **NA.posi**: `signature(x = ""genlight"")`: returns the indices of missing values (NAs) as a list with one vector of integer for each individual.
- **alleles**: `signature(x = ""genlight"")`: returns the names of the alleles of each SNPs, if provided when the object was constructed.
- **alleles<-**: `signature(x = ""genlight"")`: sets the names of the alleles of each SNPs using a character vector of length `nLoc(x)`; for each SNP, two alleles must be provided, separated by a ""/"", e.g. 'a/t', 'c/a', etc.
- **chromosome**: `signature(x = ""genlight"")`: returns a factor indicating the chromosome of each SNPs, or NULL if the information is missing.
- **chromosome<-**: `signature(x = ""genlight"")`: sets the chromosome to which SNPs belong using a factor of length `nLoc(x)`.
- **chr**: `signature(x = ""genlight"")`: shortcut for `chromosome`.
- **chr<-**: `signature(x = ""genlight"")`: shortcut for `chromosome<-`.
- **position**: `signature(x = ""genlight"")`: returns an integer vector indicating the position of each SNPs, or NULL if the information is missing.
- **position<-**: `signature(x = ""genlight"")`: sets the positions of the SNPs using an integer vector of length `nLoc(x)`.
- **pop**: `signature(x = ""genlight"")`: returns a factor indicating the population of each individual, if provided when the object was constructed.
- **pop<-**: `signature(x = ""genlight"")`: sets the population of each individual using a factor of length `nInd(x)`.
- **other**: `signature(x = ""genlight"")`: returns the content of the slot `@other`.
- **other<-**: `signature(x = ""genlight"")`: sets the content of the slot `@other`.
- **as.matrix**: `signature(x = ""genlight"")`: converts a `genlight` object into a matrix of integers, with individuals in rows and SNPs in columns. The S4 method 'as' can be used as well (e.g. as(x, ""matrix"")).
- **as.data.frame**: `signature(x = ""genlight"")`: same as `as.matrix`.
- **as.list**: `signature(x = ""genlight"")`: converts a `genlight` object into a list of genotypes coded as vector of integers (numbers of second allele). The S4 method 'as' can be used as well (e.g. as(x, ""list"")).
- **cbind**: `signature(x = ""genlight"")`: merges several genlight objects by column, i.e. regroups data of identical individuals genotyped for different SNPs.
- **rbind**: `signature(x = ""genlight"")`: merges several genlight objects by row, i.e. regroups data of different individuals genotyped for the same SNPs.

## Details

=== On the subsetting using `[` ===

The function `[` accepts the following extra arguments:

- **treatOther**: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE). If treated, elements of the list are examined for a possible match of length (vectors, lists) or number of rows (matrices, data frames) with the number of individuals. Those who match are subsetted accordingly. Others are left as is, issuing a warning unless the argument `quiet` is set to TRUE.
- **quiet**: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot which do not match the number of individuals (TRUE), or not (FALSE, default).
- **`...`**: further arguments passed to the genlight constructor.

## Author(s)

Thibaut Jombart (t.jombart@imperial.ac.uk )

Zhian N. Kamvar (kamvarz@science.oregonstate.edu )

## See Also

Related class:

- `SNPbin`, for storing individual genotypes of binary SNPs

- `genind`, for storing other types of genetic markers.

## Examples

```r
## Not run:

## TOY EXAMPLE ##
## create and convert data
dat <- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))
x <- new(""genlight"", dat)
x

## examine the content of the object
names(x)
x@gen
x@gen[[1]]@snp # bit-level coding for first individual

## conversions
as.list(x)
as.matrix(x)

## round trips - must return TRUE
identical(x, new(""genlight"", as.list(x))) # list
identical(x, new(""genlight"", as.matrix(x))) # matrix
identical(x, new(""genlight"", as.data.frame(x))) # data.frame

## test subsetting
x[c(1,3)] # keep individuals 1 and 3
as.list(x[c(1,3)])
x[c(1,3), 1:2] # keep individuals 1 and 3, loci 1 and 2
as.list(x[c(1,3), 1:2])
x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)] # same, using logicals
as.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)])


## REAL-SIZE EXAMPLE ##
## 50 genotypes of 1,000,000 SNPs
dat <- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))
names(dat) <- paste(""indiv"", 1:length(dat))
print(object.size(dat), unit=""aut"") # size of the original data

x <- new(""genlight"", dat) # conversion
x
print(object.size(x), unit=""au"") # size of the genlight object
object.size(dat)/object.size(x) # conversion efficiency



#### cbind, rbind ####
a <- new(""genlight"", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))

ara <- rbind(a,a)
ara
as.matrix(ara)

aca <- cbind(a,a)
aca
as.matrix(aca)


#### subsetting @other ####
x <- new(""genlight"", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))
x
other(x)
x[2:3]
other(x[2:3])
other(x[2:3, treatOther=FALSE])


#### seppop ####
pop(x) # no population info
pop(x) <- c(""pop1"",""pop1"", ""pop2"") # set population memberships
pop(x)
seppop(x)
## End(Not run)
```



","['class Formal class ""genlight"" DescriptionThe class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme.', 'This storage is most efficient with haploid data, where the memory taken to represent data can be reduced more than 50 times.', ""However, `genlight` can be used for any level of ploidy, and still remain an efficient storage mode.A `genlight` object can be constructed from vectors of integers giving the number of the second allele for each locus and each individual (see 'Objects of the class genlight' below)."", 'Each genotype is stored as a SNPbin object.', 'Objects from the class genlight`genlight` objects can be created by calls to `new(""genlight"", ...)`, where \'...\' can be the following arguments:- `gen`: input genotypes, where each genotype is coded as a vector of numbers of the second allele.', 'If a list, each slot of the list correspond to an individual; if a matrix or a data.frame, rows correspond to individuals and columns to SNPs.', 'If individuals or loci are named in the input, these names will we stored in the produced object.', 'All individuals are expected to have the same number of SNPs.', 'Shorter genotypes are completed with NAs, issuing a warning.- `ploidy`: an optional vector of integers indicating the ploidy of the genotypes.', 'Genotypes can therefore have different ploidy.', ""If not provided, ploidy will be guessed from the data (as the maximum number of second alleles in each individual).- `ind.names`: an optional vector of characters giving the labels of the genotypes.- `loc.names`: an optional vector of characters giving the labels of the SNPs.- `loc.all`: an optional vector of characters indicating the alleles of each SNP; for each SNP, alleles must be coded by two letters separated by '/', e.g."", ""'a/t' is valid, but 'a t' or 'a |t' are not.- `chromosome`: an optional factor indicating the chromosome to which each SNP belongs.- `position`: an optional vector of integers indicating the position of the SNPs.- `other`: an optional list storing miscellaneous information."", 'SlotsThe following slots are the content of instances of the class `genlight`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.- `gen`:: a list of genotypes stored as SNPbin objects.- `n.loc`:: an integer indicating the number of SNPs of the genotype.- `ind.names`:: a vector of characters indicating the names of genotypes.- `loc.names`:: a vector of characters indicating the names of SNPs.- `loc.all`:: a vector of characters indicating the alleles of each SNP.- `chromosome`:: an optional factor indicating the chromosome to which each SNP belongs.- `position`:: an optional vector of integers indicating the position of the SNPs.- `ploidy`:: a vector of integers indicating the ploidy of each individual.- `pop`:: a factor indicating the population of each individual.- `strata`:: a data frame containing different levels of population definition.', '(For methods, see `addStrata` and `setPop`)- `hierarchy`:: a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.- `other`:: a list containing other miscellaneous information.', 'MethodsHere is a list of methods available for `genlight` objects.', 'Most of these methods are accessors, that is, functions which are used to retrieve the content of the object.', 'Specific manpages can exist for accessors with more than one argument.', ""These are indicated by a '' symbol next to the method's name."", 'This list also contains methods for conversion from `genlight` to other classes.- [: `signature(x = ""genlight"")`: usual method to subset objects in R. Is to be applied as if the object was a matrix where genotypes were rows and SNPs were columns.', 'Indexing can be done via vectors of signed integers or of logicals.', 'See details for extra supported arguments.- show: `signature(x = ""genlight"")`: printing of the object.- $: `signature(x = ""genlight"")`: similar to the @ operator; used to access the content of slots of the object.- $<-: `signature(x = ""genlight"")`: similar to the @ operator; used to replace the content of slots of the object.- tab: `signature(x = ""genlight"")`: returns a table of allele counts (see `tab`; additional arguments are `freq`, a logical stating if relative frequencies should be returned (use for varying ploidy), and `NA.method`, a character indicating if missing values should be replaced by the mean frequency(""mean""), or left as is (""asis"").- nInd: `signature(x = ""genlight"")`: returns the number of individuals in the object.- nPop: `signature(x = ""genlight"")`: returns the number of populations in the object.- nLoc: `signature(x = ""genlight"")`: returns the number of SNPs in the object.- dim: `signature(x = ""genlight"")`: returns the number of individuals and SNPs in the object, respectively.- names: `signature(x = ""genlight"")`: returns the names of the slots of the object.- indNames: `signature(x = ""genlight"")`: returns the names of the individuals, if provided when the object was constructed.- indNames<-: `signature(x = ""genlight"")`: sets the names of the individuals using a character vector of length `nInd(x)`.- popNames: `signature(x = ""genlight"")`: returns the names of the populations, if provided when the object was constructed.- popNames<-: `signature(x = ""genlight"")`: sets the names of the populations using a character vector of length `nPop(x)`.- locNames: `signature(x = ""genlight"")`: returns the names of the loci, if provided when the object was constructed.- locNames<-: `signature(x = ""genlight"")`: sets the names of the SNPs using a character vector of length `nLoc(x)`.- ploidy: `signature(x = ""genlight"")`: returns the ploidy of the genotypes.- ploidy<-: `signature(x = ""genlight"")`: sets the ploidy of the individuals using a vector of integers of size `nInd(x)`; if a single value is provided, the same ploidy is assumed for all individuals.- NA.posi: `signature(x = ""genlight"")`: returns the indices of missing values (NAs) as a list with one vector of integer for each individual.- alleles: `signature(x = ""genlight"")`: returns the names of the alleles of each SNPs, if provided when the object was constructed.- alleles<-: `signature(x = ""genlight"")`: sets the names of the alleles of each SNPs using a character vector of length `nLoc(x)`; for each SNP, two alleles must be provided, separated by a ""/"", e.g.', '\'a/t\', \'c/a\', etc.- chromosome: `signature(x = ""genlight"")`: returns a factor indicating the chromosome of each SNPs, or NULL if the information is missing.- chromosome<-: `signature(x = ""genlight"")`: sets the chromosome to which SNPs belong using a factor of length `nLoc(x)`.- chr: `signature(x = ""genlight"")`: shortcut for `chromosome`.- chr<-: `signature(x = ""genlight"")`: shortcut for `chromosome<-`.- position: `signature(x = ""genlight"")`: returns an integer vector indicating the position of each SNPs, or NULL if the information is missing.- position<-: `signature(x = ""genlight"")`: sets the positions of the SNPs using an integer vector of length `nLoc(x)`.- pop: `signature(x = ""genlight"")`: returns a factor indicating the population of each individual, if provided when the object was constructed.- pop<-: `signature(x = ""genlight"")`: sets the population of each individual using a factor of length `nInd(x)`.- other: `signature(x = ""genlight"")`: returns the content of the slot `@other`.- other<-: `signature(x = ""genlight"")`: sets the content of the slot `@other`.- as.matrix: `signature(x = ""genlight"")`: converts a `genlight` object into a matrix of integers, with individuals in rows and SNPs in columns.', ""The S4 method 'as' can be used as well (e.g."", 'as(x, ""matrix"")).- as.data.frame: `signature(x = ""genlight"")`: same as `as.matrix`.- as.list: `signature(x = ""genlight"")`: converts a `genlight` object into a list of genotypes coded as vector of integers (numbers of second allele).', ""The S4 method 'as' can be used as well (e.g."", 'as(x, ""list"")).- cbind: `signature(x = ""genlight"")`: merges several genlight objects by column, i.e.', 'regroups data of identical individuals genotyped for different SNPs.- rbind: `signature(x = ""genlight"")`: merges several genlight objects by row, i.e.', 'regroups data of different individuals genotyped for the same SNPs.', 'Details=== On the subsetting using `[` ===The function `[` accepts the following extra arguments:- treatOther: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE).', 'If treated, elements of the list are examined for a possible match of length (vectors, lists) or number of rows (matrices, data frames) with the number of individuals.', 'Those who match are subsetted accordingly.', 'Others are left as is, issuing a warning unless the argument `quiet` is set to TRUE.- quiet: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot which do not match the number of individuals (TRUE), or not (FALSE, default).- `...`: further arguments passed to the genlight constructor.', 'Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk )Zhian N. Kamvar (kamvarz@science.oregonstate.edu ) See AlsoRelated class:- `SNPbin`, for storing individual genotypes of binary SNPs- `genind`, for storing other types of genetic markers.', 'Examples```r Not run: TOY EXAMPLE  create and convert datadat <- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))x <- new(""genlight"", dat)x examine the content of the objectnames(x)x@genx@gen[[1]]@snp  bit-level coding for first individual conversionsas.list(x)as.matrix(x) round trips - must return TRUEidentical(x, new(""genlight"", as.list(x)))  listidentical(x, new(""genlight"", as.matrix(x)))  matrixidentical(x, new(""genlight"", as.data.frame(x)))  data.frame test subsettingx[c(1,3)]  keep individuals 1 and 3as.list(x[c(1,3)])x[c(1,3), 1:2]  keep individuals 1 and 3, loci 1 and 2as.list(x[c(1,3), 1:2])x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)]  same, using logicalsas.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)]) REAL-SIZE EXAMPLE  50 genotypes of 1,000,000 SNPsdat <- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))names(dat) <- paste(""indiv"", 1:length(dat))print(object.size(dat), unit=""aut"")  size of the original datax <- new(""genlight"", dat)  conversionxprint(object.size(x), unit=""au"")  size of the genlight objectobject.size(dat)/object.size(x)  conversion efficiency cbind, rbind a <- new(""genlight"", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))ara <- rbind(a,a)araas.matrix(ara)aca <- cbind(a,a)acaas.matrix(aca) subsetting @other x <- new(""genlight"", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))xother(x)x[2:3]other(x[2:3])other(x[2:3, treatOther=FALSE]) seppop pop(x)  no population infopop(x) <- c(""pop1"",""pop1"", ""pop2"")  set population membershipspop(x)seppop(x) End(Not run)```']",1,"class Formal class ""genlight"" DescriptionThe class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme. This storage is most efficient with haploid data, where the memory taken to represent data can be reduced more than 50 times. However, `genlight` can be used for any level of ploidy, and still remain an efficient storage mode.A `genlight` object can be constructed from vectors of integers giving the number of the second allele for each locus and each individual (see 'Objects of the class genlight' below). `genlight` stores multiple genotypes. Each genotype is stored as a SNPbin object. Objects from the class genlight`genlight` objects can be created by calls to `new(""genlight"", ...)`, where '...' can be the following arguments:- `gen`: input genotypes, where each genotype is coded as a vector of numbers of the second allele. If a list, each slot of the list correspond to an individual; if a matrix or a data.frame, rows correspond to individuals and columns to SNPs. If individuals or loci are named in the input, these names will we stored in the produced object. All individuals are expected to have the same number of SNPs. Shorter genotypes are completed with NAs, issuing a warning.- `ploidy`: an optional vector of integers indicating the ploidy of the genotypes. Genotypes can therefore have different ploidy. If not provided, ploidy will be guessed from the data (as the maximum number of second alleles in each individual).- `ind.names`: an optional vector of characters giving the labels of the genotypes.- `loc.names`: an optional vector of characters giving the labels of the SNPs.- `loc.all`: an optional vector of characters indicating the alleles of each SNP; for each SNP, alleles must be coded by two letters separated by '/', e.g. 'a/t' is valid, but 'a t' or 'a |t' are not.- `chromosome`: an optional factor indicating the chromosome to which each SNP belongs.- `position`: an optional vector of integers indicating the position of the SNPs.- `other`: an optional list storing miscellaneous information. SlotsThe following slots are the content of instances of the class `genlight`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.- `gen`:: a list of genotypes stored as SNPbin objects.- `n.loc`:: an integer indicating the number of SNPs of the genotype.- `ind.names`:: a vector of characters indicating the names of genotypes.- `loc.names`:: a vector of characters indicating the names of SNPs.- `loc.all`:: a vector of characters indicating the alleles of each SNP.- `chromosome`:: an optional factor indicating the chromosome to which each SNP belongs.- `position`:: an optional vector of integers indicating the position of the SNPs.- `ploidy`:: a vector of integers indicating the ploidy of each individual.- `pop`:: a factor indicating the population of each individual.- `strata`:: a data frame containing different levels of population definition. (For methods, see `addStrata` and `setPop`)- `hierarchy`:: a hierarchical `formula` defining the hierarchical levels in the `@@strata` slot.- `other`:: a list containing other miscellaneous information. MethodsHere is a list of methods available for `genlight` objects. Most of these methods are accessors, that is, functions which are used to retrieve the content of the object. Specific manpages can exist for accessors with more than one argument. These are indicated by a '' symbol next to the method's name. This list also contains methods for conversion from `genlight` to other classes.- [: `signature(x = ""genlight"")`: usual method to subset objects in R. Is to be applied as if the object was a matrix where genotypes were rows and SNPs were columns. Indexing can be done via vectors of signed integers or of logicals. See details for extra supported arguments.- show: `signature(x = ""genlight"")`: printing of the object.- $: `signature(x = ""genlight"")`: similar to the @ operator; used to access the content of slots of the object.- $<-: `signature(x = ""genlight"")`: similar to the @ operator; used to replace the content of slots of the object.- tab: `signature(x = ""genlight"")`: returns a table of allele counts (see `tab`; additional arguments are `freq`, a logical stating if relative frequencies should be returned (use for varying ploidy), and `NA.method`, a character indicating if missing values should be replaced by the mean frequency(""mean""), or left as is (""asis"").- nInd: `signature(x = ""genlight"")`: returns the number of individuals in the object.- nPop: `signature(x = ""genlight"")`: returns the number of populations in the object.- nLoc: `signature(x = ""genlight"")`: returns the number of SNPs in the object.- dim: `signature(x = ""genlight"")`: returns the number of individuals and SNPs in the object, respectively.- names: `signature(x = ""genlight"")`: returns the names of the slots of the object.- indNames: `signature(x = ""genlight"")`: returns the names of the individuals, if provided when the object was constructed.- indNames<-: `signature(x = ""genlight"")`: sets the names of the individuals using a character vector of length `nInd(x)`.- popNames: `signature(x = ""genlight"")`: returns the names of the populations, if provided when the object was constructed.- popNames<-: `signature(x = ""genlight"")`: sets the names of the populations using a character vector of length `nPop(x)`.- locNames: `signature(x = ""genlight"")`: returns the names of the loci, if provided when the object was constructed.- locNames<-: `signature(x = ""genlight"")`: sets the names of the SNPs using a character vector of length `nLoc(x)`.- ploidy: `signature(x = ""genlight"")`: returns the ploidy of the genotypes.- ploidy<-: `signature(x = ""genlight"")`: sets the ploidy of the individuals using a vector of integers of size `nInd(x)`; if a single value is provided, the same ploidy is assumed for all individuals.- NA.posi: `signature(x = ""genlight"")`: returns the indices of missing values (NAs) as a list with one vector of integer for each individual.- alleles: `signature(x = ""genlight"")`: returns the names of the alleles of each SNPs, if provided when the object was constructed.- alleles<-: `signature(x = ""genlight"")`: sets the names of the alleles of each SNPs using a character vector of length `nLoc(x)`; for each SNP, two alleles must be provided, separated by a ""/"", e.g. 'a/t', 'c/a', etc.- chromosome: `signature(x = ""genlight"")`: returns a factor indicating the chromosome of each SNPs, or NULL if the information is missing.- chromosome<-: `signature(x = ""genlight"")`: sets the chromosome to which SNPs belong using a factor of length `nLoc(x)`.- chr: `signature(x = ""genlight"")`: shortcut for `chromosome`.- chr<-: `signature(x = ""genlight"")`: shortcut for `chromosome<-`.- position: `signature(x = ""genlight"")`: returns an integer vector indicating the position of each SNPs, or NULL if the information is missing.- position<-: `signature(x = ""genlight"")`: sets the positions of the SNPs using an integer vector of length `nLoc(x)`.- pop: `signature(x = ""genlight"")`: returns a factor indicating the population of each individual, if provided when the object was constructed.- pop<-: `signature(x = ""genlight"")`: sets the population of each individual using a factor of length `nInd(x)`.- other: `signature(x = ""genlight"")`: returns the content of the slot `@other`.- other<-: `signature(x = ""genlight"")`: sets the content of the slot `@other`.- as.matrix: `signature(x = ""genlight"")`: converts a `genlight` object into a matrix of integers, with individuals in rows and SNPs in columns. The S4 method 'as' can be used as well (e.g. as(x, ""matrix"")).- as.data.frame: `signature(x = ""genlight"")`: same as `as.matrix`.- as.list: `signature(x = ""genlight"")`: converts a `genlight` object into a list of genotypes coded as vector of integers (numbers of second allele). The S4 method 'as' can be used as well (e.g. as(x, ""list"")).- cbind: `signature(x = ""genlight"")`: merges several genlight objects by column, i.e. regroups data of identical individuals genotyped for different SNPs.- rbind: `signature(x = ""genlight"")`: merges several genlight objects by row, i.e. regroups data of different individuals genotyped for the same SNPs. Details=== On the subsetting using `[` ===The function `[` accepts the following extra arguments:- treatOther: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE). If treated, elements of the list are examined for a possible match of length (vectors, lists) or number of rows (matrices, data frames) with the number of individuals. Those who match are subsetted accordingly. Others are left as is, issuing a warning unless the argument `quiet` is set to TRUE.- quiet: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot which do not match the number of individuals (TRUE), or not (FALSE, default).- `...`: further arguments passed to the genlight constructor. Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk )Zhian N. Kamvar (kamvarz@science.oregonstate.edu ) See AlsoRelated class:- `SNPbin`, for storing individual genotypes of binary SNPs- `genind`, for storing other types of genetic markers. Examples```r Not run: TOY EXAMPLE  create and convert datadat <- list(toto=c(1,1,0,0), titi=c(NA,1,1,0), tata=c(NA,0,3, NA))x <- new(""genlight"", dat)x examine the content of the objectnames(x)x@genx@gen[[1]]@snp  bit-level coding for first individual conversionsas.list(x)as.matrix(x) round trips - must return TRUEidentical(x, new(""genlight"", as.list(x)))  listidentical(x, new(""genlight"", as.matrix(x)))  matrixidentical(x, new(""genlight"", as.data.frame(x)))  data.frame test subsettingx[c(1,3)]  keep individuals 1 and 3as.list(x[c(1,3)])x[c(1,3), 1:2]  keep individuals 1 and 3, loci 1 and 2as.list(x[c(1,3), 1:2])x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)]  same, using logicalsas.list(x[c(TRUE,FALSE), c(TRUE,TRUE,FALSE,FALSE)]) REAL-SIZE EXAMPLE  50 genotypes of 1,000,000 SNPsdat <- lapply(1:50, function(i) sample(c(0,1,NA), 1e6, prob=c(.5, .49, .01), replace=TRUE))names(dat) <- paste(""indiv"", 1:length(dat))print(object.size(dat), unit=""aut"")  size of the original datax <- new(""genlight"", dat)  conversionxprint(object.size(x), unit=""au"")  size of the genlight objectobject.size(dat)/object.size(x)  conversion efficiency cbind, rbind a <- new(""genlight"", list(toto=rep(1,10), tata=rep(c(0,1), each=5), titi=c(NA, rep(1,9)) ))ara <- rbind(a,a)araas.matrix(ara)aca <- cbind(a,a)acaas.matrix(aca) subsetting @other x <- new(""genlight"", list(a=1,b=0,c=1), other=list(1:3, letters,data.frame(2:4)))xother(x)x[2:3]other(x[2:3])other(x[2:3, treatOther=FALSE]) seppop pop(x)  no population infopop(x) <- c(""pop1"",""pop1"", ""pop2"")  set population membershipspop(x)seppop(x) End(Not run)```",17
adegenet,spca_randtest.md,"# Monte Carlo test for sPCA

```r
spca_randtest(x, nperm = 499, p = 0.05)
```

## Arguments

- `x`: A `spca` object.
- `nperm`: The number of permutations to be used for the test.
- `p`: p value to use for Bonferroni correction.

## Returns

A list with two objects of the class 'randtest' (see `as.randtest`), the first one for 'global' structures (positivie autocorrelation) and the second for 'local' structures (negative autocorrelation).

## Description

The function `spca_randtest` implements Monte-Carlo tests for the presence of significant spatial structures in a sPCA object. Two tests are run, for global (positive autocorrelation) and local (negative autocorrelation) structures, respectively. The test statistics used are the sum of the absolute values of the corresponding eigenvalues.

## Examples

```r
## Not run:

## Load data
data(sim2pop)

## Make spca
spca1 <- spca(sim2pop, type = 1, scannf = FALSE, plot.nb = FALSE)

spca1
plot(spca1)

## run tests (use more permutations in practice, e.g. 999)
tests <- spca_randtest(spca1, nperm = 49)

## check results
tests
plot(tests[[1]]) # global structures
## End(Not run)
```

## Author(s)

Original code by Valeria Montano adapted by Thibaut Jombart.



","['Monte Carlo test for sPCA```rspca_randtest(x, nperm = 499, p = 0.05)``` Arguments- `x`: A `spca` object.- `nperm`: The number of permutations to be used for the test.- `p`: p value to use for Bonferroni correction.', ""ReturnsA list with two objects of the class 'randtest' (see `as.randtest`), the first one for 'global' structures (positivie autocorrelation) and the second for 'local' structures (negative autocorrelation)."", 'DescriptionThe function `spca_randtest` implements Monte-Carlo tests for the presence of significant spatial structures in a sPCA object.', 'Two tests are run, for global (positive autocorrelation) and local (negative autocorrelation) structures, respectively.', 'The test statistics used are the sum of the absolute values of the corresponding eigenvalues.', 'Examples```r Not run: Load datadata(sim2pop) Make spcaspca1 <- spca(sim2pop, type = 1, scannf = FALSE, plot.nb = FALSE)spca1plot(spca1) run tests (use more permutations in practice, e.g.', '999)tests <- spca_randtest(spca1, nperm = 49) check resultstestsplot(tests[[1]])  global structures End(Not run)``` Author(s)Original code by Valeria Montano adapted by Thibaut Jombart.']",1," Monte Carlo test for sPCA```rspca_randtest(x, nperm = 499, p = 0.05)``` Arguments- `x`: A `spca` object.- `nperm`: The number of permutations to be used for the test.- `p`: p value to use for Bonferroni correction. ReturnsA list with two objects of the class 'randtest' (see `as.randtest`), the first one for 'global' structures (positivie autocorrelation) and the second for 'local' structures (negative autocorrelation). DescriptionThe function `spca_randtest` implements Monte-Carlo tests for the presence of significant spatial structures in a sPCA object. Two tests are run, for global (positive autocorrelation) and local (negative autocorrelation) structures, respectively. The test statistics used are the sum of the absolute values of the corresponding eigenvalues. Examples```r Not run: Load datadata(sim2pop) Make spcaspca1 <- spca(sim2pop, type = 1, scannf = FALSE, plot.nb = FALSE)spca1plot(spca1) run tests (use more permutations in practice, e.g. 999)tests <- spca_randtest(spca1, nperm = 49) check resultstestsplot(tests[[1]])  global structures End(Not run)``` Author(s)Original code by Valeria Montano adapted by Thibaut Jombart.",17
adegenet,inbreeding.md,"UTF-8

# Likelihood-based estimation of inbreeding

## Description

The function `inbreeding` estimates the inbreeding coefficient of an individuals (F) by computing its likelihood function. It can return either the density of probability of F, or a sample of F values from this distribution. This operation is performed for all the individuals of a genind object. Any ploidy greater than 1 is acceptable.

```r
inbreeding(x, pop = NULL, truenames = TRUE, 
           res.type = c(""sample"", ""function"", ""estimate""), N = 200, M = N * 10)
```

## Arguments

- `x`: an object of class genind .
- `pop`: a factor giving the 'population' of each individual. If NULL, pop is seeked from `pop(x)`. Note that the term population refers in fact to any grouping of individuals'.
- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".
- `res.type`: a character string matching ""sample"", ""function"", or ""estimate"" specifying whether the output should be a function giving the density of probability of F values (""function""), the maximum likelihood estimate of F from this distribution (""estimate""), or a sample of F values taken from this distribution (""sample"", default).
- `N`: an integer indicating the size of the sample to be taken from the distribution of F values.
- `M`: an integer indicating the number of different F values to be used to generate the sample. Values larger than N are recommended to avoid poor sampling of the distribution.

## Returns

A named list with one component for each individual, each of which is a function or a vector of sampled F values (see `res.type` argument).

## See Also

`Hs`: computation of expected heterozygosity.

## Details

Let `F` denote the inbreeding coefficient, defined as the probability for an individual to inherit two identical alleles from a single ancestor.

Let `p_i` refer to the frequency of allele `i` in the population. Let `h` be an variable which equates 1 if the individual is homozygote, and 0 otherwise. For one locus, the probability of being homozygote is computed as:

 ` F + (1-F) \sum_i p_i^2`

The probability of being heterozygote is: `1 - (F + (1-F) \sum_i p_i^2)`

The likelihood of a genotype is defined as the probability of being the observed state (homozygote or heterozygote). In the case of multilocus genotypes, log-likelihood are summed over the loci.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

Zhian N. Kamvar

## Examples

```r
## Not run:

## cattle breed microsatellite data
data(microbov)

## isolate Lagunaire breed
lagun <- seppop(microbov)$Lagunaire

## estimate inbreeding - return sample of F values
Fsamp <- inbreeding(lagun, N=30)

## plot the first 10 results
invisible(sapply(Fsamp[1:10], function(e) plot(density(e), xlab=""F"",
xlim=c(0,1), main=""Density of the sampled F values"")))

## compute means for all individuals
Fmean=sapply(Fsamp, mean)
hist(Fmean, col=""orange"", xlab=""mean value of F"",
main=""Distribution of mean F across individuals"")

## estimate inbreeding - return proba density functions
Fdens <- inbreeding(lagun, res.type=""function"")

## view function for the first individual
Fdens[[1]]

## plot the first 10 functions
invisible(sapply(Fdens[1:10], plot, ylab=""Density"",
main=""Density of probability of F values""))

## estimate inbreeding - return maximum likelihood estimates
Fest <- inbreeding(lagun, res.type = ""estimate"")
mostInbred <- which.max(Fest)
plot(Fdens[[mostInbred]], ylab = ""Density"", xlab = ""F"",
     main = paste(""Probability density of F values\nfor"", names(mostInbred)))
abline(v = Fest[mostInbred], col = ""red"", lty = 2)
legend(""topright"", legend = ""MLE"", col = ""red"", lty = 2)

## note that estimates and average samples are likely to be different.
plot(Fest, ylab = ""F"", col = ""blue"",
     main = ""comparison of MLE and average sample estimates of F"")
points(Fmean, pch = 2, col = ""red"")
arrows(x0 = 1:length(Fest), y0 = Fest, 
       y1 = Fmean, x1 = 1:length(Fest), length = 0.125)
legend(""topleft"", legend = c(""estimate"", ""sample""), col = c(""blue"", ""red""),
       pch = c(1, 2), title = ""res.type"")
## End(Not run)
```



","['UTF-8 Likelihood-based estimation of inbreeding DescriptionThe function `inbreeding` estimates the inbreeding coefficient of an individuals (F) by computing its likelihood function.', 'It can return either the density of probability of F, or a sample of F values from this distribution.', 'This operation is performed for all the individuals of a genind object.', 'Any ploidy greater than 1 is acceptable.```rinbreeding(x, pop = NULL, truenames = TRUE,            res.type = c(""sample"", ""function"", ""estimate""), N = 200, M = N  10)``` Arguments- `x`: an object of class genind .- `pop`: a factor giving the \'population\' of each individual.', 'If NULL, pop is seeked from `pop(x)`.', 'Note that the term population refers in fact to any grouping of individuals\'.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".- `res.type`: a character string matching ""sample"", ""function"", or ""estimate"" specifying whether the output should be a function giving the density of probability of F values (""function""), the maximum likelihood estimate of F from this distribution (""estimate""), or a sample of F values taken from this distribution (""sample"", default).- `N`: an integer indicating the size of the sample to be taken from the distribution of F values.- `M`: an integer indicating the number of different F values to be used to generate the sample.', 'Values larger than N are recommended to avoid poor sampling of the distribution.', 'ReturnsA named list with one component for each individual, each of which is a function or a vector of sampled F values (see `res.type` argument).', 'See Also`Hs`: computation of expected heterozygosity.', 'DetailsLet `F` denote the inbreeding coefficient, defined as the probability for an individual to inherit two identical alleles from a single ancestor.Let `p_i` refer to the frequency of allele `i` in the population.', 'Let `h` be an variable which equates 1 if the individual is homozygote, and 0 otherwise.', 'For one locus, the probability of being homozygote is computed as: ` F + (1-F) \\sum_i p_i^2`The probability of being heterozygote is: `1 - (F + (1-F) \\sum_i p_i^2)`The likelihood of a genotype is defined as the probability of being the observed state (homozygote or heterozygote).', 'In the case of multilocus genotypes, log-likelihood are summed over the loci.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.ukZhian N. Kamvar Examples```r Not run: cattle breed microsatellite datadata(microbov) isolate Lagunaire breedlagun <- seppop(microbov)$Lagunaire estimate inbreeding - return sample of F valuesFsamp <- inbreeding(lagun, N=30) plot the first 10 resultsinvisible(sapply(Fsamp[1:10], function(e) plot(density(e), xlab=""F"",xlim=c(0,1), main=""Density of the sampled F values""))) compute means for all individualsFmean=sapply(Fsamp, mean)hist(Fmean, col=""orange"", xlab=""mean value of F"",main=""Distribution of mean F across individuals"") estimate inbreeding - return proba density functionsFdens <- inbreeding(lagun, res.type=""function"") view function for the first individualFdens[[1]] plot the first 10 functionsinvisible(sapply(Fdens[1:10], plot, ylab=""Density"",main=""Density of probability of F values"")) estimate inbreeding - return maximum likelihood estimatesFest <- inbreeding(lagun, res.type = ""estimate"")mostInbred <- which.max(Fest)plot(Fdens[[mostInbred]], ylab = ""Density"", xlab = ""F"",     main = paste(""Probability density of F values\\nfor"", names(mostInbred)))abline(v = Fest[mostInbred], col = ""red"", lty = 2)legend(""topright"", legend = ""MLE"", col = ""red"", lty = 2) note that estimates and average samples are likely to be different.plot(Fest, ylab = ""F"", col = ""blue"",     main = ""comparison of MLE and average sample estimates of F"")points(Fmean, pch = 2, col = ""red"")arrows(x0 = 1:length(Fest), y0 = Fest,        y1 = Fmean, x1 = 1:length(Fest), length = 0.125)legend(""topleft"", legend = c(""estimate"", ""sample""), col = c(""blue"", ""red""),       pch = c(1, 2), title = ""res.type"") End(Not run)```']",1,"UTF-8 Likelihood-based estimation of inbreeding DescriptionThe function `inbreeding` estimates the inbreeding coefficient of an individuals (F) by computing its likelihood function. It can return either the density of probability of F, or a sample of F values from this distribution. This operation is performed for all the individuals of a genind object. Any ploidy greater than 1 is acceptable.```rinbreeding(x, pop = NULL, truenames = TRUE,            res.type = c(""sample"", ""function"", ""estimate""), N = 200, M = N  10)``` Arguments- `x`: an object of class genind .- `pop`: a factor giving the 'population' of each individual. If NULL, pop is seeked from `pop(x)`. Note that the term population refers in fact to any grouping of individuals'.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".- `res.type`: a character string matching ""sample"", ""function"", or ""estimate"" specifying whether the output should be a function giving the density of probability of F values (""function""), the maximum likelihood estimate of F from this distribution (""estimate""), or a sample of F values taken from this distribution (""sample"", default).- `N`: an integer indicating the size of the sample to be taken from the distribution of F values.- `M`: an integer indicating the number of different F values to be used to generate the sample. Values larger than N are recommended to avoid poor sampling of the distribution. ReturnsA named list with one component for each individual, each of which is a function or a vector of sampled F values (see `res.type` argument). See Also`Hs`: computation of expected heterozygosity. DetailsLet `F` denote the inbreeding coefficient, defined as the probability for an individual to inherit two identical alleles from a single ancestor.Let `p_i` refer to the frequency of allele `i` in the population. Let `h` be an variable which equates 1 if the individual is homozygote, and 0 otherwise. For one locus, the probability of being homozygote is computed as: ` F + (1-F) \sum_i p_i^2`The probability of being heterozygote is: `1 - (F + (1-F) \sum_i p_i^2)`The likelihood of a genotype is defined as the probability of being the observed state (homozygote or heterozygote). In the case of multilocus genotypes, log-likelihood are summed over the loci. Author(s)Thibaut Jombart t.jombart@imperial.ac.ukZhian N. Kamvar Examples```r Not run: cattle breed microsatellite datadata(microbov) isolate Lagunaire breedlagun <- seppop(microbov)$Lagunaire estimate inbreeding - return sample of F valuesFsamp <- inbreeding(lagun, N=30) plot the first 10 resultsinvisible(sapply(Fsamp[1:10], function(e) plot(density(e), xlab=""F"",xlim=c(0,1), main=""Density of the sampled F values""))) compute means for all individualsFmean=sapply(Fsamp, mean)hist(Fmean, col=""orange"", xlab=""mean value of F"",main=""Distribution of mean F across individuals"") estimate inbreeding - return proba density functionsFdens <- inbreeding(lagun, res.type=""function"") view function for the first individualFdens[[1]] plot the first 10 functionsinvisible(sapply(Fdens[1:10], plot, ylab=""Density"",main=""Density of probability of F values"")) estimate inbreeding - return maximum likelihood estimatesFest <- inbreeding(lagun, res.type = ""estimate"")mostInbred <- which.max(Fest)plot(Fdens[[mostInbred]], ylab = ""Density"", xlab = ""F"",     main = paste(""Probability density of F values\nfor"", names(mostInbred)))abline(v = Fest[mostInbred], col = ""red"", lty = 2)legend(""topright"", legend = ""MLE"", col = ""red"", lty = 2) note that estimates and average samples are likely to be different.plot(Fest, ylab = ""F"", col = ""blue"",     main = ""comparison of MLE and average sample estimates of F"")points(Fmean, pch = 2, col = ""red"")arrows(x0 = 1:length(Fest), y0 = Fest,        y1 = Fmean, x1 = 1:length(Fest), length = 0.125)legend(""topleft"", legend = c(""estimate"", ""sample""), col = c(""blue"", ""red""),       pch = c(1, 2), title = ""res.type"") End(Not run)```",17
adegenet,as.genlight.md,"# Conversion to class ""genlight""

## Description

The class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme. New instances of this class are best created using `new`; see the manpage of genlight for more information on this point.

As a shortcut, conversion methods can be used to convert various objects into a genlight object. Conversions can be achieved using S3-style (`as.genlight(x)`) or S4-style (`as(x,""genlight""`) procedures. All of them call upon the constructor (`new`) of genlight objects.

Conversion is currently available from the following objects: - matrix of type integer/numeric - data.frame with integer/numeric data - list of vectors of integer/numeric type

## Author(s)

Thibaut Jombart (t.jombart@imperial.ac.uk )

## See Also

Related class:

- `SNPbin`, for storing individual genotypes of binary SNPs

- `genind`

## Examples

```r
## Not run:

## data to be converted
dat <- list(toto=c(1,1,0,0,2,2,1,2,NA), titi=c(NA,1,1,0,1,1,1,0,0), tata=c(NA,0,3, NA,1,1,1,0,0))

## using the constructor
x1 <- new(""genlight"", dat)
x1

## using 'as' methods
x2 <- as.genlight(dat)
x3 <- as(dat, ""genlight"")

identical(x1,x2)
identical(x1,x3)
## End(Not run)
```



","['Conversion to class ""genlight"" DescriptionThe class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme.', 'New instances of this class are best created using `new`; see the manpage of genlight for more information on this point.As a shortcut, conversion methods can be used to convert various objects into a genlight object.', 'Conversions can be achieved using S3-style (`as.genlight(x)`) or S4-style (`as(x,""genlight""`) procedures.', 'All of them call upon the constructor (`new`) of genlight objects.Conversion is currently available from the following objects: - matrix of type integer/numeric - data.frame with integer/numeric data - list of vectors of integer/numeric type Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `SNPbin`, for storing individual genotypes of binary SNPs- `genind` Examples```r Not run: data to be converteddat <- list(toto=c(1,1,0,0,2,2,1,2,NA), titi=c(NA,1,1,0,1,1,1,0,0), tata=c(NA,0,3, NA,1,1,1,0,0)) using the constructorx1 <- new(""genlight"", dat)x1 using \'as\' methodsx2 <- as.genlight(dat)x3 <- as(dat, ""genlight"")identical(x1,x2)identical(x1,x3) End(Not run)```']",1," Conversion to class ""genlight"" DescriptionThe class `genlight` is a formal (S4) class for storing a genotypes of binary SNPs in a compact way, using a bit-level coding scheme. New instances of this class are best created using `new`; see the manpage of genlight for more information on this point.As a shortcut, conversion methods can be used to convert various objects into a genlight object. Conversions can be achieved using S3-style (`as.genlight(x)`) or S4-style (`as(x,""genlight""`) procedures. All of them call upon the constructor (`new`) of genlight objects.Conversion is currently available from the following objects: - matrix of type integer/numeric - data.frame with integer/numeric data - list of vectors of integer/numeric type Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `SNPbin`, for storing individual genotypes of binary SNPs- `genind` Examples```r Not run: data to be converteddat <- list(toto=c(1,1,0,0,2,2,1,2,NA), titi=c(NA,1,1,0,1,1,1,0,0), tata=c(NA,0,3, NA,1,1,1,0,0)) using the constructorx1 <- new(""genlight"", dat)x1 using 'as' methodsx2 <- as.genlight(dat)x3 <- as(dat, ""genlight"")identical(x1,x2)identical(x1,x3) End(Not run)```",17
adegenet,dapcGraphics.md,"UTF-8

# Graphics for Discriminant Analysis of Principal Components (DAPC)

## Description

These functions provide graphic outputs for Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). See `?dapc` for details about this method. DAPC graphics are detailed in the DAPC tutorial accessible using `vignette(""adegenet-dapc"")`.

These functions all require an object of class `dapc` (the "".dapc"" can be ommitted when calling the functions):

- `scatter.dapc`: produces scatterplots of principal components (or 'discriminant functions'), with a screeplot of eigenvalues as inset.

- `assignplot`: plot showing the probabilities of assignment of individuals to the different clusters.

```r
## S3 method for class 'dapc'
scatter(x, xax=1, yax=2, grp=x$grp, col=seasun(length(levels(grp))),
      pch=20, bg=""white"", solid=.7, scree.da=TRUE,
      scree.pca=FALSE, posi.da=""bottomright"",
      posi.pca=""bottomleft"", bg.inset=""white"", ratio.da=.25,
      ratio.pca=.25, inset.da=0.02, inset.pca=0.02,
      inset.solid=.5, onedim.filled=TRUE, mstree=FALSE, lwd=1,
      lty=1, segcol=""black"", legend=FALSE, posi.leg=""topright"",
      cleg=1, txt.leg=levels(grp), cstar = 1, cellipse = 1.5,
      axesell = FALSE, label = levels(grp), clabel = 1, xlim =
      NULL, ylim = NULL, grid = FALSE, addaxes = TRUE, origin =
      c(0,0), include.origin = TRUE, sub = """", csub = 1, possub =
      ""bottomleft"", cgrid = 1, pixmap = NULL, contour = NULL, area
      = NULL, label.inds = NULL, ...)

assignplot(x, only.grp=NULL, subset=NULL, new.pred=NULL, cex.lab=.75,pch=3)
```

## Arguments

- `x`: a `dapc` object.
- `xax,yax`: `integers` specifying which principal components of DAPC should be shown in x and y axes.
- `grp`: a factor defining group membership for the individuals. The scatterplot is optimal only for the default group, i.e. the one used in the DAPC analysis.
- `col`: a suitable color to be used for groups. The specified vector should match the number of groups, not the number of individuals.
- `pch`: a `numeric` indicating the type of point to be used to indicate the prior group of individuals (see `points` documentation for more details); one value is expected for each group; recycled if necessary.
- `bg`: the color used for the background of the scatterplot.
- `solid`: a value between 0 and 1 indicating the alpha level for the colors of the plot; 0=full transparency, 1=solid colours.
- `scree.da`: a logical indicating whether a screeplot of Discriminant Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE).
- `scree.pca`: a logical indicating whether a screeplot of Principal Component Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE); retained axes are displayed in black.
- `posi.da`: the position of the inset of DA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".
- `posi.pca`: the position of the inset of PCA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".
- `bg.inset`: the color to be used as background for the inset plots.
- `ratio.da`: the size of the inset of DA eigenvalues as a proportion of the current plotting region.
- `ratio.pca`: the size of the inset of PCA eigenvalues as a proportion of the current plotting region.
- `inset.da`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of DA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.
- `inset.pca`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of PCA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.
- `inset.solid`: a value between 0 and 1 indicating the alpha level for the colors of the inset plots; 0=full transparency, 1=solid colours.
- `onedim.filled`: a logical indicating whether curves should be filled when plotting a single discriminant function (TRUE), or not (FALSE).
- `mstree`: a logical indicating whether a minimum spanning tree linking the groups and based on the squared distances between the groups inside the entire space should added to the plot (TRUE), or not (FALSE).
- `lwd,lty,segcol`: the line width, line type, and segment colour to be used for the minimum spanning tree.
- `legend`: a logical indicating whether a legend for group colours should added to the plot (TRUE), or not (FALSE).
- `posi.leg`: the position of the legend for group colours; can match any combination of ""top/bottom"" and ""left/right"", or a set of x/y coordinates stored as a list (`locator` can be used).
- `cleg`: a size factor used for the legend.
- `cstar,cellipse,axesell,label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.class` for more informations
- `only.grp`: a `character` vector indicating which groups should be displayed. Values should match values of `x$grp`. If `NULL`, all results are displayed
- `subset`: `integer` or `logical` vector indicating which individuals should be displayed. If `NULL`, all results are displayed
- `new.pred`: an optional list, as returned by the `predict` method for `dapc` objects; if provided, the individuals with unknown groups are added at the bottom of the plot. To visualize these individuals only, specify `only.grp=""unknown""`.
- `cex.lab`: a `numeric` indicating the size of labels.
- `txt.leg`: a character vector indicating the text to be used in the legend; if not provided, group names stored in `x$grp` are used.
- `label.inds`: Named list of arguments passed to the `orditorp` function. This will label individual points witout overlapping. Arguments `x` and `display` are hardcoded and should not be specified by user.
- ``: further arguments to be passed to other functions. For `scatter`, arguments passed to `points`; for `compoplot`, arguments passed to `barplot`.

## Details

See the documentation of `dapc` for more information about the method.

## Returns

All functions return the matched call.

## References

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94

## See Also

- `dapc`: implements the DAPC.

- `find.clusters`: to identify clusters without prior.

- `dapcIllus`: a set of simulated data illustrating the DAPC

- `eHGDP`, `H3N2`: empirical datasets illustrating DAPC

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(H3N2)
dapc1 <- dapc(H3N2, pop=H3N2$other$epid, n.pca=30,n.da=6)

## defautl plot ##
scatter(dapc1)

## label individuals at the periphery
# air = 2 is a measure of how much space each label needs
# pch = NA suppresses plotting of points
scatter(dapc1, label.inds = list(air = 2, pch = NA))

## showing different scatter options ##
## remove internal segments and ellipses, different pch, add MStree
scatter(dapc1, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2, posi.da=""topleft"")

## only ellipse, custom labels, use insets
scatter(dapc1, cell=2, pch="""", cstar=0, posi.pca=""topleft"", posi.da=""topleft"", scree.pca=TRUE,
inset.pca=c(.01,.3), label=paste(""year\n"",2001:2006), axesel=FALSE, col=terrain.colors(10))

## without ellipses, use legend for groups
scatter(dapc1, cell=0, cstar=0, scree.da=FALSE, clab=0, cex=3,
solid=.4, bg=""white"", leg=TRUE, posi.leg=""topleft"")

## only one axis
scatter(dapc1,1,1,scree.da=FALSE, legend=TRUE, solid=.4,bg=""white"")



## example using genlight objects ##
## simulate data
x <- glSim(50,4e3-50, 50, ploidy=2)
x
plot(x)

## perform DAPC
dapc2 <- dapc(x, n.pca=10, n.da=1)
dapc2

## plot results
scatter(dapc2, scree.da=FALSE, leg=TRUE, txt.leg=paste(""group"",
c('A','B')), col=c(""red"",""blue""))

## SNP contributions
loadingplot(dapc2$var.contr)
loadingplot(tail(dapc2$var.contr, 100), main=""Loading plot - last 100 SNPs"")



## assignplot / compoplot ##
assignplot(dapc1, only.grp=2006)

data(microbov)
dapc3 <- dapc(microbov, n.pca=20, n.da=15)
compoplot(dapc3, lab="""")
## End(Not run)
```



","['UTF-8 Graphics for Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions provide graphic outputs for Discriminant Analysis of Principal Components (DAPC, Jombart et al.', 'See `?dapc` for details about this method.', 'DAPC graphics are detailed in the DAPC tutorial accessible using `vignette(""adegenet-dapc"")`.These functions all require an object of class `dapc` (the "".dapc"" can be ommitted when calling the functions):- `scatter.dapc`: produces scatterplots of principal components (or \'discriminant functions\'), with a screeplot of eigenvalues as inset.- `assignplot`: plot showing the probabilities of assignment of individuals to the different clusters.```r S3 method for class \'dapc\'scatter(x, xax=1, yax=2, grp=x$grp, col=seasun(length(levels(grp))),      pch=20, bg=""white"", solid=.7, scree.da=TRUE,      scree.pca=FALSE, posi.da=""bottomright"",      posi.pca=""bottomleft"", bg.inset=""white"", ratio.da=.25,      ratio.pca=.25, inset.da=0.02, inset.pca=0.02,      inset.solid=.5, onedim.filled=TRUE, mstree=FALSE, lwd=1,      lty=1, segcol=""black"", legend=FALSE, posi.leg=""topright"",      cleg=1, txt.leg=levels(grp), cstar = 1, cellipse = 1.5,      axesell = FALSE, label = levels(grp), clabel = 1, xlim =      NULL, ylim = NULL, grid = FALSE, addaxes = TRUE, origin =      c(0,0), include.origin = TRUE, sub = """", csub = 1, possub =      ""bottomleft"", cgrid = 1, pixmap = NULL, contour = NULL, area      = NULL, label.inds = NULL, ...)assignplot(x, only.grp=NULL, subset=NULL, new.pred=NULL, cex.lab=.75,pch=3)``` Arguments- `x`: a `dapc` object.- `xax,yax`: `integers` specifying which principal components of DAPC should be shown in x and y axes.- `grp`: a factor defining group membership for the individuals.', 'The scatterplot is optimal only for the default group, i.e.', 'the one used in the DAPC analysis.- `col`: a suitable color to be used for groups.', 'The specified vector should match the number of groups, not the number of individuals.- `pch`: a `numeric` indicating the type of point to be used to indicate the prior group of individuals (see `points` documentation for more details); one value is expected for each group; recycled if necessary.- `bg`: the color used for the background of the scatterplot.- `solid`: a value between 0 and 1 indicating the alpha level for the colors of the plot; 0=full transparency, 1=solid colours.- `scree.da`: a logical indicating whether a screeplot of Discriminant Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE).- `scree.pca`: a logical indicating whether a screeplot of Principal Component Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE); retained axes are displayed in black.- `posi.da`: the position of the inset of DA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".- `posi.pca`: the position of the inset of PCA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".- `bg.inset`: the color to be used as background for the inset plots.- `ratio.da`: the size of the inset of DA eigenvalues as a proportion of the current plotting region.- `ratio.pca`: the size of the inset of PCA eigenvalues as a proportion of the current plotting region.- `inset.da`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of DA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.- `inset.pca`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of PCA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.- `inset.solid`: a value between 0 and 1 indicating the alpha level for the colors of the inset plots; 0=full transparency, 1=solid colours.- `onedim.filled`: a logical indicating whether curves should be filled when plotting a single discriminant function (TRUE), or not (FALSE).- `mstree`: a logical indicating whether a minimum spanning tree linking the groups and based on the squared distances between the groups inside the entire space should added to the plot (TRUE), or not (FALSE).- `lwd,lty,segcol`: the line width, line type, and segment colour to be used for the minimum spanning tree.- `legend`: a logical indicating whether a legend for group colours should added to the plot (TRUE), or not (FALSE).- `posi.leg`: the position of the legend for group colours; can match any combination of ""top/bottom"" and ""left/right"", or a set of x/y coordinates stored as a list (`locator` can be used).- `cleg`: a size factor used for the legend.- `cstar,cellipse,axesell,label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.class` for more informations- `only.grp`: a `character` vector indicating which groups should be displayed.', 'Values should match values of `x$grp`.', 'If `NULL`, all results are displayed- `subset`: `integer` or `logical` vector indicating which individuals should be displayed.', 'If `NULL`, all results are displayed- `new.pred`: an optional list, as returned by the `predict` method for `dapc` objects; if provided, the individuals with unknown groups are added at the bottom of the plot.', 'To visualize these individuals only, specify `only.grp=""unknown""`.- `cex.lab`: a `numeric` indicating the size of labels.- `txt.leg`: a character vector indicating the text to be used in the legend; if not provided, group names stored in `x$grp` are used.- `label.inds`: Named list of arguments passed to the `orditorp` function.', 'This will label individual points witout overlapping.', 'Arguments `x` and `display` are hardcoded and should not be specified by user.- ``: further arguments to be passed to other functions.', 'For `scatter`, arguments passed to `points`; for `compoplot`, arguments passed to `barplot`.', 'DetailsSee the documentation of `dapc` for more information about the method.', 'ReturnsAll functions return the matched call.', 'ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also- `dapc`: implements the DAPC.- `find.clusters`: to identify clusters without prior.- `dapcIllus`: a set of simulated data illustrating the DAPC- `eHGDP`, `H3N2`: empirical datasets illustrating DAPC Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(H3N2)dapc1 <- dapc(H3N2, pop=H3N2$other$epid, n.pca=30,n.da=6) defautl plot scatter(dapc1) label individuals at the periphery air = 2 is a measure of how much space each label needs pch = NA suppresses plotting of pointsscatter(dapc1, label.inds = list(air = 2, pch = NA)) showing different scatter options  remove internal segments and ellipses, different pch, add MStreescatter(dapc1, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2, posi.da=""topleft"") only ellipse, custom labels, use insetsscatter(dapc1, cell=2, pch="""", cstar=0, posi.pca=""topleft"", posi.da=""topleft"", scree.pca=TRUE,inset.pca=c(.01,.3), label=paste(""year\\n"",2001:2006), axesel=FALSE, col=terrain.colors(10)) without ellipses, use legend for groupsscatter(dapc1, cell=0, cstar=0, scree.da=FALSE, clab=0, cex=3,solid=.4, bg=""white"", leg=TRUE, posi.leg=""topleft"") only one axisscatter(dapc1,1,1,scree.da=FALSE, legend=TRUE, solid=.4,bg=""white"") example using genlight objects  simulate datax <- glSim(50,4e3-50, 50, ploidy=2)xplot(x) perform DAPCdapc2 <- dapc(x, n.pca=10, n.da=1)dapc2 plot resultsscatter(dapc2, scree.da=FALSE, leg=TRUE, txt.leg=paste(""group"",c(\'A\',\'B\')), col=c(""red"",""blue"")) SNP contributionsloadingplot(dapc2$var.contr)loadingplot(tail(dapc2$var.contr, 100), main=""Loading plot - last 100 SNPs"") assignplot / compoplot assignplot(dapc1, only.grp=2006)data(microbov)dapc3 <- dapc(microbov, n.pca=20, n.da=15)compoplot(dapc3, lab="""") End(Not run)```']",1,"UTF-8 Graphics for Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions provide graphic outputs for Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). See `?dapc` for details about this method. DAPC graphics are detailed in the DAPC tutorial accessible using `vignette(""adegenet-dapc"")`.These functions all require an object of class `dapc` (the "".dapc"" can be ommitted when calling the functions):- `scatter.dapc`: produces scatterplots of principal components (or 'discriminant functions'), with a screeplot of eigenvalues as inset.- `assignplot`: plot showing the probabilities of assignment of individuals to the different clusters.```r S3 method for class 'dapc'scatter(x, xax=1, yax=2, grp=x$grp, col=seasun(length(levels(grp))),      pch=20, bg=""white"", solid=.7, scree.da=TRUE,      scree.pca=FALSE, posi.da=""bottomright"",      posi.pca=""bottomleft"", bg.inset=""white"", ratio.da=.25,      ratio.pca=.25, inset.da=0.02, inset.pca=0.02,      inset.solid=.5, onedim.filled=TRUE, mstree=FALSE, lwd=1,      lty=1, segcol=""black"", legend=FALSE, posi.leg=""topright"",      cleg=1, txt.leg=levels(grp), cstar = 1, cellipse = 1.5,      axesell = FALSE, label = levels(grp), clabel = 1, xlim =      NULL, ylim = NULL, grid = FALSE, addaxes = TRUE, origin =      c(0,0), include.origin = TRUE, sub = """", csub = 1, possub =      ""bottomleft"", cgrid = 1, pixmap = NULL, contour = NULL, area      = NULL, label.inds = NULL, ...)assignplot(x, only.grp=NULL, subset=NULL, new.pred=NULL, cex.lab=.75,pch=3)``` Arguments- `x`: a `dapc` object.- `xax,yax`: `integers` specifying which principal components of DAPC should be shown in x and y axes.- `grp`: a factor defining group membership for the individuals. The scatterplot is optimal only for the default group, i.e. the one used in the DAPC analysis.- `col`: a suitable color to be used for groups. The specified vector should match the number of groups, not the number of individuals.- `pch`: a `numeric` indicating the type of point to be used to indicate the prior group of individuals (see `points` documentation for more details); one value is expected for each group; recycled if necessary.- `bg`: the color used for the background of the scatterplot.- `solid`: a value between 0 and 1 indicating the alpha level for the colors of the plot; 0=full transparency, 1=solid colours.- `scree.da`: a logical indicating whether a screeplot of Discriminant Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE).- `scree.pca`: a logical indicating whether a screeplot of Principal Component Analysis eigenvalues should be displayed in inset (TRUE) or not (FALSE); retained axes are displayed in black.- `posi.da`: the position of the inset of DA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".- `posi.pca`: the position of the inset of PCA eigenvalues; can match any combination of ""top/bottom"" and ""left/right"".- `bg.inset`: the color to be used as background for the inset plots.- `ratio.da`: the size of the inset of DA eigenvalues as a proportion of the current plotting region.- `ratio.pca`: the size of the inset of PCA eigenvalues as a proportion of the current plotting region.- `inset.da`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of DA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.- `inset.pca`: a vector with two numeric values (recycled if needed) indicating the inset to be used for the screeplot of PCA eigenvalues as a proportion of the current plotting region; see `?add.scatter` for more details.- `inset.solid`: a value between 0 and 1 indicating the alpha level for the colors of the inset plots; 0=full transparency, 1=solid colours.- `onedim.filled`: a logical indicating whether curves should be filled when plotting a single discriminant function (TRUE), or not (FALSE).- `mstree`: a logical indicating whether a minimum spanning tree linking the groups and based on the squared distances between the groups inside the entire space should added to the plot (TRUE), or not (FALSE).- `lwd,lty,segcol`: the line width, line type, and segment colour to be used for the minimum spanning tree.- `legend`: a logical indicating whether a legend for group colours should added to the plot (TRUE), or not (FALSE).- `posi.leg`: the position of the legend for group colours; can match any combination of ""top/bottom"" and ""left/right"", or a set of x/y coordinates stored as a list (`locator` can be used).- `cleg`: a size factor used for the legend.- `cstar,cellipse,axesell,label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.class` for more informations- `only.grp`: a `character` vector indicating which groups should be displayed. Values should match values of `x$grp`. If `NULL`, all results are displayed- `subset`: `integer` or `logical` vector indicating which individuals should be displayed. If `NULL`, all results are displayed- `new.pred`: an optional list, as returned by the `predict` method for `dapc` objects; if provided, the individuals with unknown groups are added at the bottom of the plot. To visualize these individuals only, specify `only.grp=""unknown""`.- `cex.lab`: a `numeric` indicating the size of labels.- `txt.leg`: a character vector indicating the text to be used in the legend; if not provided, group names stored in `x$grp` are used.- `label.inds`: Named list of arguments passed to the `orditorp` function. This will label individual points witout overlapping. Arguments `x` and `display` are hardcoded and should not be specified by user.- ``: further arguments to be passed to other functions. For `scatter`, arguments passed to `points`; for `compoplot`, arguments passed to `barplot`. DetailsSee the documentation of `dapc` for more information about the method. ReturnsAll functions return the matched call. ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also- `dapc`: implements the DAPC.- `find.clusters`: to identify clusters without prior.- `dapcIllus`: a set of simulated data illustrating the DAPC- `eHGDP`, `H3N2`: empirical datasets illustrating DAPC Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(H3N2)dapc1 <- dapc(H3N2, pop=H3N2$other$epid, n.pca=30,n.da=6) defautl plot scatter(dapc1) label individuals at the periphery air = 2 is a measure of how much space each label needs pch = NA suppresses plotting of pointsscatter(dapc1, label.inds = list(air = 2, pch = NA)) showing different scatter options  remove internal segments and ellipses, different pch, add MStreescatter(dapc1, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2, posi.da=""topleft"") only ellipse, custom labels, use insetsscatter(dapc1, cell=2, pch="""", cstar=0, posi.pca=""topleft"", posi.da=""topleft"", scree.pca=TRUE,inset.pca=c(.01,.3), label=paste(""year\n"",2001:2006), axesel=FALSE, col=terrain.colors(10)) without ellipses, use legend for groupsscatter(dapc1, cell=0, cstar=0, scree.da=FALSE, clab=0, cex=3,solid=.4, bg=""white"", leg=TRUE, posi.leg=""topleft"") only one axisscatter(dapc1,1,1,scree.da=FALSE, legend=TRUE, solid=.4,bg=""white"") example using genlight objects  simulate datax <- glSim(50,4e3-50, 50, ploidy=2)xplot(x) perform DAPCdapc2 <- dapc(x, n.pca=10, n.da=1)dapc2 plot resultsscatter(dapc2, scree.da=FALSE, leg=TRUE, txt.leg=paste(""group"",c('A','B')), col=c(""red"",""blue"")) SNP contributionsloadingplot(dapc2$var.contr)loadingplot(tail(dapc2$var.contr, 100), main=""Loading plot - last 100 SNPs"") assignplot / compoplot assignplot(dapc1, only.grp=2006)data(microbov)dapc3 <- dapc(microbov, n.pca=20, n.da=15)compoplot(dapc3, lab="""") End(Not run)```",18
adegenet,pairDist.md,"UTF-8

# Pairwise distance plots

## Description

The function `pairDistPlot` extracts and plots pairwise distances between different groups (graphs use ggplot2). The function `pairDistPlot` does the same, without the graphs.

 `pairDistPlot` is a generic function with methods for the following types of objects:

- `dist`

- `matrix` (only numeric data)

- `genind` objects (genetic markers, individuals)

- `DNAbin` objects (DNA sequences)

```r
pairDist(x, ...)

pairDistPlot(x, ...)

## S3 method for class 'dist'
pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'matrix'
pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'genind'
pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)

## S3 method for class 'DNAbin'
pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,
             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)
```

## Arguments

- `x`: pairwise distances provided as a `dist` or a symmetric `matrix`, or `genind` or `DNAbin` object. For `genind` objects, pairwise squared Euclidean distances are computed from the allele data. For `DNAbin` objects, distances are computed uing `dist.dna`, and '...' is used to pass arguments to the function.
- `grp`: a factor defining a grouping of individuals.
- `within`: a logical indicating whether to keep within-group comparisons.
- `sep`: a character used as separator between group names
- `data`: a logical indicating whether data of the plot should be returned.
- `violin`: a logical indicating whether a violinplot should be generated.
- `boxplot`: a logical indicating whether a boxplot should be generated.
- `jitter`: a logical indicating whether a jitter-plot should be generated.
- ``...``: further arguments to be used by other functions; used for `DNAbin` object to pass argumetns to `dist.dna`.

## Returns

A list with different components, depending on the values of the arguments. Plots are returned as `ggplot2` objects.

## See Also

`gengraph` to identify connectivity based on distances.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk .

## Examples

```r
## Not run:


## use a subset of influenza data
data(H3N2)
set.seed(1)
dat <- H3N2[sample(1:nInd(H3N2), 100)]

## get pairwise distances
temp <- pairDistPlot(dat, other(dat)$epid)

## see raw data
head(temp$data)

## see plots
temp$boxplot
temp$violin
temp$jitter
## End(Not run)
```



","['UTF-8 Pairwise distance plots DescriptionThe function `pairDistPlot` extracts and plots pairwise distances between different groups (graphs use ggplot2).', 'The function `pairDistPlot` does the same, without the graphs.', '`pairDistPlot` is a generic function with methods for the following types of objects:- `dist`- `matrix` (only numeric data)- `genind` objects (genetic markers, individuals)- `DNAbin` objects (DNA sequences)```rpairDist(x, ...)pairDistPlot(x, ...) S3 method for class \'dist\'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class \'matrix\'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class \'genind\'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class \'DNAbin\'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)``` Arguments- `x`: pairwise distances provided as a `dist` or a symmetric `matrix`, or `genind` or `DNAbin` object.', 'For `genind` objects, pairwise squared Euclidean distances are computed from the allele data.', ""For `DNAbin` objects, distances are computed uing `dist.dna`, and '...' is used to pass arguments to the function.- `grp`: a factor defining a grouping of individuals.- `within`: a logical indicating whether to keep within-group comparisons.- `sep`: a character used as separator between group names- `data`: a logical indicating whether data of the plot should be returned.- `violin`: a logical indicating whether a violinplot should be generated.- `boxplot`: a logical indicating whether a boxplot should be generated.- `jitter`: a logical indicating whether a jitter-plot should be generated.- ``...``: further arguments to be used by other functions; used for `DNAbin` object to pass argumetns to `dist.dna`."", 'ReturnsA list with different components, depending on the values of the arguments.', 'Plots are returned as `ggplot2` objects.', 'See Also`gengraph` to identify connectivity based on distances.', 'Examples```r Not run: use a subset of influenza datadata(H3N2)set.seed(1)dat <- H3N2[sample(1:nInd(H3N2), 100)] get pairwise distancestemp <- pairDistPlot(dat, other(dat)$epid) see raw datahead(temp$data) see plotstemp$boxplottemp$violintemp$jitter End(Not run)```']",1,"UTF-8 Pairwise distance plots DescriptionThe function `pairDistPlot` extracts and plots pairwise distances between different groups (graphs use ggplot2). The function `pairDistPlot` does the same, without the graphs. `pairDistPlot` is a generic function with methods for the following types of objects:- `dist`- `matrix` (only numeric data)- `genind` objects (genetic markers, individuals)- `DNAbin` objects (DNA sequences)```rpairDist(x, ...)pairDistPlot(x, ...) S3 method for class 'dist'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class 'matrix'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class 'genind'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...) S3 method for class 'DNAbin'pairDistPlot(x, grp, within=FALSE, sep=""-"", data=TRUE,             violin=TRUE, boxplot=TRUE, jitter=TRUE, ...)``` Arguments- `x`: pairwise distances provided as a `dist` or a symmetric `matrix`, or `genind` or `DNAbin` object. For `genind` objects, pairwise squared Euclidean distances are computed from the allele data. For `DNAbin` objects, distances are computed uing `dist.dna`, and '...' is used to pass arguments to the function.- `grp`: a factor defining a grouping of individuals.- `within`: a logical indicating whether to keep within-group comparisons.- `sep`: a character used as separator between group names- `data`: a logical indicating whether data of the plot should be returned.- `violin`: a logical indicating whether a violinplot should be generated.- `boxplot`: a logical indicating whether a boxplot should be generated.- `jitter`: a logical indicating whether a jitter-plot should be generated.- ``...``: further arguments to be used by other functions; used for `DNAbin` object to pass argumetns to `dist.dna`. ReturnsA list with different components, depending on the values of the arguments. Plots are returned as `ggplot2` objects. See Also`gengraph` to identify connectivity based on distances. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk . Examples```r Not run: use a subset of influenza datadata(H3N2)set.seed(1)dat <- H3N2[sample(1:nInd(H3N2), 100)] get pairwise distancestemp <- pairDistPlot(dat, other(dat)$epid) see raw datahead(temp$data) see plotstemp$boxplottemp$violintemp$jitter End(Not run)```",18
adegenet,AICc.md,"# Compute Akaike Information Criterion for small samples (AICc) for snapclust

```r
AICc(object, ...)

## S3 method for class 'snapclust'
AICc(object, ...)
```

## Arguments

- `object`: An object returned by the function `snapclust`.
- `...`: Further arguments for compatibility with the `AIC` generic (currently not used).

## Description

Do not use. We work on that stuff. Contact us if interested.

## See Also

`snapclust` to generate clustering solutions.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","[""Compute Akaike Information Criterion for small samples (AICc) for snapclust```rAICc(object, ...) S3 method for class 'snapclust'AICc(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used)."", 'We work on that stuff.', 'See Also`snapclust` to generate clustering solutions.']",1," Compute Akaike Information Criterion for small samples (AICc) for snapclust```rAICc(object, ...) S3 method for class 'snapclust'AICc(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used). DescriptionDo not use. We work on that stuff. Contact us if interested. See Also`snapclust` to generate clustering solutions. Author(s)Thibaut Jombart thibautjombart@gmail.com",18
adegenet,hybridtoy.md," data

# Toy hybrid dataset

## Format

a genind object

## Description

Toy hybrid dataset

## Examples

```r
data(hybridtoy)
x <- hybridtoy
pca1 <- dudi.pca(tab(x), scannf=FALSE, scale=FALSE)
s.class(pca1$li, pop(x))

if(require(ggplot2)) {
p <- ggplot(pca1$li, aes(x=Axis1)) +
    geom_density(aes(fill=pop(x)), alpha=.4, adjust=1) +
    geom_point(aes(y=0, color=pop(x)), pch=""|"", size=10, alpha=.5)
p
}

## kmeans
km <- find.clusters(x, n.pca=10, n.clust=2)
table(pop(x), km$grp)

## dapc
dapc1 <- dapc(x, pop=km$grp, n.pca=10, n.da=1)
scatter(dapc1)
scatter(dapc1, grp=pop(x))
compoplot(dapc1, col.pal=spectral, n.col=2)

## ML-EM with hybrids
res <- snapclust(x, k=2, hybrids=TRUE, detailed=TRUE)
compoplot(res, n.col=3)
table(res$group, pop(x))
```

## Author(s)

Data simulated by Marie-Pauline Beugin. Example by Thibaut Jombart.



","['data Toy hybrid dataset Formata genind object DescriptionToy hybrid dataset Examples```rdata(hybridtoy)x <- hybridtoypca1 <- dudi.pca(tab(x), scannf=FALSE, scale=FALSE)s.class(pca1$li, pop(x))if(require(ggplot2)) {p <- ggplot(pca1$li, aes(x=Axis1)) +    geom_density(aes(fill=pop(x)), alpha=.4, adjust=1) +    geom_point(aes(y=0, color=pop(x)), pch=""|"", size=10, alpha=.5)p} kmeanskm <- find.clusters(x, n.pca=10, n.clust=2)table(pop(x), km$grp) dapcdapc1 <- dapc(x, pop=km$grp, n.pca=10, n.da=1)scatter(dapc1)scatter(dapc1, grp=pop(x))compoplot(dapc1, col.pal=spectral, n.col=2) ML-EM with hybridsres <- snapclust(x, k=2, hybrids=TRUE, detailed=TRUE)compoplot(res, n.col=3)table(res$group, pop(x))``` Author(s)Data simulated by Marie-Pauline Beugin.']",1," data Toy hybrid dataset Formata genind object DescriptionToy hybrid dataset Examples```rdata(hybridtoy)x <- hybridtoypca1 <- dudi.pca(tab(x), scannf=FALSE, scale=FALSE)s.class(pca1$li, pop(x))if(require(ggplot2)) {p <- ggplot(pca1$li, aes(x=Axis1)) +    geom_density(aes(fill=pop(x)), alpha=.4, adjust=1) +    geom_point(aes(y=0, color=pop(x)), pch=""|"", size=10, alpha=.5)p} kmeanskm <- find.clusters(x, n.pca=10, n.clust=2)table(pop(x), km$grp) dapcdapc1 <- dapc(x, pop=km$grp, n.pca=10, n.da=1)scatter(dapc1)scatter(dapc1, grp=pop(x))compoplot(dapc1, col.pal=spectral, n.col=2) ML-EM with hybridsres <- snapclust(x, k=2, hybrids=TRUE, detailed=TRUE)compoplot(res, n.col=3)table(res$group, pop(x))``` Author(s)Data simulated by Marie-Pauline Beugin. Example by Thibaut Jombart.",18
adegenet,coords.monmonier.md,"# Returns original points in results paths of an object of class 'monmonier'

## Description

The original implementation of `monmonier` in package adegenet returns path coordinates, `coords.monmonier` additionally displays identities of the original points of the network, based on original coordinates.

```r
coords.monmonier(x)
```

## Arguments

- `x`: an object of class `monmonier`.

## Returns

Returns a list with elements according to the `x$nrun` result of the `monmonier` object. Corresponding path points are in the same order as in the original object.

run1 (run2, ...): for each run, a list containing a matrix giving the original points in the network (`first` and `second`, indicating pairs of neighbours). Path coordinates are stored in columns `x.hw` and `y.hw`. `first` and `second` are integers referring to the row numbers in the `x$xy` matrix of the original `monmonier` object.

## Author(s)

Peter Solymos, Solymos.Peter@aotk.szie.hu

## See Also

`monmonier`

## Examples

```r
## Not run:

if(require(spdep)){

load(system.file(""files/mondata1.rda"",package=""adegenet""))
cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)
mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2,nrun=3)

mon1$run1
mon1$run2
mon1$run3
path.coords <- coords.monmonier(mon1)
path.coords
}
## End(Not run)
```



","[""Returns original points in results paths of an object of class 'monmonier' DescriptionThe original implementation of `monmonier` in package adegenet returns path coordinates, `coords.monmonier` additionally displays identities of the original points of the network, based on original coordinates.```rcoords.monmonier(x)``` Arguments- `x`: an object of class `monmonier`."", 'ReturnsReturns a list with elements according to the `x$nrun` result of the `monmonier` object.', 'Corresponding path points are in the same order as in the original object.run1 (run2, ...): for each run, a list containing a matrix giving the original points in the network (`first` and `second`, indicating pairs of neighbours).', 'Path coordinates are stored in columns `x.hw` and `y.hw`.', '`first` and `second` are integers referring to the row numbers in the `x$xy` matrix of the original `monmonier` object.', 'Author(s)Peter Solymos, Solymos.Peter@aotk.szie.hu See Also`monmonier` Examples```r Not run:if(require(spdep)){load(system.file(""files/mondata1.rda"",package=""adegenet""))cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2,nrun=3)mon1$run1mon1$run2mon1$run3path.coords <- coords.monmonier(mon1)path.coords} End(Not run)```']",1," Returns original points in results paths of an object of class 'monmonier' DescriptionThe original implementation of `monmonier` in package adegenet returns path coordinates, `coords.monmonier` additionally displays identities of the original points of the network, based on original coordinates.```rcoords.monmonier(x)``` Arguments- `x`: an object of class `monmonier`. ReturnsReturns a list with elements according to the `x$nrun` result of the `monmonier` object. Corresponding path points are in the same order as in the original object.run1 (run2, ...): for each run, a list containing a matrix giving the original points in the network (`first` and `second`, indicating pairs of neighbours). Path coordinates are stored in columns `x.hw` and `y.hw`. `first` and `second` are integers referring to the row numbers in the `x$xy` matrix of the original `monmonier` object. Author(s)Peter Solymos, Solymos.Peter@aotk.szie.hu See Also`monmonier` Examples```r Not run:if(require(spdep)){load(system.file(""files/mondata1.rda"",package=""adegenet""))cn1 <- chooseCN(mondata1$xy,type=2,ask=FALSE)mon1 <- monmonier(mondata1$xy,dist(mondata1$x1),cn1,threshold=2,nrun=3)mon1$run1mon1$run2mon1$run3path.coords <- coords.monmonier(mon1)path.coords} End(Not run)```",18
adegenet,swallowtails.md," data

# Microsatellites genotypes of 781 swallowtail butterflies from 40 populations in Alberta and British Columbia, Canada

## Format

`swallowtails` is a genind object containing 781 individuals, 10 microsatellite markers, and 40 populations.

## Source

Julian Dupuis (University of Hawaii, USA)

## Description

This data set gives the genotypes of 781 swallowtail butterflies (**Papilio machaon** species group) for 10 microsatellites markers. The individuals are divided into 40 populations.

## Examples

```r
## Not run:

data(swallowtails)
swallowtails

# conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)

dapc1 <- dapc(swallowtails, n.pca=40, n.da=200)

# read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon""
# columns with column headers (this example contains additional columns
# containing species identifications, locality descriptions, and COI
# haplotype clades)

input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")
loc <- read.csv(input_locs, header = TRUE)

# generate mvmapper input file, automatically write the output to a csv, and
# name the output csv ""mvMapper_Data.csv""

out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = ""mvMapper_Data.csv"")
## End(Not run)
```

## References

Dupuis, J.R. & Sperling, F.A.H. Hybrid dynamics in a species group of swallowtail butterflies. **Journal of Evolutionary Biology**, 10 , 1932--1951.



","['data Microsatellites genotypes of 781 swallowtail butterflies from 40 populations in Alberta and British Columbia, Canada Format`swallowtails` is a genind object containing 781 individuals, 10 microsatellite markers, and 40 populations.', 'SourceJulian Dupuis (University of Hawaii, USA) DescriptionThis data set gives the genotypes of 781 swallowtail butterflies (Papilio machaon species group) for 10 microsatellites markers.', 'The individuals are divided into 40 populations.', 'Examples```r Not run:data(swallowtails)swallowtails conducting a DAPC (n.pca determined using xvalDapc, see ?', '?xvalDapc)dapc1 <- dapc(swallowtails, n.pca=40, n.da=200) read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon"" columns with column headers (this example contains additional columns containing species identifications, locality descriptions, and COI haplotype clades)input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")loc <- read.csv(input_locs, header = TRUE) generate mvmapper input file, automatically write the output to a csv, and name the output csv ""mvMapper_Data.csv""out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = ""mvMapper_Data.csv"") End(Not run)``` ReferencesDupuis, J.R. & Sperling, F.A.H.', 'Hybrid dynamics in a species group of swallowtail butterflies.', 'Journal of Evolutionary Biology, 10 , 1932--1951.']",1," data Microsatellites genotypes of 781 swallowtail butterflies from 40 populations in Alberta and British Columbia, Canada Format`swallowtails` is a genind object containing 781 individuals, 10 microsatellite markers, and 40 populations. SourceJulian Dupuis (University of Hawaii, USA) DescriptionThis data set gives the genotypes of 781 swallowtail butterflies (Papilio machaon species group) for 10 microsatellites markers. The individuals are divided into 40 populations. Examples```r Not run:data(swallowtails)swallowtails conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)dapc1 <- dapc(swallowtails, n.pca=40, n.da=200) read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon"" columns with column headers (this example contains additional columns containing species identifications, locality descriptions, and COI haplotype clades)input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")loc <- read.csv(input_locs, header = TRUE) generate mvmapper input file, automatically write the output to a csv, and name the output csv ""mvMapper_Data.csv""out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = ""mvMapper_Data.csv"") End(Not run)``` ReferencesDupuis, J.R. & Sperling, F.A.H. Hybrid dynamics in a species group of swallowtail butterflies. Journal of Evolutionary Biology, 10 , 1932--1951.",18
adegenet,find.clusters.md,"UTF-8

# find.cluster: cluster identification using successive K-means

## Description

 These functions implement the clustering procedure used in Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). This procedure consists in running successive K-means with an increasing number of clusters (`k`), after transforming data using a principal component analysis (PCA). For each model, a statistical measure of goodness of fit (by default, BIC) is computed, which allows to choose the optimal `k`. See `details` for a description of how to select the optimal `k` and `vignette(""adegenet-dapc"")` for a tutorial.

Optionally, hierarchical clustering can be sought by providing a prior clustering of individuals (argument `clust`). In such case, clusters will be sought within each prior group.

The K-means procedure used in `find.clusters` is `kmeans` function from the `stats` package. The PCA function is `dudi.pca` from the `ade4` package, except for genlight objects which use the `glPca` procedure from adegenet. `find.clusters` is a generic function with methods for the following types of objects:

 

 * `data.frame` (only numeric data)
 * `matrix` (only numeric data)
 * `genind` objects (genetic markers)
 * `genlight` objects (genome-wide SNPs)

```r
## S3 method for class 'data.frame'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust =
              NULL, method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),
              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",
              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x)/10),
              n.iter = 1e5, n.start = 10, center = TRUE, scale = FALSE,
              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL, ..., dudi =
              NULL)

## S3 method for class 'matrix'
find.clusters(x, ...)

## S3 method for class 'genind'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,
              method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),
              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",
              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x@tab)/10),
              n.iter = 1e5, n.start = 10, scale = FALSE, truenames = TRUE,
              ...)

## S3 method for class 'genlight'
find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,
              method = c(""kmeans"", ""ward""), stat = c(""BIC"", ""AIC"", ""WSS""),
              choose.n.clust = TRUE, criterion = c(""diffNgroup"",
              ""min"",""goesup"",""smoothNgoesup"", ""goodfit""), max.n.clust =
              round(nInd(x)/10), n.iter = 1e5,n.start = 10, scale = FALSE,
              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL,glPca=NULL,
              ...)
```

## Arguments

- `x`: `a data.frame`, `matrix`, or `genind` object. For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.
- `clust`: an optional `factor` indicating a prior group membership of individuals. If provided, sub-clusters will be sought within each prior group.
- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step. If `NULL`, interactive selection is triggered.
- `n.clust`: an optinal `integer` indicating the number of clusters to be sought. If provided, the function will only run K-means once, for this number of clusters. If left as `NULL`, several K-means are run for a range of k (number of clusters) values.
- `method`: a `character` string indicating the type of clustering method to be used; ""kmeans"" (default) uses K-means clustering, and is the original implementation of `find.clusters`; ""ward"" is an alternative which uses Ward's hierarchical clustering; this latter method seems to be more reliable on some simulated datasets, but will be less computer-efficient for large numbers (thousands) of individuals.
- `stat`: a `character` string matching 'BIC', 'AIC', or 'WSS', which indicates the statistic to be computed for each model (i.e., for each value of `k`). BIC: Bayesian Information Criterion. AIC: Aikaike's Information Criterion. WSS: within-groups sum of squares, that is, residual variance.
- `choose.n.clust`: a `logical` indicating whether the number of clusters should be chosen by the user (TRUE, default), or automatically, based on a given criterion (argument `criterion`). It is HIGHLY RECOMMENDED to choose the number of clusters INTERACTIVELY, since i) the decrease of the summary statistics (BIC by default) is informative, and ii) no criteria for automatic selection is appropriate to all cases (see details).
- `criterion`: a `character` string matching ""diffNgroup"", ""min"",""goesup"", ""smoothNgoesup"", or ""goodfit"", indicating the criterion for automatic selection of the optimal number of clusters. See `details` for an explanation of these procedures.
- `max.n.clust`: an `integer` indicating the maximum number of clusters to be tried. Values of 'k' will be picked up between 1 and `max.n.clust`
- `n.iter`: an `integer` indicating the number of iterations to be used in each run of K-means algorithm. Corresponds to `iter.max` of `kmeans` function.
- `n.start`: an `integer` indicating the number of randomly chosen starting centroids to be used in each run of the K-means algorithm. Using more starting points ensures convergence of the algorithm. Corresponds to `nstart` of `kmeans` function.
- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind
    
    objects.
- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances. In allele frequencies, it comes with the risk of giving uninformative alleles more importance while downweighting informative alleles. Further scaling options are available for genind
    
    objects (see argument `scale.method`).
- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"". For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`). For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).
- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.
- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE), in which case generic labels are used.
- ``: further arguments to be passed to other functions. For `find.clusters.matrix`, arguments are to match those of the `data.frame` method.
- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package). If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.
- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object.

## Details

=== ON THE SELECTION OF K ===

(where K is the 'optimal' number of clusters)

So far, the analysis of data simulated under various population genetics models (see reference) suggested an ad hoc rule for the selection of the optimal number of clusters. First important result is that BIC seems more efficient than AIC and WSS to select the appropriate number of clusters (see example). The rule of thumb consists in increasing K until it no longer leads to an appreciable improvement of fit (i.e., to a decrease of BIC). In the most simple models (island models), BIC decreases until it reaches the optimal K, and then increases. In these cases, our rule amounts to choosing the lowest K. In other models such as stepping stones, the decrease of BIC often continues after the optimal K, but is much less steep.

An alternative approach is the automatic selection based on a fixed criterion. Note that, in any case, it is highly recommended to look at the graph of the BIC for different numbers of clusters as displayed during the interactive cluster selection. To use automated selection, set `choose.n.clust` to FALSE and specify the `criterion` you want to use, from the following values:

- ""diffNgroup"": differences between successive values of the summary statistics (by default, BIC) are splitted into two groups using a Ward's clustering method (see `?hclust`), to differentiate sharp decrease from mild decreases or increases. The retained K is the one before the first group switch. Appears to work well for island/hierarchical models, and decently for isolation by distance models, albeit with some unstability. Can be impacted by an initial, very sharp decrease of the test statistics. IF UNSURE ABOUT THE CRITERION TO USE, USE THIS ONE.

- ""min"": the model with the minimum summary statistics (as specified by `stat` argument, BIC by default) is retained. Is likely to work for simple island model, using BIC. It is likely to fail in models relating to stepping stones, where the BIC always decreases (albeit by a small amount) as K increases. In general, this approach tends to over-estimate the number of clusters.

- ""goesup"": the selected model is the K after which increasing the number of clusters leads to increasing the summary statistics. Suffers from inaccuracy, since i) a steep decrease might follow a small 'bump' of increase of the statistics, and ii) increase might never happen, or happen after negligible decreases. Is likely to work only for clear-cut island models.

- ""smoothNgoesup"": a variant of ""goesup"", in which the summary statistics is first smoothed using a lowess approach. Is meant to be more accurate than ""goesup"" as it is less prone to stopping to small 'bumps' in the decrease of the statistics.

- ""goodfit"": another criterion seeking a good fit with a minimum number of clusters. This approach does not rely on differences between successive statistics, but on absolute fit. It selects the model with the smallest K so that the overall fit is above a given threshold.

## Returns

The class `find.clusters` is a list with the following components:

 - **Kstat**: a `numeric` vector giving the values of the summary statistics for the different values of K. Is NULL if `n.clust` was specified.

 - **stat**: a `numeric` value giving the value of the summary statistics for the retained model

 - **grp**: a `factor` giving group membership for each individual.

 - **size**: an `integer` vector giving the size of the different clusters.

## References

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics 11:94. doi:10.1186/1471-2156-11-94

## See Also

- `dapc`: implements the DAPC.

- `scatter.dapc`: graphics for DAPC.

- `dapcIllus`: dataset illustrating the DAPC and `find.clusters`.

- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.

- `kmeans`: implementation of K-means in the stat package.

- `dudi.pca`: implementation of PCA in the ade4 package.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## THIS ONE TAKES A FEW MINUTES TO RUN ## 
data(eHGDP)

## here, n.clust is specified, so that only on K value is used
grp <- find.clusters(eHGDP, max.n=30, n.pca=200, scale=FALSE,
n.clust=4) # takes about 2 minutes
names(grp)
grp$Kstat
grp$stat


## to try different values of k (interactive)
grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE)

## and then, to plot BIC values:
plot(grp$Kstat, type=""b"", col=""blue"")



## ANOTHER SIMPLE EXAMPLE ## 
data(sim2pop) # this actually contains 2 pop

## DETECTION WITH BIC (clear result)
foo.BIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE)
plot(foo.BIC$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""BIC"",
col=""blue"", main=""Detection based on BIC"")
points(2, foo.BIC$Kstat[2], pch=""x"", cex=3)
mtext(3, tex=""'X' indicates the actual number of clusters"")


## DETECTION WITH AIC (less clear-cut)
foo.AIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""AIC"")
plot(foo.AIC$Kstat, type=""o"", xlab=""number of clusters (K)"",
ylab=""AIC"", col=""purple"", main=""Detection based on AIC"")
points(2, foo.AIC$Kstat[2], pch=""x"", cex=3)
mtext(3, tex=""'X' indicates the actual number of clusters"")


## DETECTION WITH WSS (less clear-cut)
foo.WSS <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""WSS"")
plot(foo.WSS$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""WSS
(residual variance)"", col=""red"", main=""Detection based on WSS"")
points(2, foo.WSS$Kstat[2], pch=""x"", cex=3)
mtext(3, tex=""'X' indicates the actual number of clusters"")


## TOY EXAMPLE FOR GENLIGHT OBJECTS ##
x <- glSim(100,500,500)
x
plot(x)
grp <- find.clusters(x, n.pca = 100, choose = FALSE, stat = ""BIC"")
plot(grp$Kstat, type = ""o"", xlab = ""number of clusters (K)"",
     ylab = ""BIC"",
     main = ""find.clusters on a genlight object\n(two groups)"")
## End(Not run)
```



","['UTF-8 find.cluster: cluster identification using successive K-means Description These functions implement the clustering procedure used in Discriminant Analysis of Principal Components (DAPC, Jombart et al.', 'This procedure consists in running successive K-means with an increasing number of clusters (`k`), after transforming data using a principal component analysis (PCA).', 'For each model, a statistical measure of goodness of fit (by default, BIC) is computed, which allows to choose the optimal `k`.', 'See `details` for a description of how to select the optimal `k` and `vignette(""adegenet-dapc"")` for a tutorial.Optionally, hierarchical clustering can be sought by providing a prior clustering of individuals (argument `clust`).', 'In such case, clusters will be sought within each prior group.The K-means procedure used in `find.clusters` is `kmeans` function from the `stats` package.', 'The PCA function is `dudi.pca` from the `ade4` package, except for genlight objects which use the `glPca` procedure from adegenet.', '`find.clusters` is a generic function with methods for the following types of objects:   `data.frame` (only numeric data)  `matrix` (only numeric data)  `genind` objects (genetic markers)  `genlight` objects (genome-wide SNPs)```r S3 method for class \'data.frame\'find.clusters(x, clust = NULL, n.pca = NULL, n.clust =              NULL, method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x)/10),              n.iter = 1e5, n.start = 10, center = TRUE, scale = FALSE,              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL, ..., dudi =              NULL) S3 method for class \'matrix\'find.clusters(x, ...) S3 method for class \'genind\'find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,              method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x@tab)/10),              n.iter = 1e5, n.start = 10, scale = FALSE, truenames = TRUE,              ...) S3 method for class \'genlight\'find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,              method = c(""kmeans"", ""ward""), stat = c(""BIC"", ""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"",              ""min"",""goesup"",""smoothNgoesup"", ""goodfit""), max.n.clust =              round(nInd(x)/10), n.iter = 1e5,n.start = 10, scale = FALSE,              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL,glPca=NULL,              ...)``` Arguments- `x`: `a data.frame`, `matrix`, or `genind` object.', 'For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.- `clust`: an optional `factor` indicating a prior group membership of individuals.', 'If provided, sub-clusters will be sought within each prior group.- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step.', 'If `NULL`, interactive selection is triggered.- `n.clust`: an optinal `integer` indicating the number of clusters to be sought.', 'If provided, the function will only run K-means once, for this number of clusters.', 'If left as `NULL`, several K-means are run for a range of k (number of clusters) values.- `method`: a `character` string indicating the type of clustering method to be used; ""kmeans"" (default) uses K-means clustering, and is the original implementation of `find.clusters`; ""ward"" is an alternative which uses Ward\'s hierarchical clustering; this latter method seems to be more reliable on some simulated datasets, but will be less computer-efficient for large numbers (thousands) of individuals.- `stat`: a `character` string matching \'BIC\', \'AIC\', or \'WSS\', which indicates the statistic to be computed for each model (i.e., for each value of `k`).', 'WSS: within-groups sum of squares, that is, residual variance.- `choose.n.clust`: a `logical` indicating whether the number of clusters should be chosen by the user (TRUE, default), or automatically, based on a given criterion (argument `criterion`).', 'It is HIGHLY RECOMMENDED to choose the number of clusters INTERACTIVELY, since i) the decrease of the summary statistics (BIC by default) is informative, and ii) no criteria for automatic selection is appropriate to all cases (see details).- `criterion`: a `character` string matching ""diffNgroup"", ""min"",""goesup"", ""smoothNgoesup"", or ""goodfit"", indicating the criterion for automatic selection of the optimal number of clusters.', 'See `details` for an explanation of these procedures.- `max.n.clust`: an `integer` indicating the maximum number of clusters to be tried.', ""Values of 'k' will be picked up between 1 and `max.n.clust`- `n.iter`: an `integer` indicating the number of iterations to be used in each run of K-means algorithm."", 'Corresponds to `iter.max` of `kmeans` function.- `n.start`: an `integer` indicating the number of randomly chosen starting centroids to be used in each run of the K-means algorithm.', 'Using more starting points ensures convergence of the algorithm.', 'Corresponds to `nstart` of `kmeans` function.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE).', 'Always TRUE for genind        objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default).', 'Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.', 'In allele frequencies, it comes with the risk of giving uninformative alleles more importance while downweighting informative alleles.', 'Further scaling options are available for genind        objects (see argument `scale.method`).- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"".', 'For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`).', 'For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE), in which case generic labels are used.- ``: further arguments to be passed to other functions.', 'For `find.clusters.matrix`, arguments are to match those of the `data.frame` method.- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package).', 'If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object.', ""Details=== ON THE SELECTION OF K ===(where K is the 'optimal' number of clusters)So far, the analysis of data simulated under various population genetics models (see reference) suggested an ad hoc rule for the selection of the optimal number of clusters."", 'First important result is that BIC seems more efficient than AIC and WSS to select the appropriate number of clusters (see example).', 'The rule of thumb consists in increasing K until it no longer leads to an appreciable improvement of fit (i.e., to a decrease of BIC).', 'In the most simple models (island models), BIC decreases until it reaches the optimal K, and then increases.', 'In these cases, our rule amounts to choosing the lowest K. In other models such as stepping stones, the decrease of BIC often continues after the optimal K, but is much less steep.An alternative approach is the automatic selection based on a fixed criterion.', 'Note that, in any case, it is highly recommended to look at the graph of the BIC for different numbers of clusters as displayed during the interactive cluster selection.', 'To use automated selection, set `choose.n.clust` to FALSE and specify the `criterion` you want to use, from the following values:- ""diffNgroup"": differences between successive values of the summary statistics (by default, BIC) are splitted into two groups using a Ward\'s clustering method (see `?hclust`), to differentiate sharp decrease from mild decreases or increases.', 'The retained K is the one before the first group switch.', 'Appears to work well for island/hierarchical models, and decently for isolation by distance models, albeit with some unstability.', 'Can be impacted by an initial, very sharp decrease of the test statistics.', 'IF UNSURE ABOUT THE CRITERION TO USE, USE THIS ONE.- ""min"": the model with the minimum summary statistics (as specified by `stat` argument, BIC by default) is retained.', 'Is likely to work for simple island model, using BIC.', 'It is likely to fail in models relating to stepping stones, where the BIC always decreases (albeit by a small amount) as K increases.', 'In general, this approach tends to over-estimate the number of clusters.- ""goesup"": the selected model is the K after which increasing the number of clusters leads to increasing the summary statistics.', ""Suffers from inaccuracy, since i) a steep decrease might follow a small 'bump' of increase of the statistics, and ii) increase might never happen, or happen after negligible decreases."", 'Is likely to work only for clear-cut island models.- ""smoothNgoesup"": a variant of ""goesup"", in which the summary statistics is first smoothed using a lowess approach.', 'Is meant to be more accurate than ""goesup"" as it is less prone to stopping to small \'bumps\' in the decrease of the statistics.- ""goodfit"": another criterion seeking a good fit with a minimum number of clusters.', 'This approach does not rely on differences between successive statistics, but on absolute fit.', 'It selects the model with the smallest K so that the overall fit is above a given threshold.', 'ReturnsThe class `find.clusters` is a list with the following components: - Kstat: a `numeric` vector giving the values of the summary statistics for the different values of K. Is NULL if `n.clust` was specified.', '- stat: a `numeric` value giving the value of the summary statistics for the retained model - grp: a `factor` giving group membership for each individual.', '- size: an `integer` vector giving the size of the different clusters.', 'ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics 11:94. doi:10.1186/1471-2156-11-94 See Also- `dapc`: implements the DAPC.- `scatter.dapc`: graphics for DAPC.- `dapcIllus`: dataset illustrating the DAPC and `find.clusters`.- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.- `kmeans`: implementation of K-means in the stat package.- `dudi.pca`: implementation of PCA in the ade4 package.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: THIS ONE TAKES A FEW MINUTES TO RUN  data(eHGDP) here, n.clust is specified, so that only on K value is usedgrp <- find.clusters(eHGDP, max.n=30, n.pca=200, scale=FALSE,n.clust=4)  takes about 2 minutesnames(grp)grp$Kstatgrp$stat to try different values of k (interactive)grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE) and then, to plot BIC values:plot(grp$Kstat, type=""b"", col=""blue"") ANOTHER SIMPLE EXAMPLE  data(sim2pop)  this actually contains 2 pop DETECTION WITH BIC (clear result)foo.BIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE)plot(foo.BIC$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""BIC"",col=""blue"", main=""Detection based on BIC"")points(2, foo.BIC$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""\'X\' indicates the actual number of clusters"") DETECTION WITH AIC (less clear-cut)foo.AIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""AIC"")plot(foo.AIC$Kstat, type=""o"", xlab=""number of clusters (K)"",ylab=""AIC"", col=""purple"", main=""Detection based on AIC"")points(2, foo.AIC$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""\'X\' indicates the actual number of clusters"") DETECTION WITH WSS (less clear-cut)foo.WSS <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""WSS"")plot(foo.WSS$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""WSS(residual variance)"", col=""red"", main=""Detection based on WSS"")points(2, foo.WSS$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""\'X\' indicates the actual number of clusters"") TOY EXAMPLE FOR GENLIGHT OBJECTS x <- glSim(100,500,500)xplot(x)grp <- find.clusters(x, n.pca = 100, choose = FALSE, stat = ""BIC"")plot(grp$Kstat, type = ""o"", xlab = ""number of clusters (K)"",     ylab = ""BIC"",     main = ""find.clusters on a genlight object\\n(two groups)"") End(Not run)```']",1,"UTF-8 find.cluster: cluster identification using successive K-means Description These functions implement the clustering procedure used in Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). This procedure consists in running successive K-means with an increasing number of clusters (`k`), after transforming data using a principal component analysis (PCA). For each model, a statistical measure of goodness of fit (by default, BIC) is computed, which allows to choose the optimal `k`. See `details` for a description of how to select the optimal `k` and `vignette(""adegenet-dapc"")` for a tutorial.Optionally, hierarchical clustering can be sought by providing a prior clustering of individuals (argument `clust`). In such case, clusters will be sought within each prior group.The K-means procedure used in `find.clusters` is `kmeans` function from the `stats` package. The PCA function is `dudi.pca` from the `ade4` package, except for genlight objects which use the `glPca` procedure from adegenet. `find.clusters` is a generic function with methods for the following types of objects:   `data.frame` (only numeric data)  `matrix` (only numeric data)  `genind` objects (genetic markers)  `genlight` objects (genome-wide SNPs)```r S3 method for class 'data.frame'find.clusters(x, clust = NULL, n.pca = NULL, n.clust =              NULL, method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x)/10),              n.iter = 1e5, n.start = 10, center = TRUE, scale = FALSE,              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL, ..., dudi =              NULL) S3 method for class 'matrix'find.clusters(x, ...) S3 method for class 'genind'find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,              method = c(""kmeans"", ""ward""), stat = c(""BIC"",""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"", ""min"",""goesup"",              ""smoothNgoesup"", ""goodfit""), max.n.clust = round(nrow(x@tab)/10),              n.iter = 1e5, n.start = 10, scale = FALSE, truenames = TRUE,              ...) S3 method for class 'genlight'find.clusters(x, clust = NULL, n.pca = NULL, n.clust = NULL,              method = c(""kmeans"", ""ward""), stat = c(""BIC"", ""AIC"", ""WSS""),              choose.n.clust = TRUE, criterion = c(""diffNgroup"",              ""min"",""goesup"",""smoothNgoesup"", ""goodfit""), max.n.clust =              round(nInd(x)/10), n.iter = 1e5,n.start = 10, scale = FALSE,              pca.select = c(""nbEig"",""percVar""), perc.pca = NULL,glPca=NULL,              ...)``` Arguments- `x`: `a data.frame`, `matrix`, or `genind` object. For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.- `clust`: an optional `factor` indicating a prior group membership of individuals. If provided, sub-clusters will be sought within each prior group.- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step. If `NULL`, interactive selection is triggered.- `n.clust`: an optinal `integer` indicating the number of clusters to be sought. If provided, the function will only run K-means once, for this number of clusters. If left as `NULL`, several K-means are run for a range of k (number of clusters) values.- `method`: a `character` string indicating the type of clustering method to be used; ""kmeans"" (default) uses K-means clustering, and is the original implementation of `find.clusters`; ""ward"" is an alternative which uses Ward's hierarchical clustering; this latter method seems to be more reliable on some simulated datasets, but will be less computer-efficient for large numbers (thousands) of individuals.- `stat`: a `character` string matching 'BIC', 'AIC', or 'WSS', which indicates the statistic to be computed for each model (i.e., for each value of `k`). BIC: Bayesian Information Criterion. AIC: Aikaike's Information Criterion. WSS: within-groups sum of squares, that is, residual variance.- `choose.n.clust`: a `logical` indicating whether the number of clusters should be chosen by the user (TRUE, default), or automatically, based on a given criterion (argument `criterion`). It is HIGHLY RECOMMENDED to choose the number of clusters INTERACTIVELY, since i) the decrease of the summary statistics (BIC by default) is informative, and ii) no criteria for automatic selection is appropriate to all cases (see details).- `criterion`: a `character` string matching ""diffNgroup"", ""min"",""goesup"", ""smoothNgoesup"", or ""goodfit"", indicating the criterion for automatic selection of the optimal number of clusters. See `details` for an explanation of these procedures.- `max.n.clust`: an `integer` indicating the maximum number of clusters to be tried. Values of 'k' will be picked up between 1 and `max.n.clust`- `n.iter`: an `integer` indicating the number of iterations to be used in each run of K-means algorithm. Corresponds to `iter.max` of `kmeans` function.- `n.start`: an `integer` indicating the number of randomly chosen starting centroids to be used in each run of the K-means algorithm. Using more starting points ensures convergence of the algorithm. Corresponds to `nstart` of `kmeans` function.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind        objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances. In allele frequencies, it comes with the risk of giving uninformative alleles more importance while downweighting informative alleles. Further scaling options are available for genind        objects (see argument `scale.method`).- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"". For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`). For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE), in which case generic labels are used.- ``: further arguments to be passed to other functions. For `find.clusters.matrix`, arguments are to match those of the `data.frame` method.- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package). If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object. Details=== ON THE SELECTION OF K ===(where K is the 'optimal' number of clusters)So far, the analysis of data simulated under various population genetics models (see reference) suggested an ad hoc rule for the selection of the optimal number of clusters. First important result is that BIC seems more efficient than AIC and WSS to select the appropriate number of clusters (see example). The rule of thumb consists in increasing K until it no longer leads to an appreciable improvement of fit (i.e., to a decrease of BIC). In the most simple models (island models), BIC decreases until it reaches the optimal K, and then increases. In these cases, our rule amounts to choosing the lowest K. In other models such as stepping stones, the decrease of BIC often continues after the optimal K, but is much less steep.An alternative approach is the automatic selection based on a fixed criterion. Note that, in any case, it is highly recommended to look at the graph of the BIC for different numbers of clusters as displayed during the interactive cluster selection. To use automated selection, set `choose.n.clust` to FALSE and specify the `criterion` you want to use, from the following values:- ""diffNgroup"": differences between successive values of the summary statistics (by default, BIC) are splitted into two groups using a Ward's clustering method (see `?hclust`), to differentiate sharp decrease from mild decreases or increases. The retained K is the one before the first group switch. Appears to work well for island/hierarchical models, and decently for isolation by distance models, albeit with some unstability. Can be impacted by an initial, very sharp decrease of the test statistics. IF UNSURE ABOUT THE CRITERION TO USE, USE THIS ONE.- ""min"": the model with the minimum summary statistics (as specified by `stat` argument, BIC by default) is retained. Is likely to work for simple island model, using BIC. It is likely to fail in models relating to stepping stones, where the BIC always decreases (albeit by a small amount) as K increases. In general, this approach tends to over-estimate the number of clusters.- ""goesup"": the selected model is the K after which increasing the number of clusters leads to increasing the summary statistics. Suffers from inaccuracy, since i) a steep decrease might follow a small 'bump' of increase of the statistics, and ii) increase might never happen, or happen after negligible decreases. Is likely to work only for clear-cut island models.- ""smoothNgoesup"": a variant of ""goesup"", in which the summary statistics is first smoothed using a lowess approach. Is meant to be more accurate than ""goesup"" as it is less prone to stopping to small 'bumps' in the decrease of the statistics.- ""goodfit"": another criterion seeking a good fit with a minimum number of clusters. This approach does not rely on differences between successive statistics, but on absolute fit. It selects the model with the smallest K so that the overall fit is above a given threshold. ReturnsThe class `find.clusters` is a list with the following components: - Kstat: a `numeric` vector giving the values of the summary statistics for the different values of K. Is NULL if `n.clust` was specified. - stat: a `numeric` value giving the value of the summary statistics for the retained model - grp: a `factor` giving group membership for each individual. - size: an `integer` vector giving the size of the different clusters. ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics 11:94. doi:10.1186/1471-2156-11-94 See Also- `dapc`: implements the DAPC.- `scatter.dapc`: graphics for DAPC.- `dapcIllus`: dataset illustrating the DAPC and `find.clusters`.- `eHGDP`: dataset illustrating the DAPC and `find.clusters`.- `kmeans`: implementation of K-means in the stat package.- `dudi.pca`: implementation of PCA in the ade4 package. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: THIS ONE TAKES A FEW MINUTES TO RUN  data(eHGDP) here, n.clust is specified, so that only on K value is usedgrp <- find.clusters(eHGDP, max.n=30, n.pca=200, scale=FALSE,n.clust=4)  takes about 2 minutesnames(grp)grp$Kstatgrp$stat to try different values of k (interactive)grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE) and then, to plot BIC values:plot(grp$Kstat, type=""b"", col=""blue"") ANOTHER SIMPLE EXAMPLE  data(sim2pop)  this actually contains 2 pop DETECTION WITH BIC (clear result)foo.BIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE)plot(foo.BIC$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""BIC"",col=""blue"", main=""Detection based on BIC"")points(2, foo.BIC$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""'X' indicates the actual number of clusters"") DETECTION WITH AIC (less clear-cut)foo.AIC <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""AIC"")plot(foo.AIC$Kstat, type=""o"", xlab=""number of clusters (K)"",ylab=""AIC"", col=""purple"", main=""Detection based on AIC"")points(2, foo.AIC$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""'X' indicates the actual number of clusters"") DETECTION WITH WSS (less clear-cut)foo.WSS <- find.clusters(sim2pop, n.pca=100, choose=FALSE, stat=""WSS"")plot(foo.WSS$Kstat, type=""o"", xlab=""number of clusters (K)"", ylab=""WSS(residual variance)"", col=""red"", main=""Detection based on WSS"")points(2, foo.WSS$Kstat[2], pch=""x"", cex=3)mtext(3, tex=""'X' indicates the actual number of clusters"") TOY EXAMPLE FOR GENLIGHT OBJECTS x <- glSim(100,500,500)xplot(x)grp <- find.clusters(x, n.pca = 100, choose = FALSE, stat = ""BIC"")plot(grp$Kstat, type = ""o"", xlab = ""number of clusters (K)"",     ylab = ""BIC"",     main = ""find.clusters on a genlight object\n(two groups)"") End(Not run)```",18
adegenet,haploGen.md,"# Simulation of genealogies of haplotypes

## Description

The function `haploGen` implements simulations of genealogies of haplotypes. This forward-time, individual-based simulation tool allows haplotypes to replicate and mutate according to specified parameters, and keeps track of their genealogy.

Simulations can be spatially explicit or not (see `geo.sim` argument). In the first case, haplotypes are assigned to locations on a regular grip. New haplotypes disperse from their ancestor's location according to a random Poisson diffusion, or alternatively according to a pre-specified migration scheme. This tool does not allow for simulating selection or linkage disequilibrium.

Produced objects are lists with the class `haploGen`; see 'value' section for more information on this class. Other functions are available to print, plot, subset, sample or convert `haploGen` objects. A seqTrack method is also provided for analysing `haploGen` objects.

Note that for simulation of outbreaks, the new tool `simOutbreak` in the `outbreaker` package should be used.

```r
haploGen(seq.length=1e4, mu.transi=1e-4, mu.transv=mu.transi/2, t.max=20,
         gen.time=function(){1+rpois(1,0.5)},
         repro=function(){rpois(1,1.5)}, max.nb.haplo=200,
         geo.sim=FALSE, grid.size=10, lambda.xy=0.5,
         mat.connect=NULL,
         ini.n=1, ini.xy=NULL)
## S3 method for class 'haploGen'
print(x, ...)
## S3 method for class 'haploGen'
as.igraph(x, col.pal=redpal, ...)
## S3 method for class 'haploGen'
plot(x, y=NULL, col.pal=redpal, ...)
## S3 method for class 'haploGen'
x[i, j, drop=FALSE]
## S3 method for class 'haploGen'
labels(object, ...)
## S3 method for class 'haploGen'
as.POSIXct(x, tz="""", origin=as.POSIXct(""2000/01/01""), ...)
## S3 method for class 'haploGen'
seqTrack(x, best=c(""min"",""max""), prox.mat=NULL, ...)
as.seqTrack.haploGen(x)
plotHaploGen(x, annot=FALSE, date.range=NULL, col=NULL, bg=""grey"", add=FALSE, ...)
sample.haploGen(x, n)
```

## Arguments

- `seq.length`: an integer indicating the length of the simulated haplotypes, in number of nucleotides.
- `mu.transi`: the rate of transitions, in number of mutation per site and per time unit.
- `mu.transv`: the rate of transversions, in number of mutation per site and per time unit.
- `t.max`: an integer indicating the maximum number of time units to run the simulation for.
- `gen.time`: an integer indicating the generation time, in number of time units. Can be a (fixed) number or a function returning a number (then called for each reproduction event).
- `repro`: an integer indicating the number of descendents per haplotype. Can be a (fixed) number or a function returning a number (then called for each reproduction event).
- `max.nb.haplo`: an integer indicating the maximum number of haplotypes handled at any time of the simulation, used to control the size of the produced object. Larger number will lead to slower simulations. If this number is exceeded, the genealogy is prunded to as to keep this number of haplotypes.
- `geo.sim`: a logical stating whether simulations should be spatially explicit (TRUE) or not (FALSE, default). Spatially-explicit simulations are slightly slower than their non-spatial counterpart.
- `grid.size`: the size of the square grid of possible locations for spatial simulations. The total number of locations will be this number squared.
- `lambda.xy`: the parameter of the Poisson distribution used to determine dispersion in x and y axes.
- `mat.connect`: a matrix of connectivity describing migration amongts all pairs of locations. `mat.connect[i,j]` indicates the probability, being in 'i', to migrate to 'j'. The rows of this matrix thus sum to 1. It has as many rows and columns as there are locations, with row 'i' / column 'j' corresponding to locations number 'i' and 'j'. Locations are numbered as in a matrix in which rows and columns are respectively x and y coordinates. For instance, in a 5x5 grid, locations are numbered as in `matrix(1:25,5,5)`.
- `ini.n`: an integer specifying the number of (identical) haplotypes to initiate the simulation
- `ini.xy`: a vector of two integers giving the x/y coordinates of the initial haplotype.
- `x,object`: `haploGen` objects.
- `y`: unused argument, for compatibility with 'plot'.
- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph. See `?num2col`. Note that the palette is inversed by default.
- `i,j, drop`: `i` is a vector used for subsetting the object. For instance, `i=1:3` will retain only the first three haplotypes of the genealogy. `j` and `drop` are only provided for compatibility, but not used.
- `best, prox.mat`: arguments to be passed to the `seqTrack` function. See documentation of `seqTrack` for more information.
- `annot,date.range,col,bg,add`: arguments to be passed to `plotSeqTrack`.
- `n`: an integer indicating the number of haplotypes to be retained in the sample





- `tz, origin`: aguments to be passed to `as.POSIXct` (see ?as.POSIXct)
- ``...``: further arguments to be passed to other methods; for 'plot', arguments are passed to `plot.igraph`.







## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## References

Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. Heredity. doi: 10.1038/hdy.2010.78.

## Returns

=== haploGen class ===

 `haploGen` objects are lists containing the following slots:

- seq: DNA sequences in the DNAbin matrix format

- dates: dates of appearance of the haplotypes

- ances: a vector of integers giving the index of each haplotype's ancestor

- id: a vector of integers giving the index of each haplotype

- xy: (optional) a matrix of spatial coordinates of haplotypes

- call: the matched call

=== misc functions ===

- as.POSIXct: returns a vector of dates with POSIXct format

- labels: returns the labels of the haplotypes

- as.seqTrack: returns a seqTrack object. Note that this object is not a proper seqTrack analysis, but just a format conversion convenient for plotting `haploGen` objects.

## Details

=== Dependencies with other packages ===

- ape package is required as it implements efficient handling of DNA sequences used in `haploGen` objects. To install this package, simply type:

 `install.packages(""ape"")`

- for various purposes including plotting, converting genealogies to graphs can be useful. From adegenet version 1.3-5 onwards, this is achieved using the package `igraph`. See below.

=== Converting haploGen objects to graphs ===

 `haploGen` objects can be converted to `igraph` objects (package `igraph`), which can in turn be plotted and manipulated using classical graph tools. Simply use 'as.igraph(x)' where 'x' is a `haploGen` object. This functionality requires the `igraph` package. Graphs are time oriented (top=old, bottom=recent).

## See Also

`simOutbreak` in the package 'outbreaker' for simulating disease outbreaks under a realistic epidemiological model.

## Examples

```r
## Not run:

if(require(ape) && require(igraph)){
## PERFORM SIMULATIONS
x <- haploGen(geo.sim=TRUE)
x

## PLOT DATA
plot(x)

## PLOT SPATIAL SPREAD
plotHaploGen(x, bg=""white"")
title(""Spatial dispersion"")


## USE SEQTRACK RECONSTRUCTION
x.recons <- seqTrack(x)
mean(x.recons$ances==x$ances, na.rm=TRUE) # proportion of correct reconstructions

g <- as.igraph(x)
g
plot(g)
plot(g, vertex.size=0)


}
## End(Not run)
```



","['Simulation of genealogies of haplotypes DescriptionThe function `haploGen` implements simulations of genealogies of haplotypes.', 'This forward-time, individual-based simulation tool allows haplotypes to replicate and mutate according to specified parameters, and keeps track of their genealogy.Simulations can be spatially explicit or not (see `geo.sim` argument).', 'In the first case, haplotypes are assigned to locations on a regular grip.', ""New haplotypes disperse from their ancestor's location according to a random Poisson diffusion, or alternatively according to a pre-specified migration scheme."", ""This tool does not allow for simulating selection or linkage disequilibrium.Produced objects are lists with the class `haploGen`; see 'value' section for more information on this class."", 'Other functions are available to print, plot, subset, sample or convert `haploGen` objects.', 'A seqTrack method is also provided for analysing `haploGen` objects.Note that for simulation of outbreaks, the new tool `simOutbreak` in the `outbreaker` package should be used.```rhaploGen(seq.length=1e4, mu.transi=1e-4, mu.transv=mu.transi/2, t.max=20,         gen.time=function(){1+rpois(1,0.5)},         repro=function(){rpois(1,1.5)}, max.nb.haplo=200,         geo.sim=FALSE, grid.size=10, lambda.xy=0.5,         mat.connect=NULL,         ini.n=1, ini.xy=NULL) S3 method for class \'haploGen\'print(x, ...) S3 method for class \'haploGen\'as.igraph(x, col.pal=redpal, ...) S3 method for class \'haploGen\'plot(x, y=NULL, col.pal=redpal, ...) S3 method for class \'haploGen\'x[i, j, drop=FALSE] S3 method for class \'haploGen\'labels(object, ...) S3 method for class \'haploGen\'as.POSIXct(x, tz="""", origin=as.POSIXct(""2000/01/01""), ...) S3 method for class \'haploGen\'seqTrack(x, best=c(""min"",""max""), prox.mat=NULL, ...)as.seqTrack.haploGen(x)plotHaploGen(x, annot=FALSE, date.range=NULL, col=NULL, bg=""grey"", add=FALSE, ...)sample.haploGen(x, n)``` Arguments- `seq.length`: an integer indicating the length of the simulated haplotypes, in number of nucleotides.- `mu.transi`: the rate of transitions, in number of mutation per site and per time unit.- `mu.transv`: the rate of transversions, in number of mutation per site and per time unit.- `t.max`: an integer indicating the maximum number of time units to run the simulation for.- `gen.time`: an integer indicating the generation time, in number of time units.', 'Can be a (fixed) number or a function returning a number (then called for each reproduction event).- `repro`: an integer indicating the number of descendents per haplotype.', 'Can be a (fixed) number or a function returning a number (then called for each reproduction event).- `max.nb.haplo`: an integer indicating the maximum number of haplotypes handled at any time of the simulation, used to control the size of the produced object.', 'Larger number will lead to slower simulations.', 'If this number is exceeded, the genealogy is prunded to as to keep this number of haplotypes.- `geo.sim`: a logical stating whether simulations should be spatially explicit (TRUE) or not (FALSE, default).', 'Spatially-explicit simulations are slightly slower than their non-spatial counterpart.- `grid.size`: the size of the square grid of possible locations for spatial simulations.', 'The total number of locations will be this number squared.- `lambda.xy`: the parameter of the Poisson distribution used to determine dispersion in x and y axes.- `mat.connect`: a matrix of connectivity describing migration amongts all pairs of locations.', ""`mat.connect[i,j]` indicates the probability, being in 'i', to migrate to 'j'."", 'The rows of this matrix thus sum to 1.', ""It has as many rows and columns as there are locations, with row 'i' / column 'j' corresponding to locations number 'i' and 'j'."", 'Locations are numbered as in a matrix in which rows and columns are respectively x and y coordinates.', ""For instance, in a 5x5 grid, locations are numbered as in `matrix(1:25,5,5)`.- `ini.n`: an integer specifying the number of (identical) haplotypes to initiate the simulation- `ini.xy`: a vector of two integers giving the x/y coordinates of the initial haplotype.- `x,object`: `haploGen` objects.- `y`: unused argument, for compatibility with 'plot'.- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph."", 'Note that the palette is inversed by default.- `i,j, drop`: `i` is a vector used for subsetting the object.', 'For instance, `i=1:3` will retain only the first three haplotypes of the genealogy.', '`j` and `drop` are only provided for compatibility, but not used.- `best, prox.mat`: arguments to be passed to the `seqTrack` function.', ""See documentation of `seqTrack` for more information.- `annot,date.range,col,bg,add`: arguments to be passed to `plotSeqTrack`.- `n`: an integer indicating the number of haplotypes to be retained in the sample- `tz, origin`: aguments to be passed to `as.POSIXct` (see ?as.POSIXct)- ``...``: further arguments to be passed to other methods; for 'plot', arguments are passed to `plot.igraph`."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk ReferencesJombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach.', ""Returns=== haploGen class === `haploGen` objects are lists containing the following slots:- seq: DNA sequences in the DNAbin matrix format- dates: dates of appearance of the haplotypes- ances: a vector of integers giving the index of each haplotype's ancestor- id: a vector of integers giving the index of each haplotype- xy: (optional) a matrix of spatial coordinates of haplotypes- call: the matched call=== misc functions ===- as.POSIXct: returns a vector of dates with POSIXct format- labels: returns the labels of the haplotypes- as.seqTrack: returns a seqTrack object."", 'Note that this object is not a proper seqTrack analysis, but just a format conversion convenient for plotting `haploGen` objects.', 'Details=== Dependencies with other packages ===- ape package is required as it implements efficient handling of DNA sequences used in `haploGen` objects.', 'To install this package, simply type: `install.packages(""ape"")`- for various purposes including plotting, converting genealogies to graphs can be useful.', 'From adegenet version 1.3-5 onwards, this is achieved using the package `igraph`.', 'See below.=== Converting haploGen objects to graphs === `haploGen` objects can be converted to `igraph` objects (package `igraph`), which can in turn be plotted and manipulated using classical graph tools.', ""Simply use 'as.igraph(x)' where 'x' is a `haploGen` object."", 'This functionality requires the `igraph` package.', 'Graphs are time oriented (top=old, bottom=recent).', ""See Also`simOutbreak` in the package 'outbreaker' for simulating disease outbreaks under a realistic epidemiological model."", 'Examples```r Not run:if(require(ape) && require(igraph)){ PERFORM SIMULATIONSx <- haploGen(geo.sim=TRUE)x PLOT DATAplot(x) PLOT SPATIAL SPREADplotHaploGen(x, bg=""white"")title(""Spatial dispersion"") USE SEQTRACK RECONSTRUCTIONx.recons <- seqTrack(x)mean(x.recons$ances==x$ances, na.rm=TRUE)  proportion of correct reconstructionsg <- as.igraph(x)gplot(g)plot(g, vertex.size=0)} End(Not run)```']",1," Simulation of genealogies of haplotypes DescriptionThe function `haploGen` implements simulations of genealogies of haplotypes. This forward-time, individual-based simulation tool allows haplotypes to replicate and mutate according to specified parameters, and keeps track of their genealogy.Simulations can be spatially explicit or not (see `geo.sim` argument). In the first case, haplotypes are assigned to locations on a regular grip. New haplotypes disperse from their ancestor's location according to a random Poisson diffusion, or alternatively according to a pre-specified migration scheme. This tool does not allow for simulating selection or linkage disequilibrium.Produced objects are lists with the class `haploGen`; see 'value' section for more information on this class. Other functions are available to print, plot, subset, sample or convert `haploGen` objects. A seqTrack method is also provided for analysing `haploGen` objects.Note that for simulation of outbreaks, the new tool `simOutbreak` in the `outbreaker` package should be used.```rhaploGen(seq.length=1e4, mu.transi=1e-4, mu.transv=mu.transi/2, t.max=20,         gen.time=function(){1+rpois(1,0.5)},         repro=function(){rpois(1,1.5)}, max.nb.haplo=200,         geo.sim=FALSE, grid.size=10, lambda.xy=0.5,         mat.connect=NULL,         ini.n=1, ini.xy=NULL) S3 method for class 'haploGen'print(x, ...) S3 method for class 'haploGen'as.igraph(x, col.pal=redpal, ...) S3 method for class 'haploGen'plot(x, y=NULL, col.pal=redpal, ...) S3 method for class 'haploGen'x[i, j, drop=FALSE] S3 method for class 'haploGen'labels(object, ...) S3 method for class 'haploGen'as.POSIXct(x, tz="""", origin=as.POSIXct(""2000/01/01""), ...) S3 method for class 'haploGen'seqTrack(x, best=c(""min"",""max""), prox.mat=NULL, ...)as.seqTrack.haploGen(x)plotHaploGen(x, annot=FALSE, date.range=NULL, col=NULL, bg=""grey"", add=FALSE, ...)sample.haploGen(x, n)``` Arguments- `seq.length`: an integer indicating the length of the simulated haplotypes, in number of nucleotides.- `mu.transi`: the rate of transitions, in number of mutation per site and per time unit.- `mu.transv`: the rate of transversions, in number of mutation per site and per time unit.- `t.max`: an integer indicating the maximum number of time units to run the simulation for.- `gen.time`: an integer indicating the generation time, in number of time units. Can be a (fixed) number or a function returning a number (then called for each reproduction event).- `repro`: an integer indicating the number of descendents per haplotype. Can be a (fixed) number or a function returning a number (then called for each reproduction event).- `max.nb.haplo`: an integer indicating the maximum number of haplotypes handled at any time of the simulation, used to control the size of the produced object. Larger number will lead to slower simulations. If this number is exceeded, the genealogy is prunded to as to keep this number of haplotypes.- `geo.sim`: a logical stating whether simulations should be spatially explicit (TRUE) or not (FALSE, default). Spatially-explicit simulations are slightly slower than their non-spatial counterpart.- `grid.size`: the size of the square grid of possible locations for spatial simulations. The total number of locations will be this number squared.- `lambda.xy`: the parameter of the Poisson distribution used to determine dispersion in x and y axes.- `mat.connect`: a matrix of connectivity describing migration amongts all pairs of locations. `mat.connect[i,j]` indicates the probability, being in 'i', to migrate to 'j'. The rows of this matrix thus sum to 1. It has as many rows and columns as there are locations, with row 'i' / column 'j' corresponding to locations number 'i' and 'j'. Locations are numbered as in a matrix in which rows and columns are respectively x and y coordinates. For instance, in a 5x5 grid, locations are numbered as in `matrix(1:25,5,5)`.- `ini.n`: an integer specifying the number of (identical) haplotypes to initiate the simulation- `ini.xy`: a vector of two integers giving the x/y coordinates of the initial haplotype.- `x,object`: `haploGen` objects.- `y`: unused argument, for compatibility with 'plot'.- `col.pal`: a color palette to be used to represent weights using colors on the edges of the graph. See `?num2col`. Note that the palette is inversed by default.- `i,j, drop`: `i` is a vector used for subsetting the object. For instance, `i=1:3` will retain only the first three haplotypes of the genealogy. `j` and `drop` are only provided for compatibility, but not used.- `best, prox.mat`: arguments to be passed to the `seqTrack` function. See documentation of `seqTrack` for more information.- `annot,date.range,col,bg,add`: arguments to be passed to `plotSeqTrack`.- `n`: an integer indicating the number of haplotypes to be retained in the sample- `tz, origin`: aguments to be passed to `as.POSIXct` (see ?as.POSIXct)- ``...``: further arguments to be passed to other methods; for 'plot', arguments are passed to `plot.igraph`. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk ReferencesJombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. Heredity. doi: 10.1038/hdy.2010.78. Returns=== haploGen class === `haploGen` objects are lists containing the following slots:- seq: DNA sequences in the DNAbin matrix format- dates: dates of appearance of the haplotypes- ances: a vector of integers giving the index of each haplotype's ancestor- id: a vector of integers giving the index of each haplotype- xy: (optional) a matrix of spatial coordinates of haplotypes- call: the matched call=== misc functions ===- as.POSIXct: returns a vector of dates with POSIXct format- labels: returns the labels of the haplotypes- as.seqTrack: returns a seqTrack object. Note that this object is not a proper seqTrack analysis, but just a format conversion convenient for plotting `haploGen` objects. Details=== Dependencies with other packages ===- ape package is required as it implements efficient handling of DNA sequences used in `haploGen` objects. To install this package, simply type: `install.packages(""ape"")`- for various purposes including plotting, converting genealogies to graphs can be useful. From adegenet version 1.3-5 onwards, this is achieved using the package `igraph`. See below.=== Converting haploGen objects to graphs === `haploGen` objects can be converted to `igraph` objects (package `igraph`), which can in turn be plotted and manipulated using classical graph tools. Simply use 'as.igraph(x)' where 'x' is a `haploGen` object. This functionality requires the `igraph` package. Graphs are time oriented (top=old, bottom=recent). See Also`simOutbreak` in the package 'outbreaker' for simulating disease outbreaks under a realistic epidemiological model. Examples```r Not run:if(require(ape) && require(igraph)){ PERFORM SIMULATIONSx <- haploGen(geo.sim=TRUE)x PLOT DATAplot(x) PLOT SPATIAL SPREADplotHaploGen(x, bg=""white"")title(""Spatial dispersion"") USE SEQTRACK RECONSTRUCTIONx.recons <- seqTrack(x)mean(x.recons$ances==x$ances, na.rm=TRUE)  proportion of correct reconstructionsg <- as.igraph(x)gplot(g)plot(g, vertex.size=0)} End(Not run)```",19
adegenet,tab.md," methods

# Access allele counts or frequencies

```r
tab(x, ...)

## S4 method for signature 'genind'
tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...)

## S4 method for signature 'genpop'
tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...)
```

## Arguments

- `x`: a genind or genpop object.
- `...`: further arguments passed to other methods.
- `freq`: a logical indicating if data should be transformed into relative frequencies (TRUE); defaults to FALSE.
- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero

## Returns

a matrix of integers or numeric

## Description

This accessor is used to retrieve a matrix of allele data. By default, a matrix of integers representing allele counts is returned. If `freq` is TRUE, then data are standardised as frequencies, so that for any individual and any locus the data sum to 1. The argument `NA.method` allows to replace missing data (NAs). This accessor replaces the previous function `truenames` as well as the function `makefreq`.

## Examples

```r
data(microbov)
head(tab(microbov))
head(tab(microbov,freq=TRUE))
```



","['methods Access allele counts or frequencies```rtab(x, ...) S4 method for signature \'genind\'tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...) S4 method for signature \'genpop\'tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...)``` Arguments- `x`: a genind or genpop object.- `...`: further arguments passed to other methods.- `freq`: a logical indicating if data should be transformed into relative frequencies (TRUE); defaults to FALSE.- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero Returnsa matrix of integers or numeric DescriptionThis accessor is used to retrieve a matrix of allele data.', 'By default, a matrix of integers representing allele counts is returned.', 'If `freq` is TRUE, then data are standardised as frequencies, so that for any individual and any locus the data sum to 1.', 'The argument `NA.method` allows to replace missing data (NAs).', 'This accessor replaces the previous function `truenames` as well as the function `makefreq`.']",1," methods Access allele counts or frequencies```rtab(x, ...) S4 method for signature 'genind'tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...) S4 method for signature 'genpop'tab(x, freq = FALSE, NA.method = c(""asis"", ""mean"", ""zero""), ...)``` Arguments- `x`: a genind or genpop object.- `...`: further arguments passed to other methods.- `freq`: a logical indicating if data should be transformed into relative frequencies (TRUE); defaults to FALSE.- `NA.method`: a method to replace NA; asis: leave NAs as is; mean: replace by the mean allele frequencies; zero: replace by zero Returnsa matrix of integers or numeric DescriptionThis accessor is used to retrieve a matrix of allele data. By default, a matrix of integers representing allele counts is returned. If `freq` is TRUE, then data are standardised as frequencies, so that for any individual and any locus the data sum to 1. The argument `NA.method` allows to replace missing data (NAs). This accessor replaces the previous function `truenames` as well as the function `makefreq`. Examples```rdata(microbov)head(tab(microbov))head(tab(microbov,freq=TRUE))```",19
adegenet,accessors.md,"UTF-8

methods

# Accessors for adegenet objects

## Description

An accessor is a function that allows to interact with slots of an object in a convenient way. Several accessors are available for genind or genpop objects. The operator ""$"" and ""$<-"" are used to access the slots, being equivalent to ""@"" and ""@<-"".

The operator ""["" is a flexible way to subset data by individuals, populations, alleles, and loci. When using a matrix-like syntax, subsetting will apply to the dimensios of the @tab slot. In addition, specific arguments `loc` and `pop` can be used to indicate subsets of loci and populations. The argument `drop` is a logical indicating if alleles becoming non-polymorphic in a new dataset should be removed (default: FALSE). Examples:

 

 * ""obj[i,j]"" returns ""obj"" with a subset 'i' of individuals and 'j' of alleles.
 * ""obj[1:10,]"" returns an object with only the first 10 genotypes (if ""obj"" is a genind ) or the first 10 populations (if ""obj"" is a genpop )
 * ""obj[1:10, 5:10]"" returns an object keeping the first 10 entities and the alleles 5 to 10.
 * ""obj[loc=c(1,3)]"" returns an object keeping only the 1st and 3rd loci, using `locNames(obj)` as reference; logicals, or named loci also work; this overrides other subsetting of alleles.
 * ""obj[pop=2:4]"" returns an object keeping only individuals from the populations 2, 3 and 4, using `popNames(obj)` as reference; logicals, or named populations also work; this overrides other subsetting of individuals.
 * ""obj[i=1:2, drop=TRUE]"" returns an object keeping only the first two individuals (or populations), dropping the alleles no longer present in the data.

The argument `treatOther` handles the treatment of objects in the `@other` slot (see details). The argument `drop` can be set to TRUE to drop alleles that are no longer represented in the subset.

## Methods

- **nInd**: returns the number of individuals in the `genind` object
- **nLoc**: returns the number of loci
- **nAll**: returns the number of observed alleles in each locus
- **nPop**: returns the number of populations
- **pop**: returns a factor assigning individuals to populations.
- **pop<-**: replacement method for the `@pop` slot of an object.
- **popNames**: returns the names of populations.
- **popNames<-**: sets the names of populations using a vector of length `nPop(x)`.
- **indNames**: returns the names of individuals.
- **indNames<-**: sets the names of individuals using a vector of length `nInd(x)`.
- **locNames**: returns the names of markers and/or alleles.
- **locNames<-**: sets the names of markers using a vector of length `nLoc(x)`.
- **locFac**: returns a factor that defines which locus each column of the `@tab` slot belongs to
- **ploidy**: returns the ploidy of the data.
- **ploidy<-**: sets the ploidy of the data using an integer.
- **alleles**: returns the alleles of each locus.
- **alleles<-**: sets the alleles of each locus using a list with one character vector for each locus.
- **other**: returns the content of the `@other` slot (misc. information); returns `NULL` if the slot is onlyObserved or of length zero.
- **other<-**: sets the content of the `@other` slot (misc. information); the provided value needs to be a list; it not, provided value will be stored within a list.

```r
nInd(x, ...)
nLoc(x, ...)
nAll(x, onlyObserved = FALSE, ...)
nPop(x, ...)
pop(x)
indNames(x, ...)
## S4 method for signature 'genind'
indNames(x, ...)
locNames(x, ...)
## S4 method for signature 'genind'
locNames(x, withAlleles=FALSE, ...)
## S4 method for signature 'genpop'
locNames(x, withAlleles=FALSE, ...)
popNames(x, ...)
## S4 method for signature 'genind'
popNames(x, ...)
popNames(x, ...)
## S4 method for signature 'genpop'
popNames(x, ...)
ploidy(x, ...)
## S4 method for signature 'genind'
ploidy(x, ...)
## S4 method for signature 'genpop'
ploidy(x, ...)
## S4 method for signature 'genind'
other(x, ...)
## S4 method for signature 'genpop'
other(x, ...)
```

## Arguments

- `x`: a genind or a genpop object.
- `onlyObserved`: a logical indicating whether the allele count should also include the alleles with onlyObserved columns in the matrix. Defaults to `FALSE`, which will report only the observed alleles in the given population. `onlyObserved = TRUE` will be the equivalent of `table(locFac(x))`, but faster.
- `withAlleles`: a logical indicating whether the result should be of the form [locus name].[allele name], instead of [locus name].
- ``...``: further arguments to be passed to other methods (currently not used).

## Returns

A genind or genpop object.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Details

The ""["" operator can treat elements in the `@other` slot as well. For instance, if `obj@other$xy` contains spatial coordinates, the `obj[1:3, ]@other$xy` will contain the spatial coordinates of the genotypes (or population) 1,2 and 3. This is handled through the argument `treatOther`, a logical defaulting to TRUE. If set to FALSE, the `@other` returned unmodified.

Note that only matrix-like, vector-like and lists can be proceeded in `@other`. Other kind of objects will issue a warning an be returned as they are, unless the argument `quiet` is left to TRUE, its default value.

The `drop` argument can be set to TRUE to retain only alleles that are present in the subset. To achieve better control of polymorphism of the data, see `isPoly`.

 `nAll()` reflects the number of columns per locus present in the current gen object. If `onlyObserved = TRUE`, then the number of columns with at least one non-missing allele is shown.

## Examples

```r
data(nancycats)
nancycats
pop(nancycats) # get the populations
indNames(nancycats) # get the labels of individuals
locNames(nancycats) # get the labels of the loci
alleles(nancycats)  # get the alleles
nAll(nancycats)     # count the number of alleles

head(tab(nancycats)) # get allele counts

# get allele frequencies, replace NAs
head(tab(nancycats, freq = TRUE, NA.method = ""mean"")) 

# let's isolate populations 4 and 8
popNames(nancycats)
obj <- nancycats[pop=c(4, 8)]
obj
popNames(obj)
pop(obj)
nAll(obj, onlyObserved = TRUE) # count number of alleles among these two populations
nAll(obj) # count number of columns in the data
all(nAll(obj, onlyObserved = TRUE) == lengths(alleles(obj))) # will be FALSE since drop = FALSE
all(nAll(obj) == lengths(alleles(obj))) # will be FALSE since drop = FALSE

# let's isolate two markers, fca23 and fca90
locNames(nancycats)
obj <- nancycats[loc=c(""fca23"",""fca90"")]
obj
locNames(obj)

# illustrate pop
obj <- nancycats[sample(1:100, 10)]
pop(obj)
pop(obj) <- rep(c('b', 'a'), each = 5)
pop(obj)

# illustrate locNames
locNames(obj)
locNames(obj, withAlleles = TRUE)
locNames(obj)[1] <- ""newLocus""
locNames(obj)
locNames(obj, withAlleles=TRUE)

# illustrate how 'other' slot is handled
data(sim2pop)
nInd(sim2pop)
other(sim2pop[1:6]) # xy is subsetted automatically
other(sim2pop[1:6, treatOther=FALSE]) # xy is left as is
```



","['UTF-8methods Accessors for adegenet objects DescriptionAn accessor is a function that allows to interact with slots of an object in a convenient way.', 'Several accessors are available for genind or genpop objects.', 'The operator ""$"" and ""$<-"" are used to access the slots, being equivalent to ""@"" and ""@<-"".The operator ""["" is a flexible way to subset data by individuals, populations, alleles, and loci.', 'When using a matrix-like syntax, subsetting will apply to the dimensios of the @tab slot.', 'In addition, specific arguments `loc` and `pop` can be used to indicate subsets of loci and populations.', 'The argument `drop` is a logical indicating if alleles becoming non-polymorphic in a new dataset should be removed (default: FALSE).', 'Examples:   ""obj[i,j]"" returns ""obj"" with a subset \'i\' of individuals and \'j\' of alleles.', '""obj[1:10,]"" returns an object with only the first 10 genotypes (if ""obj"" is a genind ) or the first 10 populations (if ""obj"" is a genpop )  ""obj[1:10, 5:10]"" returns an object keeping the first 10 entities and the alleles 5 to 10.', '""obj[loc=c(1,3)]"" returns an object keeping only the 1st and 3rd loci, using `locNames(obj)` as reference; logicals, or named loci also work; this overrides other subsetting of alleles.', '""obj[pop=2:4]"" returns an object keeping only individuals from the populations 2, 3 and 4, using `popNames(obj)` as reference; logicals, or named populations also work; this overrides other subsetting of individuals.', '""obj[i=1:2, drop=TRUE]"" returns an object keeping only the first two individuals (or populations), dropping the alleles no longer present in the data.The argument `treatOther` handles the treatment of objects in the `@other` slot (see details).', 'The argument `drop` can be set to TRUE to drop alleles that are no longer represented in the subset.', 'Methods- nInd: returns the number of individuals in the `genind` object- nLoc: returns the number of loci- nAll: returns the number of observed alleles in each locus- nPop: returns the number of populations- pop: returns a factor assigning individuals to populations.- pop<-: replacement method for the `@pop` slot of an object.- popNames: returns the names of populations.- popNames<-: sets the names of populations using a vector of length `nPop(x)`.- indNames: returns the names of individuals.- indNames<-: sets the names of individuals using a vector of length `nInd(x)`.- locNames: returns the names of markers and/or alleles.- locNames<-: sets the names of markers using a vector of length `nLoc(x)`.- locFac: returns a factor that defines which locus each column of the `@tab` slot belongs to- ploidy: returns the ploidy of the data.- ploidy<-: sets the ploidy of the data using an integer.- alleles: returns the alleles of each locus.- alleles<-: sets the alleles of each locus using a list with one character vector for each locus.- other: returns the content of the `@other` slot (misc.', 'information); returns `NULL` if the slot is onlyObserved or of length zero.- other<-: sets the content of the `@other` slot (misc.', ""information); the provided value needs to be a list; it not, provided value will be stored within a list.```rnInd(x, ...)nLoc(x, ...)nAll(x, onlyObserved = FALSE, ...)nPop(x, ...)pop(x)indNames(x, ...) S4 method for signature 'genind'indNames(x, ...)locNames(x, ...) S4 method for signature 'genind'locNames(x, withAlleles=FALSE, ...) S4 method for signature 'genpop'locNames(x, withAlleles=FALSE, ...)popNames(x, ...) S4 method for signature 'genind'popNames(x, ...)popNames(x, ...) S4 method for signature 'genpop'popNames(x, ...)ploidy(x, ...) S4 method for signature 'genind'ploidy(x, ...) S4 method for signature 'genpop'ploidy(x, ...) S4 method for signature 'genind'other(x, ...) S4 method for signature 'genpop'other(x, ...)``` Arguments- `x`: a genind or a genpop object.- `onlyObserved`: a logical indicating whether the allele count should also include the alleles with onlyObserved columns in the matrix."", 'Defaults to `FALSE`, which will report only the observed alleles in the given population.', '`onlyObserved = TRUE` will be the equivalent of `table(locFac(x))`, but faster.- `withAlleles`: a logical indicating whether the result should be of the form [locus name].', '[allele name], instead of [locus name].- ``...``: further arguments to be passed to other methods (currently not used).', 'ReturnsA genind or genpop object.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk DetailsThe ""["" operator can treat elements in the `@other` slot as well.', 'For instance, if `obj@other$xy` contains spatial coordinates, the `obj[1:3, ]@other$xy` will contain the spatial coordinates of the genotypes (or population) 1,2 and 3.', 'This is handled through the argument `treatOther`, a logical defaulting to TRUE.', 'If set to FALSE, the `@other` returned unmodified.Note that only matrix-like, vector-like and lists can be proceeded in `@other`.', 'Other kind of objects will issue a warning an be returned as they are, unless the argument `quiet` is left to TRUE, its default value.The `drop` argument can be set to TRUE to retain only alleles that are present in the subset.', 'To achieve better control of polymorphism of the data, see `isPoly`.', '`nAll()` reflects the number of columns per locus present in the current gen object.', 'If `onlyObserved = TRUE`, then the number of columns with at least one non-missing allele is shown.', 'Examples```rdata(nancycats)nancycatspop(nancycats)  get the populationsindNames(nancycats)  get the labels of individualslocNames(nancycats)  get the labels of the locialleles(nancycats)   get the allelesnAll(nancycats)      count the number of alleleshead(tab(nancycats))  get allele counts get allele frequencies, replace NAshead(tab(nancycats, freq = TRUE, NA.method = ""mean""))  let\'s isolate populations 4 and 8popNames(nancycats)obj <- nancycats[pop=c(4, 8)]objpopNames(obj)pop(obj)nAll(obj, onlyObserved = TRUE)  count number of alleles among these two populationsnAll(obj)  count number of columns in the dataall(nAll(obj, onlyObserved = TRUE) == lengths(alleles(obj)))  will be FALSE since drop = FALSEall(nAll(obj) == lengths(alleles(obj)))  will be FALSE since drop = FALSE let\'s isolate two markers, fca23 and fca90locNames(nancycats)obj <- nancycats[loc=c(""fca23"",""fca90"")]objlocNames(obj) illustrate popobj <- nancycats[sample(1:100, 10)]pop(obj)pop(obj) <- rep(c(\'b\', \'a\'), each = 5)pop(obj) illustrate locNameslocNames(obj)locNames(obj, withAlleles = TRUE)locNames(obj)[1] <- ""newLocus""locNames(obj)locNames(obj, withAlleles=TRUE) illustrate how \'other\' slot is handleddata(sim2pop)nInd(sim2pop)other(sim2pop[1:6])  xy is subsetted automaticallyother(sim2pop[1:6, treatOther=FALSE])  xy is left as is```']",1,"UTF-8methods Accessors for adegenet objects DescriptionAn accessor is a function that allows to interact with slots of an object in a convenient way. Several accessors are available for genind or genpop objects. The operator ""$"" and ""$<-"" are used to access the slots, being equivalent to ""@"" and ""@<-"".The operator ""["" is a flexible way to subset data by individuals, populations, alleles, and loci. When using a matrix-like syntax, subsetting will apply to the dimensios of the @tab slot. In addition, specific arguments `loc` and `pop` can be used to indicate subsets of loci and populations. The argument `drop` is a logical indicating if alleles becoming non-polymorphic in a new dataset should be removed (default: FALSE). Examples:   ""obj[i,j]"" returns ""obj"" with a subset 'i' of individuals and 'j' of alleles.  ""obj[1:10,]"" returns an object with only the first 10 genotypes (if ""obj"" is a genind ) or the first 10 populations (if ""obj"" is a genpop )  ""obj[1:10, 5:10]"" returns an object keeping the first 10 entities and the alleles 5 to 10.  ""obj[loc=c(1,3)]"" returns an object keeping only the 1st and 3rd loci, using `locNames(obj)` as reference; logicals, or named loci also work; this overrides other subsetting of alleles.  ""obj[pop=2:4]"" returns an object keeping only individuals from the populations 2, 3 and 4, using `popNames(obj)` as reference; logicals, or named populations also work; this overrides other subsetting of individuals.  ""obj[i=1:2, drop=TRUE]"" returns an object keeping only the first two individuals (or populations), dropping the alleles no longer present in the data.The argument `treatOther` handles the treatment of objects in the `@other` slot (see details). The argument `drop` can be set to TRUE to drop alleles that are no longer represented in the subset. Methods- nInd: returns the number of individuals in the `genind` object- nLoc: returns the number of loci- nAll: returns the number of observed alleles in each locus- nPop: returns the number of populations- pop: returns a factor assigning individuals to populations.- pop<-: replacement method for the `@pop` slot of an object.- popNames: returns the names of populations.- popNames<-: sets the names of populations using a vector of length `nPop(x)`.- indNames: returns the names of individuals.- indNames<-: sets the names of individuals using a vector of length `nInd(x)`.- locNames: returns the names of markers and/or alleles.- locNames<-: sets the names of markers using a vector of length `nLoc(x)`.- locFac: returns a factor that defines which locus each column of the `@tab` slot belongs to- ploidy: returns the ploidy of the data.- ploidy<-: sets the ploidy of the data using an integer.- alleles: returns the alleles of each locus.- alleles<-: sets the alleles of each locus using a list with one character vector for each locus.- other: returns the content of the `@other` slot (misc. information); returns `NULL` if the slot is onlyObserved or of length zero.- other<-: sets the content of the `@other` slot (misc. information); the provided value needs to be a list; it not, provided value will be stored within a list.```rnInd(x, ...)nLoc(x, ...)nAll(x, onlyObserved = FALSE, ...)nPop(x, ...)pop(x)indNames(x, ...) S4 method for signature 'genind'indNames(x, ...)locNames(x, ...) S4 method for signature 'genind'locNames(x, withAlleles=FALSE, ...) S4 method for signature 'genpop'locNames(x, withAlleles=FALSE, ...)popNames(x, ...) S4 method for signature 'genind'popNames(x, ...)popNames(x, ...) S4 method for signature 'genpop'popNames(x, ...)ploidy(x, ...) S4 method for signature 'genind'ploidy(x, ...) S4 method for signature 'genpop'ploidy(x, ...) S4 method for signature 'genind'other(x, ...) S4 method for signature 'genpop'other(x, ...)``` Arguments- `x`: a genind or a genpop object.- `onlyObserved`: a logical indicating whether the allele count should also include the alleles with onlyObserved columns in the matrix. Defaults to `FALSE`, which will report only the observed alleles in the given population. `onlyObserved = TRUE` will be the equivalent of `table(locFac(x))`, but faster.- `withAlleles`: a logical indicating whether the result should be of the form [locus name].[allele name], instead of [locus name].- ``...``: further arguments to be passed to other methods (currently not used). ReturnsA genind or genpop object. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk DetailsThe ""["" operator can treat elements in the `@other` slot as well. For instance, if `obj@other$xy` contains spatial coordinates, the `obj[1:3, ]@other$xy` will contain the spatial coordinates of the genotypes (or population) 1,2 and 3. This is handled through the argument `treatOther`, a logical defaulting to TRUE. If set to FALSE, the `@other` returned unmodified.Note that only matrix-like, vector-like and lists can be proceeded in `@other`. Other kind of objects will issue a warning an be returned as they are, unless the argument `quiet` is left to TRUE, its default value.The `drop` argument can be set to TRUE to retain only alleles that are present in the subset. To achieve better control of polymorphism of the data, see `isPoly`. `nAll()` reflects the number of columns per locus present in the current gen object. If `onlyObserved = TRUE`, then the number of columns with at least one non-missing allele is shown. Examples```rdata(nancycats)nancycatspop(nancycats)  get the populationsindNames(nancycats)  get the labels of individualslocNames(nancycats)  get the labels of the locialleles(nancycats)   get the allelesnAll(nancycats)      count the number of alleleshead(tab(nancycats))  get allele counts get allele frequencies, replace NAshead(tab(nancycats, freq = TRUE, NA.method = ""mean""))  let's isolate populations 4 and 8popNames(nancycats)obj <- nancycats[pop=c(4, 8)]objpopNames(obj)pop(obj)nAll(obj, onlyObserved = TRUE)  count number of alleles among these two populationsnAll(obj)  count number of columns in the dataall(nAll(obj, onlyObserved = TRUE) == lengths(alleles(obj)))  will be FALSE since drop = FALSEall(nAll(obj) == lengths(alleles(obj)))  will be FALSE since drop = FALSE let's isolate two markers, fca23 and fca90locNames(nancycats)obj <- nancycats[loc=c(""fca23"",""fca90"")]objlocNames(obj) illustrate popobj <- nancycats[sample(1:100, 10)]pop(obj)pop(obj) <- rep(c('b', 'a'), each = 5)pop(obj) illustrate locNameslocNames(obj)locNames(obj, withAlleles = TRUE)locNames(obj)[1] <- ""newLocus""locNames(obj)locNames(obj, withAlleles=TRUE) illustrate how 'other' slot is handleddata(sim2pop)nInd(sim2pop)other(sim2pop[1:6])  xy is subsetted automaticallyother(sim2pop[1:6, treatOther=FALSE])  xy is left as is```",19
adegenet,AIC.snapclust.md,"# Compute Akaike Information Criterion (AIC) for snapclust

```r
## S3 method for class 'snapclust'
AIC(object, ...)
```

## Arguments

- `object`: An object returned by the function `snapclust`.
- `...`: Further arguments for compatibility with the `AIC` generic (currently not used).

## Description

Do not use. We work on that stuff. Contact us if interested.

## See Also

`snapclust` to generate clustering solutions.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","[""Compute Akaike Information Criterion (AIC) for snapclust```r S3 method for class 'snapclust'AIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used)."", 'We work on that stuff.', 'See Also`snapclust` to generate clustering solutions.']",1," Compute Akaike Information Criterion (AIC) for snapclust```r S3 method for class 'snapclust'AIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used). DescriptionDo not use. We work on that stuff. Contact us if interested. See Also`snapclust` to generate clustering solutions. Author(s)Thibaut Jombart thibautjombart@gmail.com",19
adegenet,isPoly.md,"methods

# Assess polymorphism in genind/genpop objects

## Description

The simple function `isPoly` can be used to check which loci are polymorphic, or alternatively to check which alleles give rise to polymorphism.

```r
## S4 method for signature 'genind'
isPoly(x, by=c(""locus"",""allele""), thres=1/100)
## S4 method for signature 'genpop'
isPoly(x, by=c(""locus"",""allele""), thres=1/100)
```

## Arguments

- `x`: a genind and genpop object
- `by`: a character being ""locus"" or ""allele"", indicating whether results should indicate polymorphic loci (""locus""), or alleles giving rise to polymorphism (""allele"").
- `thres`: a numeric value giving the minimum frequency of an allele giving rise to polymorphism (defaults to 0.01).

 

## Returns

A vector of logicals.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(nancycats)
isPoly(nancycats,by=""loc"", thres=0.1)
isPoly(nancycats[1:3],by=""loc"", thres=0.1)
genind2df(nancycats[1:3])
## End(Not run)
```



","['methods Assess polymorphism in genind/genpop objects DescriptionThe simple function `isPoly` can be used to check which loci are polymorphic, or alternatively to check which alleles give rise to polymorphism.```r S4 method for signature \'genind\'isPoly(x, by=c(""locus"",""allele""), thres=1/100) S4 method for signature \'genpop\'isPoly(x, by=c(""locus"",""allele""), thres=1/100)``` Arguments- `x`: a genind and genpop object- `by`: a character being ""locus"" or ""allele"", indicating whether results should indicate polymorphic loci (""locus""), or alleles giving rise to polymorphism (""allele"").- `thres`: a numeric value giving the minimum frequency of an allele giving rise to polymorphism (defaults to 0.01).', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)isPoly(nancycats,by=""loc"", thres=0.1)isPoly(nancycats[1:3],by=""loc"", thres=0.1)genind2df(nancycats[1:3]) End(Not run)```']",1,"methods Assess polymorphism in genind/genpop objects DescriptionThe simple function `isPoly` can be used to check which loci are polymorphic, or alternatively to check which alleles give rise to polymorphism.```r S4 method for signature 'genind'isPoly(x, by=c(""locus"",""allele""), thres=1/100) S4 method for signature 'genpop'isPoly(x, by=c(""locus"",""allele""), thres=1/100)``` Arguments- `x`: a genind and genpop object- `by`: a character being ""locus"" or ""allele"", indicating whether results should indicate polymorphic loci (""locus""), or alleles giving rise to polymorphism (""allele"").- `thres`: a numeric value giving the minimum frequency of an allele giving rise to polymorphism (defaults to 0.01).  ReturnsA vector of logicals. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(nancycats)isPoly(nancycats,by=""loc"", thres=0.1)isPoly(nancycats[1:3],by=""loc"", thres=0.1)genind2df(nancycats[1:3]) End(Not run)```",19
adegenet,makefreq.md," methods

# Compute allelic frequencies

```r
makefreq(x, ...)

## S4 method for signature 'genind'
makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)

## S4 method for signature 'genpop'
makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)
```

## Arguments

- `x`: a genind or genpop object.
- `...`: further arguments (curently unused)
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).
- `missing`: treatment for missing values. Can be NA, 0 or ""mean"" (see details)
- `truenames`: deprecated; there for backward compatibility

## Returns

Returns a list with the following components: - **tab**: matrix of allelic frequencies (rows: populations; columns: alleles).

- **nobs**: number of observations (i.e. alleles) for each population x locus combinaison. - **call**: the matched call

## Description

The function `makefreq` is a generic to compute allele frequencies. These can be derived for genind or genpop objects. In the case of genind objects, data are kept at the individual level, but standardised so that allele frequencies sum up to 1.

## Details

There are 3 treatments for missing values:

- NA: kept as NA.

- 0: missing values are considered as zero. Recommended for a PCA on compositionnal data.

- ""mean"": missing values are given the mean frequency of the corresponding allele. Recommended for a centred PCA.

Note that this function is now a simple wrapper for the accessor `tab`.

## Examples

```r
## Not run:

data(microbov)
obj1 <- microbov
obj2 <- genind2genpop(obj1)

# perform a correspondance analysis on counts data
Xcount <- tab(obj2, NA.method=""zero"")
ca1 <- dudi.coa(Xcount,scannf=FALSE)
s.label(ca1$li,sub=""Correspondance Analysis"",csub=1.2)
add.scatter.eig(ca1$eig,nf=2,xax=1,yax=2,posi=""topleft"")

# perform a principal component analysis on frequency data
Xfreq <- makefreq(obj2, missing=""mean"")
Xfreq <- tab(obj2, NA.method=""mean"") # equivalent to line above
pca1 <- dudi.pca(Xfreq,scale=FALSE,scannf=FALSE)
s.label(pca1$li,sub=""Principal Component Analysis"",csub=1.2)
add.scatter.eig(pca1$eig,nf=2,xax=1,yax=2,posi=""top"")
## End(Not run)
```

## See Also

`genpop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","[""methods Compute allelic frequencies```rmakefreq(x, ...) S4 method for signature 'genind'makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...) S4 method for signature 'genpop'makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)``` Arguments- `x`: a genind or genpop object.- `...`: further arguments (curently unused)- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- `missing`: treatment for missing values."", 'Can be NA, 0 or ""mean"" (see details)- `truenames`: deprecated; there for backward compatibility ReturnsReturns a list with the following components: - tab: matrix of allelic frequencies (rows: populations; columns: alleles).- nobs: number of observations (i.e.', 'alleles) for each population x locus combinaison.', '- call: the matched call DescriptionThe function `makefreq` is a generic to compute allele frequencies.', 'These can be derived for genind or genpop objects.', 'In the case of genind objects, data are kept at the individual level, but standardised so that allele frequencies sum up to 1.', 'DetailsThere are 3 treatments for missing values:- NA: kept as NA.- 0: missing values are considered as zero.', 'Recommended for a PCA on compositionnal data.- ""mean"": missing values are given the mean frequency of the corresponding allele.', 'Recommended for a centred PCA.Note that this function is now a simple wrapper for the accessor `tab`.', 'Examples```r Not run:data(microbov)obj1 <- microbovobj2 <- genind2genpop(obj1) perform a correspondance analysis on counts dataXcount <- tab(obj2, NA.method=""zero"")ca1 <- dudi.coa(Xcount,scannf=FALSE)s.label(ca1$li,sub=""Correspondance Analysis"",csub=1.2)add.scatter.eig(ca1$eig,nf=2,xax=1,yax=2,posi=""topleft"") perform a principal component analysis on frequency dataXfreq <- makefreq(obj2, missing=""mean"")Xfreq <- tab(obj2, NA.method=""mean"")  equivalent to line abovepca1 <- dudi.pca(Xfreq,scale=FALSE,scannf=FALSE)s.label(pca1$li,sub=""Principal Component Analysis"",csub=1.2)add.scatter.eig(pca1$eig,nf=2,xax=1,yax=2,posi=""top"") End(Not run)``` See Also`genpop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," methods Compute allelic frequencies```rmakefreq(x, ...) S4 method for signature 'genind'makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...) S4 method for signature 'genpop'makefreq(x, quiet = FALSE, missing = NA, truenames = TRUE, ...)``` Arguments- `x`: a genind or genpop object.- `...`: further arguments (curently unused)- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- `missing`: treatment for missing values. Can be NA, 0 or ""mean"" (see details)- `truenames`: deprecated; there for backward compatibility ReturnsReturns a list with the following components: - tab: matrix of allelic frequencies (rows: populations; columns: alleles).- nobs: number of observations (i.e. alleles) for each population x locus combinaison. - call: the matched call DescriptionThe function `makefreq` is a generic to compute allele frequencies. These can be derived for genind or genpop objects. In the case of genind objects, data are kept at the individual level, but standardised so that allele frequencies sum up to 1. DetailsThere are 3 treatments for missing values:- NA: kept as NA.- 0: missing values are considered as zero. Recommended for a PCA on compositionnal data.- ""mean"": missing values are given the mean frequency of the corresponding allele. Recommended for a centred PCA.Note that this function is now a simple wrapper for the accessor `tab`. Examples```r Not run:data(microbov)obj1 <- microbovobj2 <- genind2genpop(obj1) perform a correspondance analysis on counts dataXcount <- tab(obj2, NA.method=""zero"")ca1 <- dudi.coa(Xcount,scannf=FALSE)s.label(ca1$li,sub=""Correspondance Analysis"",csub=1.2)add.scatter.eig(ca1$eig,nf=2,xax=1,yax=2,posi=""topleft"") perform a principal component analysis on frequency dataXfreq <- makefreq(obj2, missing=""mean"")Xfreq <- tab(obj2, NA.method=""mean"")  equivalent to line abovepca1 <- dudi.pca(Xfreq,scale=FALSE,scannf=FALSE)s.label(pca1$li,sub=""Principal Component Analysis"",csub=1.2)add.scatter.eig(pca1$eig,nf=2,xax=1,yax=2,posi=""top"") End(Not run)``` See Also`genpop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",19
adegenet,hierarchy-methods.md," methods

# Access and manipulate the population hierarchy for genind or genlight objects.

```r
hier(x, formula = NULL, combine = TRUE, value)

hier(x) <- value
```

## Arguments

- `x`: a genind or genlight object
- `formula`: a nested formula indicating the order of the population hierarchy to be returned.
- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument. If it is `FALSE`, the levels will not be combined.
- `value`: a formula specifying the full hierarchy of columns in the strata slot. (See Details below)

## Description

The following methods allow the user to quickly change the hierarchy or population of a genind or genlight object.

## Details

You must first specify your strata before you can specify your hierarchies. Hierarchies are special cases of strata in that the levels must be nested within each other. An error will occur if you specify a hierarchy that is not truly hierarchical.

 

### Details on Formulas

 The preferred use of these functions is with a `formula` object. Specifically, a hierarchical formula argument is used to name which strata are hierarchical. An example of a hierarchical formula would be:

||
|--:|
|`~Country/City/Neighborhood`|

This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy. Note: it is important to use hierarchical formulas when specifying hierarchies as other types of formulas (eg. `~Country*City*Neighborhood`) will give incorrect results.

## Examples

```r
# let's look at the microbov data set:
data(microbov)
microbov

# We see that we have three vectors of different names in the 'other' slot. 
?microbov
# These are Country, Breed, and Species
names(other(microbov))

# Let's set the hierarchy
strata(microbov) <- data.frame(other(microbov))
microbov

# And change the names so we know what they are
nameStrata(microbov) <- ~Country/Breed/Species

# let's see what the hierarchy looks like by Species and Breed:
hier(microbov) <- ~Species/Breed
head(hier(microbov, ~Species/Breed))
```

## See Also

`strata` `genind` `as.genind`

## Author(s)

Zhian N. Kamvar



","['methods Access and manipulate the population hierarchy for genind or genlight objects.```rhier(x, formula = NULL, combine = TRUE, value)hier(x) <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population hierarchy to be returned.- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument.', 'If it is `FALSE`, the levels will not be combined.- `value`: a formula specifying the full hierarchy of columns in the strata slot.', '(See Details below) DescriptionThe following methods allow the user to quickly change the hierarchy or population of a genind or genlight object.', 'DetailsYou must first specify your strata before you can specify your hierarchies.', 'Hierarchies are special cases of strata in that the levels must be nested within each other.', 'An error will occur if you specify a hierarchy that is not truly hierarchical.', 'Details on Formulas The preferred use of these functions is with a `formula` object.', 'Specifically, a hierarchical formula argument is used to name which strata are hierarchical.', 'An example of a hierarchical formula would be:|||--:||`~Country/City/Neighborhood`|This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy.', 'Note: it is important to use hierarchical formulas when specifying hierarchies as other types of formulas (eg.', '`~CountryCityNeighborhood`) will give incorrect results.', ""Examples```r let's look at the microbov data set:data(microbov)microbov We see that we have three vectors of different names in the 'other' slot."", ""?microbov These are Country, Breed, and Speciesnames(other(microbov)) Let's set the hierarchystrata(microbov) <- data.frame(other(microbov))microbov And change the names so we know what they arenameStrata(microbov) <- ~Country/Breed/Species let's see what the hierarchy looks like by Species and Breed:hier(microbov) <- ~Species/Breedhead(hier(microbov, ~Species/Breed))``` See Also`strata` `genind` `as.genind` Author(s)Zhian N. Kamvar""]",1," methods Access and manipulate the population hierarchy for genind or genlight objects.```rhier(x, formula = NULL, combine = TRUE, value)hier(x) <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population hierarchy to be returned.- `combine`: if `TRUE` (default), the levels will be combined according to the formula argument. If it is `FALSE`, the levels will not be combined.- `value`: a formula specifying the full hierarchy of columns in the strata slot. (See Details below) DescriptionThe following methods allow the user to quickly change the hierarchy or population of a genind or genlight object. DetailsYou must first specify your strata before you can specify your hierarchies. Hierarchies are special cases of strata in that the levels must be nested within each other. An error will occur if you specify a hierarchy that is not truly hierarchical.  Details on Formulas The preferred use of these functions is with a `formula` object. Specifically, a hierarchical formula argument is used to name which strata are hierarchical. An example of a hierarchical formula would be:|||--:||`~Country/City/Neighborhood`|This convention was chosen as it becomes easier to type and makes intuitive sense when defining a hierarchy. Note: it is important to use hierarchical formulas when specifying hierarchies as other types of formulas (eg. `~CountryCityNeighborhood`) will give incorrect results. Examples```r let's look at the microbov data set:data(microbov)microbov We see that we have three vectors of different names in the 'other' slot. ?microbov These are Country, Breed, and Speciesnames(other(microbov)) Let's set the hierarchystrata(microbov) <- data.frame(other(microbov))microbov And change the names so we know what they arenameStrata(microbov) <- ~Country/Breed/Species let's see what the hierarchy looks like by Species and Breed:hier(microbov) <- ~Species/Breedhead(hier(microbov, ~Species/Breed))``` See Also`strata` `genind` `as.genind` Author(s)Zhian N. Kamvar",19
adegenet,new.genind.md," methods

# genind constructor

```r
## S4 method for signature 'genind'
initialize(
  .Object,
  tab,
  pop = NULL,
  prevcall = NULL,
  ploidy = 2L,
  type = c(""codom"", ""PA""),
  strata = NULL,
  hierarchy = NULL,
  ...
)

genind(...)

as.genind(...)
```

## Arguments

- `.Object`: prototyped object (generated automatically when calling 'new')
- `tab`: A matrix of integers corresponding to the @tab slot of a genind object, with individuals in rows and alleles in columns, and containing either allele counts (if type=""codom"") or allele presence/absence (if type=""PA"")
- `pop`: an optional factor with one value per row in `tab` indicating the population of each individual
- `prevcall`: an optional call to be stored in the object
- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.
- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")
- `strata`: a data frame containing population hierarchies or stratifications in columns. This must be the same length as the number of individuals in the data set.
- `hierarchy`: a hierarchical formula defining the columns of the strata slot that are hierarchical. Defaults to NULL.
- `...`: further arguments passed to other methods (currently not used)

## Returns

a genind object

## Description

The function `new` has a method for building genind objects. See the class description of genind for more information on this data structure. The functions `genind` and `as.genind` are aliases for `new(""genind"", ...)`.

## Details

Most users do not need using the constructor, but merely to convert raw allele data using `df2genind` and related functions.

## See Also

the description of the genind class; `df2genind`



","['methods genind constructor```r S4 method for signature \'genind\'initialize(  .Object,  tab,  pop = NULL,  prevcall = NULL,  ploidy = 2L,  type = c(""codom"", ""PA""),  strata = NULL,  hierarchy = NULL,  ...)genind(...)as.genind(...)``` Arguments- `.Object`: prototyped object (generated automatically when calling \'new\')- `tab`: A matrix of integers corresponding to the @tab slot of a genind object, with individuals in rows and alleles in columns, and containing either allele counts (if type=""codom"") or allele presence/absence (if type=""PA"")- `pop`: an optional factor with one value per row in `tab` indicating the population of each individual- `prevcall`: an optional call to be stored in the object- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")- `strata`: a data frame containing population hierarchies or stratifications in columns.', 'This must be the same length as the number of individuals in the data set.- `hierarchy`: a hierarchical formula defining the columns of the strata slot that are hierarchical.', 'Defaults to NULL.- `...`: further arguments passed to other methods (currently not used) Returnsa genind object DescriptionThe function `new` has a method for building genind objects.', 'See the class description of genind for more information on this data structure.', 'The functions `genind` and `as.genind` are aliases for `new(""genind"", ...)`.', 'DetailsMost users do not need using the constructor, but merely to convert raw allele data using `df2genind` and related functions.', 'See Alsothe description of the genind class; `df2genind`']",1," methods genind constructor```r S4 method for signature 'genind'initialize(  .Object,  tab,  pop = NULL,  prevcall = NULL,  ploidy = 2L,  type = c(""codom"", ""PA""),  strata = NULL,  hierarchy = NULL,  ...)genind(...)as.genind(...)``` Arguments- `.Object`: prototyped object (generated automatically when calling 'new')- `tab`: A matrix of integers corresponding to the @tab slot of a genind object, with individuals in rows and alleles in columns, and containing either allele counts (if type=""codom"") or allele presence/absence (if type=""PA"")- `pop`: an optional factor with one value per row in `tab` indicating the population of each individual- `prevcall`: an optional call to be stored in the object- `ploidy`: an integer vector indicating the ploidy of the individual; each individual can have a different value; if only one value is provided, it is recycled to generate a vector of the right length.- `type`: a character string indicating the type of marker: codominant (""codom"") or presence/absence (""PA"")- `strata`: a data frame containing population hierarchies or stratifications in columns. This must be the same length as the number of individuals in the data set.- `hierarchy`: a hierarchical formula defining the columns of the strata slot that are hierarchical. Defaults to NULL.- `...`: further arguments passed to other methods (currently not used) Returnsa genind object DescriptionThe function `new` has a method for building genind objects. See the class description of genind for more information on this data structure. The functions `genind` and `as.genind` are aliases for `new(""genind"", ...)`. DetailsMost users do not need using the constructor, but merely to convert raw allele data using `df2genind` and related functions. See Alsothe description of the genind class; `df2genind`",20
adegenet,chooseCN.md,"# Function to choose a connection network

```r
chooseCN(
  xy,
  ask = TRUE,
  type = NULL,
  result.type = ""nb"",
  d1 = NULL,
  d2 = NULL,
  k = NULL,
  a = NULL,
  dmin = NULL,
  plot.nb = TRUE,
  edit.nb = FALSE,
  check.duplicates = TRUE
)
```

## Arguments

- `xy`: an matrix or data.frame with two columns for x and y coordinates.
- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE). Set to FALSE if `type` is provided.
- `type`: an integer giving the type of graph (see details).
- `result.type`: a character giving the class of the returned object. Either ""nb"" (default) or ""listw"", both from `spdep` package. See details.
- `d1`: the minimum distance between any two neighbours. Used if `type=5.`
- `d2`: the maximum distance between any two neighbours. Used if `type=5`. Can also be a character: ""dmin"" for the minimum distance so that each site has at least one connection, or ""dmax"" to have all sites connected (despite the later has no sense).
- `k`: the number of neighbours per point. Used if `type=6`.
- `a`: the exponent of the inverse distance matrix. Used if `type=7`.
- `dmin`: the minimum distance between any two distinct points. Used to avoid infinite spatial proximities (defined as the inversed spatial distances). Used if `type=7`.
- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).
- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).
- `check.duplicates`: a logical indicating if duplicate coordinates should be detected; this can be an issue for some graphs; TRUE by default.

## Returns

Returns a connection network having the class `nb` or `listw`. The xy coordinates are passed as attribute to the created object.

## Description

The function `chooseCN` is a simple interface to build a connection network (CN) from xy coordinates. The user chooses from 6 types of graph and one additional weighting scheme. `chooseCN` calls functions from appropriate packages, handles non-unique coordinates and returns a connection network either with classe `nb` or `listw`. For graph types 1-4, duplicated locations are not accepted and will issue an error.

## Details

There are 7 kinds of graphs proposed:

Delaunay triangulation (type 1)

Gabriel graph (type 2)

Relative neighbours (type 3)

Minimum spanning tree (type 4)

Neighbourhood by distance (type 5)

K nearests neighbours (type 6)

Inverse distances (type 7)

The last option (type=7) is not a true neighbouring graph: all sites are neighbours, but the spatial weights are directly proportional to the inversed spatial distances.

Also not that in this case, the output of the function is always a `listw` object, even if `nb` was requested.

The choice of the connection network has been discuted on the adegenet forum. Please search the archives from adegenet website (section 'contact') using 'graph' as keyword.

## Examples

```r
## Not run:

data(nancycats)

par(mfrow=c(2,2))
cn1 <- chooseCN(nancycats@other$xy,ask=FALSE,type=1)
cn2 <- chooseCN(nancycats@other$xy,ask=FALSE,type=2)
cn3 <- chooseCN(nancycats@other$xy,ask=FALSE,type=3)
cn4 <- chooseCN(nancycats@other$xy,ask=FALSE,type=4)
par(mfrow=c(1,1))
## End(Not run)
```

## See Also

`spca`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Function to choose a connection network```rchooseCN(  xy,  ask = TRUE,  type = NULL,  result.type = ""nb"",  d1 = NULL,  d2 = NULL,  k = NULL,  a = NULL,  dmin = NULL,  plot.nb = TRUE,  edit.nb = FALSE,  check.duplicates = TRUE)``` Arguments- `xy`: an matrix or data.frame with two columns for x and y coordinates.- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE).', 'Set to FALSE if `type` is provided.- `type`: an integer giving the type of graph (see details).- `result.type`: a character giving the class of the returned object.', 'Either ""nb"" (default) or ""listw"", both from `spdep` package.', 'See details.- `d1`: the minimum distance between any two neighbours.', 'Used if `type=5.`- `d2`: the maximum distance between any two neighbours.', 'Can also be a character: ""dmin"" for the minimum distance so that each site has at least one connection, or ""dmax"" to have all sites connected (despite the later has no sense).- `k`: the number of neighbours per point.', 'Used if `type=6`.- `a`: the exponent of the inverse distance matrix.', 'Used if `type=7`.- `dmin`: the minimum distance between any two distinct points.', 'Used to avoid infinite spatial proximities (defined as the inversed spatial distances).', 'Used if `type=7`.- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).- `check.duplicates`: a logical indicating if duplicate coordinates should be detected; this can be an issue for some graphs; TRUE by default.', 'ReturnsReturns a connection network having the class `nb` or `listw`.', 'The xy coordinates are passed as attribute to the created object.', 'DescriptionThe function `chooseCN` is a simple interface to build a connection network (CN) from xy coordinates.', 'The user chooses from 6 types of graph and one additional weighting scheme.', '`chooseCN` calls functions from appropriate packages, handles non-unique coordinates and returns a connection network either with classe `nb` or `listw`.', 'For graph types 1-4, duplicated locations are not accepted and will issue an error.', 'DetailsThere are 7 kinds of graphs proposed:Delaunay triangulation (type 1)Gabriel graph (type 2)Relative neighbours (type 3)Minimum spanning tree (type 4)Neighbourhood by distance (type 5)K nearests neighbours (type 6)Inverse distances (type 7)The last option (type=7) is not a true neighbouring graph: all sites are neighbours, but the spatial weights are directly proportional to the inversed spatial distances.Also not that in this case, the output of the function is always a `listw` object, even if `nb` was requested.The choice of the connection network has been discuted on the adegenet forum.', ""Please search the archives from adegenet website (section 'contact') using 'graph' as keyword."", 'Examples```r Not run:data(nancycats)par(mfrow=c(2,2))cn1 <- chooseCN(nancycats@other$xy,ask=FALSE,type=1)cn2 <- chooseCN(nancycats@other$xy,ask=FALSE,type=2)cn3 <- chooseCN(nancycats@other$xy,ask=FALSE,type=3)cn4 <- chooseCN(nancycats@other$xy,ask=FALSE,type=4)par(mfrow=c(1,1)) End(Not run)``` See Also`spca` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Function to choose a connection network```rchooseCN(  xy,  ask = TRUE,  type = NULL,  result.type = ""nb"",  d1 = NULL,  d2 = NULL,  k = NULL,  a = NULL,  dmin = NULL,  plot.nb = TRUE,  edit.nb = FALSE,  check.duplicates = TRUE)``` Arguments- `xy`: an matrix or data.frame with two columns for x and y coordinates.- `ask`: a logical stating whether graph should be chosen interactively (TRUE,default) or not (FALSE). Set to FALSE if `type` is provided.- `type`: an integer giving the type of graph (see details).- `result.type`: a character giving the class of the returned object. Either ""nb"" (default) or ""listw"", both from `spdep` package. See details.- `d1`: the minimum distance between any two neighbours. Used if `type=5.`- `d2`: the maximum distance between any two neighbours. Used if `type=5`. Can also be a character: ""dmin"" for the minimum distance so that each site has at least one connection, or ""dmax"" to have all sites connected (despite the later has no sense).- `k`: the number of neighbours per point. Used if `type=6`.- `a`: the exponent of the inverse distance matrix. Used if `type=7`.- `dmin`: the minimum distance between any two distinct points. Used to avoid infinite spatial proximities (defined as the inversed spatial distances). Used if `type=7`.- `plot.nb`: a logical stating whether the resulting graph should be plotted (TRUE, default) or not (FALSE).- `edit.nb`: a logical stating whether the resulting graph should be edited manually for corrections (TRUE) or not (FALSE, default).- `check.duplicates`: a logical indicating if duplicate coordinates should be detected; this can be an issue for some graphs; TRUE by default. ReturnsReturns a connection network having the class `nb` or `listw`. The xy coordinates are passed as attribute to the created object. DescriptionThe function `chooseCN` is a simple interface to build a connection network (CN) from xy coordinates. The user chooses from 6 types of graph and one additional weighting scheme. `chooseCN` calls functions from appropriate packages, handles non-unique coordinates and returns a connection network either with classe `nb` or `listw`. For graph types 1-4, duplicated locations are not accepted and will issue an error. DetailsThere are 7 kinds of graphs proposed:Delaunay triangulation (type 1)Gabriel graph (type 2)Relative neighbours (type 3)Minimum spanning tree (type 4)Neighbourhood by distance (type 5)K nearests neighbours (type 6)Inverse distances (type 7)The last option (type=7) is not a true neighbouring graph: all sites are neighbours, but the spatial weights are directly proportional to the inversed spatial distances.Also not that in this case, the output of the function is always a `listw` object, even if `nb` was requested.The choice of the connection network has been discuted on the adegenet forum. Please search the archives from adegenet website (section 'contact') using 'graph' as keyword. Examples```r Not run:data(nancycats)par(mfrow=c(2,2))cn1 <- chooseCN(nancycats@other$xy,ask=FALSE,type=1)cn2 <- chooseCN(nancycats@other$xy,ask=FALSE,type=2)cn3 <- chooseCN(nancycats@other$xy,ask=FALSE,type=3)cn4 <- chooseCN(nancycats@other$xy,ask=FALSE,type=4)par(mfrow=c(1,1)) End(Not run)``` See Also`spca` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",20
adegenet,export_to_mvmapper.md,"# Export analysis for mvmapper visualisation

```r
export_to_mvmapper(x, ...)

## Default S3 method:
export_to_mvmapper(x, ...)

## S3 method for class 'dapc'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)

## S3 method for class 'dudi'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)

## S3 method for class 'spca'
export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)
```

## Arguments

- `x`: The analysis to be exported. Can be a `dapc`, `spca`, or a `dudi` object.
- `...`: Further arguments to pass to other methods.
- `info`: A `data.frame` with additional information containing at least the following columns: `key` (unique individual identifier), `lat` (latitude), and `lon` (longitude). Other columns will be exported as well, but are optional.
- `write_file`: A `logical` indicating if the output should be written out to a .csv file. Defaults to `TRUE`.
- `out_file`: A character string indicating the file to which the output should be written. If NULL, the file used will be named `'mvmapper_data_[date and time].csv'`

## Returns

A `data.frame` which can serve as input to `mvmapper`, containing at least the following columns:

 * `key`: unique individual identifiers
 * `PC1`: first principal component; further principal components are optional, but if provided will be numbered and follow `PC1`.
 * `lat`: latitude for each individual
 * `lon`: longitude for each individual

In addition, specific information is added for some analyses:

 * `spca`: `Lag_PC` columns contain the lag-vectors of the principal components; the lag operator computes, for each individual, the average score of neighbouring individuals; it is useful for clarifying patches and clines.
 * `dapc`: `grp` is the group used in the analysis; `assigned_grp` is the group assignment based on the discriminant functions; `support` is the statistical support (i.e. assignment probability) for `assigned_grp`.

## Description

`mvmapper` is an interactive tool for visualising outputs of a multivariate analysis on a map from a web browser. The function `export_to_mvmapper` is a generic with methods for several standard classes of analyses in `adegenet` and `ade4`. Information on individual locations, as well as any other relevant data, is passed through the second argument `info`. By default, the function returns a formatted `data.frame` and writes the output to a .csv file.

## Details

`mvmapper` can be found at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/)

## Examples

```r
# An example using the microsatellite dataset of Dupuis et al. 2016 (781
# individuals, 10 loci, doi: 10.1111/jeb.12931)

# Reading input file from adegenet

input_data <- system.file(""data/swallowtails.rda"", package=""adegenet"")
data(swallowtails)


# conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)

dapc1 <- dapc(swallowtails, n.pca=40, n.da=200)


# read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon""
# columns with column headers (this example contains additional columns
# containing species identifications, locality descriptions, and COI
# haplotype clades)

input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")
loc <- read.csv(input_locs, header = TRUE)


# generate mvmapper input file, automatically write the output to a csv, and
# name the output csv ""mvMapper_Data.csv""
out_dir <- tempdir()
out_file <- file.path(out_dir, ""mvMapper_Data.csv"")

out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = out_file)
```

## See Also

`mvmapper` is available at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/)

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","[""Export analysis for mvmapper visualisation```rexport_to_mvmapper(x, ...) Default S3 method:export_to_mvmapper(x, ...) S3 method for class 'dapc'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...) S3 method for class 'dudi'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...) S3 method for class 'spca'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)``` Arguments- `x`: The analysis to be exported."", 'Can be a `dapc`, `spca`, or a `dudi` object.- `...`: Further arguments to pass to other methods.- `info`: A `data.frame` with additional information containing at least the following columns: `key` (unique individual identifier), `lat` (latitude), and `lon` (longitude).', 'Other columns will be exported as well, but are optional.- `write_file`: A `logical` indicating if the output should be written out to a .csv file.', 'Defaults to `TRUE`.- `out_file`: A character string indicating the file to which the output should be written.', ""If NULL, the file used will be named `'mvmapper_data_[date and time].csv'` ReturnsA `data.frame` which can serve as input to `mvmapper`, containing at least the following columns:  `key`: unique individual identifiers  `PC1`: first principal component; further principal components are optional, but if provided will be numbered and follow `PC1`."", '`lat`: latitude for each individual  `lon`: longitude for each individualIn addition, specific information is added for some analyses:  `spca`: `Lag_PC` columns contain the lag-vectors of the principal components; the lag operator computes, for each individual, the average score of neighbouring individuals; it is useful for clarifying patches and clines.', '`dapc`: `grp` is the group used in the analysis; `assigned_grp` is the group assignment based on the discriminant functions; `support` is the statistical support (i.e.', 'Description`mvmapper` is an interactive tool for visualising outputs of a multivariate analysis on a map from a web browser.', 'The function `export_to_mvmapper` is a generic with methods for several standard classes of analyses in `adegenet` and `ade4`.', 'Information on individual locations, as well as any other relevant data, is passed through the second argument `info`.', 'By default, the function returns a formatted `data.frame` and writes the output to a .csv file.', 'Details`mvmapper` can be found at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/) Examples```r An example using the microsatellite dataset of Dupuis et al.', '2016 (781 individuals, 10 loci, doi: 10.1111/jeb.12931) Reading input file from adegenetinput_data <- system.file(""data/swallowtails.rda"", package=""adegenet"")data(swallowtails) conducting a DAPC (n.pca determined using xvalDapc, see ?', '?xvalDapc)dapc1 <- dapc(swallowtails, n.pca=40, n.da=200) read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon"" columns with column headers (this example contains additional columns containing species identifications, locality descriptions, and COI haplotype clades)input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")loc <- read.csv(input_locs, header = TRUE) generate mvmapper input file, automatically write the output to a csv, and name the output csv ""mvMapper_Data.csv""out_dir <- tempdir()out_file <- file.path(out_dir, ""mvMapper_Data.csv"")out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = out_file)``` See Also`mvmapper` is available at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/) Author(s)Thibaut Jombart thibautjombart@gmail.com']",1," Export analysis for mvmapper visualisation```rexport_to_mvmapper(x, ...) Default S3 method:export_to_mvmapper(x, ...) S3 method for class 'dapc'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...) S3 method for class 'dudi'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...) S3 method for class 'spca'export_to_mvmapper(x, info, write_file = TRUE, out_file = NULL, ...)``` Arguments- `x`: The analysis to be exported. Can be a `dapc`, `spca`, or a `dudi` object.- `...`: Further arguments to pass to other methods.- `info`: A `data.frame` with additional information containing at least the following columns: `key` (unique individual identifier), `lat` (latitude), and `lon` (longitude). Other columns will be exported as well, but are optional.- `write_file`: A `logical` indicating if the output should be written out to a .csv file. Defaults to `TRUE`.- `out_file`: A character string indicating the file to which the output should be written. If NULL, the file used will be named `'mvmapper_data_[date and time].csv'` ReturnsA `data.frame` which can serve as input to `mvmapper`, containing at least the following columns:  `key`: unique individual identifiers  `PC1`: first principal component; further principal components are optional, but if provided will be numbered and follow `PC1`.  `lat`: latitude for each individual  `lon`: longitude for each individualIn addition, specific information is added for some analyses:  `spca`: `Lag_PC` columns contain the lag-vectors of the principal components; the lag operator computes, for each individual, the average score of neighbouring individuals; it is useful for clarifying patches and clines.  `dapc`: `grp` is the group used in the analysis; `assigned_grp` is the group assignment based on the discriminant functions; `support` is the statistical support (i.e. assignment probability) for `assigned_grp`. Description`mvmapper` is an interactive tool for visualising outputs of a multivariate analysis on a map from a web browser. The function `export_to_mvmapper` is a generic with methods for several standard classes of analyses in `adegenet` and `ade4`. Information on individual locations, as well as any other relevant data, is passed through the second argument `info`. By default, the function returns a formatted `data.frame` and writes the output to a .csv file. Details`mvmapper` can be found at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/) Examples```r An example using the microsatellite dataset of Dupuis et al. 2016 (781 individuals, 10 loci, doi: 10.1111/jeb.12931) Reading input file from adegenetinput_data <- system.file(""data/swallowtails.rda"", package=""adegenet"")data(swallowtails) conducting a DAPC (n.pca determined using xvalDapc, see ??xvalDapc)dapc1 <- dapc(swallowtails, n.pca=40, n.da=200) read in swallowtails_loc.csv, which contains ""key"", ""lat"", and ""lon"" columns with column headers (this example contains additional columns containing species identifications, locality descriptions, and COI haplotype clades)input_locs <- system.file(""files/swallowtails_loc.csv"", package = ""adegenet"")loc <- read.csv(input_locs, header = TRUE) generate mvmapper input file, automatically write the output to a csv, and name the output csv ""mvMapper_Data.csv""out_dir <- tempdir()out_file <- file.path(out_dir, ""mvMapper_Data.csv"")out <- export_to_mvmapper(dapc1, loc, write_file = TRUE, out_file = out_file)``` See Also`mvmapper` is available at: [https://popphylotools.github.io/mvMapper/](https://popphylotools.github.io/mvMapper/) Author(s)Thibaut Jombart thibautjombart@gmail.com",20
adegenet,glPlot.md,"UTF-8

# Plotting genlight objects

## Description

genlight object can be plotted using the function `glPlot`, which is also used as the dedicated `plot` method. These functions relie on `image` to represent SNPs data. More specifically, colors are used to represent the number of second allele for each locus and individual.

```r
glPlot(x, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...)

## S4 method for signature 'genlight'
plot(x, y=NULL, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...)
```

## Arguments

- `x`: a genlight object.
- `col`: an optional color vector; the first value corresponds to 0 alleles, the last value corresponds to the ploidy level of the data. Therefore, the vector should have a length of (`ploidy(x)+1`).
- `legend`: a logical indicating whether a legend should be added to the plot.
- `posi`: a character string indicating where the legend should be positioned. Can be any concatenation of ""bottom""/""top"" and ""left""/""right"".
- `bg`: a color used as a background for the legend; by default, transparent white is used; this may not be supported on some devices, and therefore background should be specified (e.g. `bg=""white""`).
- ``...``: further arguments to be passed to `image`.
- `y`: ununsed argument, present for compatibility with the `plot` generic.

## See Also

- `genlight`: class of object for storing massive binary SNP data.

- `glSim`: a simple simulator for genlight

objects.

- `glPca`: PCA for genlight objects.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## simulate data
x <- glSim(100, 1e3, n.snp.struc=100, ploid=2)

## default plot
glPlot(x)
plot(x) # identical plot

## disable legend
plot(x, leg=FALSE)

## use other colors
plot(x, col=heat.colors(3), bg=""white"")
## End(Not run)
```



","['UTF-8 Plotting genlight objects Descriptiongenlight object can be plotted using the function `glPlot`, which is also used as the dedicated `plot` method.', 'These functions relie on `image` to represent SNPs data.', 'More specifically, colors are used to represent the number of second allele for each locus and individual.```rglPlot(x, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...) S4 method for signature \'genlight\'plot(x, y=NULL, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...)``` Arguments- `x`: a genlight object.- `col`: an optional color vector; the first value corresponds to 0 alleles, the last value corresponds to the ploidy level of the data.', 'Therefore, the vector should have a length of (`ploidy(x)+1`).- `legend`: a logical indicating whether a legend should be added to the plot.- `posi`: a character string indicating where the legend should be positioned.', 'Can be any concatenation of ""bottom""/""top"" and ""left""/""right"".- `bg`: a color used as a background for the legend; by default, transparent white is used; this may not be supported on some devices, and therefore background should be specified (e.g.', '`bg=""white""`).- ``...``: further arguments to be passed to `image`.- `y`: ununsed argument, present for compatibility with the `plot` generic.', 'See Also- `genlight`: class of object for storing massive binary SNP data.- `glSim`: a simple simulator for genlightobjects.- `glPca`: PCA for genlight objects.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: simulate datax <- glSim(100, 1e3, n.snp.struc=100, ploid=2) default plotglPlot(x)plot(x)  identical plot disable legendplot(x, leg=FALSE) use other colorsplot(x, col=heat.colors(3), bg=""white"") End(Not run)```']",1,"UTF-8 Plotting genlight objects Descriptiongenlight object can be plotted using the function `glPlot`, which is also used as the dedicated `plot` method. These functions relie on `image` to represent SNPs data. More specifically, colors are used to represent the number of second allele for each locus and individual.```rglPlot(x, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...) S4 method for signature 'genlight'plot(x, y=NULL, col=NULL, legend=TRUE, posi=""bottomleft"", bg=rgb(1,1,1,.5),...)``` Arguments- `x`: a genlight object.- `col`: an optional color vector; the first value corresponds to 0 alleles, the last value corresponds to the ploidy level of the data. Therefore, the vector should have a length of (`ploidy(x)+1`).- `legend`: a logical indicating whether a legend should be added to the plot.- `posi`: a character string indicating where the legend should be positioned. Can be any concatenation of ""bottom""/""top"" and ""left""/""right"".- `bg`: a color used as a background for the legend; by default, transparent white is used; this may not be supported on some devices, and therefore background should be specified (e.g. `bg=""white""`).- ``...``: further arguments to be passed to `image`.- `y`: ununsed argument, present for compatibility with the `plot` generic. See Also- `genlight`: class of object for storing massive binary SNP data.- `glSim`: a simple simulator for genlightobjects.- `glPca`: PCA for genlight objects. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: simulate datax <- glSim(100, 1e3, n.snp.struc=100, ploid=2) default plotglPlot(x)plot(x)  identical plot disable legendplot(x, leg=FALSE) use other colorsplot(x, col=heat.colors(3), bg=""white"") End(Not run)```",20
adegenet,read.fstat.md,"# Reading data from Fstat

```r
read.fstat(file, quiet = FALSE)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the appropriate extension.
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).

## Returns

an object of the class `genind`

## Description

The function `read.fstat` reads Fstat data files (.dat) and convert them into a genind object.

## Details

Note: `read.fstat` is meant for DIPLOID DATA ONLY. Haploid data with the Hierfstat format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`.

## Examples

```r
obj <- read.fstat(system.file(""files/nancycats.dat"",package=""adegenet""))
obj
```

## References

Fstat (version 2.9.3). Software by Jerome Goudet. http://www2.unil.ch/popgen/softwares/fstat.htm

## See Also

`import2genind`, `df2genind`, `read.genetix`, `read.structure`, `read.genepop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading data from Fstat```rread.fstat(file, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).', 'Returnsan object of the class `genind` DescriptionThe function `read.fstat` reads Fstat data files (.dat) and convert them into a genind object.', 'DetailsNote: `read.fstat` is meant for DIPLOID DATA ONLY.', ""Haploid data with the Hierfstat format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`."", 'Examples```robj <- read.fstat(system.file(""files/nancycats.dat"",package=""adegenet""))obj``` ReferencesFstat (version 2.9.3).', 'http://www2.unil.ch/popgen/softwares/fstat.htm See Also`import2genind`, `df2genind`, `read.genetix`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Reading data from Fstat```rread.fstat(file, quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE). Returnsan object of the class `genind` DescriptionThe function `read.fstat` reads Fstat data files (.dat) and convert them into a genind object. DetailsNote: `read.fstat` is meant for DIPLOID DATA ONLY. Haploid data with the Hierfstat format can be read into R using `read.table` or `read.csv` after removing headers and 'POP' lines, and then converted using `df2genind`. Examples```robj <- read.fstat(system.file(""files/nancycats.dat"",package=""adegenet""))obj``` ReferencesFstat (version 2.9.3). Software by Jerome Goudet. http://www2.unil.ch/popgen/softwares/fstat.htm See Also`import2genind`, `df2genind`, `read.genetix`, `read.structure`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",20
adegenet,glPca.md,"UTF-8

# Principal Component Analysis for genlight objects

## Description

These functions implement Principal Component Analysis (PCA) for massive SNP datasets stored as genlight object. This implementation has the advantage of never representing to complete data matrix, therefore making huge economies in terms of rapid access memory (RAM). When the `parallel` package is available, `glPca` uses multiple-core ressources for more efficient computations. `glPca` returns lists with the class `glPca` (see 'value').

Other functions are defined for objects of this class:

- `print`: prints the content of a `glPca` object.

- `scatter`: produces scatterplots of principal components, with a screeplot of eigenvalues as inset.

- `loadingplot`: plots the loadings of the analysis for one given axis, using an adapted version of the generic function `loadingplot`.

```r
glPca(x, center = TRUE, scale = FALSE, nf = NULL, loadings = TRUE, 
    alleleAsUnit = FALSE, useC = TRUE, parallel = FALSE,
  n.cores = NULL, returnDotProd=FALSE, matDotProd=NULL)

## S3 method for class 'glPca'
print(x, ...)

## S3 method for class 'glPca'
scatter(x, xax = 1, yax = 2, posi = ""bottomleft"", bg = ""white"", 
    ratio = 0.3, label = rownames(x$scores), clabel = 1, xlim = NULL, 
    ylim = NULL, grid = TRUE, addaxes = TRUE, origin = c(0, 0), 
    include.origin = TRUE, sub = """", csub = 1, possub = ""bottomleft"", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, ...)

## S3 method for class 'glPca'
loadingplot(x, at=NULL, threshold=NULL, axis=1,
    fac=NULL, byfac=FALSE, lab=rownames(x$loadings), cex.lab=0.7, cex.fac=1,
    lab.jitter=0, main=""Loading plot"", xlab=""SNP positions"",
    ylab=""Contributions"", srt = 90, adj = c(0, 0.5), ...)
```

## Arguments

- `x`: for `glPca`, a genlight object; for `print`, `scatter`, and `loadingplot`, a `glPca` object.
- `center`: a logical indicating whether the numbers of alleles should be centered; defaults to TRUE
- `scale`: a logical indicating whether the numbers of alleles should be scaled; defaults to FALSE
- `nf`: an integer indicating the number of principal components to be retained; if NULL, a screeplot of eigenvalues will be displayed and the user will be asked for a number of retained axes.
- `loadings`: a logical indicating whether loadings of the alleles should be computed (TRUE, default), or not (FALSE). Vectors of loadings are not always useful, and can take a large amount of RAM when millions of SNPs are considered.
- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.) or whether individuals are considered as units of information.
- `useC`: a logical indicating whether compiled C code should be used for faster computations; this option cannot be used alongside parallel option.
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE), or not (FALSE, default); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.
- `returnDotProd`: a logical indicating whether the matrix of dot products between individuals should be returned (TRUE) or not (FALSE, default).
- `matDotProd`: an optional matrix of dot products between individuals, NULL by default. This option is used internally to speed up computation time when re-running the same PCA several times. Leave this argument as NULL unless you really know what you are doing.
- ``...``: further arguments to be passed to other functions.
- `xax,yax`: `integers` specifying which principal components should be shown in x and y axes.
- `posi,bg,ratio`: arguments used to customize the inset in scatterplots of `glPca` results. See `add.scatter` documentation in the ade4 package for more details.
- `label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.label` for more information
- `at`: an optional numeric vector giving the abscissa at which loadings are plotted. Useful when variates are SNPs with a known position in an alignement.
- `threshold`: a threshold value above which values of x are identified. By default, this is the third quartile of x.
- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.
- `fac`: a factor defining groups of SNPs.
- `byfac`: a logical stating whether loadings should be averaged by groups of SNPs, as defined by `fac`.
- `lab`: a character vector giving the labels used to annotate values above the threshold.
- `cex.lab`: a numeric value indicating the size of annotations.
- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.
- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations. Set to 0 (by default) implies no randomisation.
- `main`: the main title of the figure.
- `xlab`: the title of the x axis.
- `ylab`: the title of the y axis.
- `srt`: rotation of the labels; see ?text.
- `adj`: adjustment of the labels; see ?text.

## Details

=== Using multiple cores ===

Most recent machines have one or several processors with multiple cores. R processes usually use one single core. The package `parallel` allows for parallelizing some computations on multiple cores, which can decrease drastically computational time.

Lastly, note that using compiled C code (`useC=TRUE`)is an alternative for speeding up computations, but cannot be used together with the parallel option.

## Returns

=== glPca objects ===

The class `glPca` is a list with the following components:

 - **call**: the matched call.

 - **eig**: a numeric vector of eigenvalues.

 - **scores**: a matrix of principal components, containing the coordinates of each individual (in row) on each principal axis (in column).

 - **loadings**: (optional) a matrix of loadings, containing the loadings of each SNP (in row) for each principal axis (in column).

-

=== other outputs ===

Other functions have different outputs:

- `scatter` return the matched call.

- `loadingplot` returns information about the most contributing SNPs (see `loadingplot.default`)

## See Also

- `genlight`: class of object for storing massive binary SNP data.

- `glSim`: a simple simulator for genlight objects.

- `glPlot`: plotting genlight objects.

- `dapc`: Discriminant Analysis of Principal Components.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## simulate a toy dataset
x <- glSim(50,4e3, 50, ploidy=2)
x
plot(x)

## perform PCA
pca1 <- glPca(x, nf=2)

## plot eigenvalues
barplot(pca1$eig, main=""eigenvalues"", col=heat.colors(length(pca1$eig)))

## basic plot
scatter(pca1, ratio=.2)

## plot showing groups
s.class(pca1$scores, pop(x), col=colors()[c(131,134)])
add.scatter.eig(pca1$eig,2,1,2)
## End(Not run)
```



","['UTF-8 Principal Component Analysis for genlight objects DescriptionThese functions implement Principal Component Analysis (PCA) for massive SNP datasets stored as genlight object.', 'This implementation has the advantage of never representing to complete data matrix, therefore making huge economies in terms of rapid access memory (RAM).', 'When the `parallel` package is available, `glPca` uses multiple-core ressources for more efficient computations.', '`glPca` returns lists with the class `glPca` (see \'value\').Other functions are defined for objects of this class:- `print`: prints the content of a `glPca` object.- `scatter`: produces scatterplots of principal components, with a screeplot of eigenvalues as inset.- `loadingplot`: plots the loadings of the analysis for one given axis, using an adapted version of the generic function `loadingplot`.```rglPca(x, center = TRUE, scale = FALSE, nf = NULL, loadings = TRUE,     alleleAsUnit = FALSE, useC = TRUE, parallel = FALSE,  n.cores = NULL, returnDotProd=FALSE, matDotProd=NULL) S3 method for class \'glPca\'print(x, ...) S3 method for class \'glPca\'scatter(x, xax = 1, yax = 2, posi = ""bottomleft"", bg = ""white"",     ratio = 0.3, label = rownames(x$scores), clabel = 1, xlim = NULL,     ylim = NULL, grid = TRUE, addaxes = TRUE, origin = c(0, 0),     include.origin = TRUE, sub = """", csub = 1, possub = ""bottomleft"",     cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, ...) S3 method for class \'glPca\'loadingplot(x, at=NULL, threshold=NULL, axis=1,    fac=NULL, byfac=FALSE, lab=rownames(x$loadings), cex.lab=0.7, cex.fac=1,    lab.jitter=0, main=""Loading plot"", xlab=""SNP positions"",    ylab=""Contributions"", srt = 90, adj = c(0, 0.5), ...)``` Arguments- `x`: for `glPca`, a genlight object; for `print`, `scatter`, and `loadingplot`, a `glPca` object.- `center`: a logical indicating whether the numbers of alleles should be centered; defaults to TRUE- `scale`: a logical indicating whether the numbers of alleles should be scaled; defaults to FALSE- `nf`: an integer indicating the number of principal components to be retained; if NULL, a screeplot of eigenvalues will be displayed and the user will be asked for a number of retained axes.- `loadings`: a logical indicating whether loadings of the alleles should be computed (TRUE, default), or not (FALSE).', 'Vectors of loadings are not always useful, and can take a large amount of RAM when millions of SNPs are considered.- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.)', 'or whether individuals are considered as units of information.- `useC`: a logical indicating whether compiled C code should be used for faster computations; this option cannot be used alongside parallel option.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE), or not (FALSE, default); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- `returnDotProd`: a logical indicating whether the matrix of dot products between individuals should be returned (TRUE) or not (FALSE, default).- `matDotProd`: an optional matrix of dot products between individuals, NULL by default.', 'This option is used internally to speed up computation time when re-running the same PCA several times.', 'Leave this argument as NULL unless you really know what you are doing.- ``...``: further arguments to be passed to other functions.- `xax,yax`: `integers` specifying which principal components should be shown in x and y axes.- `posi,bg,ratio`: arguments used to customize the inset in scatterplots of `glPca` results.', 'See `add.scatter` documentation in the ade4 package for more details.- `label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.label` for more information- `at`: an optional numeric vector giving the abscissa at which loadings are plotted.', 'Useful when variates are SNPs with a known position in an alignement.- `threshold`: a threshold value above which values of x are identified.', 'By default, this is the third quartile of x.- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.- `fac`: a factor defining groups of SNPs.- `byfac`: a logical stating whether loadings should be averaged by groups of SNPs, as defined by `fac`.- `lab`: a character vector giving the labels used to annotate values above the threshold.- `cex.lab`: a numeric value indicating the size of annotations.- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations.', 'Set to 0 (by default) implies no randomisation.- `main`: the main title of the figure.- `xlab`: the title of the x axis.- `ylab`: the title of the y axis.- `srt`: rotation of the labels; see ?text.- `adj`: adjustment of the labels; see ?text.', 'Details=== Using multiple cores ===Most recent machines have one or several processors with multiple cores.', 'R processes usually use one single core.', 'The package `parallel` allows for parallelizing some computations on multiple cores, which can decrease drastically computational time.Lastly, note that using compiled C code (`useC=TRUE`)is an alternative for speeding up computations, but cannot be used together with the parallel option.', 'Returns=== glPca objects ===The class `glPca` is a list with the following components: - call: the matched call.', '- eig: a numeric vector of eigenvalues.', '- scores: a matrix of principal components, containing the coordinates of each individual (in row) on each principal axis (in column).', '- loadings: (optional) a matrix of loadings, containing the loadings of each SNP (in row) for each principal axis (in column).-=== other outputs ===Other functions have different outputs:- `scatter` return the matched call.- `loadingplot` returns information about the most contributing SNPs (see `loadingplot.default`) See Also- `genlight`: class of object for storing massive binary SNP data.- `glSim`: a simple simulator for genlight objects.- `glPlot`: plotting genlight objects.- `dapc`: Discriminant Analysis of Principal Components.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: simulate a toy datasetx <- glSim(50,4e3, 50, ploidy=2)xplot(x) perform PCApca1 <- glPca(x, nf=2) plot eigenvaluesbarplot(pca1$eig, main=""eigenvalues"", col=heat.colors(length(pca1$eig))) basic plotscatter(pca1, ratio=.2) plot showing groupss.class(pca1$scores, pop(x), col=colors()[c(131,134)])add.scatter.eig(pca1$eig,2,1,2) End(Not run)```']",1,"UTF-8 Principal Component Analysis for genlight objects DescriptionThese functions implement Principal Component Analysis (PCA) for massive SNP datasets stored as genlight object. This implementation has the advantage of never representing to complete data matrix, therefore making huge economies in terms of rapid access memory (RAM). When the `parallel` package is available, `glPca` uses multiple-core ressources for more efficient computations. `glPca` returns lists with the class `glPca` (see 'value').Other functions are defined for objects of this class:- `print`: prints the content of a `glPca` object.- `scatter`: produces scatterplots of principal components, with a screeplot of eigenvalues as inset.- `loadingplot`: plots the loadings of the analysis for one given axis, using an adapted version of the generic function `loadingplot`.```rglPca(x, center = TRUE, scale = FALSE, nf = NULL, loadings = TRUE,     alleleAsUnit = FALSE, useC = TRUE, parallel = FALSE,  n.cores = NULL, returnDotProd=FALSE, matDotProd=NULL) S3 method for class 'glPca'print(x, ...) S3 method for class 'glPca'scatter(x, xax = 1, yax = 2, posi = ""bottomleft"", bg = ""white"",     ratio = 0.3, label = rownames(x$scores), clabel = 1, xlim = NULL,     ylim = NULL, grid = TRUE, addaxes = TRUE, origin = c(0, 0),     include.origin = TRUE, sub = """", csub = 1, possub = ""bottomleft"",     cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, ...) S3 method for class 'glPca'loadingplot(x, at=NULL, threshold=NULL, axis=1,    fac=NULL, byfac=FALSE, lab=rownames(x$loadings), cex.lab=0.7, cex.fac=1,    lab.jitter=0, main=""Loading plot"", xlab=""SNP positions"",    ylab=""Contributions"", srt = 90, adj = c(0, 0.5), ...)``` Arguments- `x`: for `glPca`, a genlight object; for `print`, `scatter`, and `loadingplot`, a `glPca` object.- `center`: a logical indicating whether the numbers of alleles should be centered; defaults to TRUE- `scale`: a logical indicating whether the numbers of alleles should be scaled; defaults to FALSE- `nf`: an integer indicating the number of principal components to be retained; if NULL, a screeplot of eigenvalues will be displayed and the user will be asked for a number of retained axes.- `loadings`: a logical indicating whether loadings of the alleles should be computed (TRUE, default), or not (FALSE). Vectors of loadings are not always useful, and can take a large amount of RAM when millions of SNPs are considered.- `alleleAsUnit`: a logical indicating whether alleles are considered as units (i.e., a diploid genotype equals two samples, a triploid, three, etc.) or whether individuals are considered as units of information.- `useC`: a logical indicating whether compiled C code should be used for faster computations; this option cannot be used alongside parallel option.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE), or not (FALSE, default); requires the package `parallel` to be installed (see details); this option cannot be used alongside useCoption.- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- `returnDotProd`: a logical indicating whether the matrix of dot products between individuals should be returned (TRUE) or not (FALSE, default).- `matDotProd`: an optional matrix of dot products between individuals, NULL by default. This option is used internally to speed up computation time when re-running the same PCA several times. Leave this argument as NULL unless you really know what you are doing.- ``...``: further arguments to be passed to other functions.- `xax,yax`: `integers` specifying which principal components should be shown in x and y axes.- `posi,bg,ratio`: arguments used to customize the inset in scatterplots of `glPca` results. See `add.scatter` documentation in the ade4 package for more details.- `label,clabel,xlim,ylim,grid,addaxes,origin,include.origin,sub,csub,possub,cgrid,pixmap,contour,area`: arguments passed to `s.class`; see `?s.label` for more information- `at`: an optional numeric vector giving the abscissa at which loadings are plotted. Useful when variates are SNPs with a known position in an alignement.- `threshold`: a threshold value above which values of x are identified. By default, this is the third quartile of x.- `axis`: an integer indicating the column of x to be plotted; used only if x is a matrix-like object.- `fac`: a factor defining groups of SNPs.- `byfac`: a logical stating whether loadings should be averaged by groups of SNPs, as defined by `fac`.- `lab`: a character vector giving the labels used to annotate values above the threshold.- `cex.lab`: a numeric value indicating the size of annotations.- `cex.fac`: a numeric value indicating the size of annotations for groups of observations.- `lab.jitter`: a numeric value indicating the factor of randomisation for the position of annotations. Set to 0 (by default) implies no randomisation.- `main`: the main title of the figure.- `xlab`: the title of the x axis.- `ylab`: the title of the y axis.- `srt`: rotation of the labels; see ?text.- `adj`: adjustment of the labels; see ?text. Details=== Using multiple cores ===Most recent machines have one or several processors with multiple cores. R processes usually use one single core. The package `parallel` allows for parallelizing some computations on multiple cores, which can decrease drastically computational time.Lastly, note that using compiled C code (`useC=TRUE`)is an alternative for speeding up computations, but cannot be used together with the parallel option. Returns=== glPca objects ===The class `glPca` is a list with the following components: - call: the matched call. - eig: a numeric vector of eigenvalues. - scores: a matrix of principal components, containing the coordinates of each individual (in row) on each principal axis (in column). - loadings: (optional) a matrix of loadings, containing the loadings of each SNP (in row) for each principal axis (in column).-=== other outputs ===Other functions have different outputs:- `scatter` return the matched call.- `loadingplot` returns information about the most contributing SNPs (see `loadingplot.default`) See Also- `genlight`: class of object for storing massive binary SNP data.- `glSim`: a simple simulator for genlight objects.- `glPlot`: plotting genlight objects.- `dapc`: Discriminant Analysis of Principal Components. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: simulate a toy datasetx <- glSim(50,4e3, 50, ploidy=2)xplot(x) perform PCApca1 <- glPca(x, nf=2) plot eigenvaluesbarplot(pca1$eig, main=""eigenvalues"", col=heat.colors(length(pca1$eig))) basic plotscatter(pca1, ratio=.2) plot showing groupss.class(pca1$scores, pop(x), col=colors()[c(131,134)])add.scatter.eig(pca1$eig,2,1,2) End(Not run)```",20
adegenet,repool.md,"# Pool several genotypes into a single dataset

```r
repool(..., list = FALSE)
```

## Arguments

- `...`: a list of genind objects, or a series of genind objects separated by commas
- `list`: a logical indicating whether a list of objects with matched alleles shall be returned (TRUE), or a single genind object (FALSE, default).

## Description

The function `repool` allows to merge genotypes from different genind objects into a single 'pool' (i.e. a new genind ). The markers have to be the same for all objects to be merged, but there is no constraint on alleles.

## Details

This function can be useful, for instance, when hybrids are created using `hybridize`, to merge hybrids with their parent population for further analyses. Note that `repool` can also reverse the action of `seppop`.

## Examples

```r
## Not run:

## use the cattle breeds dataset
data(microbov)
temp <- seppop(microbov)
names(temp)
## hybridize salers and zebu -- nasty cattle
zebler <- hybridize(temp$Salers, temp$Zebu, n=40)
zebler
## now merge zebler with other cattle breeds
nastyCattle <- repool(microbov, zebler)
nastyCattle
## End(Not run)
```

## See Also

`seploc`, `seppop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Pool several genotypes into a single dataset```rrepool(..., list = FALSE)``` Arguments- `...`: a list of genind objects, or a series of genind objects separated by commas- `list`: a logical indicating whether a list of objects with matched alleles shall be returned (TRUE), or a single genind object (FALSE, default).', ""DescriptionThe function `repool` allows to merge genotypes from different genind objects into a single 'pool' (i.e."", 'The markers have to be the same for all objects to be merged, but there is no constraint on alleles.', 'DetailsThis function can be useful, for instance, when hybrids are created using `hybridize`, to merge hybrids with their parent population for further analyses.', 'Note that `repool` can also reverse the action of `seppop`.', 'Examples```r Not run: use the cattle breeds datasetdata(microbov)temp <- seppop(microbov)names(temp) hybridize salers and zebu -- nasty cattlezebler <- hybridize(temp$Salers, temp$Zebu, n=40)zebler now merge zebler with other cattle breedsnastyCattle <- repool(microbov, zebler)nastyCattle End(Not run)``` See Also`seploc`, `seppop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Pool several genotypes into a single dataset```rrepool(..., list = FALSE)``` Arguments- `...`: a list of genind objects, or a series of genind objects separated by commas- `list`: a logical indicating whether a list of objects with matched alleles shall be returned (TRUE), or a single genind object (FALSE, default). DescriptionThe function `repool` allows to merge genotypes from different genind objects into a single 'pool' (i.e. a new genind ). The markers have to be the same for all objects to be merged, but there is no constraint on alleles. DetailsThis function can be useful, for instance, when hybrids are created using `hybridize`, to merge hybrids with their parent population for further analyses. Note that `repool` can also reverse the action of `seppop`. Examples```r Not run: use the cattle breeds datasetdata(microbov)temp <- seppop(microbov)names(temp) hybridize salers and zebu -- nasty cattlezebler <- hybridize(temp$Salers, temp$Zebu, n=40)zebler now merge zebler with other cattle breedsnastyCattle <- repool(microbov, zebler)nastyCattle End(Not run)``` See Also`seploc`, `seppop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",20
adegenet,nancycats.md," data

# Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France)

## Format

`nancycats` is a genind object with spatial coordinates of the colonies as a supplementary components (@xy).

## Source

Dominique Pontier (UMR CNRS 5558, University Lyon1, France)

## Description

This data set gives the genotypes of 237 cats (**Felis catus** L.) for 9 microsatellites markers. The individuals are divided into 17 colonies whose spatial coordinates are also provided.

## Examples

```r
## Not run:

data(nancycats)
nancycats

# summary's results are stored in x
x <- summary(nancycats)

# some useful graphics
barplot(x$loc.n.all,ylab=""Alleles numbers"",main=""Alleles numbers
per locus"")

plot(x$pop.eff,x$pop.nall,type=""n"",xlab=""Sample size"",ylab=""Number of alleles"")
text(x$pop.eff,y=x$pop.nall,lab=names(x$pop.nall))

par(las=3)
barplot(table(nancycats@pop),ylab=""Number of genotypes"",main=""Number of genotypes per colony"")

# are cats structured among colonies ?
if(require(hierfstat)){

gtest <- gstat.randtest(nancycats,nsim=99)
gtest
plot(gtest)


dat <- genind2hierfstat(nancycats)

Fstat <- varcomp.glob(dat$pop,dat[,-1])
Fstat
}
## End(Not run)
```

## References

Devillard, S.; Jombart, T. & Pontier, D. Disentangling spatial and genetic structure of stray cat (**Felis catus** L.) colonies in urban habitat using: not all colonies are equal. submitted to **Molecular Ecology**



","['data Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France) Format`nancycats` is a genind object with spatial coordinates of the colonies as a supplementary components (@xy).', 'SourceDominique Pontier (UMR CNRS 5558, University Lyon1, France) DescriptionThis data set gives the genotypes of 237 cats (Felis catus L.) for 9 microsatellites markers.', 'The individuals are divided into 17 colonies whose spatial coordinates are also provided.', 'Examples```r Not run:data(nancycats)nancycats summary\'s results are stored in xx <- summary(nancycats) some useful graphicsbarplot(x$loc.n.all,ylab=""Alleles numbers"",main=""Alleles numbersper locus"")plot(x$pop.eff,x$pop.nall,type=""n"",xlab=""Sample size"",ylab=""Number of alleles"")text(x$pop.eff,y=x$pop.nall,lab=names(x$pop.nall))par(las=3)barplot(table(nancycats@pop),ylab=""Number of genotypes"",main=""Number of genotypes per colony"") are cats structured among colonies ?if(require(hierfstat)){gtest <- gstat.randtest(nancycats,nsim=99)gtestplot(gtest)dat <- genind2hierfstat(nancycats)Fstat <- varcomp.glob(dat$pop,dat[,-1])Fstat} End(Not run)``` ReferencesDevillard, S.; Jombart, T. & Pontier, D. Disentangling spatial and genetic structure of stray cat (Felis catus L.) colonies in urban habitat using: not all colonies are equal.']",1," data Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France) Format`nancycats` is a genind object with spatial coordinates of the colonies as a supplementary components (@xy). SourceDominique Pontier (UMR CNRS 5558, University Lyon1, France) DescriptionThis data set gives the genotypes of 237 cats (Felis catus L.) for 9 microsatellites markers. The individuals are divided into 17 colonies whose spatial coordinates are also provided. Examples```r Not run:data(nancycats)nancycats summary's results are stored in xx <- summary(nancycats) some useful graphicsbarplot(x$loc.n.all,ylab=""Alleles numbers"",main=""Alleles numbersper locus"")plot(x$pop.eff,x$pop.nall,type=""n"",xlab=""Sample size"",ylab=""Number of alleles"")text(x$pop.eff,y=x$pop.nall,lab=names(x$pop.nall))par(las=3)barplot(table(nancycats@pop),ylab=""Number of genotypes"",main=""Number of genotypes per colony"") are cats structured among colonies ?if(require(hierfstat)){gtest <- gstat.randtest(nancycats,nsim=99)gtestplot(gtest)dat <- genind2hierfstat(nancycats)Fstat <- varcomp.glob(dat$pop,dat[,-1])Fstat} End(Not run)``` ReferencesDevillard, S.; Jombart, T. & Pontier, D. Disentangling spatial and genetic structure of stray cat (Felis catus L.) colonies in urban habitat using: not all colonies are equal. submitted to Molecular Ecology",21
adegenet,propShared.md,"UTF-8

# Compute proportion of shared alleles

## Description

The function `propShared` computes the proportion of shared alleles in a set of genotypes (i.e. from a genind

object). Current implementation works for any level of ploidy.

```r
propShared(obj)
```

## Arguments

- `obj`: a genind object.

 

## Details

Computations of the numbers of shared alleles are done in C. Proportions are computed from all available data, i.e. proportion can be computed as far as there is at least one typed locus in common between two genotypes.

## Returns

Returns a matrix of proportions

## See Also

`dist.genpop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## make a small object
data(microbov)
obj <- microbov[1:5, loc = locNames(microbov)[1:2]]

## verify results
propShared(obj)
genind2df(obj,sep=""|"")

## Use this similarity measure inside a PCoA
##  ! This is for illustration only !
## the distance should be rendered Euclidean before
## (e.g. using cailliez from package ade4).
matSimil <- propShared(microbov)
matDist <- exp(-matSimil)
D <- cailliez(as.dist(matDist))
pcoa1 <- dudi.pco(D,scannf=FALSE,nf=3)
s.class(pcoa1$li,microbov$pop,lab=popNames(microbov))
## End(Not run)
```



","['UTF-8 Compute proportion of shared alleles DescriptionThe function `propShared` computes the proportion of shared alleles in a set of genotypes (i.e.', 'Current implementation works for any level of ploidy.```rpropShared(obj)``` Arguments- `obj`: a genind object.', 'DetailsComputations of the numbers of shared alleles are done in C. Proportions are computed from all available data, i.e.', 'proportion can be computed as far as there is at least one typed locus in common between two genotypes.', 'ReturnsReturns a matrix of proportions See Also`dist.genpop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: make a small objectdata(microbov)obj <- microbov[1:5, loc = locNames(microbov)[1:2]] verify resultspropShared(obj)genind2df(obj,sep=""|"") Use this similarity measure inside a PCoA  !', 'This is for illustration only !', 'the distance should be rendered Euclidean before (e.g.', 'using cailliez from package ade4).matSimil <- propShared(microbov)matDist <- exp(-matSimil)D <- cailliez(as.dist(matDist))pcoa1 <- dudi.pco(D,scannf=FALSE,nf=3)s.class(pcoa1$li,microbov$pop,lab=popNames(microbov)) End(Not run)```']",1,"UTF-8 Compute proportion of shared alleles DescriptionThe function `propShared` computes the proportion of shared alleles in a set of genotypes (i.e. from a genindobject). Current implementation works for any level of ploidy.```rpropShared(obj)``` Arguments- `obj`: a genind object.  DetailsComputations of the numbers of shared alleles are done in C. Proportions are computed from all available data, i.e. proportion can be computed as far as there is at least one typed locus in common between two genotypes. ReturnsReturns a matrix of proportions See Also`dist.genpop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: make a small objectdata(microbov)obj <- microbov[1:5, loc = locNames(microbov)[1:2]] verify resultspropShared(obj)genind2df(obj,sep=""|"") Use this similarity measure inside a PCoA  ! This is for illustration only ! the distance should be rendered Euclidean before (e.g. using cailliez from package ade4).matSimil <- propShared(microbov)matDist <- exp(-matSimil)D <- cailliez(as.dist(matDist))pcoa1 <- dudi.pco(D,scannf=FALSE,nf=3)s.class(pcoa1$li,microbov$pop,lab=popNames(microbov)) End(Not run)```",21
adegenet,Hs.test.md,"# Test differences in expected heterozygosity (Hs)

```r
Hs.test(x, y, n.sim = 999, alter = c(""two-sided"", ""greater"", ""less""))
```

## Arguments

- `x`: a genind object.
- `y`: a genind object.
- `n.sim`: the number of permutations to be used to generate the reference distribution.
- `alter`: a character string indicating the alternative hypothesis

## Returns

an object of the class randtest

## Description

This procedure permits to test if two groups have significant differences in expected heterozygosity (Hs). The test statistic used is simply the difference in Hs between the two groups 'x' and 'y':

## Details

`Hs(x) - Hs(y)`

Individuals are randomly permuted between groups to obtain a reference distribution of the test statistics.

## Examples

```r
## Not run:

data(microbov)
Hs(microbov)
test <- Hs.test(microbov[pop=""Borgou""],
                microbov[pop=""Lagunaire""],
                n.sim=499)
test
plot(test)
## End(Not run)
```

## See Also

`Hs` to compute Hs for different populations; `as.randtest` for the class of Monte Carlo tests.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Test differences in expected heterozygosity (Hs)```rHs.test(x, y, n.sim = 999, alter = c(""two-sided"", ""greater"", ""less""))``` Arguments- `x`: a genind object.- `y`: a genind object.- `n.sim`: the number of permutations to be used to generate the reference distribution.- `alter`: a character string indicating the alternative hypothesis Returnsan object of the class randtest DescriptionThis procedure permits to test if two groups have significant differences in expected heterozygosity (Hs).', ""The test statistic used is simply the difference in Hs between the two groups 'x' and 'y': Details`Hs(x) - Hs(y)`Individuals are randomly permuted between groups to obtain a reference distribution of the test statistics."", 'Examples```r Not run:data(microbov)Hs(microbov)test <- Hs.test(microbov[pop=""Borgou""],                microbov[pop=""Lagunaire""],                n.sim=499)testplot(test) End(Not run)``` See Also`Hs` to compute Hs for different populations; `as.randtest` for the class of Monte Carlo tests.']",1," Test differences in expected heterozygosity (Hs)```rHs.test(x, y, n.sim = 999, alter = c(""two-sided"", ""greater"", ""less""))``` Arguments- `x`: a genind object.- `y`: a genind object.- `n.sim`: the number of permutations to be used to generate the reference distribution.- `alter`: a character string indicating the alternative hypothesis Returnsan object of the class randtest DescriptionThis procedure permits to test if two groups have significant differences in expected heterozygosity (Hs). The test statistic used is simply the difference in Hs between the two groups 'x' and 'y': Details`Hs(x) - Hs(y)`Individuals are randomly permuted between groups to obtain a reference distribution of the test statistics. Examples```r Not run:data(microbov)Hs(microbov)test <- Hs.test(microbov[pop=""Borgou""],                microbov[pop=""Lagunaire""],                n.sim=499)testplot(test) End(Not run)``` See Also`Hs` to compute Hs for different populations; `as.randtest` for the class of Monte Carlo tests. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",21
adegenet,genpop.md,"UTF-8

# adegenet formal class (S4) for allele counts in populations

## Description

An object of class `genpop` contain alleles counts for several loci.

It contains several components (see 'slots' section).

Such object is obtained using `genind2genpop` which converts individuals genotypes of known population into a `genpop` object. Note that the function `summary` of a `genpop` object returns a list of components. Note that as in other S4 classes, slots are accessed using @ instead of $.

## Slots

- **`tab`:**: matrix of alleles counts for each combinaison of population (in rows) and alleles (in columns).
- **`loc.fac`:**: locus factor for the columns of `tab`
- **`loc.n.all`:**: integer vector giving the number of alleles per locus
- **`all.names`:**: list having one component per locus, each containing a character vector of alleles names
- **`call`:**: the matched call
- **`ploidy`:**: an integer indicating the degree of ploidy of the genotypes. Beware: 2 is not an integer, but as.integer(2) is.
- **`type`:**: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).
- **`other`:**: (optional) a list containing other information

## Extends

Class `""gen""`, directly. Class `""popInfo""`, directly.

## Methods

- **names**: `signature(x = ""genpop"")`: give the names of the components of a genpop object
- **print**: `signature(x = ""genpop"")`: prints a genpop object
- **show**: `signature(object = ""genpop"")`: shows a genpop object (same as print)
- **summary**: `signature(object = ""genpop"")`: summarizes a genpop object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE`

## See Also

`as.genpop`, `is.genpop`,`makefreq`, `genind`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
obj1 <- import2genind(system.file(""files/nancycats.gen"",
package=""adegenet""))
obj1


obj2 <- genind2genpop(obj1)
obj2

## Not run:

data(microsatt)
# use as.genpop to convert convenient count tab to genpop
obj3 <- as.genpop(microsatt$tab)
obj3

all(obj3@tab==microsatt$tab)

# perform a correspondance analysis
obj4 <- genind2genpop(obj1,missing=""chi2"")
ca1 <- dudi.coa(as.data.frame(obj4@tab),scannf=FALSE)
s.label(ca1$li,sub=""Correspondance Analysis"",csub=2)
add.scatter.eig(ca1$eig,2,xax=1,yax=2,posi=""top"")
## End(Not run)
```



","[""UTF-8 adegenet formal class (S4) for allele counts in populations DescriptionAn object of class `genpop` contain alleles counts for several loci.It contains several components (see 'slots' section).Such object is obtained using `genind2genpop` which converts individuals genotypes of known population into a `genpop` object."", 'Note that the function `summary` of a `genpop` object returns a list of components.', 'Note that as in other S4 classes, slots are accessed using @ instead of $.', 'Slots- `tab`:: matrix of alleles counts for each combinaison of population (in rows) and alleles (in columns).- `loc.fac`:: locus factor for the columns of `tab`- `loc.n.all`:: integer vector giving the number of alleles per locus- `all.names`:: list having one component per locus, each containing a character vector of alleles names- `call`:: the matched call- `ploidy`:: an integer indicating the degree of ploidy of the genotypes.', ""Beware: 2 is not an integer, but as.integer(2) is.- `type`:: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g."", ""microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g."", 'AFLP).- `other`:: (optional) a list containing other information ExtendsClass `""gen""`, directly.', 'Methods- names: `signature(x = ""genpop"")`: give the names of the components of a genpop object- print: `signature(x = ""genpop"")`: prints a genpop object- show: `signature(object = ""genpop"")`: shows a genpop object (same as print)- summary: `signature(object = ""genpop"")`: summarizes a genpop object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE` See Also`as.genpop`, `is.genpop`,`makefreq`, `genind`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```robj1 <- import2genind(system.file(""files/nancycats.gen"",package=""adegenet""))obj1obj2 <- genind2genpop(obj1)obj2 Not run:data(microsatt) use as.genpop to convert convenient count tab to genpopobj3 <- as.genpop(microsatt$tab)obj3all(obj3@tab==microsatt$tab) perform a correspondance analysisobj4 <- genind2genpop(obj1,missing=""chi2"")ca1 <- dudi.coa(as.data.frame(obj4@tab),scannf=FALSE)s.label(ca1$li,sub=""Correspondance Analysis"",csub=2)add.scatter.eig(ca1$eig,2,xax=1,yax=2,posi=""top"") End(Not run)```']",1,"UTF-8 adegenet formal class (S4) for allele counts in populations DescriptionAn object of class `genpop` contain alleles counts for several loci.It contains several components (see 'slots' section).Such object is obtained using `genind2genpop` which converts individuals genotypes of known population into a `genpop` object. Note that the function `summary` of a `genpop` object returns a list of components. Note that as in other S4 classes, slots are accessed using @ instead of $. Slots- `tab`:: matrix of alleles counts for each combinaison of population (in rows) and alleles (in columns).- `loc.fac`:: locus factor for the columns of `tab`- `loc.n.all`:: integer vector giving the number of alleles per locus- `all.names`:: list having one component per locus, each containing a character vector of alleles names- `call`:: the matched call- `ploidy`:: an integer indicating the degree of ploidy of the genotypes. Beware: 2 is not an integer, but as.integer(2) is.- `type`:: a character string indicating the type of marker: 'codom' stands for 'codominant' (e.g. microstallites, allozymes); 'PA' stands for 'presence/absence' (e.g. AFLP).- `other`:: (optional) a list containing other information ExtendsClass `""gen""`, directly. Class `""popInfo""`, directly. Methods- names: `signature(x = ""genpop"")`: give the names of the components of a genpop object- print: `signature(x = ""genpop"")`: prints a genpop object- show: `signature(object = ""genpop"")`: shows a genpop object (same as print)- summary: `signature(object = ""genpop"")`: summarizes a genpop object, invisibly returning its content or suppress printing of auxiliary information by specifying `verbose = FALSE` See Also`as.genpop`, `is.genpop`,`makefreq`, `genind`, `import2genind`, `read.genetix`, `read.genepop`, `read.fstat` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```robj1 <- import2genind(system.file(""files/nancycats.gen"",package=""adegenet""))obj1obj2 <- genind2genpop(obj1)obj2 Not run:data(microsatt) use as.genpop to convert convenient count tab to genpopobj3 <- as.genpop(microsatt$tab)obj3all(obj3@tab==microsatt$tab) perform a correspondance analysisobj4 <- genind2genpop(obj1,missing=""chi2"")ca1 <- dudi.coa(as.data.frame(obj4@tab),scannf=FALSE)s.label(ca1$li,sub=""Correspondance Analysis"",csub=2)add.scatter.eig(ca1$eig,2,xax=1,yax=2,posi=""top"") End(Not run)```",21
adegenet,compoplot.md,"# Genotype composition plot

```r
compoplot(x, ...)

## S3 method for class 'matrix'
compoplot(
  x,
  col.pal = funky,
  border = NA,
  subset = NULL,
  show.lab = FALSE,
  lab = rownames(x),
  legend = TRUE,
  txt.leg = colnames(x),
  n.col = 4,
  posi = NULL,
  cleg = 0.8,
  bg = transp(""white""),
  ...
)

## S3 method for class 'dapc'
compoplot(x, only.grp = NULL, border = NA, ...)

## S3 method for class 'snapclust'
compoplot(x, border = NA, ...)
```

## Arguments

- `x`: an object to be used for plotting (see description)
- `...`: further arguments to be passed to `barplot`
- `col.pal`: a color palette to be used for the groups; defaults to `funky`
- `border`: a color for the border of the barplot; use `NA` to indicate no border.
- `subset`: a subset of individuals to retain
- `show.lab`: a logical indicating if individual labels should be displayed
- `lab`: a vector of individual labels; if NULL, row.names of the matrix are used
- `legend`: a logical indicating whether a legend should be provided for the colors
- `txt.leg`: a character vector to be used for the legend
- `n.col`: the number of columns to be used for the legend
- `posi`: the position of the legend
- `cleg`: a size factor for the legend
- `bg`: the background to be used for the legend
- `only.grp`: a subset of groups to retain

## Description

The compoplot uses a barplot to represent the group assignment probability of individuals to several groups. It is a generic with methods for the following objects:

## Details

 * `matrix`: a matrix with individuals in row and genetic clusters in column, each entry being an assignment probability of the corresponding individual to the corresponding group
 * `dapc`: the output of the `dapc` function; in this case, group assignments are based upon geometric criteria in the discriminant space
 * `snapclust`: the output of the `snapclust` function; in this case, group assignments are based upon the likelihood of genotypes belonging to their groups

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","['Genotype composition plot```rcompoplot(x, ...) S3 method for class \'matrix\'compoplot(  x,  col.pal = funky,  border = NA,  subset = NULL,  show.lab = FALSE,  lab = rownames(x),  legend = TRUE,  txt.leg = colnames(x),  n.col = 4,  posi = NULL,  cleg = 0.8,  bg = transp(""white""),  ...) S3 method for class \'dapc\'compoplot(x, only.grp = NULL, border = NA, ...) S3 method for class \'snapclust\'compoplot(x, border = NA, ...)``` Arguments- `x`: an object to be used for plotting (see description)- `...`: further arguments to be passed to `barplot`- `col.pal`: a color palette to be used for the groups; defaults to `funky`- `border`: a color for the border of the barplot; use `NA` to indicate no border.- `subset`: a subset of individuals to retain- `show.lab`: a logical indicating if individual labels should be displayed- `lab`: a vector of individual labels; if NULL, row.names of the matrix are used- `legend`: a logical indicating whether a legend should be provided for the colors- `txt.leg`: a character vector to be used for the legend- `n.col`: the number of columns to be used for the legend- `posi`: the position of the legend- `cleg`: a size factor for the legend- `bg`: the background to be used for the legend- `only.grp`: a subset of groups to retain DescriptionThe compoplot uses a barplot to represent the group assignment probability of individuals to several groups.', 'It is a generic with methods for the following objects: Details  `matrix`: a matrix with individuals in row and genetic clusters in column, each entry being an assignment probability of the corresponding individual to the corresponding group  `dapc`: the output of the `dapc` function; in this case, group assignments are based upon geometric criteria in the discriminant space  `snapclust`: the output of the `snapclust` function; in this case, group assignments are based upon the likelihood of genotypes belonging to their groups Author(s)Thibaut Jombart thibautjombart@gmail.com']",1," Genotype composition plot```rcompoplot(x, ...) S3 method for class 'matrix'compoplot(  x,  col.pal = funky,  border = NA,  subset = NULL,  show.lab = FALSE,  lab = rownames(x),  legend = TRUE,  txt.leg = colnames(x),  n.col = 4,  posi = NULL,  cleg = 0.8,  bg = transp(""white""),  ...) S3 method for class 'dapc'compoplot(x, only.grp = NULL, border = NA, ...) S3 method for class 'snapclust'compoplot(x, border = NA, ...)``` Arguments- `x`: an object to be used for plotting (see description)- `...`: further arguments to be passed to `barplot`- `col.pal`: a color palette to be used for the groups; defaults to `funky`- `border`: a color for the border of the barplot; use `NA` to indicate no border.- `subset`: a subset of individuals to retain- `show.lab`: a logical indicating if individual labels should be displayed- `lab`: a vector of individual labels; if NULL, row.names of the matrix are used- `legend`: a logical indicating whether a legend should be provided for the colors- `txt.leg`: a character vector to be used for the legend- `n.col`: the number of columns to be used for the legend- `posi`: the position of the legend- `cleg`: a size factor for the legend- `bg`: the background to be used for the legend- `only.grp`: a subset of groups to retain DescriptionThe compoplot uses a barplot to represent the group assignment probability of individuals to several groups. It is a generic with methods for the following objects: Details  `matrix`: a matrix with individuals in row and genetic clusters in column, each entry being an assignment probability of the corresponding individual to the corresponding group  `dapc`: the output of the `dapc` function; in this case, group assignments are based upon geometric criteria in the discriminant space  `snapclust`: the output of the `snapclust` function; in this case, group assignments are based upon the likelihood of genotypes belonging to their groups Author(s)Thibaut Jombart thibautjombart@gmail.com",21
adegenet,sequences.md,"UTF-8

# Importing data from an alignement of sequences to a genind object

## Description

These functions take an alignement of sequences and translate SNPs into a genind object. Note that only polymorphic loci are retained.

Currently, accepted sequence formats are:

- DNAbin (ape package): function DNAbin2genind

- alignment (seqinr package): function alignment2genind

```r
DNAbin2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), polyThres=1/100)

alignment2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), na.char=""-"",
                 polyThres=1/100)
```

## Arguments

- `x`: an object containing aligned sequences.
- `pop`: an optional factor giving the population to which each sequence belongs.
- `exp.char`: a vector of single character providing expected values; all other characters will be turned to NA.
- `na.char`: a vector of single characters providing values that should be considered as NA. If not NULL, this is used instead of `exp.char`.
- `polyThres`: the minimum frequency of a minor allele for a locus to be considered as polymorphic (defaults to 0.01).

## Returns

an object of the class genind

## See Also

`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop`, `DNAbin`, `as.alignment`.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

data(woodmouse)
x <- DNAbin2genind(woodmouse)
x
genind2df(x)
## End(Not run)


if(require(seqinr)){
mase.res   <- read.alignment(file=system.file(""sequences/test.mase"",package=""seqinr""),
format = ""mase"")
mase.res
x <- alignment2genind(mase.res)
x
locNames(x) # list of polymorphic sites
genind2df(x)

## look at Euclidean distances
D <- dist(tab(x))
D

## summarise with a PCoA
pco1 <- dudi.pco(D, scannf=FALSE,nf=2)
scatter(pco1, posi=""bottomright"")
title(""Principal Coordinate Analysis\n-based on proteic distances-"")

}
```



","['UTF-8 Importing data from an alignement of sequences to a genind object DescriptionThese functions take an alignement of sequences and translate SNPs into a genind object.', 'Note that only polymorphic loci are retained.Currently, accepted sequence formats are:- DNAbin (ape package): function DNAbin2genind- alignment (seqinr package): function alignment2genind```rDNAbin2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), polyThres=1/100)alignment2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), na.char=""-"",                 polyThres=1/100)``` Arguments- `x`: an object containing aligned sequences.- `pop`: an optional factor giving the population to which each sequence belongs.- `exp.char`: a vector of single character providing expected values; all other characters will be turned to NA.- `na.char`: a vector of single characters providing values that should be considered as NA.', 'If not NULL, this is used instead of `exp.char`.- `polyThres`: the minimum frequency of a minor allele for a locus to be considered as polymorphic (defaults to 0.01).', 'Returnsan object of the class genind See Also`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop`, `DNAbin`, `as.alignment`.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(woodmouse)x <- DNAbin2genind(woodmouse)xgenind2df(x) End(Not run)if(require(seqinr)){mase.res   <- read.alignment(file=system.file(""sequences/test.mase"",package=""seqinr""),format = ""mase"")mase.resx <- alignment2genind(mase.res)xlocNames(x)  list of polymorphic sitesgenind2df(x) look at Euclidean distancesD <- dist(tab(x))D summarise with a PCoApco1 <- dudi.pco(D, scannf=FALSE,nf=2)scatter(pco1, posi=""bottomright"")title(""Principal Coordinate Analysis\\n-based on proteic distances-"")}```']",1,"UTF-8 Importing data from an alignement of sequences to a genind object DescriptionThese functions take an alignement of sequences and translate SNPs into a genind object. Note that only polymorphic loci are retained.Currently, accepted sequence formats are:- DNAbin (ape package): function DNAbin2genind- alignment (seqinr package): function alignment2genind```rDNAbin2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), polyThres=1/100)alignment2genind(x, pop=NULL, exp.char=c(""a"",""t"",""g"",""c""), na.char=""-"",                 polyThres=1/100)``` Arguments- `x`: an object containing aligned sequences.- `pop`: an optional factor giving the population to which each sequence belongs.- `exp.char`: a vector of single character providing expected values; all other characters will be turned to NA.- `na.char`: a vector of single characters providing values that should be considered as NA. If not NULL, this is used instead of `exp.char`.- `polyThres`: the minimum frequency of a minor allele for a locus to be considered as polymorphic (defaults to 0.01). Returnsan object of the class genind See Also`import2genind`, `read.genetix`, `read.fstat`, `read.structure`, `read.genepop`, `DNAbin`, `as.alignment`. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run:data(woodmouse)x <- DNAbin2genind(woodmouse)xgenind2df(x) End(Not run)if(require(seqinr)){mase.res   <- read.alignment(file=system.file(""sequences/test.mase"",package=""seqinr""),format = ""mase"")mase.resx <- alignment2genind(mase.res)xlocNames(x)  list of polymorphic sitesgenind2df(x) look at Euclidean distancesD <- dist(tab(x))D summarise with a PCoApco1 <- dudi.pco(D, scannf=FALSE,nf=2)scatter(pco1, posi=""bottomright"")title(""Principal Coordinate Analysis\n-based on proteic distances-"")}```",21
adegenet,dapc.md,"UTF-8

# Discriminant Analysis of Principal Components (DAPC)

## Description

These functions implement the Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). This method descibes the diversity between pre-defined groups. When groups are unknown, use `find.clusters` to infer genetic clusters. See 'details' section for a succint description of the method, and `vignette(""adegenet-dapc"")` for a tutorial. Graphical methods for DAPC are documented in `scatter.dapc` (see `?scatter.dapc`).

 `dapc` is a generic function performing the DAPC on the following types of objects:

- `data.frame` (only numeric data)

- `matrix` (only numeric data)

- `genind` objects (genetic markers)

- `genlight` objects (genome-wide SNPs)

These methods all return an object with class `dapc`.

Functions that can be applied to these objects are (the "".dapc"" can be ommitted):

- `print.dapc`: prints the content of a `dapc` object.

- `summary.dapc`: extracts useful information from a `dapc` object.

- `predict.dapc`: predicts group memberships based on DAPC results.

- `xvalDapc`: performs cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); it currently has methods for `data.frame` and `matrix`.

DAPC implementation calls upon `dudi.pca` from the `ade4` package (except for genlight objects) and `lda` from the `MASS` package. The `predict` procedure uses `predict.lda` from the `MASS` package.

 `as.lda` is a generic with a method for `dapc` object which converts these objects into outputs similar to that of `lda.default`.

```r
## S3 method for class 'data.frame'
dapc(x, grp, n.pca=NULL, n.da=NULL, center=TRUE,
     scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ..., dudi=NULL)

## S3 method for class 'matrix'
dapc(x, ...)

## S3 method for class 'genind'
dapc(x, pop=NULL, n.pca=NULL, n.da=NULL, scale=FALSE,
     truenames=TRUE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ...)

## S3 method for class 'genlight'
dapc(x, pop=NULL, n.pca=NULL, n.da=NULL,
   scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,
   pca.select=c(""nbEig"", ""percVar""), perc.pca=NULL, glPca=NULL, ...)

## S3 method for class 'dudi'
dapc(x, grp, ...)

## S3 method for class 'dapc'
print(x, ...)

## S3 method for class 'dapc'
summary(object, ...)

## S3 method for class 'dapc'
predict(object, newdata, prior = object$prior, dimen,
         method = c(""plug-in"", ""predictive"", ""debiased""), ...)
```

## Arguments

- `x`: `a data.frame`, `matrix`, or `genind` object. For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.
- `grp,pop`: a `factor` indicating the group membership of individuals; for `scatter`, an optional grouping of individuals.
- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step. If `NULL`, interactive selection is triggered.
- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step. If `NULL`, interactive selection is triggered.
- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind objects.
- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.
- `var.contrib`: a `logical` indicating whether the contribution of original variables (alleles, for genind objects) should be provided (TRUE, default) or not (FALSE). Such output can be useful, but can also create huge matrices when there is a lot of variables.
- `var.loadings`: a `logical` indicating whether the loadings of original variables (alleles, for genind objects) should be provided (TRUE) or not (FALSE, default). Such output can be useful, but can also create huge matrices when there is a lot of variables.
- `pca.info`: a `logical` indicating whether information about the prior PCA should be stored (TRUE, default) or not (FALSE). This information is required to predict group membership of new individuals using `predict`, but makes the object slightly bigger.
- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"". For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`). For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).
- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.
- ``: further arguments to be passed to other functions. For `dapc.matrix`, arguments are to match those of `dapc.data.frame`; for `dapc.genlight`, arguments passed to `glPca`
- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object.
- `object`: a `dapc` object.
- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE).
- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package). If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.
- `newdata`: an optional dataset of individuals whose membership is seeked; can be a data.frame, a matrix, a genind or a genlight object, but object class must match the original ('training') data. In particular, variables must be exactly the same as in the original data. For genind
    
    objects, see `repool` to ensure matching of alleles.
- `prior,dimen,method`: see `?predict.lda`.

## Details

The Discriminant Analysis of Principal Components (DAPC) is designed to investigate the genetic structure of biological populations. This multivariate method consists in a two-steps procedure. First, genetic data are transformed (centred, possibly scaled) and submitted to a Principal Component Analysis (PCA). Second, principal components of PCA are submitted to a Linear Discriminant Analysis (LDA). A trivial matrix operation allows to express discriminant functions as linear combination of alleles, therefore allowing one to compute allele contributions. More details about the computation of DAPC are to be found in the indicated reference.

DAPC does not infer genetic clusters ex nihilo; for this, see the `find.clusters` function.

## Returns

=== dapc objects ===

The class `dapc` is a list with the following components:

 - **call**: the matched call.

 - **n.pca**: number of PCA axes retained

 - **n.da**: number of DA axes retained

 - **var**: proportion of variance conserved by PCA principal components

 - **eig**: a numeric vector of eigenvalues.

 - **grp**: a factor giving prior group assignment

 - **prior**: a numeric vector giving prior group probabilities

 - **assign**: a factor giving posterior group assignment

 - **tab**: matrix of retained principal components of PCA

 - **loadings**: principal axes of DAPC, giving coefficients of the linear combination of retained PCA axes.

 - **ind.coord**: principal components of DAPC, giving the coordinates of individuals onto principal axes of DAPC; also called the discriminant functions.

 - **grp.coord**: coordinates of the groups onto the principal axes of DAPC.

 - **posterior**: a data.frame giving posterior membership probabilities for all individuals and all clusters.

 - **var.contr**: (optional) a data.frame giving the contributions of original variables (alleles in the case of genetic data) to the principal components of DAPC.

 - **var.load**: (optional) a data.frame giving the loadings of original variables (alleles in the case of genetic data) to the principal components of DAPC.

 - **match.prp**: a list, where each item is the proportion of individuals correctly matched to their original population in cross-validation.

=== other outputs ===

Other functions have different outputs:

- `summary.dapc` returns a list with 6 components: `n.dim` (number of retained DAPC axes), `n.pop` (number of groups/populations), `assign.prop` (proportion of overall correct assignment), `assign.per.pop` (proportion of correct assignment per group), `prior.grp.size` (prior group sizes), and `post.grp.size` (posterior group sizes), `xval.dapc`, `xval.genind` and `xval` (all return a list of four lists, each one with as many items as cross-validation runs. The first item is a list of `assign` components, the secon is a list of `posterior` components, the thirs is a list of `ind.score` components and the fourth is a list of `match.prp` items, i.e. the prortion of the validation set correctly matched to its original population)

## References

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94

## See Also

 * `xvalDapc`: selection of the optimal numbers of PCA axes retained in DAPC using cross-validation.
 * `scatter.dapc`, `assignplot`, `compoplot`: graphics for DAPC.
 * `find.clusters`: to identify clusters without prior.
 * `dapcIllus`: a set of simulated data illustrating the DAPC
 * `eHGDP`, `H3N2`: empirical datasets illustrating DAPC

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## data(dapcIllus), data(eHGDP), and data(H3N2) illustrate the dapc
## see ?dapcIllus, ?eHGDP, ?H3N2
##
## Not run:

example(dapcIllus)
example(eHGDP)
example(H3N2)
## End(Not run)


## H3N2 EXAMPLE ##
data(H3N2)
pop(H3N2) <- factor(H3N2$other$epid)
dapc1 <- dapc(H3N2, var.contrib=FALSE, scale=FALSE, n.pca=150, n.da=5)

## remove internal segments and ellipses, different pch, add MStree
scatter(dapc1, cell=0, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2)

## label individuals at the periphery
# air = 2 is a measure of how much space each label needs
# pch = NA suppresses plotting of points
scatter(dapc1, label.inds = list(air = 2, pch = NA))

## only ellipse, custom labels
scatter(dapc1, cell=2, pch="""", cstar=0, posi.da=""top"",
        label=paste(""year\n"",2001:2006), axesel=FALSE, col=terrain.colors(10))


## SHOW COMPOPLOT ON MICROBOV DATA ##
data(microbov)
dapc1 <- dapc(microbov, n.pca=20, n.da=15)
compoplot(dapc1, lab="""")




## Not run:

## EXAMPLE USING GENLIGHT OBJECTS ##
## simulate data
x <- glSim(50,4e3-50, 50, ploidy=2)
x
plot(x)

## perform DAPC
dapc1 <- dapc(x, n.pca=10, n.da=1)
dapc1

## plot results
scatter(dapc1, scree.da=FALSE)

## SNP contributions
loadingplot(dapc1$var.contr)
loadingplot(tail(dapc1$var.contr, 100), main=""Loading plot - last 100 SNPs"")



## USE ""PREDICT"" TO PREDICT GROUPS OF NEW INDIVIDUALS ##
## load data
data(sim2pop)

## we make a dataset of:
## 30 individuals from pop A
## 30 individuals from pop B
## 30 hybrids

## separate populations and make F1
temp <- seppop(sim2pop)
temp <- lapply(temp, function(e) hybridize(e,e,n=30)) # force equal popsizes

## make hybrids
hyb <- hybridize(temp[[1]], temp[[2]], n=30)

## repool data - needed to ensure allele matching
newdat <- repool(temp[[1]], temp[[2]], hyb)
pop(newdat) <- rep(c(""pop A"", ""popB"", ""hyb AB""), c(30,30,30))

## perform the DAPC on the first 2 pop (60 first indiv)
dapc1 <- dapc(newdat[1:60],n.pca=5,n.da=1)

## plot results
scatter(dapc1, scree.da=FALSE)

## make prediction for the 30 hybrids
hyb.pred <- predict(dapc1, newdat[61:90])
hyb.pred

## plot the inferred coordinates (circles are hybrids)
points(hyb.pred$ind.scores, rep(.1, 30))

## look at assignment using assignplot
assignplot(dapc1, new.pred=hyb.pred)
title(""30 indiv popA, 30 indiv pop B, 30 hybrids"")

## image using compoplot
compoplot(dapc1, new.pred=hyb.pred, ncol=2)
title(""30 indiv popA, 30 indiv pop B, 30 hybrids"")

## CROSS-VALIDATION ##
data(sim2pop)
xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)
xval
boxplot(xval$success~xval$n.pca, xlab=""Number of PCA components"",
ylab=""Classification succes"", main=""DAPC - cross-validation"")
## End(Not run)
```



","['UTF-8 Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions implement the Discriminant Analysis of Principal Components (DAPC, Jombart et al.', 'This method descibes the diversity between pre-defined groups.', 'When groups are unknown, use `find.clusters` to infer genetic clusters.', 'See \'details\' section for a succint description of the method, and `vignette(""adegenet-dapc"")` for a tutorial.', 'Graphical methods for DAPC are documented in `scatter.dapc` (see `?scatter.dapc`).', '`dapc` is a generic function performing the DAPC on the following types of objects:- `data.frame` (only numeric data)- `matrix` (only numeric data)- `genind` objects (genetic markers)- `genlight` objects (genome-wide SNPs)These methods all return an object with class `dapc`.Functions that can be applied to these objects are (the "".dapc"" can be ommitted):- `print.dapc`: prints the content of a `dapc` object.- `summary.dapc`: extracts useful information from a `dapc` object.- `predict.dapc`: predicts group memberships based on DAPC results.- `xvalDapc`: performs cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); it currently has methods for `data.frame` and `matrix`.DAPC implementation calls upon `dudi.pca` from the `ade4` package (except for genlight objects) and `lda` from the `MASS` package.', 'The `predict` procedure uses `predict.lda` from the `MASS` package.', '`as.lda` is a generic with a method for `dapc` object which converts these objects into outputs similar to that of `lda.default`.```r S3 method for class \'data.frame\'dapc(x, grp, n.pca=NULL, n.da=NULL, center=TRUE,     scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ..., dudi=NULL) S3 method for class \'matrix\'dapc(x, ...) S3 method for class \'genind\'dapc(x, pop=NULL, n.pca=NULL, n.da=NULL, scale=FALSE,     truenames=TRUE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ...) S3 method for class \'genlight\'dapc(x, pop=NULL, n.pca=NULL, n.da=NULL,   scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,   pca.select=c(""nbEig"", ""percVar""), perc.pca=NULL, glPca=NULL, ...) S3 method for class \'dudi\'dapc(x, grp, ...) S3 method for class \'dapc\'print(x, ...) S3 method for class \'dapc\'summary(object, ...) S3 method for class \'dapc\'predict(object, newdata, prior = object$prior, dimen,         method = c(""plug-in"", ""predictive"", ""debiased""), ...)``` Arguments- `x`: `a data.frame`, `matrix`, or `genind` object.', 'For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.- `grp,pop`: a `factor` indicating the group membership of individuals; for `scatter`, an optional grouping of individuals.- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step.', 'If `NULL`, interactive selection is triggered.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step.', 'If `NULL`, interactive selection is triggered.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE).', 'Always TRUE for genind objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default).', 'Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.- `var.contrib`: a `logical` indicating whether the contribution of original variables (alleles, for genind objects) should be provided (TRUE, default) or not (FALSE).', 'Such output can be useful, but can also create huge matrices when there is a lot of variables.- `var.loadings`: a `logical` indicating whether the loadings of original variables (alleles, for genind objects) should be provided (TRUE) or not (FALSE, default).', 'Such output can be useful, but can also create huge matrices when there is a lot of variables.- `pca.info`: a `logical` indicating whether information about the prior PCA should be stored (TRUE, default) or not (FALSE).', 'This information is required to predict group membership of new individuals using `predict`, but makes the object slightly bigger.- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"".', 'For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`).', 'For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.- ``: further arguments to be passed to other functions.', 'For `dapc.matrix`, arguments are to match those of `dapc.data.frame`; for `dapc.genlight`, arguments passed to `glPca`- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object.- `object`: a `dapc` object.- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE).- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package).', ""If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.- `newdata`: an optional dataset of individuals whose membership is seeked; can be a data.frame, a matrix, a genind or a genlight object, but object class must match the original ('training') data."", 'In particular, variables must be exactly the same as in the original data.', 'For genind        objects, see `repool` to ensure matching of alleles.- `prior,dimen,method`: see `?predict.lda`.', 'DetailsThe Discriminant Analysis of Principal Components (DAPC) is designed to investigate the genetic structure of biological populations.', 'This multivariate method consists in a two-steps procedure.', 'First, genetic data are transformed (centred, possibly scaled) and submitted to a Principal Component Analysis (PCA).', 'Second, principal components of PCA are submitted to a Linear Discriminant Analysis (LDA).', 'A trivial matrix operation allows to express discriminant functions as linear combination of alleles, therefore allowing one to compute allele contributions.', 'More details about the computation of DAPC are to be found in the indicated reference.DAPC does not infer genetic clusters ex nihilo; for this, see the `find.clusters` function.', 'Returns=== dapc objects ===The class `dapc` is a list with the following components: - call: the matched call.', '- n.pca: number of PCA axes retained - n.da: number of DA axes retained - var: proportion of variance conserved by PCA principal components - eig: a numeric vector of eigenvalues.', '- grp: a factor giving prior group assignment - prior: a numeric vector giving prior group probabilities - assign: a factor giving posterior group assignment - tab: matrix of retained principal components of PCA - loadings: principal axes of DAPC, giving coefficients of the linear combination of retained PCA axes.', '- ind.coord: principal components of DAPC, giving the coordinates of individuals onto principal axes of DAPC; also called the discriminant functions.', '- grp.coord: coordinates of the groups onto the principal axes of DAPC.', '- posterior: a data.frame giving posterior membership probabilities for all individuals and all clusters.', '- var.contr: (optional) a data.frame giving the contributions of original variables (alleles in the case of genetic data) to the principal components of DAPC.', '- var.load: (optional) a data.frame giving the loadings of original variables (alleles in the case of genetic data) to the principal components of DAPC.', '- match.prp: a list, where each item is the proportion of individuals correctly matched to their original population in cross-validation.=== other outputs ===Other functions have different outputs:- `summary.dapc` returns a list with 6 components: `n.dim` (number of retained DAPC axes), `n.pop` (number of groups/populations), `assign.prop` (proportion of overall correct assignment), `assign.per.pop` (proportion of correct assignment per group), `prior.grp.size` (prior group sizes), and `post.grp.size` (posterior group sizes), `xval.dapc`, `xval.genind` and `xval` (all return a list of four lists, each one with as many items as cross-validation runs.', 'The first item is a list of `assign` components, the secon is a list of `posterior` components, the thirs is a list of `ind.score` components and the fourth is a list of `match.prp` items, i.e.', 'the prortion of the validation set correctly matched to its original population) ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also  `xvalDapc`: selection of the optimal numbers of PCA axes retained in DAPC using cross-validation.', '`scatter.dapc`, `assignplot`, `compoplot`: graphics for DAPC.', '`find.clusters`: to identify clusters without prior.', '`dapcIllus`: a set of simulated data illustrating the DAPC  `eHGDP`, `H3N2`: empirical datasets illustrating DAPC Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r data(dapcIllus), data(eHGDP), and data(H3N2) illustrate the dapc see ?dapcIllus, ?eHGDP, ?H3N2 Not run:example(dapcIllus)example(eHGDP)example(H3N2) End(Not run) H3N2 EXAMPLE data(H3N2)pop(H3N2) <- factor(H3N2$other$epid)dapc1 <- dapc(H3N2, var.contrib=FALSE, scale=FALSE, n.pca=150, n.da=5) remove internal segments and ellipses, different pch, add MStreescatter(dapc1, cell=0, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2) label individuals at the periphery air = 2 is a measure of how much space each label needs pch = NA suppresses plotting of pointsscatter(dapc1, label.inds = list(air = 2, pch = NA)) only ellipse, custom labelsscatter(dapc1, cell=2, pch="""", cstar=0, posi.da=""top"",        label=paste(""year\\n"",2001:2006), axesel=FALSE, col=terrain.colors(10)) SHOW COMPOPLOT ON MICROBOV DATA data(microbov)dapc1 <- dapc(microbov, n.pca=20, n.da=15)compoplot(dapc1, lab="""") Not run: EXAMPLE USING GENLIGHT OBJECTS  simulate datax <- glSim(50,4e3-50, 50, ploidy=2)xplot(x) perform DAPCdapc1 <- dapc(x, n.pca=10, n.da=1)dapc1 plot resultsscatter(dapc1, scree.da=FALSE) SNP contributionsloadingplot(dapc1$var.contr)loadingplot(tail(dapc1$var.contr, 100), main=""Loading plot - last 100 SNPs"") USE ""PREDICT"" TO PREDICT GROUPS OF NEW INDIVIDUALS  load datadata(sim2pop) we make a dataset of: 30 individuals from pop A 30 individuals from pop B 30 hybrids separate populations and make F1temp <- seppop(sim2pop)temp <- lapply(temp, function(e) hybridize(e,e,n=30))  force equal popsizes make hybridshyb <- hybridize(temp[[1]], temp[[2]], n=30) repool data - needed to ensure allele matchingnewdat <- repool(temp[[1]], temp[[2]], hyb)pop(newdat) <- rep(c(""pop A"", ""popB"", ""hyb AB""), c(30,30,30)) perform the DAPC on the first 2 pop (60 first indiv)dapc1 <- dapc(newdat[1:60],n.pca=5,n.da=1) plot resultsscatter(dapc1, scree.da=FALSE) make prediction for the 30 hybridshyb.pred <- predict(dapc1, newdat[61:90])hyb.pred plot the inferred coordinates (circles are hybrids)points(hyb.pred$ind.scores, rep(.1, 30)) look at assignment using assignplotassignplot(dapc1, new.pred=hyb.pred)title(""30 indiv popA, 30 indiv pop B, 30 hybrids"") image using compoplotcompoplot(dapc1, new.pred=hyb.pred, ncol=2)title(""30 indiv popA, 30 indiv pop B, 30 hybrids"") CROSS-VALIDATION data(sim2pop)xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)xvalboxplot(xval$success~xval$n.pca, xlab=""Number of PCA components"",ylab=""Classification succes"", main=""DAPC - cross-validation"") End(Not run)```']",1,"UTF-8 Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions implement the Discriminant Analysis of Principal Components (DAPC, Jombart et al. 2010). This method descibes the diversity between pre-defined groups. When groups are unknown, use `find.clusters` to infer genetic clusters. See 'details' section for a succint description of the method, and `vignette(""adegenet-dapc"")` for a tutorial. Graphical methods for DAPC are documented in `scatter.dapc` (see `?scatter.dapc`). `dapc` is a generic function performing the DAPC on the following types of objects:- `data.frame` (only numeric data)- `matrix` (only numeric data)- `genind` objects (genetic markers)- `genlight` objects (genome-wide SNPs)These methods all return an object with class `dapc`.Functions that can be applied to these objects are (the "".dapc"" can be ommitted):- `print.dapc`: prints the content of a `dapc` object.- `summary.dapc`: extracts useful information from a `dapc` object.- `predict.dapc`: predicts group memberships based on DAPC results.- `xvalDapc`: performs cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); it currently has methods for `data.frame` and `matrix`.DAPC implementation calls upon `dudi.pca` from the `ade4` package (except for genlight objects) and `lda` from the `MASS` package. The `predict` procedure uses `predict.lda` from the `MASS` package. `as.lda` is a generic with a method for `dapc` object which converts these objects into outputs similar to that of `lda.default`.```r S3 method for class 'data.frame'dapc(x, grp, n.pca=NULL, n.da=NULL, center=TRUE,     scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ..., dudi=NULL) S3 method for class 'matrix'dapc(x, ...) S3 method for class 'genind'dapc(x, pop=NULL, n.pca=NULL, n.da=NULL, scale=FALSE,     truenames=TRUE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,     pca.select=c(""nbEig"",""percVar""), perc.pca=NULL, ...) S3 method for class 'genlight'dapc(x, pop=NULL, n.pca=NULL, n.da=NULL,   scale=FALSE, var.contrib=TRUE, var.loadings=FALSE, pca.info=TRUE,   pca.select=c(""nbEig"", ""percVar""), perc.pca=NULL, glPca=NULL, ...) S3 method for class 'dudi'dapc(x, grp, ...) S3 method for class 'dapc'print(x, ...) S3 method for class 'dapc'summary(object, ...) S3 method for class 'dapc'predict(object, newdata, prior = object$prior, dimen,         method = c(""plug-in"", ""predictive"", ""debiased""), ...)``` Arguments- `x`: `a data.frame`, `matrix`, or `genind` object. For the `data.frame` and `matrix` arguments, only quantitative variables should be provided.- `grp,pop`: a `factor` indicating the group membership of individuals; for `scatter`, an optional grouping of individuals.- `n.pca`: an `integer` indicating the number of axes retained in the Principal Component Analysis (PCA) step. If `NULL`, interactive selection is triggered.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step. If `NULL`, interactive selection is triggered.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.- `var.contrib`: a `logical` indicating whether the contribution of original variables (alleles, for genind objects) should be provided (TRUE, default) or not (FALSE). Such output can be useful, but can also create huge matrices when there is a lot of variables.- `var.loadings`: a `logical` indicating whether the loadings of original variables (alleles, for genind objects) should be provided (TRUE) or not (FALSE, default). Such output can be useful, but can also create huge matrices when there is a lot of variables.- `pca.info`: a `logical` indicating whether information about the prior PCA should be stored (TRUE, default) or not (FALSE). This information is required to predict group membership of new individuals using `predict`, but makes the object slightly bigger.- `pca.select`: a `character` indicating the mode of selection of PCA axes, matching either ""nbEig"" or ""percVar"". For ""nbEig"", the user has to specify the number of axes retained (interactively, or via `n.pca`). For ""percVar"", the user has to specify the minimum amount of the total variance to be preserved by the retained axes, expressed as a percentage (interactively, or via `perc.pca`).- `perc.pca`: a `numeric` value between 0 and 100 indicating the minimal percentage of the total variance of the data to be expressed by the retained axes of PCA.- ``: further arguments to be passed to other functions. For `dapc.matrix`, arguments are to match those of `dapc.data.frame`; for `dapc.genlight`, arguments passed to `glPca`- `glPca`: an optional `glPca` object; if provided, dimension reduction is not performed (saving computational time) but taken directly from this object.- `object`: a `dapc` object.- `truenames`: a `logical` indicating whether true (i.e., user-specified) labels should be used in object outputs (TRUE, default) or not (FALSE).- `dudi`: optionally, a multivariate analysis with the class `dudi` (from the ade4 package). If provided, prior PCA will be ignored, and this object will be used as a prior step for variable orthogonalisation.- `newdata`: an optional dataset of individuals whose membership is seeked; can be a data.frame, a matrix, a genind or a genlight object, but object class must match the original ('training') data. In particular, variables must be exactly the same as in the original data. For genind        objects, see `repool` to ensure matching of alleles.- `prior,dimen,method`: see `?predict.lda`. DetailsThe Discriminant Analysis of Principal Components (DAPC) is designed to investigate the genetic structure of biological populations. This multivariate method consists in a two-steps procedure. First, genetic data are transformed (centred, possibly scaled) and submitted to a Principal Component Analysis (PCA). Second, principal components of PCA are submitted to a Linear Discriminant Analysis (LDA). A trivial matrix operation allows to express discriminant functions as linear combination of alleles, therefore allowing one to compute allele contributions. More details about the computation of DAPC are to be found in the indicated reference.DAPC does not infer genetic clusters ex nihilo; for this, see the `find.clusters` function. Returns=== dapc objects ===The class `dapc` is a list with the following components: - call: the matched call. - n.pca: number of PCA axes retained - n.da: number of DA axes retained - var: proportion of variance conserved by PCA principal components - eig: a numeric vector of eigenvalues. - grp: a factor giving prior group assignment - prior: a numeric vector giving prior group probabilities - assign: a factor giving posterior group assignment - tab: matrix of retained principal components of PCA - loadings: principal axes of DAPC, giving coefficients of the linear combination of retained PCA axes. - ind.coord: principal components of DAPC, giving the coordinates of individuals onto principal axes of DAPC; also called the discriminant functions. - grp.coord: coordinates of the groups onto the principal axes of DAPC. - posterior: a data.frame giving posterior membership probabilities for all individuals and all clusters. - var.contr: (optional) a data.frame giving the contributions of original variables (alleles in the case of genetic data) to the principal components of DAPC. - var.load: (optional) a data.frame giving the loadings of original variables (alleles in the case of genetic data) to the principal components of DAPC. - match.prp: a list, where each item is the proportion of individuals correctly matched to their original population in cross-validation.=== other outputs ===Other functions have different outputs:- `summary.dapc` returns a list with 6 components: `n.dim` (number of retained DAPC axes), `n.pop` (number of groups/populations), `assign.prop` (proportion of overall correct assignment), `assign.per.pop` (proportion of correct assignment per group), `prior.grp.size` (prior group sizes), and `post.grp.size` (posterior group sizes), `xval.dapc`, `xval.genind` and `xval` (all return a list of four lists, each one with as many items as cross-validation runs. The first item is a list of `assign` components, the secon is a list of `posterior` components, the thirs is a list of `ind.score` components and the fourth is a list of `match.prp` items, i.e. the prortion of the validation set correctly matched to its original population) ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also  `xvalDapc`: selection of the optimal numbers of PCA axes retained in DAPC using cross-validation.  `scatter.dapc`, `assignplot`, `compoplot`: graphics for DAPC.  `find.clusters`: to identify clusters without prior.  `dapcIllus`: a set of simulated data illustrating the DAPC  `eHGDP`, `H3N2`: empirical datasets illustrating DAPC Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r data(dapcIllus), data(eHGDP), and data(H3N2) illustrate the dapc see ?dapcIllus, ?eHGDP, ?H3N2 Not run:example(dapcIllus)example(eHGDP)example(H3N2) End(Not run) H3N2 EXAMPLE data(H3N2)pop(H3N2) <- factor(H3N2$other$epid)dapc1 <- dapc(H3N2, var.contrib=FALSE, scale=FALSE, n.pca=150, n.da=5) remove internal segments and ellipses, different pch, add MStreescatter(dapc1, cell=0, pch=18:23, cstar=0, mstree=TRUE, lwd=2, lty=2) label individuals at the periphery air = 2 is a measure of how much space each label needs pch = NA suppresses plotting of pointsscatter(dapc1, label.inds = list(air = 2, pch = NA)) only ellipse, custom labelsscatter(dapc1, cell=2, pch="""", cstar=0, posi.da=""top"",        label=paste(""year\n"",2001:2006), axesel=FALSE, col=terrain.colors(10)) SHOW COMPOPLOT ON MICROBOV DATA data(microbov)dapc1 <- dapc(microbov, n.pca=20, n.da=15)compoplot(dapc1, lab="""") Not run: EXAMPLE USING GENLIGHT OBJECTS  simulate datax <- glSim(50,4e3-50, 50, ploidy=2)xplot(x) perform DAPCdapc1 <- dapc(x, n.pca=10, n.da=1)dapc1 plot resultsscatter(dapc1, scree.da=FALSE) SNP contributionsloadingplot(dapc1$var.contr)loadingplot(tail(dapc1$var.contr, 100), main=""Loading plot - last 100 SNPs"") USE ""PREDICT"" TO PREDICT GROUPS OF NEW INDIVIDUALS  load datadata(sim2pop) we make a dataset of: 30 individuals from pop A 30 individuals from pop B 30 hybrids separate populations and make F1temp <- seppop(sim2pop)temp <- lapply(temp, function(e) hybridize(e,e,n=30))  force equal popsizes make hybridshyb <- hybridize(temp[[1]], temp[[2]], n=30) repool data - needed to ensure allele matchingnewdat <- repool(temp[[1]], temp[[2]], hyb)pop(newdat) <- rep(c(""pop A"", ""popB"", ""hyb AB""), c(30,30,30)) perform the DAPC on the first 2 pop (60 first indiv)dapc1 <- dapc(newdat[1:60],n.pca=5,n.da=1) plot resultsscatter(dapc1, scree.da=FALSE) make prediction for the 30 hybridshyb.pred <- predict(dapc1, newdat[61:90])hyb.pred plot the inferred coordinates (circles are hybrids)points(hyb.pred$ind.scores, rep(.1, 30)) look at assignment using assignplotassignplot(dapc1, new.pred=hyb.pred)title(""30 indiv popA, 30 indiv pop B, 30 hybrids"") image using compoplotcompoplot(dapc1, new.pred=hyb.pred, ncol=2)title(""30 indiv popA, 30 indiv pop B, 30 hybrids"") CROSS-VALIDATION data(sim2pop)xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)xvalboxplot(xval$success~xval$n.pca, xlab=""Number of PCA components"",ylab=""Classification succes"", main=""DAPC - cross-validation"") End(Not run)```",21
adegenet,web.md,"# Functions to access online resources for adegenet

```r
adegenetWeb()

adegenetTutorial(
  which = c(""basics"", ""spca"", ""dapc"", ""genomics"", ""strata"", ""snapclust"")
)

adegenetIssues()
```

## Arguments

- `which`: a character string indicating which tutorial to open (see details)

## Description

These functions simply open websites or documents available online providing resources for adegenet.

## Details

 * adegenetWeb opens adegenet's website
 * adegenetTutorial opens adegenet tutorials
 * adegenetIssues opens the issue page on github; this is used to report a bug or post a feature request.

Available tutorials are:

 * 'basics': general introduction to adegenet; covers basic data structures, import/export, handling, and a number of population genetics methods
 * 'spca': spatial genetic structures using the spatial Principal Component Analysis
 * 'dapc': population structure using the Discriminant Analysis of Principal Components
 * 'genomics': handling large genome-wide SNP data using adegenet
 * 'strata': introduction to hierarchical population structure in adegenet
 * 'snapclust': introduction to fast maximum-likelihood genetic clustering using snapclust



","['Functions to access online resources for adegenet```radegenetWeb()adegenetTutorial(  which = c(""basics"", ""spca"", ""dapc"", ""genomics"", ""strata"", ""snapclust""))adegenetIssues()``` Arguments- `which`: a character string indicating which tutorial to open (see details) DescriptionThese functions simply open websites or documents available online providing resources for adegenet.', ""Details  adegenetWeb opens adegenet's website  adegenetTutorial opens adegenet tutorials  adegenetIssues opens the issue page on github; this is used to report a bug or post a feature request.Available tutorials are:  'basics': general introduction to adegenet; covers basic data structures, import/export, handling, and a number of population genetics methods  'spca': spatial genetic structures using the spatial Principal Component Analysis  'dapc': population structure using the Discriminant Analysis of Principal Components  'genomics': handling large genome-wide SNP data using adegenet  'strata': introduction to hierarchical population structure in adegenet  'snapclust': introduction to fast maximum-likelihood genetic clustering using snapclust""]",1," Functions to access online resources for adegenet```radegenetWeb()adegenetTutorial(  which = c(""basics"", ""spca"", ""dapc"", ""genomics"", ""strata"", ""snapclust""))adegenetIssues()``` Arguments- `which`: a character string indicating which tutorial to open (see details) DescriptionThese functions simply open websites or documents available online providing resources for adegenet. Details  adegenetWeb opens adegenet's website  adegenetTutorial opens adegenet tutorials  adegenetIssues opens the issue page on github; this is used to report a bug or post a feature request.Available tutorials are:  'basics': general introduction to adegenet; covers basic data structures, import/export, handling, and a number of population genetics methods  'spca': spatial genetic structures using the spatial Principal Component Analysis  'dapc': population structure using the Discriminant Analysis of Principal Components  'genomics': handling large genome-wide SNP data using adegenet  'strata': introduction to hierarchical population structure in adegenet  'snapclust': introduction to fast maximum-likelihood genetic clustering using snapclust",22
adegenet,SNPbin.md,"class

# Formal class ""SNPbin""

## Description

The class `SNPbin` is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme. This storage is most efficient with haploid data, where the memory taken to represent data can reduced more than 50 times. However, `SNPbin` can be used for any level of ploidy, and still remain an efficient storage mode.

A `SNPbin` object can be constructed from a vector of integers giving the number of the second allele for each locus.

 `SNPbin` stores a single genotype. To store multiple genotypes, use the genlight class.

## Objects from the class SNPbin

`SNPbin` objects can be created by calls to `new(""SNPbin"", ...)`, where '...' can be the following arguments:

 

- **`snp`**: a vector of integers or numeric giving numbers of copies of the second alleles for each locus. If only one unnamed argument is provided to 'new', it is considered as this one.
- **`ploidy`**: an integer indicating the ploidy of the genotype; if not provided, will be guessed from the data (as the maximum from the 'snp' input vector).
- **`label`**: an optional character string serving as a label for the genotype.

## Slots

The following slots are the content of instances of the class `SNPbin`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.

- **`snp`:**: a list of vectors with the class `raw`.
- **`n.loc`:**: an integer indicating the number of SNPs of the genotype.
- **`NA.posi`:**: a vector of integer giving the position of missing data.
- **`label`:**: an optional character string serving as a label for the genotype..
- **`ploidy`:**: an integer indicating the ploidy of the genotype.

## Methods

Here is a list of methods available for `SNPbin` objects. Most of these methods are accessors, that is, functions which are used to retrieve the content of the object. Specific manpages can exist for accessors with more than one argument. These are indicated by a '*' symbol next to the method's name. This list also contains methods for conversion from `SNPbin` to other classes.

- **[**: `signature(x = ""SNPbin"")`: usual method to subset objects in R. The argument indicates how SNPs are to be subsetted. It can be a vector of signed integers or of logicals.
- **show**: `signature(x = ""SNPbin"")`: printing of the object.
- **$**: `signature(x = ""SNPbin"")`: similar to the @ operator; used to access the content of slots of the object.
- **$<-**: `signature(x = ""SNPbin"")`: similar to the @ operator; used to replace the content of slots of the object.
- **nLoc**: `signature(x = ""SNPbin"")`: returns the number of SNPs in the object.
- **names**: `signature(x = ""SNPbin"")`: returns the names of the slots of the object.
- **ploidy**: `signature(x = ""SNPbin"")`: returns the ploidy of the genotype.
- **as.integer**: `signature(x = ""SNPbin"")`: converts a `SNPbin` object to a vector of integers. The S4 method 'as' can be used as well (e.g. as(x, ""integer"")).
- **cbind**: `signature(x = ""SNPbin"")`: merges genotyping of the same individual at different SNPs (all stored as SNPbin objects) into a single SNPbin .
- **c**: `signature(x = ""SNPbin"")`: same as cbind.SNPbin.

## Author(s)

Thibaut Jombart (t.jombart@imperial.ac.uk )

## See Also

Related class:

- `genlight`, for storing multiple binary SNP genotypes.

- `genind`, for storing other types of genetic markers.

## Examples

```r
## Not run:

#### HAPLOID EXAMPLE ####
## create a genotype of 100,000 SNPs
dat <- sample(c(0,1,NA), 1e5, prob=c(.495, .495, .01), replace=TRUE)
dat[1:10]
x <- new(""SNPbin"", dat)
x
x[1:10] # subsetting
as.integer(x[1:10])

## try a few accessors
ploidy(x)
nLoc(x)
head(x$snp[[1]]) # internal bit-level coding

## check that conversion is OK
identical(as(x, ""integer""),as.integer(dat)) # SHOULD BE TRUE

## compare the size of the objects
print(object.size(dat), unit=""auto"")
print(object.size(x), unit=""auto"")
object.size(dat)/object.size(x) # EFFICIENCY OF CONVERSION


#### TETRAPLOID EXAMPLE ####
## create a genotype of 100,000 SNPs
dat <- sample(c(0:4,NA), 1e5, prob=c(rep(.995/5,5), 0.005), replace=TRUE)
x <- new(""SNPbin"", dat)
identical(as(x, ""integer""),as.integer(dat)) # MUST BE TRUE

## compare the size of the objects
print(object.size(dat), unit=""auto"")
print(object.size(x), unit=""auto"")
object.size(dat)/object.size(x) # EFFICIENCY OF CONVERSION


#### c, cbind ####
a <- new(""SNPbin"", c(1,1,1,1,1))
b <- new(""SNPbin"", c(0,0,0,0,0))
a
b
ab <- c(a,b)
ab
identical(c(a,b),cbind(a,b))
as.integer(ab)
## End(Not run)
```



","['class Formal class ""SNPbin"" DescriptionThe class `SNPbin` is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme.', 'This storage is most efficient with haploid data, where the memory taken to represent data can reduced more than 50 times.', 'However, `SNPbin` can be used for any level of ploidy, and still remain an efficient storage mode.A `SNPbin` object can be constructed from a vector of integers giving the number of the second allele for each locus.', '`SNPbin` stores a single genotype.', 'To store multiple genotypes, use the genlight class.', 'Objects from the class SNPbin`SNPbin` objects can be created by calls to `new(""SNPbin"", ...)`, where \'...\' can be the following arguments: - `snp`: a vector of integers or numeric giving numbers of copies of the second alleles for each locus.', ""If only one unnamed argument is provided to 'new', it is considered as this one.- `ploidy`: an integer indicating the ploidy of the genotype; if not provided, will be guessed from the data (as the maximum from the 'snp' input vector).- `label`: an optional character string serving as a label for the genotype."", 'SlotsThe following slots are the content of instances of the class `SNPbin`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.- `snp`:: a list of vectors with the class `raw`.- `n.loc`:: an integer indicating the number of SNPs of the genotype.- `NA.posi`:: a vector of integer giving the position of missing data.- `label`:: an optional character string serving as a label for the genotype..- `ploidy`:: an integer indicating the ploidy of the genotype.', 'MethodsHere is a list of methods available for `SNPbin` objects.', 'Most of these methods are accessors, that is, functions which are used to retrieve the content of the object.', 'Specific manpages can exist for accessors with more than one argument.', ""These are indicated by a '' symbol next to the method's name."", 'This list also contains methods for conversion from `SNPbin` to other classes.- [: `signature(x = ""SNPbin"")`: usual method to subset objects in R. The argument indicates how SNPs are to be subsetted.', 'It can be a vector of signed integers or of logicals.- show: `signature(x = ""SNPbin"")`: printing of the object.- $: `signature(x = ""SNPbin"")`: similar to the @ operator; used to access the content of slots of the object.- $<-: `signature(x = ""SNPbin"")`: similar to the @ operator; used to replace the content of slots of the object.- nLoc: `signature(x = ""SNPbin"")`: returns the number of SNPs in the object.- names: `signature(x = ""SNPbin"")`: returns the names of the slots of the object.- ploidy: `signature(x = ""SNPbin"")`: returns the ploidy of the genotype.- as.integer: `signature(x = ""SNPbin"")`: converts a `SNPbin` object to a vector of integers.', ""The S4 method 'as' can be used as well (e.g."", 'as(x, ""integer"")).- cbind: `signature(x = ""SNPbin"")`: merges genotyping of the same individual at different SNPs (all stored as SNPbin objects) into a single SNPbin .- c: `signature(x = ""SNPbin"")`: same as cbind.SNPbin.', 'Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `genlight`, for storing multiple binary SNP genotypes.- `genind`, for storing other types of genetic markers.', 'Examples```r Not run: HAPLOID EXAMPLE  create a genotype of 100,000 SNPsdat <- sample(c(0,1,NA), 1e5, prob=c(.495, .495, .01), replace=TRUE)dat[1:10]x <- new(""SNPbin"", dat)xx[1:10]  subsettingas.integer(x[1:10]) try a few accessorsploidy(x)nLoc(x)head(x$snp[[1]])  internal bit-level coding check that conversion is OKidentical(as(x, ""integer""),as.integer(dat))  SHOULD BE TRUE compare the size of the objectsprint(object.size(dat), unit=""auto"")print(object.size(x), unit=""auto"")object.size(dat)/object.size(x)  EFFICIENCY OF CONVERSION TETRAPLOID EXAMPLE  create a genotype of 100,000 SNPsdat <- sample(c(0:4,NA), 1e5, prob=c(rep(.995/5,5), 0.005), replace=TRUE)x <- new(""SNPbin"", dat)identical(as(x, ""integer""),as.integer(dat))  MUST BE TRUE compare the size of the objectsprint(object.size(dat), unit=""auto"")print(object.size(x), unit=""auto"")object.size(dat)/object.size(x)  EFFICIENCY OF CONVERSION c, cbind a <- new(""SNPbin"", c(1,1,1,1,1))b <- new(""SNPbin"", c(0,0,0,0,0))abab <- c(a,b)abidentical(c(a,b),cbind(a,b))as.integer(ab) End(Not run)```']",1,"class Formal class ""SNPbin"" DescriptionThe class `SNPbin` is a formal (S4) class for storing a genotype of binary SNPs in a compact way, using a bit-level coding scheme. This storage is most efficient with haploid data, where the memory taken to represent data can reduced more than 50 times. However, `SNPbin` can be used for any level of ploidy, and still remain an efficient storage mode.A `SNPbin` object can be constructed from a vector of integers giving the number of the second allele for each locus. `SNPbin` stores a single genotype. To store multiple genotypes, use the genlight class. Objects from the class SNPbin`SNPbin` objects can be created by calls to `new(""SNPbin"", ...)`, where '...' can be the following arguments: - `snp`: a vector of integers or numeric giving numbers of copies of the second alleles for each locus. If only one unnamed argument is provided to 'new', it is considered as this one.- `ploidy`: an integer indicating the ploidy of the genotype; if not provided, will be guessed from the data (as the maximum from the 'snp' input vector).- `label`: an optional character string serving as a label for the genotype. SlotsThe following slots are the content of instances of the class `SNPbin`; note that in most cases, it is better to retrieve information via accessors (see below), rather than by accessing the slots manually.- `snp`:: a list of vectors with the class `raw`.- `n.loc`:: an integer indicating the number of SNPs of the genotype.- `NA.posi`:: a vector of integer giving the position of missing data.- `label`:: an optional character string serving as a label for the genotype..- `ploidy`:: an integer indicating the ploidy of the genotype. MethodsHere is a list of methods available for `SNPbin` objects. Most of these methods are accessors, that is, functions which are used to retrieve the content of the object. Specific manpages can exist for accessors with more than one argument. These are indicated by a '' symbol next to the method's name. This list also contains methods for conversion from `SNPbin` to other classes.- [: `signature(x = ""SNPbin"")`: usual method to subset objects in R. The argument indicates how SNPs are to be subsetted. It can be a vector of signed integers or of logicals.- show: `signature(x = ""SNPbin"")`: printing of the object.- $: `signature(x = ""SNPbin"")`: similar to the @ operator; used to access the content of slots of the object.- $<-: `signature(x = ""SNPbin"")`: similar to the @ operator; used to replace the content of slots of the object.- nLoc: `signature(x = ""SNPbin"")`: returns the number of SNPs in the object.- names: `signature(x = ""SNPbin"")`: returns the names of the slots of the object.- ploidy: `signature(x = ""SNPbin"")`: returns the ploidy of the genotype.- as.integer: `signature(x = ""SNPbin"")`: converts a `SNPbin` object to a vector of integers. The S4 method 'as' can be used as well (e.g. as(x, ""integer"")).- cbind: `signature(x = ""SNPbin"")`: merges genotyping of the same individual at different SNPs (all stored as SNPbin objects) into a single SNPbin .- c: `signature(x = ""SNPbin"")`: same as cbind.SNPbin. Author(s)Thibaut Jombart (t.jombart@imperial.ac.uk ) See AlsoRelated class:- `genlight`, for storing multiple binary SNP genotypes.- `genind`, for storing other types of genetic markers. Examples```r Not run: HAPLOID EXAMPLE  create a genotype of 100,000 SNPsdat <- sample(c(0,1,NA), 1e5, prob=c(.495, .495, .01), replace=TRUE)dat[1:10]x <- new(""SNPbin"", dat)xx[1:10]  subsettingas.integer(x[1:10]) try a few accessorsploidy(x)nLoc(x)head(x$snp[[1]])  internal bit-level coding check that conversion is OKidentical(as(x, ""integer""),as.integer(dat))  SHOULD BE TRUE compare the size of the objectsprint(object.size(dat), unit=""auto"")print(object.size(x), unit=""auto"")object.size(dat)/object.size(x)  EFFICIENCY OF CONVERSION TETRAPLOID EXAMPLE  create a genotype of 100,000 SNPsdat <- sample(c(0:4,NA), 1e5, prob=c(rep(.995/5,5), 0.005), replace=TRUE)x <- new(""SNPbin"", dat)identical(as(x, ""integer""),as.integer(dat))  MUST BE TRUE compare the size of the objectsprint(object.size(dat), unit=""auto"")print(object.size(x), unit=""auto"")object.size(dat)/object.size(x)  EFFICIENCY OF CONVERSION c, cbind a <- new(""SNPbin"", c(1,1,1,1,1))b <- new(""SNPbin"", c(0,0,0,0,0))abab <- c(a,b)abidentical(c(a,b),cbind(a,b))as.integer(ab) End(Not run)```",22
adegenet,doc_C_routines.md," data

# Internal C routines

## Format

An object of class `NULL` of length 0.

```r
.internal_C_routines
```

## Description

These functions are internal C routines used in adegenet. Do not use them unless you know what you are doing.

## Author(s)

Thibaut Jombart



","['data Internal C routines FormatAn object of class `NULL` of length 0.```r.internal_C_routines``` DescriptionThese functions are internal C routines used in adegenet.', 'Do not use them unless you know what you are doing.']",1, data Internal C routines FormatAn object of class `NULL` of length 0.```r.internal_C_routines``` DescriptionThese functions are internal C routines used in adegenet. Do not use them unless you know what you are doing. Author(s)Thibaut Jombart,22
adegenet,xvalDapc.md,"UTF-8

# Cross-validation for Discriminant Analysis of Principal Components (DAPC)

## Description

The function `xvalDapc` performs stratified cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); `xvalDapc` is a generic with methods for `data.frame` and `matrix`.

```r
xvalDapc(x, ...)

## Default S3 method:
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c(""groupMean"", ""overall""),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'data.frame'
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c(""groupMean"", ""overall""),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'matrix'
xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,
              training.set = 0.9, result = c(""groupMean"", ""overall""),
              center = TRUE, scale = FALSE,
              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...)

## S3 method for class 'genlight'
xvalDapc(x, ...)

## S3 method for class 'genind'
xvalDapc(x, ...)
```

## Arguments

- `x`: `a data.frame` or a `matrix` used as input of DAPC.
- `grp`: a `factor` indicating the group membership of individuals.
- `n.pca.max`: maximum number of PCA components to retain.
- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step. If `NULL`, n.da defaults to 1 less than the number of groups.
- `training.set`: the proportion of data (individuals) to be used for the training set; defaults to 0.9 if all groups have >= 10 members; otherwise, training.set scales automatically to the largest proportion that still ensures all groups will be present in both training and validation sets.
- `result`: a character string; ""groupMean"" for group-wise assignment sucess, or ""overall"" for an overall mean assignment success; see details.
- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind objects.
- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.
- `n.pca`: an `integer` vector indicating the number of different number of PCA axes to be retained for the cross validation; if `NULL`, this will be dertermined automatically.
- `n.rep`: the number of replicates to be carried out at each level of PC retention; defaults to 30.
- `xval.plot`: a logical indicating whether a plot of the cross-validation results should be generated.
- ``...``: further arguments to be passed to `boot`. see Details.

## Details

The Discriminant Analysis of Principal Components (DAPC) relies on dimension reduction of the data using PCA followed by a linear discriminant analysis. How many PCA axes to retain is often a non-trivial question. Cross validation provides an objective way to decide how many axes to retain: different numbers are tried and the quality of the corresponding DAPC is assessed by cross- validation: DAPC is performed on a training set, typically made of 90% of the observations (comprising 90% of the observations in each subpopulation) , and then used to predict the groups of the 10% of remaining observations. The current method uses the average prediction success per group (result=""groupMean""), or the overall prediction success (result=""overall""). The number of PCs associated with the lowest Mean Squared Error is then retained in the DAPC.

### Parallel Computing

The permutation of the data for cross-validation is performed in part by the function`boot`. If you have a modern computer, it is likely that you have multiple cores on your system. R by default utilizes only one of these cores unless you tell it otherwise. For details, please see the documentation of `boot`. Basically, if you want to use multiple cores, you need two arguments:

1. `parallel` - what R parallel system to use (see below)
2. `ncpus` - number of cores you want to use

If you are on a unix system (Linux or OSX), you will want to specify `parallel = ""multicore""`. If you are on Windows, you will want to specify `parallel = ""snow""`.

 

## Returns

A `list` containing seven items, and a `plot` of the results. The first is a `data.frame` with two columns, the first giving the number of PCs of PCA retained in the corresponding DAPC, and the second giving the proportion of successful group assignment for each replicate. The second item gives the mean and confidence interval for random chance. The third gives the mean successful assignment at each level of PC retention. The fourth indicates which number of PCs is associated with the highest mean success. The fifth gives the Root Mean Squared Error at each level of PC retention. The sixth indicates which number of PCs is associated with the lowest MSE. The seventh item contains the DAPC carried out with the optimal number of PCs, determined with reference to MSE.

If `xval.plot=TRUE` a scatterplot of the results of cross-validation will be displayed.

## References

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94

## See Also

`dapc`

## Author(s)

Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu

## Examples

```r
## Not run:

## CROSS-VALIDATION ##
data(sim2pop)
xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)
xval

## 100 replicates ##

# Serial version (SLOW!)
system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100))

# Parallel version (faster!)
system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100, 
                             parallel = ""multicore"", ncpus = 2))
## End(Not run)
```



","['UTF-8 Cross-validation for Discriminant Analysis of Principal Components (DAPC) DescriptionThe function `xvalDapc` performs stratified cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); `xvalDapc` is a generic with methods for `data.frame` and `matrix`.```rxvalDapc(x, ...) Default S3 method:xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class \'data.frame\'xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class \'matrix\'xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class \'genlight\'xvalDapc(x, ...) S3 method for class \'genind\'xvalDapc(x, ...)``` Arguments- `x`: `a data.frame` or a `matrix` used as input of DAPC.- `grp`: a `factor` indicating the group membership of individuals.- `n.pca.max`: maximum number of PCA components to retain.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step.', 'If `NULL`, n.da defaults to 1 less than the number of groups.- `training.set`: the proportion of data (individuals) to be used for the training set; defaults to 0.9 if all groups have >= 10 members; otherwise, training.set scales automatically to the largest proportion that still ensures all groups will be present in both training and validation sets.- `result`: a character string; ""groupMean"" for group-wise assignment sucess, or ""overall"" for an overall mean assignment success; see details.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE).', 'Always TRUE for genind objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default).', 'Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.- `n.pca`: an `integer` vector indicating the number of different number of PCA axes to be retained for the cross validation; if `NULL`, this will be dertermined automatically.- `n.rep`: the number of replicates to be carried out at each level of PC retention; defaults to 30.- `xval.plot`: a logical indicating whether a plot of the cross-validation results should be generated.- ``...``: further arguments to be passed to `boot`.', 'DetailsThe Discriminant Analysis of Principal Components (DAPC) relies on dimension reduction of the data using PCA followed by a linear discriminant analysis.', 'How many PCA axes to retain is often a non-trivial question.', 'Cross validation provides an objective way to decide how many axes to retain: different numbers are tried and the quality of the corresponding DAPC is assessed by cross- validation: DAPC is performed on a training set, typically made of 90% of the observations (comprising 90% of the observations in each subpopulation) , and then used to predict the groups of the 10% of remaining observations.', 'The current method uses the average prediction success per group (result=""groupMean""), or the overall prediction success (result=""overall"").', 'The number of PCs associated with the lowest Mean Squared Error is then retained in the DAPC.', 'Parallel ComputingThe permutation of the data for cross-validation is performed in part by the function`boot`.', 'If you have a modern computer, it is likely that you have multiple cores on your system.', 'R by default utilizes only one of these cores unless you tell it otherwise.', 'For details, please see the documentation of `boot`.', 'Basically, if you want to use multiple cores, you need two arguments:1.', '`parallel` - what R parallel system to use (see below)2.', '`ncpus` - number of cores you want to useIf you are on a unix system (Linux or OSX), you will want to specify `parallel = ""multicore""`.', 'If you are on Windows, you will want to specify `parallel = ""snow""`.', 'ReturnsA `list` containing seven items, and a `plot` of the results.', 'The first is a `data.frame` with two columns, the first giving the number of PCs of PCA retained in the corresponding DAPC, and the second giving the proportion of successful group assignment for each replicate.', 'The second item gives the mean and confidence interval for random chance.', 'The third gives the mean successful assignment at each level of PC retention.', 'The fourth indicates which number of PCs is associated with the highest mean success.', 'The fifth gives the Root Mean Squared Error at each level of PC retention.', 'The sixth indicates which number of PCs is associated with the lowest MSE.', 'The seventh item contains the DAPC carried out with the optimal number of PCs, determined with reference to MSE.If `xval.plot=TRUE` a scatterplot of the results of cross-validation will be displayed.', 'ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also`dapc` Author(s)Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu Examples```r Not run: CROSS-VALIDATION data(sim2pop)xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)xval 100 replicates  Serial version (SLOW!', ')system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100)) Parallel version (faster!', ')system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100,                              parallel = ""multicore"", ncpus = 2)) End(Not run)```']",1,"UTF-8 Cross-validation for Discriminant Analysis of Principal Components (DAPC) DescriptionThe function `xvalDapc` performs stratified cross-validation of DAPC using varying numbers of PCs (and keeping the number of discriminant functions fixed); `xvalDapc` is a generic with methods for `data.frame` and `matrix`.```rxvalDapc(x, ...) Default S3 method:xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class 'data.frame'xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class 'matrix'xvalDapc(x, grp, n.pca.max = 300, n.da = NULL,              training.set = 0.9, result = c(""groupMean"", ""overall""),              center = TRUE, scale = FALSE,              n.pca=NULL, n.rep = 30, xval.plot = TRUE, ...) S3 method for class 'genlight'xvalDapc(x, ...) S3 method for class 'genind'xvalDapc(x, ...)``` Arguments- `x`: `a data.frame` or a `matrix` used as input of DAPC.- `grp`: a `factor` indicating the group membership of individuals.- `n.pca.max`: maximum number of PCA components to retain.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step. If `NULL`, n.da defaults to 1 less than the number of groups.- `training.set`: the proportion of data (individuals) to be used for the training set; defaults to 0.9 if all groups have >= 10 members; otherwise, training.set scales automatically to the largest proportion that still ensures all groups will be present in both training and validation sets.- `result`: a character string; ""groupMean"" for group-wise assignment sucess, or ""overall"" for an overall mean assignment success; see details.- `center`: a `logical` indicating whether variables should be centred to mean 0 (TRUE, default) or not (FALSE). Always TRUE for genind objects.- `scale`: a `logical` indicating whether variables should be scaled (TRUE) or not (FALSE, default). Scaling consists in dividing variables by their (estimated) standard deviation to account for trivial differences in variances.- `n.pca`: an `integer` vector indicating the number of different number of PCA axes to be retained for the cross validation; if `NULL`, this will be dertermined automatically.- `n.rep`: the number of replicates to be carried out at each level of PC retention; defaults to 30.- `xval.plot`: a logical indicating whether a plot of the cross-validation results should be generated.- ``...``: further arguments to be passed to `boot`. see Details. DetailsThe Discriminant Analysis of Principal Components (DAPC) relies on dimension reduction of the data using PCA followed by a linear discriminant analysis. How many PCA axes to retain is often a non-trivial question. Cross validation provides an objective way to decide how many axes to retain: different numbers are tried and the quality of the corresponding DAPC is assessed by cross- validation: DAPC is performed on a training set, typically made of 90% of the observations (comprising 90% of the observations in each subpopulation) , and then used to predict the groups of the 10% of remaining observations. The current method uses the average prediction success per group (result=""groupMean""), or the overall prediction success (result=""overall""). The number of PCs associated with the lowest Mean Squared Error is then retained in the DAPC. Parallel ComputingThe permutation of the data for cross-validation is performed in part by the function`boot`. If you have a modern computer, it is likely that you have multiple cores on your system. R by default utilizes only one of these cores unless you tell it otherwise. For details, please see the documentation of `boot`. Basically, if you want to use multiple cores, you need two arguments:1. `parallel` - what R parallel system to use (see below)2. `ncpus` - number of cores you want to useIf you are on a unix system (Linux or OSX), you will want to specify `parallel = ""multicore""`. If you are on Windows, you will want to specify `parallel = ""snow""`.  ReturnsA `list` containing seven items, and a `plot` of the results. The first is a `data.frame` with two columns, the first giving the number of PCs of PCA retained in the corresponding DAPC, and the second giving the proportion of successful group assignment for each replicate. The second item gives the mean and confidence interval for random chance. The third gives the mean successful assignment at each level of PC retention. The fourth indicates which number of PCs is associated with the highest mean success. The fifth gives the Root Mean Squared Error at each level of PC retention. The sixth indicates which number of PCs is associated with the lowest MSE. The seventh item contains the DAPC carried out with the optimal number of PCs, determined with reference to MSE.If `xval.plot=TRUE` a scatterplot of the results of cross-validation will be displayed. ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also`dapc` Author(s)Caitlin Collins caitlin.collins12@imperial.ac.uk , Thibaut Jombart t.jombart@imperial.ac.uk , Zhian N. Kamvar kamvarz@science.oregonstate.edu Examples```r Not run: CROSS-VALIDATION data(sim2pop)xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=3)xval 100 replicates  Serial version (SLOW!)system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100)) Parallel version (faster!)system.time(xval <- xvalDapc(sim2pop@tab, pop(sim2pop), n.pca.max=100, n.rep=100,                              parallel = ""multicore"", ncpus = 2)) End(Not run)```",22
adegenet,ascore.md,"UTF-8

# Compute and optimize a-score for Discriminant Analysis of Principal Components (DAPC)

## Description

These functions are under development. Please email the author before using them for published results.

```r
a.score(x, n.sim=10, ...)

optim.a.score(x, n.pca=1:ncol(x$tab), smart=TRUE, n=10, plot=TRUE,
              n.sim=10, n.da=length(levels(x$grp)), ...)
```

## Arguments

- `x`: a `dapc` object.
- `n.pca`: a vector of `integers` indicating the number of axes retained in the Principal Component Analysis (PCA) steps of DAPC. `nsim` DAPC will be run for each value in `n.pca`, unless the smart approach is used (see details).
- `smart`: a `logical` indicating whether a smart, less computer-intensive approach should be used (TRUE, default) or not (FALSE). See details section.
- `n`: an `integer` indicating the numbers of values spanning the range of `n.pca` to be used in the smart approach.
- `plot`: a `logical` indicating whether the results should be displayed graphically (TRUE, default) or not (FALSE).
- `n.sim`: an `integer` indicating the number of simulations to be performed for each number of retained PC.
- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step.
- ``: further arguments passed to other methods; currently unused..

## Details

The Discriminant Analysis of Principal Components seeks a reduced space inside which observations are best discriminated into pre-defined groups. One way to assess the quality of the discrimination is looking at re-assignment of individuals to their prior group, successful re-assignment being a sign of strong discrimination.

However, when the original space is very large, ad hoc solutions can be found, which discriminate very well the sampled individuals but would perform poorly on new samples. In such a case, DAPC re-assignment would be high even for randomly chosen clusters. The a-score measures this bias. It is computed as (Pt-Pr), where Pt is the reassignment probability using the true cluster, and Pr is the reassignment probability for randomly permuted clusters. A a-score close to one is a sign that the DAPC solution is both strongly discriminating and stable, while low values (toward 0 or lower) indicate either weak discrimination or instability of the results.

The a-score can serve as a criterion for choosing the optimal number of PCs in the PCA step of DAPC, i.e. the number of PC maximizing the a-score. Two procedures are implemented in `optim.a.score`. The smart procedure selects evenly distributed number of PCs in a pre-defined range, compute the a-score for each, and then interpolate the results using splines, predicting an approximate optimal number of PCs. The other procedure (when `smart` is FALSE) performs the computations for all number of PCs request by the user. The 'optimal' number is then the one giving the highest mean a-score (computed over the groups).

## Returns

=== a.score ===

 `a.score` returns a list with the following components:

 - **tab**: a matrix of a-scores with groups in columns and simulations in row.

 - **pop.score**: a vector giving the mean a-score for each population.

 - **mean**: the overall mean a-score.

=== optim.a.score ===

 `optima.score` returns a list with the following components:

 - **pop.score**: a list giving the mean a-score of the populations for each number of retained PC (each element of the list corresponds to a number of retained PCs).

 - **mean**: a vector giving the overall mean a-score for each number of retained PCs.

 - **pred**: (only when `smart` is TRUE) the predictions of the spline, given in x and y coordinates.

 - **best**: the optimal number of PCs to be retained.

## References

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94

## See Also

- `find.clusters`: to identify clusters without prior.

- `dapc`: the Discriminant Analysis of Principal Components (DAPC)

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['UTF-8 Compute and optimize a-score for Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions are under development.', 'Please email the author before using them for published results.```ra.score(x, n.sim=10, ...)optim.a.score(x, n.pca=1:ncol(x$tab), smart=TRUE, n=10, plot=TRUE,              n.sim=10, n.da=length(levels(x$grp)), ...)``` Arguments- `x`: a `dapc` object.- `n.pca`: a vector of `integers` indicating the number of axes retained in the Principal Component Analysis (PCA) steps of DAPC.', '`nsim` DAPC will be run for each value in `n.pca`, unless the smart approach is used (see details).- `smart`: a `logical` indicating whether a smart, less computer-intensive approach should be used (TRUE, default) or not (FALSE).', 'See details section.- `n`: an `integer` indicating the numbers of values spanning the range of `n.pca` to be used in the smart approach.- `plot`: a `logical` indicating whether the results should be displayed graphically (TRUE, default) or not (FALSE).- `n.sim`: an `integer` indicating the number of simulations to be performed for each number of retained PC.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step.- ``: further arguments passed to other methods; currently unused.. DetailsThe Discriminant Analysis of Principal Components seeks a reduced space inside which observations are best discriminated into pre-defined groups.', 'One way to assess the quality of the discrimination is looking at re-assignment of individuals to their prior group, successful re-assignment being a sign of strong discrimination.However, when the original space is very large, ad hoc solutions can be found, which discriminate very well the sampled individuals but would perform poorly on new samples.', 'In such a case, DAPC re-assignment would be high even for randomly chosen clusters.', 'The a-score measures this bias.', 'It is computed as (Pt-Pr), where Pt is the reassignment probability using the true cluster, and Pr is the reassignment probability for randomly permuted clusters.', 'A a-score close to one is a sign that the DAPC solution is both strongly discriminating and stable, while low values (toward 0 or lower) indicate either weak discrimination or instability of the results.The a-score can serve as a criterion for choosing the optimal number of PCs in the PCA step of DAPC, i.e.', 'the number of PC maximizing the a-score.', 'Two procedures are implemented in `optim.a.score`.', 'The smart procedure selects evenly distributed number of PCs in a pre-defined range, compute the a-score for each, and then interpolate the results using splines, predicting an approximate optimal number of PCs.', 'The other procedure (when `smart` is FALSE) performs the computations for all number of PCs request by the user.', ""The 'optimal' number is then the one giving the highest mean a-score (computed over the groups)."", 'Returns=== a.score === `a.score` returns a list with the following components: - tab: a matrix of a-scores with groups in columns and simulations in row.', '- pop.score: a vector giving the mean a-score for each population.', '- mean: the overall mean a-score.=== optim.a.score === `optima.score` returns a list with the following components: - pop.score: a list giving the mean a-score of the populations for each number of retained PC (each element of the list corresponds to a number of retained PCs).', '- mean: a vector giving the overall mean a-score for each number of retained PCs.', '- pred: (only when `smart` is TRUE) the predictions of the spline, given in x and y coordinates.', '- best: the optimal number of PCs to be retained.', 'ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also- `find.clusters`: to identify clusters without prior.- `dapc`: the Discriminant Analysis of Principal Components (DAPC) Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1,"UTF-8 Compute and optimize a-score for Discriminant Analysis of Principal Components (DAPC) DescriptionThese functions are under development. Please email the author before using them for published results.```ra.score(x, n.sim=10, ...)optim.a.score(x, n.pca=1:ncol(x$tab), smart=TRUE, n=10, plot=TRUE,              n.sim=10, n.da=length(levels(x$grp)), ...)``` Arguments- `x`: a `dapc` object.- `n.pca`: a vector of `integers` indicating the number of axes retained in the Principal Component Analysis (PCA) steps of DAPC. `nsim` DAPC will be run for each value in `n.pca`, unless the smart approach is used (see details).- `smart`: a `logical` indicating whether a smart, less computer-intensive approach should be used (TRUE, default) or not (FALSE). See details section.- `n`: an `integer` indicating the numbers of values spanning the range of `n.pca` to be used in the smart approach.- `plot`: a `logical` indicating whether the results should be displayed graphically (TRUE, default) or not (FALSE).- `n.sim`: an `integer` indicating the number of simulations to be performed for each number of retained PC.- `n.da`: an `integer` indicating the number of axes retained in the Discriminant Analysis step.- ``: further arguments passed to other methods; currently unused.. DetailsThe Discriminant Analysis of Principal Components seeks a reduced space inside which observations are best discriminated into pre-defined groups. One way to assess the quality of the discrimination is looking at re-assignment of individuals to their prior group, successful re-assignment being a sign of strong discrimination.However, when the original space is very large, ad hoc solutions can be found, which discriminate very well the sampled individuals but would perform poorly on new samples. In such a case, DAPC re-assignment would be high even for randomly chosen clusters. The a-score measures this bias. It is computed as (Pt-Pr), where Pt is the reassignment probability using the true cluster, and Pr is the reassignment probability for randomly permuted clusters. A a-score close to one is a sign that the DAPC solution is both strongly discriminating and stable, while low values (toward 0 or lower) indicate either weak discrimination or instability of the results.The a-score can serve as a criterion for choosing the optimal number of PCs in the PCA step of DAPC, i.e. the number of PC maximizing the a-score. Two procedures are implemented in `optim.a.score`. The smart procedure selects evenly distributed number of PCs in a pre-defined range, compute the a-score for each, and then interpolate the results using splines, predicting an approximate optimal number of PCs. The other procedure (when `smart` is FALSE) performs the computations for all number of PCs request by the user. The 'optimal' number is then the one giving the highest mean a-score (computed over the groups). Returns=== a.score === `a.score` returns a list with the following components: - tab: a matrix of a-scores with groups in columns and simulations in row. - pop.score: a vector giving the mean a-score for each population. - mean: the overall mean a-score.=== optim.a.score === `optima.score` returns a list with the following components: - pop.score: a list giving the mean a-score of the populations for each number of retained PC (each element of the list corresponds to a number of retained PCs). - mean: a vector giving the overall mean a-score for each number of retained PCs. - pred: (only when `smart` is TRUE) the predictions of the spline, given in x and y coordinates. - best: the optimal number of PCs to be retained. ReferencesJombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics11:94. doi:10.1186/1471-2156-11-94 See Also- `find.clusters`: to identify clusters without prior.- `dapc`: the Discriminant Analysis of Principal Components (DAPC) Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",22
adegenet,spca.rtests.md,"# Global and local tests

## Description

These two Monte Carlo tests are used to assess the existence of global and local spatial structures. They can be used as an aid to interprete global and local components of spatial Principal Component Analysis (sPCA).

They rely on the decomposition of a data matrix X into global and local components using multiple regression on Moran's Eigenvector Maps (MEMs). They require a data matrix (X) and a list of weights derived from a connection network. X is regressed onto global MEMs (U+) in the global test and on local ones (U-) in the local test. One mean `R^2`

is obtained for each MEM, the k highest being summed to form the test statistic.

The reference distribution of these statistics are obtained by randomly permuting the rows of X.

```r
global.rtest(X, listw, k = 1, nperm = 499)
local.rtest(X, listw, k = 1, nperm = 499)
```

## Arguments

- `X`: a data matrix, with variables in columns
- `listw`: a list of weights of class `listw`. Can be obtained easily using the function `chooseCN`.
- `k`: integer: the number of highest `R^2` summed to form the test statistics
- `nperm`: integer: the number of randomisations to be performed.

## Details

This test is purely R code. A C or C++ version will be developped soon.

## Returns

An object of class `randtest`.

## References

Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. **Heredity**, 101 , 92--103.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`chooseCN`, `spca`, `monmonier`

## Examples

```r
## Not run:

 data(sim2pop)
if(require(spdep)){
cn <- chooseCN(sim2pop@other$xy,ask=FALSE,type=1,plot=FALSE,res=""listw"")

# global test
Gtest <- global.rtest(sim2pop@tab,cn)
Gtest

# local test
Ltest <- local.rtest(sim2pop@tab,cn)
Ltest
}
## End(Not run)
```



","['Global and local tests DescriptionThese two Monte Carlo tests are used to assess the existence of global and local spatial structures.', ""They can be used as an aid to interprete global and local components of spatial Principal Component Analysis (sPCA).They rely on the decomposition of a data matrix X into global and local components using multiple regression on Moran's Eigenvector Maps (MEMs)."", 'They require a data matrix (X) and a list of weights derived from a connection network.', 'X is regressed onto global MEMs (U+) in the global test and on local ones (U-) in the local test.', 'One mean `R^2`is obtained for each MEM, the k highest being summed to form the test statistic.The reference distribution of these statistics are obtained by randomly permuting the rows of X.```rglobal.rtest(X, listw, k = 1, nperm = 499)local.rtest(X, listw, k = 1, nperm = 499)``` Arguments- `X`: a data matrix, with variables in columns- `listw`: a list of weights of class `listw`.', 'Can be obtained easily using the function `chooseCN`.- `k`: integer: the number of highest `R^2` summed to form the test statistics- `nperm`: integer: the number of randomisations to be performed.', 'DetailsThis test is purely R code.', 'A C or C++ version will be developped soon.', 'ReturnsAn object of class `randtest`.', 'ReferencesJombart, T., Devillard, S., Dufour, A.-B.', 'and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`chooseCN`, `spca`, `monmonier` Examples```r Not run: data(sim2pop)if(require(spdep)){cn <- chooseCN(sim2pop@other$xy,ask=FALSE,type=1,plot=FALSE,res=""listw"") global testGtest <- global.rtest(sim2pop@tab,cn)Gtest local testLtest <- local.rtest(sim2pop@tab,cn)Ltest} End(Not run)```']",1," Global and local tests DescriptionThese two Monte Carlo tests are used to assess the existence of global and local spatial structures. They can be used as an aid to interprete global and local components of spatial Principal Component Analysis (sPCA).They rely on the decomposition of a data matrix X into global and local components using multiple regression on Moran's Eigenvector Maps (MEMs). They require a data matrix (X) and a list of weights derived from a connection network. X is regressed onto global MEMs (U+) in the global test and on local ones (U-) in the local test. One mean `R^2`is obtained for each MEM, the k highest being summed to form the test statistic.The reference distribution of these statistics are obtained by randomly permuting the rows of X.```rglobal.rtest(X, listw, k = 1, nperm = 499)local.rtest(X, listw, k = 1, nperm = 499)``` Arguments- `X`: a data matrix, with variables in columns- `listw`: a list of weights of class `listw`. Can be obtained easily using the function `chooseCN`.- `k`: integer: the number of highest `R^2` summed to form the test statistics- `nperm`: integer: the number of randomisations to be performed. DetailsThis test is purely R code. A C or C++ version will be developped soon. ReturnsAn object of class `randtest`. ReferencesJombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. Revealing cryptic spatial patterns in genetic variability by a new multivariate method. Heredity, 101 , 92--103. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`chooseCN`, `spca`, `monmonier` Examples```r Not run: data(sim2pop)if(require(spdep)){cn <- chooseCN(sim2pop@other$xy,ask=FALSE,type=1,plot=FALSE,res=""listw"") global testGtest <- global.rtest(sim2pop@tab,cn)Gtest local testLtest <- local.rtest(sim2pop@tab,cn)Ltest} End(Not run)```",22
adegenet,microbov.md," data

# Microsatellites genotypes of 15 cattle breeds

## Format

`microbov` is a genind object with 3 supplementary components:

- **coun**: a factor giving the country of each individual (AF: Afric; FR: France).
- **breed**: a factor giving the breed of each individual.
- **spe**: is a factor giving the species of each individual (BT: Bos taurus; BI: Bos indicus).

## Source

Data prepared by Katayoun Moazami-Goudarzi and Denis Lalo\""e (INRA, Jouy-en-Josas, France)

## Description

This data set gives the genotypes of 704 cattle individuals for 30 microsatellites recommended by the FAO. The individuals are divided into two countries (Afric, France), two species (Bos taurus, Bos indicus) and 15 breeds. Individuals were chosen in order to avoid pseudoreplication according to their exact genealogy.

## Examples

```r
## Not run:

data(microbov)
microbov
summary(microbov)

# make Y, a genpop object
Y <- genind2genpop(microbov)

# make allelic frequency table
temp <- makefreq(Y,missing=""mean"")
X <- temp$tab
nsamp <- temp$nobs

# perform 1 PCA per marker

kX <- ktab.data.frame(data.frame(X),Y@loc.n.all)

kpca <- list()
for(i in 1:30) {kpca[[i]] <- dudi.pca(kX[[i]],scannf=FALSE,nf=2,center=TRUE,scale=FALSE)}


sel <- sample(1:30,4)
col = rep('red',15)
col[c(2,10)] = 'darkred'
col[c(4,12,14)] = 'deepskyblue4'
col[c(8,15)] = 'darkblue'

# display %PCA
par(mfrow=c(2,2))
for(i in sel) {
s.multinom(kpca[[i]]$c1,kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])
add.scatter.eig(kpca[[i]]$eig,3,xax=1,yax=2,posi=""top"")
}

# perform a Multiple Coinertia Analysis
kXcent <- kX
for(i in 1:30) kXcent[[i]] <- as.data.frame(scalewt(kX[[i]],center=TRUE,scale=FALSE))
mcoa1 <- mcoa(kXcent,scannf=FALSE,nf=3, option=""uniform"")

# coordinated %PCA
mcoa.axes <- split(mcoa1$axis, Y@loc.fac)
mcoa.coord <- split(mcoa1$Tli,mcoa1$TL[,1])
var.coord <- lapply(mcoa.coord,function(e) apply(e,2,var))

par(mfrow=c(2,2))
for(i in sel) {
s.multinom(mcoa.axes[[i]][,1:2],kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])
add.scatter.eig(var.coord[[i]],2,xax=1,yax=2,posi=""top"")
}

# reference typology
par(mfrow=c(1,1))
s.label(mcoa1$SynVar,lab=popNames(microbov),sub=""Reference typology"",csub=1.5)
add.scatter.eig(mcoa1$pseudoeig,nf=3,xax=1,yax=2,posi=""top"")

# typologial values
tv <- mcoa1$cov2
tv <- apply(tv,2,function(c) c/sum(c))*100
rownames(tv) <- locNames(Y)
tv <- tv[order(locNames(Y)),]

par(mfrow=c(3,1),mar=c(5,3,3,4),las=3)
for(i in 1:3){
barplot(round(tv[,i],3),ylim=c(0,12),yaxt=""n"",main=paste(""Typological value -
structure"",i))
axis(side=2,at=seq(0,12,by=2),labels=paste(seq(0,12,by=2),""%""),cex=3)
abline(h=seq(0,12,by=2),col=""grey"",lty=2)
}
## End(Not run)
```

## References

Lalo\""e D., Jombart T., Dufour A.-B. and Moazami-Goudarzi K. (2007) Consensus genetic structuring and typological value of markers using Multiple Co-Inertia Analysis. **Genetics Selection Evolution**. 39 : 545--567.



","['data Microsatellites genotypes of 15 cattle breeds Format`microbov` is a genind object with 3 supplementary components:- coun: a factor giving the country of each individual (AF: Afric; FR: France).- breed: a factor giving the breed of each individual.- spe: is a factor giving the species of each individual (BT: Bos taurus; BI: Bos indicus).', 'SourceData prepared by Katayoun Moazami-Goudarzi and Denis Lalo\\""e (INRA, Jouy-en-Josas, France) DescriptionThis data set gives the genotypes of 704 cattle individuals for 30 microsatellites recommended by the FAO.', 'The individuals are divided into two countries (Afric, France), two species (Bos taurus, Bos indicus) and 15 breeds.', 'Individuals were chosen in order to avoid pseudoreplication according to their exact genealogy.', 'Examples```r Not run:data(microbov)microbovsummary(microbov) make Y, a genpop objectY <- genind2genpop(microbov) make allelic frequency tabletemp <- makefreq(Y,missing=""mean"")X <- temp$tabnsamp <- temp$nobs perform 1 PCA per markerkX <- ktab.data.frame(data.frame(X),Y@loc.n.all)kpca <- list()for(i in 1:30) {kpca[[i]] <- dudi.pca(kX[[i]],scannf=FALSE,nf=2,center=TRUE,scale=FALSE)}sel <- sample(1:30,4)col = rep(\'red\',15)col[c(2,10)] = \'darkred\'col[c(4,12,14)] = \'deepskyblue4\'col[c(8,15)] = \'darkblue\' display %PCApar(mfrow=c(2,2))for(i in sel) {s.multinom(kpca[[i]]$c1,kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])add.scatter.eig(kpca[[i]]$eig,3,xax=1,yax=2,posi=""top"")} perform a Multiple Coinertia AnalysiskXcent <- kXfor(i in 1:30) kXcent[[i]] <- as.data.frame(scalewt(kX[[i]],center=TRUE,scale=FALSE))mcoa1 <- mcoa(kXcent,scannf=FALSE,nf=3, option=""uniform"") coordinated %PCAmcoa.axes <- split(mcoa1$axis, Y@loc.fac)mcoa.coord <- split(mcoa1$Tli,mcoa1$TL[,1])var.coord <- lapply(mcoa.coord,function(e) apply(e,2,var))par(mfrow=c(2,2))for(i in sel) {s.multinom(mcoa.axes[[i]][,1:2],kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])add.scatter.eig(var.coord[[i]],2,xax=1,yax=2,posi=""top"")} reference typologypar(mfrow=c(1,1))s.label(mcoa1$SynVar,lab=popNames(microbov),sub=""Reference typology"",csub=1.5)add.scatter.eig(mcoa1$pseudoeig,nf=3,xax=1,yax=2,posi=""top"") typologial valuestv <- mcoa1$cov2tv <- apply(tv,2,function(c) c/sum(c))100rownames(tv) <- locNames(Y)tv <- tv[order(locNames(Y)),]par(mfrow=c(3,1),mar=c(5,3,3,4),las=3)for(i in 1:3){barplot(round(tv[,i],3),ylim=c(0,12),yaxt=""n"",main=paste(""Typological value -structure"",i))axis(side=2,at=seq(0,12,by=2),labels=paste(seq(0,12,by=2),""%""),cex=3)abline(h=seq(0,12,by=2),col=""grey"",lty=2)} End(Not run)``` ReferencesLalo\\""e D., Jombart T., Dufour A.-B.', 'and Moazami-Goudarzi K. (2007) Consensus genetic structuring and typological value of markers using Multiple Co-Inertia Analysis.']",1," data Microsatellites genotypes of 15 cattle breeds Format`microbov` is a genind object with 3 supplementary components:- coun: a factor giving the country of each individual (AF: Afric; FR: France).- breed: a factor giving the breed of each individual.- spe: is a factor giving the species of each individual (BT: Bos taurus; BI: Bos indicus). SourceData prepared by Katayoun Moazami-Goudarzi and Denis Lalo\""e (INRA, Jouy-en-Josas, France) DescriptionThis data set gives the genotypes of 704 cattle individuals for 30 microsatellites recommended by the FAO. The individuals are divided into two countries (Afric, France), two species (Bos taurus, Bos indicus) and 15 breeds. Individuals were chosen in order to avoid pseudoreplication according to their exact genealogy. Examples```r Not run:data(microbov)microbovsummary(microbov) make Y, a genpop objectY <- genind2genpop(microbov) make allelic frequency tabletemp <- makefreq(Y,missing=""mean"")X <- temp$tabnsamp <- temp$nobs perform 1 PCA per markerkX <- ktab.data.frame(data.frame(X),Y@loc.n.all)kpca <- list()for(i in 1:30) {kpca[[i]] <- dudi.pca(kX[[i]],scannf=FALSE,nf=2,center=TRUE,scale=FALSE)}sel <- sample(1:30,4)col = rep('red',15)col[c(2,10)] = 'darkred'col[c(4,12,14)] = 'deepskyblue4'col[c(8,15)] = 'darkblue' display %PCApar(mfrow=c(2,2))for(i in sel) {s.multinom(kpca[[i]]$c1,kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])add.scatter.eig(kpca[[i]]$eig,3,xax=1,yax=2,posi=""top"")} perform a Multiple Coinertia AnalysiskXcent <- kXfor(i in 1:30) kXcent[[i]] <- as.data.frame(scalewt(kX[[i]],center=TRUE,scale=FALSE))mcoa1 <- mcoa(kXcent,scannf=FALSE,nf=3, option=""uniform"") coordinated %PCAmcoa.axes <- split(mcoa1$axis, Y@loc.fac)mcoa.coord <- split(mcoa1$Tli,mcoa1$TL[,1])var.coord <- lapply(mcoa.coord,function(e) apply(e,2,var))par(mfrow=c(2,2))for(i in sel) {s.multinom(mcoa.axes[[i]][,1:2],kX[[i]],n.sample=nsamp[,i],coulrow=col,sub=locNames(Y)[i])add.scatter.eig(var.coord[[i]],2,xax=1,yax=2,posi=""top"")} reference typologypar(mfrow=c(1,1))s.label(mcoa1$SynVar,lab=popNames(microbov),sub=""Reference typology"",csub=1.5)add.scatter.eig(mcoa1$pseudoeig,nf=3,xax=1,yax=2,posi=""top"") typologial valuestv <- mcoa1$cov2tv <- apply(tv,2,function(c) c/sum(c))100rownames(tv) <- locNames(Y)tv <- tv[order(locNames(Y)),]par(mfrow=c(3,1),mar=c(5,3,3,4),las=3)for(i in 1:3){barplot(round(tv[,i],3),ylim=c(0,12),yaxt=""n"",main=paste(""Typological value -structure"",i))axis(side=2,at=seq(0,12,by=2),labels=paste(seq(0,12,by=2),""%""),cex=3)abline(h=seq(0,12,by=2),col=""grey"",lty=2)} End(Not run)``` ReferencesLalo\""e D., Jombart T., Dufour A.-B. and Moazami-Goudarzi K. (2007) Consensus genetic structuring and typological value of markers using Multiple Co-Inertia Analysis. Genetics Selection Evolution. 39 : 545--567.",22
adegenet,genind2genpop.md,"# Conversion from a genind to a genpop object

```r
genind2genpop(
  x,
  pop = NULL,
  quiet = FALSE,
  process.other = FALSE,
  other.action = mean
)
```

## Arguments

- `x`: an object of class `genind`.
- `pop`: a factor giving the population of each genotype in 'x' OR a formula specifying which strata are to be used when converting to a genpop object. If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).
- `process.other`: a logical indicating whether the `@other` slot should be processed (see details).
- `other.action`: a function to be used when processing the `@other` slot. By default, 'mean' is used.

## Returns

A genpop object. The component @other in 'x' is passed to the created genpop object.

## Description

The function `genind2genpop` converts genotypes data (genind) into alleles counts per population (genpop).

## Details

=== 'missing' argument ===

The values of the 'missing' argument in `genind2genpop` have the following effects:

- ""NA"": if all genotypes of a population for a given allele are missing, count value will be NA

- ""0"": if all genotypes of a population for a given allele are missing, count value will be 0

- ""chi2"": if all genotypes of a population for a given allele are missing, count value will be that of a theoretical count in of a Chi-squared test. This is obtained by the product of the margins sums divided by the total number of alleles.

=== processing the `@other` slot ===

Essentially, `genind2genpop` is about aggregating data per population. The function can do the same for all numeric items in the `@other` slot provided they have the same length (for vectors) or the same number of rows (matrix-like objects) as the number of genotypes. When the case is encountered and if `process.other` is TRUE, then these objects are processed using the function defined in `other.action` per population. For instance, spatial coordinates of genotypes would be averaged to obtain population coordinates.

## Examples

```r
## simple conversion
data(nancycats)
nancycats
catpop <- genind2genpop(nancycats)
catpop
summary(catpop)

## processing the @other slot
data(sim2pop)
sim2pop$other$foo <- letters
sim2pop
dim(sim2pop$other$xy) # matches the number of genotypes
sim2pop$other$foo # does not match the number of genotypes

obj <- genind2genpop(sim2pop, process.other=TRUE)
obj$other # the new xy is the populations' centre

pch <- as.numeric(pop(sim2pop))
col <- pop(sim2pop)
levels(col) <- c(""blue"",""red"")
col <- as.character(col)
plot(sim2pop$other$xy, pch=pch, col=col)
text(obj$other$xy, lab=row.names(obj$other$xy), col=c(""blue"",""red""), cex=2, font=2)
## Not run:

data(microbov)
strata(microbov) <- data.frame(other(microbov))
summary(genind2genpop(microbov)) # Conversion based on population factor
summary(genind2genpop(microbov, ~coun)) # Conversion based on country
summary(genind2genpop(microbov, ~coun/spe)) # Conversion based on country and species
## End(Not run)
```

## See Also

genind , genpop

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","[""Conversion from a genind to a genpop object```rgenind2genpop(  x,  pop = NULL,  quiet = FALSE,  process.other = FALSE,  other.action = mean)``` Arguments- `x`: an object of class `genind`.- `pop`: a factor giving the population of each genotype in 'x' OR a formula specifying which strata are to be used when converting to a genpop object."", 'If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- `process.other`: a logical indicating whether the `@other` slot should be processed (see details).- `other.action`: a function to be used when processing the `@other` slot.', ""By default, 'mean' is used."", ""The component @other in 'x' is passed to the created genpop object."", 'DescriptionThe function `genind2genpop` converts genotypes data (genind) into alleles counts per population (genpop).', 'Details=== \'missing\' argument ===The values of the \'missing\' argument in `genind2genpop` have the following effects:- ""NA"": if all genotypes of a population for a given allele are missing, count value will be NA- ""0"": if all genotypes of a population for a given allele are missing, count value will be 0- ""chi2"": if all genotypes of a population for a given allele are missing, count value will be that of a theoretical count in of a Chi-squared test.', 'This is obtained by the product of the margins sums divided by the total number of alleles.=== processing the `@other` slot ===Essentially, `genind2genpop` is about aggregating data per population.', 'The function can do the same for all numeric items in the `@other` slot provided they have the same length (for vectors) or the same number of rows (matrix-like objects) as the number of genotypes.', 'When the case is encountered and if `process.other` is TRUE, then these objects are processed using the function defined in `other.action` per population.', 'For instance, spatial coordinates of genotypes would be averaged to obtain population coordinates.', 'Examples```r simple conversiondata(nancycats)nancycatscatpop <- genind2genpop(nancycats)catpopsummary(catpop) processing the @other slotdata(sim2pop)sim2pop$other$foo <- letterssim2popdim(sim2pop$other$xy)  matches the number of genotypessim2pop$other$foo  does not match the number of genotypesobj <- genind2genpop(sim2pop, process.other=TRUE)obj$other  the new xy is the populations\' centrepch <- as.numeric(pop(sim2pop))col <- pop(sim2pop)levels(col) <- c(""blue"",""red"")col <- as.character(col)plot(sim2pop$other$xy, pch=pch, col=col)text(obj$other$xy, lab=row.names(obj$other$xy), col=c(""blue"",""red""), cex=2, font=2) Not run:data(microbov)strata(microbov) <- data.frame(other(microbov))summary(genind2genpop(microbov))  Conversion based on population factorsummary(genind2genpop(microbov, ~coun))  Conversion based on countrysummary(genind2genpop(microbov, ~coun/spe))  Conversion based on country and species End(Not run)``` See Alsogenind , genpop Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Conversion from a genind to a genpop object```rgenind2genpop(  x,  pop = NULL,  quiet = FALSE,  process.other = FALSE,  other.action = mean)``` Arguments- `x`: an object of class `genind`.- `pop`: a factor giving the population of each genotype in 'x' OR a formula specifying which strata are to be used when converting to a genpop object. If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).- `process.other`: a logical indicating whether the `@other` slot should be processed (see details).- `other.action`: a function to be used when processing the `@other` slot. By default, 'mean' is used. ReturnsA genpop object. The component @other in 'x' is passed to the created genpop object. DescriptionThe function `genind2genpop` converts genotypes data (genind) into alleles counts per population (genpop). Details=== 'missing' argument ===The values of the 'missing' argument in `genind2genpop` have the following effects:- ""NA"": if all genotypes of a population for a given allele are missing, count value will be NA- ""0"": if all genotypes of a population for a given allele are missing, count value will be 0- ""chi2"": if all genotypes of a population for a given allele are missing, count value will be that of a theoretical count in of a Chi-squared test. This is obtained by the product of the margins sums divided by the total number of alleles.=== processing the `@other` slot ===Essentially, `genind2genpop` is about aggregating data per population. The function can do the same for all numeric items in the `@other` slot provided they have the same length (for vectors) or the same number of rows (matrix-like objects) as the number of genotypes. When the case is encountered and if `process.other` is TRUE, then these objects are processed using the function defined in `other.action` per population. For instance, spatial coordinates of genotypes would be averaged to obtain population coordinates. Examples```r simple conversiondata(nancycats)nancycatscatpop <- genind2genpop(nancycats)catpopsummary(catpop) processing the @other slotdata(sim2pop)sim2pop$other$foo <- letterssim2popdim(sim2pop$other$xy)  matches the number of genotypessim2pop$other$foo  does not match the number of genotypesobj <- genind2genpop(sim2pop, process.other=TRUE)obj$other  the new xy is the populations' centrepch <- as.numeric(pop(sim2pop))col <- pop(sim2pop)levels(col) <- c(""blue"",""red"")col <- as.character(col)plot(sim2pop$other$xy, pch=pch, col=col)text(obj$other$xy, lab=row.names(obj$other$xy), col=c(""blue"",""red""), cex=2, font=2) Not run:data(microbov)strata(microbov) <- data.frame(other(microbov))summary(genind2genpop(microbov))  Conversion based on population factorsummary(genind2genpop(microbov, ~coun))  Conversion based on countrysummary(genind2genpop(microbov, ~coun/spe))  Conversion based on country and species End(Not run)``` See Alsogenind , genpop Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",23
adegenet,BIC.snapclust.md,"# Compute Bayesian Information Criterion (BIC) for snapclust

```r
## S3 method for class 'snapclust'
BIC(object, ...)
```

## Arguments

- `object`: An object returned by the function `snapclust`.
- `...`: Further arguments for compatibility with the `BIC` generic (currently not used).

## Description

Do not use. We work on that stuff. Contact us if interested.

## See Also

`snapclust` to generate clustering solutions.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","[""Compute Bayesian Information Criterion (BIC) for snapclust```r S3 method for class 'snapclust'BIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `BIC` generic (currently not used)."", 'We work on that stuff.', 'See Also`snapclust` to generate clustering solutions.']",1," Compute Bayesian Information Criterion (BIC) for snapclust```r S3 method for class 'snapclust'BIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `BIC` generic (currently not used). DescriptionDo not use. We work on that stuff. Contact us if interested. See Also`snapclust` to generate clustering solutions. Author(s)Thibaut Jombart thibautjombart@gmail.com",23
adegenet,KIC.md,"# Compute Akaike Information Criterion for small samples (AICc) for snapclust

```r
KIC(object, ...)

## S3 method for class 'snapclust'
KIC(object, ...)
```

## Arguments

- `object`: An object returned by the function `snapclust`.
- `...`: Further arguments for compatibility with the `AIC` generic (currently not used).

## Description

Do not use. We work on that stuff. Contact us if interested.

## See Also

`snapclust` to generate clustering solutions.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","[""Compute Akaike Information Criterion for small samples (AICc) for snapclust```rKIC(object, ...) S3 method for class 'snapclust'KIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used)."", 'We work on that stuff.', 'See Also`snapclust` to generate clustering solutions.']",1," Compute Akaike Information Criterion for small samples (AICc) for snapclust```rKIC(object, ...) S3 method for class 'snapclust'KIC(object, ...)``` Arguments- `object`: An object returned by the function `snapclust`.- `...`: Further arguments for compatibility with the `AIC` generic (currently not used). DescriptionDo not use. We work on that stuff. Contact us if interested. See Also`snapclust` to generate clustering solutions. Author(s)Thibaut Jombart thibautjombart@gmail.com",23
adegenet,fasta2DNAbin.md,"UTF-8

# Read large DNA alignments into R

## Description

The function `fasta2DNAbin` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), and outputs a `DNAbin` object (the efficient DNA representation from the ape package). The output contains either the full alignments, or only SNPs. This implementation is designed for memory-efficiency, and can read in larger datasets than Ape's `read.dna`.

The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.

```r
fasta2DNAbin(file, quiet=FALSE, chunkSize=10, snpOnly=FALSE)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".
    
    Can also be a connection (which will be opened for reading if necessary, and if so `close`d (and hence destroyed) at the end of the function call).
- `quiet`: a logical stating whether a conversion messages should be printed (FALSE, default) or not (TRUE).
- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.
- `snpOnly`: a logical indicating whether SNPs only should be returned.

## Returns

an object of the class `DNAbin`

## See Also

- `?DNAbin` for a description of the class `DNAbin`.

- `read.snp`: read SNPs in adegenet's '.snp' format.

- `read.PLINK`: read SNPs in PLINK's '.raw' format.

- `df2genind`: convert any multiallelic markers into adegenet genind .

- `import2genind`: read multiallelic markers from various software into adegenet.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## show the example file ##
## this is the path to the file:
myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")
myPath

## read the file
obj <- fasta2DNAbin(myPath, chunk=10) # process 10 sequences at a time
obj
## End(Not run)
```



","['UTF-8 Read large DNA alignments into R DescriptionThe function `fasta2DNAbin` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), and outputs a `DNAbin` object (the efficient DNA representation from the ape package).', 'The output contains either the full alignments, or only SNPs.', ""This implementation is designed for memory-efficiency, and can read in larger datasets than Ape's `read.dna`.The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time)."", 'The argument `chunkSize` indicates the number of genomes read at a time.', 'Increasing this value decreases the computational time required to read data in, while increasing memory requirements.```rfasta2DNAbin(file, quiet=FALSE, chunkSize=10, snpOnly=FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".', 'Can also be a connection (which will be opened for reading if necessary, and if so `close`d (and hence destroyed) at the end of the function call).- `quiet`: a logical stating whether a conversion messages should be printed (FALSE, default) or not (TRUE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `snpOnly`: a logical indicating whether SNPs only should be returned.', ""Returnsan object of the class `DNAbin` See Also- `?DNAbin` for a description of the class `DNAbin`.- `read.snp`: read SNPs in adegenet's '.snp' format.- `read.PLINK`: read SNPs in PLINK's '.raw' format.- `df2genind`: convert any multiallelic markers into adegenet genind .- `import2genind`: read multiallelic markers from various software into adegenet."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: show the example file  this is the path to the file:myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath read the fileobj <- fasta2DNAbin(myPath, chunk=10)  process 10 sequences at a timeobj End(Not run)```']",1,"UTF-8 Read large DNA alignments into R DescriptionThe function `fasta2DNAbin` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), and outputs a `DNAbin` object (the efficient DNA representation from the ape package). The output contains either the full alignments, or only SNPs. This implementation is designed for memory-efficiency, and can read in larger datasets than Ape's `read.dna`.The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.```rfasta2DNAbin(file, quiet=FALSE, chunkSize=10, snpOnly=FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".        Can also be a connection (which will be opened for reading if necessary, and if so `close`d (and hence destroyed) at the end of the function call).- `quiet`: a logical stating whether a conversion messages should be printed (FALSE, default) or not (TRUE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `snpOnly`: a logical indicating whether SNPs only should be returned. Returnsan object of the class `DNAbin` See Also- `?DNAbin` for a description of the class `DNAbin`.- `read.snp`: read SNPs in adegenet's '.snp' format.- `read.PLINK`: read SNPs in PLINK's '.raw' format.- `df2genind`: convert any multiallelic markers into adegenet genind .- `import2genind`: read multiallelic markers from various software into adegenet. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: show the example file  this is the path to the file:myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath read the fileobj <- fasta2DNAbin(myPath, chunk=10)  process 10 sequences at a timeobj End(Not run)```",23
adegenet,sim2pop.md," data

# Simulated genotypes of two georeferenced populations

## Format

`sim2pop` is a genind object with a matrix of xy coordinates as supplementary component.

## Source

Easypop version 2.0.1 was run with the following parameters:

- two diploid populations, one sex, random mating

- 1000 individuals per population

- proportion of migration: 0.002

- 20 loci

- mutation rate: 0.0001 (KAM model)

- maximum of 50 allelic states

- 1000 generations (last one taken)

## Description

This simple data set was obtained by sampling two populations evolving in a island model, simulated using Easypop (2.0.1). See `source` for simulation details. Sample sizes were respectively 100 and 30 genotypes. The genotypes were given spatial coordinates so that both populations were spatially differentiated.

## Examples

```r
## Not run:

data(sim2pop)

if(require(hierfstat)){
## try and find the Fst
temp <- genind2hierfstat(sim2pop)
varcomp.glob(temp[,1],temp[,-1])
# Fst = 0.038
}

## run monmonier algorithm

# build connection network
gab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2)

# filter random noise
pca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1)

# run the algorithm
mon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab, scanthres=FALSE)

# graphical display
temp <- sim2pop@pop
levels(temp) <- c(17,19)
temp <- as.numeric(as.character(temp))
plot(mon1)
points(sim2pop@other$xy,pch=temp,cex=2)
legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19))
## End(Not run)
```

## References

Balloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations **Journal of Heredity**, 92 : 301-302

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['data Simulated genotypes of two georeferenced populations Format`sim2pop` is a genind object with a matrix of xy coordinates as supplementary component.', 'SourceEasypop version 2.0.1 was run with the following parameters:- two diploid populations, one sex, random mating- 1000 individuals per population- proportion of migration: 0.002- 20 loci- mutation rate: 0.0001 (KAM model)- maximum of 50 allelic states- 1000 generations (last one taken) DescriptionThis simple data set was obtained by sampling two populations evolving in a island model, simulated using Easypop (2.0.1).', 'See `source` for simulation details.', 'Sample sizes were respectively 100 and 30 genotypes.', 'The genotypes were given spatial coordinates so that both populations were spatially differentiated.', 'Examples```r Not run:data(sim2pop)if(require(hierfstat)){ try and find the Fsttemp <- genind2hierfstat(sim2pop)varcomp.glob(temp[,1],temp[,-1]) Fst = 0.038} run monmonier algorithm build connection networkgab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2) filter random noisepca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1) run the algorithmmon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab, scanthres=FALSE) graphical displaytemp <- sim2pop@poplevels(temp) <- c(17,19)temp <- as.numeric(as.character(temp))plot(mon1)points(sim2pop@other$xy,pch=temp,cex=2)legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19)) End(Not run)``` ReferencesBalloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations Journal of Heredity, 92 : 301-302 Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," data Simulated genotypes of two georeferenced populations Format`sim2pop` is a genind object with a matrix of xy coordinates as supplementary component. SourceEasypop version 2.0.1 was run with the following parameters:- two diploid populations, one sex, random mating- 1000 individuals per population- proportion of migration: 0.002- 20 loci- mutation rate: 0.0001 (KAM model)- maximum of 50 allelic states- 1000 generations (last one taken) DescriptionThis simple data set was obtained by sampling two populations evolving in a island model, simulated using Easypop (2.0.1). See `source` for simulation details. Sample sizes were respectively 100 and 30 genotypes. The genotypes were given spatial coordinates so that both populations were spatially differentiated. Examples```r Not run:data(sim2pop)if(require(hierfstat)){ try and find the Fsttemp <- genind2hierfstat(sim2pop)varcomp.glob(temp[,1],temp[,-1]) Fst = 0.038} run monmonier algorithm build connection networkgab <- chooseCN(sim2pop@other$xy,ask=FALSE,type=2) filter random noisepca1 <- dudi.pca(sim2pop@tab,scale=FALSE, scannf=FALSE, nf=1) run the algorithmmon1 <- monmonier(sim2pop@other$xy,dist(pca1$l1[,1]),gab, scanthres=FALSE) graphical displaytemp <- sim2pop@poplevels(temp) <- c(17,19)temp <- as.numeric(as.character(temp))plot(mon1)points(sim2pop@other$xy,pch=temp,cex=2)legend(""topright"",leg=c(""Pop A"", ""Pop B""),pch=c(17,19)) End(Not run)``` ReferencesBalloux F (2001) Easypop (version 1.7): a computer program for oppulation genetics simulations Journal of Heredity, 92 : 301-302 Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",23
adegenet,truenames.md,"UTF-8

methods

# Restore true labels of an object

## Description

The function `truenames` returns some elements of an object (genind or genpop ) using true names (as opposed to generic labels) for individuals, markers, alleles, and population.

Important: as of adegenet_2.0-0, these functions are deprecated as true labels are used whenever possible. Please use the function `tab` instead.

```r
## S4 method for signature 'genind'
truenames(x)
## S4 method for signature 'genpop'
truenames(x)
```

## Arguments

- `x`: a genind or a genpop object

## Returns

If x$pop is empty (NULL), a matrix similar to the x$tab slot but with true labels.

If x$pop exists, a list with this matrix ($tab) and a population vector with true names ($pop).

 

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`tab`



","['UTF-8methods Restore true labels of an object DescriptionThe function `truenames` returns some elements of an object (genind or genpop ) using true names (as opposed to generic labels) for individuals, markers, alleles, and population.Important: as of adegenet_2.0-0, these functions are deprecated as true labels are used whenever possible.', ""Please use the function `tab` instead.```r S4 method for signature 'genind'truenames(x) S4 method for signature 'genpop'truenames(x)``` Arguments- `x`: a genind or a genpop object ReturnsIf x$pop is empty (NULL), a matrix similar to the x$tab slot but with true labels.If x$pop exists, a list with this matrix ($tab) and a population vector with true names ($pop)."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`tab`']",1,"UTF-8methods Restore true labels of an object DescriptionThe function `truenames` returns some elements of an object (genind or genpop ) using true names (as opposed to generic labels) for individuals, markers, alleles, and population.Important: as of adegenet_2.0-0, these functions are deprecated as true labels are used whenever possible. Please use the function `tab` instead.```r S4 method for signature 'genind'truenames(x) S4 method for signature 'genpop'truenames(x)``` Arguments- `x`: a genind or a genpop object ReturnsIf x$pop is empty (NULL), a matrix similar to the x$tab slot but with true labels.If x$pop exists, a list with this matrix ($tab) and a population vector with true names ($pop).  Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`tab`",23
adegenet,read.snp.md,"# Reading Single Nucleotide Polymorphism data

```r
read.snp(
  file,
  quiet = FALSE,
  chunkSize = 1000,
  parallel = FALSE,
  n.cores = NULL,
  ...
)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the extension "".snp"".
- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).
- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.
- ``...``: other arguments to be passed to other functions - currently not used.

## Returns

an object of the class `""genlight""`

## Description

The function `read.snp` reads a SNP data file with extension '.snp' and converts it into a genlight object. This format is devoted to handle biallelic SNP only, but can accommodate massive datasets such as complete genomes with considerably less memory than other formats.

## Details

The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.

A description of the .snp format is provided in an example file distributed with adegenet (see example below).

=== The .snp format ===

Details of the .snp format can be found in the example file distributed with adegenet (see below), or on the adegenet website (type `adegenetWeb()` in R).

## Examples

```r
## Not run:

## show the example file ##
## this is the path to the file:
system.file(""files/exampleSnpDat.snp"",package=""adegenet"")

## show its content:
file.show(system.file(""files/exampleSnpDat.snp"",package=""adegenet""))


## read the file
obj <-
read.snp(system.file(""files/exampleSnpDat.snp"",package=""adegenet""), chunk=2)
obj
as.matrix(obj)
ploidy(obj)
alleles(obj)
locNames(obj)
## End(Not run)
```

## See Also

- `?genlight` for a description of the class `""genlight""`.

- `read.PLINK`: read SNPs in PLINK's '.raw' format.

- `fasta2genlight`: extract SNPs from alignments with fasta format.

- `df2genind`: convert any multiallelic markers into adegenet `""genlight""`.

- `import2genind`: read multiallelic markers from various software into adegenet.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading Single Nucleotide Polymorphism data```rread.snp(  file,  quiet = FALSE,  chunkSize = 1000,  parallel = FALSE,  n.cores = NULL,  ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".snp"".- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used.', 'Returnsan object of the class `""genlight""` DescriptionThe function `read.snp` reads a SNP data file with extension \'.snp\' and converts it into a genlight object.', 'This format is devoted to handle biallelic SNP only, but can accommodate massive datasets such as complete genomes with considerably less memory than other formats.', 'DetailsThe function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time).', 'The argument `chunkSize` indicates the number of genomes read at a time.', 'Increasing this value decreases the computational time required to read data in, while increasing memory requirements.A description of the .snp format is provided in an example file distributed with adegenet (see example below).=== The .snp format ===Details of the .snp format can be found in the example file distributed with adegenet (see below), or on the adegenet website (type `adegenetWeb()` in R).', 'Examples```r Not run: show the example file  this is the path to the file:system.file(""files/exampleSnpDat.snp"",package=""adegenet"") show its content:file.show(system.file(""files/exampleSnpDat.snp"",package=""adegenet"")) read the fileobj <-read.snp(system.file(""files/exampleSnpDat.snp"",package=""adegenet""), chunk=2)objas.matrix(obj)ploidy(obj)alleles(obj)locNames(obj) End(Not run)``` See Also- `?genlight` for a description of the class `""genlight""`.- `read.PLINK`: read SNPs in PLINK\'s \'.raw\' format.- `fasta2genlight`: extract SNPs from alignments with fasta format.- `df2genind`: convert any multiallelic markers into adegenet `""genlight""`.- `import2genind`: read multiallelic markers from various software into adegenet.']",1," Reading Single Nucleotide Polymorphism data```rread.snp(  file,  quiet = FALSE,  chunkSize = 1000,  parallel = FALSE,  n.cores = NULL,  ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".snp"".- `quiet`: logical stating whether a conversion messages should be printed (TRUE,default) or not (FALSE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used. Returnsan object of the class `""genlight""` DescriptionThe function `read.snp` reads a SNP data file with extension '.snp' and converts it into a genlight object. This format is devoted to handle biallelic SNP only, but can accommodate massive datasets such as complete genomes with considerably less memory than other formats. DetailsThe function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.A description of the .snp format is provided in an example file distributed with adegenet (see example below).=== The .snp format ===Details of the .snp format can be found in the example file distributed with adegenet (see below), or on the adegenet website (type `adegenetWeb()` in R). Examples```r Not run: show the example file  this is the path to the file:system.file(""files/exampleSnpDat.snp"",package=""adegenet"") show its content:file.show(system.file(""files/exampleSnpDat.snp"",package=""adegenet"")) read the fileobj <-read.snp(system.file(""files/exampleSnpDat.snp"",package=""adegenet""), chunk=2)objas.matrix(obj)ploidy(obj)alleles(obj)locNames(obj) End(Not run)``` See Also- `?genlight` for a description of the class `""genlight""`.- `read.PLINK`: read SNPs in PLINK's '.raw' format.- `fasta2genlight`: extract SNPs from alignments with fasta format.- `df2genind`: convert any multiallelic markers into adegenet `""genlight""`.- `import2genind`: read multiallelic markers from various software into adegenet. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",23
adegenet,servers.md,"UTF-8

# Web servers for adegenet

## Description

The function `adegenetServer` opens up a web page providing a simple user interface for some of the functionalities implemented in adegenet. These servers have been developed using the package `shiny`.

Currently available servers include:

 * `DAPC`: a server for the Discriminant Analysis of Principal Components (see ?dapc)

## See Also

dapc

```r
adegenetServer(what=c(""DAPC""))
```

## Arguments

- `what`: a character string indicating which server to start; currently accepted values are: ""DAPC""

## Returns

The function invisibly returns NULL.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

Caitlin Collins

## Examples

```r
## Not run:

## this opens a web page for DAPC
adegenetServer()
## End(Not run)
```



","['UTF-8 Web servers for adegenet DescriptionThe function `adegenetServer` opens up a web page providing a simple user interface for some of the functionalities implemented in adegenet.', 'These servers have been developed using the package `shiny`.Currently available servers include:  `DAPC`: a server for the Discriminant Analysis of Principal Components (see ?dapc) See Alsodapc```radegenetServer(what=c(""DAPC""))``` Arguments- `what`: a character string indicating which server to start; currently accepted values are: ""DAPC"" ReturnsThe function invisibly returns NULL.', 'Author(s)Thibaut Jombart t.jombart@imperial.ac.ukCaitlin Collins Examples```r Not run: this opens a web page for DAPCadegenetServer() End(Not run)```']",1,"UTF-8 Web servers for adegenet DescriptionThe function `adegenetServer` opens up a web page providing a simple user interface for some of the functionalities implemented in adegenet. These servers have been developed using the package `shiny`.Currently available servers include:  `DAPC`: a server for the Discriminant Analysis of Principal Components (see ?dapc) See Alsodapc```radegenetServer(what=c(""DAPC""))``` Arguments- `what`: a character string indicating which server to start; currently accepted values are: ""DAPC"" ReturnsThe function invisibly returns NULL. Author(s)Thibaut Jombart t.jombart@imperial.ac.ukCaitlin Collins Examples```r Not run: this opens a web page for DAPCadegenetServer() End(Not run)```",24
adegenet,eHGDP.md," data

# Extended HGDP-CEPH dataset

## Format

`eHGDP` is a genind object with a data frame named `popInfo` as supplementary component (`eHGDP@other$popInfo`), which contains the following variables:

- **Population:**: a character vector indicating populations.
- **Region:**: a character vector indicating the geographic region of each population.
- **Label:**: a character vector indicating the correspondence with population labels used in the genind object (i.e., as output by `pop(eHGDP)`).
- **Latitude,Longitude:**: geographic coordinates of the populations, indicated as north and east degrees.

## Source

Original panel by Human Genome Diversity Project (HGDP) and Centre d'Etude du Polymorphisme Humain (CEPH). See reference [4] for Native American populations.

This copy of the dataset was prepared by Francois Balloux.

## Description

This dataset consists of 1350 individuals from native Human populations distributed worldwide typed at 678 microsatellite loci. The original HGDP-CEPH panel [1-3] has been extended by several native American populations [4]. This dataset was used to illustrate the Discriminant Analysis of Principal Components (DAPC, [5]).

## Examples

```r
## Not run:

## LOAD DATA
data(eHGDP)
eHGDP


## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use ""n.pca=1000""
dapc1 <- dapc(eHGDP, all.contrib=TRUE, scale=FALSE,
n.pca=200, n.da=80) # takes 2 minutes
dapc1

## (see ?dapc for details about the output)



## SCREEPLOT OF EIGENVALUES
barplot(dapc1$eig, main=""eHGDP - DAPC eigenvalues"",
col=c(""red"",""green"",""blue"", rep(""grey"", 1000)))



## SCATTERPLOTS
## (!) Note: colors may be inverted with respect to [5]
## as signs of principal components are arbitrary
## and change from one computer to another
##
## axes 1-2
s.label(dapc1$grp.coord[,1:2], clab=0, sub=""Axes 1-2"")
par(xpd=T)
colorplot(dapc1$grp.coord[,1:2], dapc1$grp.coord, cex=3, add=TRUE)
add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25)

## axes 2-3
s.label(dapc1$grp.coord[,2:3], clab=0, sub=""Axes 2-3"")
par(xpd=T)
colorplot(dapc1$grp.coord[,2:3], dapc1$grp.coord, cex=3, add=TRUE)
add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25)



## MAP DAPC1 RESULTS
if(require(maps)){

xy <- cbind(eHGDP$other$popInfo$Longitude, eHGDP$other$popInfo$Latitude)

par(mar=rep(.1,4))
map(fill=TRUE, col=""lightgrey"")
colorplot(xy, -dapc1$grp.coord, cex=3, add=TRUE, trans=FALSE)
}



## LOOK FOR OTHER CLUSTERS
## to reproduce results of the reference paper, use :
## grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE)
## and then
## plot(grp$Kstat, type=""b"", col=""blue"")

grp <- find.clusters(eHGDP, max.n=30, n.pca=200,
scale=FALSE, n.clust=4) # takes about 2 minutes
names(grp)

## (see ?find.clusters for details about the output)



## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use ""n.pca=1000""
dapc2 <- dapc(eHGDP, pop=grp$grp, all.contrib=TRUE,
scale=FALSE, n.pca=200, n.da=80) # takes around a 1 minute
dapc2


## PRODUCE SCATTERPLOT
scatter(dapc2) # axes 1-2
scatter(dapc2,2,3) # axes 2-3


## MAP DAPC2 RESULTS
if(require(maps)){
xy <- cbind(eHGDP$other$popInfo$Longitude,
eHGDP$other$popInfo$Latitude)

myCoords <- apply(dapc2$ind.coord, 2, tapply, pop(eHGDP), mean)

par(mar=rep(.1,4))
map(fill=TRUE, col=""lightgrey"")
colorplot(xy, myCoords, cex=3, add=TRUE, trans=FALSE)
}
## End(Not run)
```

## References

[1] Rosenberg NA, Pritchard JK, Weber JL, Cann HM, Kidd KK, et al. (2002) Genetic structure of human populations. **Science** 298: 2381-2385.

[2] Ramachandran S, Deshpande O, Roseman CC, Rosenberg NA, Feldman MW, et al. (2005) Support from the relationship of genetic and geographic distance in human populations for a serial founder effect originating in Africa. **Proc Natl Acad Sci U S A** 102: 15942-15947.

[3] Cann HM, de Toma C, Cazes L, Legrand MF, Morel V, et al. (2002) A human genome diversity cell line panel. **Science** 296: 261-262.

[4] Wang S, Lewis CM, Jakobsson M, Ramachandran S, Ray N, et al. (2007) Genetic Variation and Population Structure in Native Americans. **PLoS Genetics** 3: e185.

[5] Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to **BMC genetics**.



","['data Extended HGDP-CEPH dataset Format`eHGDP` is a genind object with a data frame named `popInfo` as supplementary component (`eHGDP@other$popInfo`), which contains the following variables:- Population:: a character vector indicating populations.- Region:: a character vector indicating the geographic region of each population.- Label:: a character vector indicating the correspondence with population labels used in the genind object (i.e., as output by `pop(eHGDP)`).- Latitude,Longitude:: geographic coordinates of the populations, indicated as north and east degrees.', ""SourceOriginal panel by Human Genome Diversity Project (HGDP) and Centre d'Etude du Polymorphisme Humain (CEPH)."", 'See reference [4] for Native American populations.This copy of the dataset was prepared by Francois Balloux.', 'DescriptionThis dataset consists of 1350 individuals from native Human populations distributed worldwide typed at 678 microsatellite loci.', 'The original HGDP-CEPH panel [1-3] has been extended by several native American populations [4].', 'This dataset was used to illustrate the Discriminant Analysis of Principal Components (DAPC, [5]).', 'Examples```r Not run: LOAD DATAdata(eHGDP)eHGDP PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc1 <- dapc(eHGDP, all.contrib=TRUE, scale=FALSE,n.pca=200, n.da=80)  takes 2 minutesdapc1 (see ?dapc for details about the output) SCREEPLOT OF EIGENVALUESbarplot(dapc1$eig, main=""eHGDP - DAPC eigenvalues"",col=c(""red"",""green"",""blue"", rep(""grey"", 1000))) SCATTERPLOTS (!)', 'Note: colors may be inverted with respect to [5] as signs of principal components are arbitrary and change from one computer to another axes 1-2s.label(dapc1$grp.coord[,1:2], clab=0, sub=""Axes 1-2"")par(xpd=T)colorplot(dapc1$grp.coord[,1:2], dapc1$grp.coord, cex=3, add=TRUE)add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25) axes 2-3s.label(dapc1$grp.coord[,2:3], clab=0, sub=""Axes 2-3"")par(xpd=T)colorplot(dapc1$grp.coord[,2:3], dapc1$grp.coord, cex=3, add=TRUE)add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25) MAP DAPC1 RESULTSif(require(maps)){xy <- cbind(eHGDP$other$popInfo$Longitude, eHGDP$other$popInfo$Latitude)par(mar=rep(.1,4))map(fill=TRUE, col=""lightgrey"")colorplot(xy, -dapc1$grp.coord, cex=3, add=TRUE, trans=FALSE)} LOOK FOR OTHER CLUSTERS to reproduce results of the reference paper, use : grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE) and then plot(grp$Kstat, type=""b"", col=""blue"")grp <- find.clusters(eHGDP, max.n=30, n.pca=200,scale=FALSE, n.clust=4)  takes about 2 minutesnames(grp) (see ?find.clusters for details about the output) PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc2 <- dapc(eHGDP, pop=grp$grp, all.contrib=TRUE,scale=FALSE, n.pca=200, n.da=80)  takes around a 1 minutedapc2 PRODUCE SCATTERPLOTscatter(dapc2)  axes 1-2scatter(dapc2,2,3)  axes 2-3 MAP DAPC2 RESULTSif(require(maps)){xy <- cbind(eHGDP$other$popInfo$Longitude,eHGDP$other$popInfo$Latitude)myCoords <- apply(dapc2$ind.coord, 2, tapply, pop(eHGDP), mean)par(mar=rep(.1,4))map(fill=TRUE, col=""lightgrey"")colorplot(xy, myCoords, cex=3, add=TRUE, trans=FALSE)} End(Not run)``` References[1] Rosenberg NA, Pritchard JK, Weber JL, Cann HM, Kidd KK, et al.', '(2002) Genetic structure of human populations.', '[2] Ramachandran S, Deshpande O, Roseman CC, Rosenberg NA, Feldman MW, et al.', '(2005) Support from the relationship of genetic and geographic distance in human populations for a serial founder effect originating in Africa.', 'Proc Natl Acad Sci U S A 102: 15942-15947.', '[3] Cann HM, de Toma C, Cazes L, Legrand MF, Morel V, et al.', '(2002) A human genome diversity cell line panel.', '[4] Wang S, Lewis CM, Jakobsson M, Ramachandran S, Ray N, et al.', '(2007) Genetic Variation and Population Structure in Native Americans.', '[5] Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.']",1," data Extended HGDP-CEPH dataset Format`eHGDP` is a genind object with a data frame named `popInfo` as supplementary component (`eHGDP@other$popInfo`), which contains the following variables:- Population:: a character vector indicating populations.- Region:: a character vector indicating the geographic region of each population.- Label:: a character vector indicating the correspondence with population labels used in the genind object (i.e., as output by `pop(eHGDP)`).- Latitude,Longitude:: geographic coordinates of the populations, indicated as north and east degrees. SourceOriginal panel by Human Genome Diversity Project (HGDP) and Centre d'Etude du Polymorphisme Humain (CEPH). See reference [4] for Native American populations.This copy of the dataset was prepared by Francois Balloux. DescriptionThis dataset consists of 1350 individuals from native Human populations distributed worldwide typed at 678 microsatellite loci. The original HGDP-CEPH panel [1-3] has been extended by several native American populations [4]. This dataset was used to illustrate the Discriminant Analysis of Principal Components (DAPC, [5]). Examples```r Not run: LOAD DATAdata(eHGDP)eHGDP PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc1 <- dapc(eHGDP, all.contrib=TRUE, scale=FALSE,n.pca=200, n.da=80)  takes 2 minutesdapc1 (see ?dapc for details about the output) SCREEPLOT OF EIGENVALUESbarplot(dapc1$eig, main=""eHGDP - DAPC eigenvalues"",col=c(""red"",""green"",""blue"", rep(""grey"", 1000))) SCATTERPLOTS (!) Note: colors may be inverted with respect to [5] as signs of principal components are arbitrary and change from one computer to another axes 1-2s.label(dapc1$grp.coord[,1:2], clab=0, sub=""Axes 1-2"")par(xpd=T)colorplot(dapc1$grp.coord[,1:2], dapc1$grp.coord, cex=3, add=TRUE)add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25) axes 2-3s.label(dapc1$grp.coord[,2:3], clab=0, sub=""Axes 2-3"")par(xpd=T)colorplot(dapc1$grp.coord[,2:3], dapc1$grp.coord, cex=3, add=TRUE)add.scatter.eig(dapc1$eig,10,1,2, posi=""bottomright"", ratio=.3, csub=1.25) MAP DAPC1 RESULTSif(require(maps)){xy <- cbind(eHGDP$other$popInfo$Longitude, eHGDP$other$popInfo$Latitude)par(mar=rep(.1,4))map(fill=TRUE, col=""lightgrey"")colorplot(xy, -dapc1$grp.coord, cex=3, add=TRUE, trans=FALSE)} LOOK FOR OTHER CLUSTERS to reproduce results of the reference paper, use : grp <- find.clusters(eHGDP, max.n=50, n.pca=200, scale=FALSE) and then plot(grp$Kstat, type=""b"", col=""blue"")grp <- find.clusters(eHGDP, max.n=30, n.pca=200,scale=FALSE, n.clust=4)  takes about 2 minutesnames(grp) (see ?find.clusters for details about the output) PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc2 <- dapc(eHGDP, pop=grp$grp, all.contrib=TRUE,scale=FALSE, n.pca=200, n.da=80)  takes around a 1 minutedapc2 PRODUCE SCATTERPLOTscatter(dapc2)  axes 1-2scatter(dapc2,2,3)  axes 2-3 MAP DAPC2 RESULTSif(require(maps)){xy <- cbind(eHGDP$other$popInfo$Longitude,eHGDP$other$popInfo$Latitude)myCoords <- apply(dapc2$ind.coord, 2, tapply, pop(eHGDP), mean)par(mar=rep(.1,4))map(fill=TRUE, col=""lightgrey"")colorplot(xy, myCoords, cex=3, add=TRUE, trans=FALSE)} End(Not run)``` References[1] Rosenberg NA, Pritchard JK, Weber JL, Cann HM, Kidd KK, et al. (2002) Genetic structure of human populations. Science 298: 2381-2385.[2] Ramachandran S, Deshpande O, Roseman CC, Rosenberg NA, Feldman MW, et al. (2005) Support from the relationship of genetic and geographic distance in human populations for a serial founder effect originating in Africa. Proc Natl Acad Sci U S A 102: 15942-15947.[3] Cann HM, de Toma C, Cazes L, Legrand MF, Morel V, et al. (2002) A human genome diversity cell line panel. Science 296: 261-262.[4] Wang S, Lewis CM, Jakobsson M, Ramachandran S, Ray N, et al. (2007) Genetic Variation and Population Structure in Native Americans. PLoS Genetics 3: e185.[5] Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to BMC genetics.",24
adegenet,minorAllele.md,"# Compute minor allele frequency

```r
minorAllele(x)
```

## Arguments

- `x`: a genind object

## Description

This function computes the minor allele frequency for each locus in a genind object. To test if loci are polymorphic, see the function `isPoly`.

## Examples

```r
## Not run:


## LOAD DATA
data(nancycats)

## COMPUTE ALLELE FREQUENCIES
x <- nancycats
apply(tab(x, freq=TRUE),2,mean, na.rm=TRUE)

## GET MINOR ALLELE FREQUENCY
m.freq <- minorAllele(x)
m.freq
## End(Not run)
```

## See Also

`isPoly`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Compute minor allele frequency```rminorAllele(x)``` Arguments- `x`: a genind object DescriptionThis function computes the minor allele frequency for each locus in a genind object.', 'To test if loci are polymorphic, see the function `isPoly`.', 'Examples```r Not run: LOAD DATAdata(nancycats) COMPUTE ALLELE FREQUENCIESx <- nancycatsapply(tab(x, freq=TRUE),2,mean, na.rm=TRUE) GET MINOR ALLELE FREQUENCYm.freq <- minorAllele(x)m.freq End(Not run)``` See Also`isPoly` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Compute minor allele frequency```rminorAllele(x)``` Arguments- `x`: a genind object DescriptionThis function computes the minor allele frequency for each locus in a genind object. To test if loci are polymorphic, see the function `isPoly`. Examples```r Not run: LOAD DATAdata(nancycats) COMPUTE ALLELE FREQUENCIESx <- nancycatsapply(tab(x, freq=TRUE),2,mean, na.rm=TRUE) GET MINOR ALLELE FREQUENCYm.freq <- minorAllele(x)m.freq End(Not run)``` See Also`isPoly` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",24
adegenet,snapclust.md,"# Maximum-likelihood genetic clustering using EM algorithm

```r
snapclust(
  x,
  k,
  pop.ini = ""ward"",
  max.iter = 100,
  n.start = 10,
  n.start.kmeans = 50,
  hybrids = FALSE,
  dim.ini = 100,
  hybrid.coef = NULL,
  parent.lab = c(""A"", ""B""),
  ...
)
```

## Arguments

- `x`: a genind object
- `k`: the number of clusters to look for
- `pop.ini`: parameter indicating how the initial group membership should be found. If `NULL`, groups are chosen at random, and the algorithm will be run `n.start times`. If ""kmeans"", then the function `find.clusters` is used to define initial groups using the K-means algorithm. If ""ward"", then the function `find.clusters` is used to define initial groups using the Ward algorithm. Alternatively, a factor defining the initial cluster configuration can be provided.
- `max.iter`: the maximum number of iteration of the EM algorithm
- `n.start`: the number of times the EM algorithm is run, each time with different random starting conditions
- `n.start.kmeans`: the number of times the K-means algorithm is run to define the starting point of the ML-EM algorithm, each time with different random starting conditions
- `hybrids`: a logical indicating if hybrids should be modelled explicitely; this is currently implemented for 2 groups only.
- `dim.ini`: the number of PCA axes to retain in the dimension reduction step for `find.clusters`, if this method is used to define initial group memberships (see argument `pop.ini`).
- `hybrid.coef`: a vector of hybridization coefficients, defining the proportion of hybrid gene pool coming from the first parental population; this is symmetrized around 0.5, so that e.g. c(0.25, 0.5) will be converted to c(0.25, 0.5, 0.75)
- `parent.lab`: a vector of 2 character strings used to label the two parental populations; only used if hybrids are detected (see argument `hybrids`)
- `...`: further arguments passed on to `find.clusters`

## Returns

The function `snapclust` returns a list with the following components:

 * `$group` a factor indicating the maximum-likelihood assignment of individuals to groups; if identified, hybrids are labelled after hybridization coefficients, e.g. 0.5_A - 0.5_B for F1, 0.75_A - 0.25_B for backcross F1 / A, etc.
 * `$ll`: the log-likelihood of the model
 * `$proba`: a matrix of group membership probabilities, with individuals in rows and groups in columns; each value correspond to the probability that a given individual genotype was generated under a given group, under Hardy-Weinberg hypotheses.
 * `$converged` a logical indicating if the algorithm converged; if FALSE, it is doubtful that the result is an actual Maximum Likelihood estimate.
 * `$n.iter` an integer indicating the number of iterations the EM algorithm was run for.

## Description

This function implements the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018). The underlying model is very close to the model implemented by STRUCTURE, but allows for much faster estimation of genetic clusters thanks to the use of the Expectation-Maximization (EM) algorithm. Optionally, the model can explicitely account for hybridization and detect different types of hybrids (see `hybrids` and `hybrid.coef` arguments). The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`.

## Details

The method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem. Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") . A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`.

## Examples

```r
## Not run:

data(microbov)

## try function using k-means initialization
grp.ini <- find.clusters(microbov, n.clust=15, n.pca=150)

## run EM algo
res <- snapclust(microbov, 15, pop.ini = grp.ini$grp)
names(res)
res$converged
res$n.iter

## plot result
compoplot(res)

## flag potential hybrids
to.flag <- apply(res$proba,1,max)<.9
compoplot(res, subset=to.flag, show.lab=TRUE,
                 posi=""bottomleft"", bg=""white"")


## Simulate hybrids F1
zebu <- microbov[pop=""Zebu""]
salers <- microbov[pop=""Salers""]
hyb <- hybridize(zebu, salers, n=30)
x <- repool(zebu, salers, hyb)

## method without hybrids
res.no.hyb <- snapclust(x, k=2, hybrids=FALSE)
compoplot(res.no.hyb, col.pal=spectral, n.col=2)

## method with hybrids
res.hyb <- snapclust(x, k=2, hybrids=TRUE)
compoplot(res.hyb, col.pal =
          hybridpal(col.pal = spectral), n.col = 2)


## Simulate hybrids backcross (F1 / parental)
f1.zebu <- hybridize(hyb, zebu, 20, pop = ""f1.zebu"")
f1.salers <- hybridize(hyb, salers, 25, pop = ""f1.salers"")
y <- repool(x, f1.zebu, f1.salers)

## method without hybrids
res2.no.hyb <- snapclust(y, k = 2, hybrids = FALSE)
compoplot(res2.no.hyb, col.pal = hybridpal(), n.col = 2)

## method with hybrids F1 only
res2.hyb <- snapclust(y, k = 2, hybrids = TRUE)
compoplot(res2.hyb, col.pal = hybridpal(), n.col = 2)

## method with back-cross
res2.back <- snapclust(y, k = 2, hybrids = TRUE, hybrid.coef = c(.25,.5))
compoplot(res2.back, col.pal = hybridpal(), n.col = 2)
## End(Not run)
```

## See Also

The function `snapclust.choose.k` to investigate the optimal value number of clusters 'k'.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com and Marie-Pauline Beugin



","['Maximum-likelihood genetic clustering using EM algorithm```rsnapclust(  x,  k,  pop.ini = ""ward"",  max.iter = 100,  n.start = 10,  n.start.kmeans = 50,  hybrids = FALSE,  dim.ini = 100,  hybrid.coef = NULL,  parent.lab = c(""A"", ""B""),  ...)``` Arguments- `x`: a genind object- `k`: the number of clusters to look for- `pop.ini`: parameter indicating how the initial group membership should be found.', 'If `NULL`, groups are chosen at random, and the algorithm will be run `n.start times`.', 'If ""kmeans"", then the function `find.clusters` is used to define initial groups using the K-means algorithm.', 'If ""ward"", then the function `find.clusters` is used to define initial groups using the Ward algorithm.', 'Alternatively, a factor defining the initial cluster configuration can be provided.- `max.iter`: the maximum number of iteration of the EM algorithm- `n.start`: the number of times the EM algorithm is run, each time with different random starting conditions- `n.start.kmeans`: the number of times the K-means algorithm is run to define the starting point of the ML-EM algorithm, each time with different random starting conditions- `hybrids`: a logical indicating if hybrids should be modelled explicitely; this is currently implemented for 2 groups only.- `dim.ini`: the number of PCA axes to retain in the dimension reduction step for `find.clusters`, if this method is used to define initial group memberships (see argument `pop.ini`).- `hybrid.coef`: a vector of hybridization coefficients, defining the proportion of hybrid gene pool coming from the first parental population; this is symmetrized around 0.5, so that e.g.', 'c(0.25, 0.5) will be converted to c(0.25, 0.5, 0.75)- `parent.lab`: a vector of 2 character strings used to label the two parental populations; only used if hybrids are detected (see argument `hybrids`)- `...`: further arguments passed on to `find.clusters` ReturnsThe function `snapclust` returns a list with the following components:  `$group` a factor indicating the maximum-likelihood assignment of individuals to groups; if identified, hybrids are labelled after hybridization coefficients, e.g.', '0.5_A - 0.5_B for F1, 0.75_A - 0.25_B for backcross F1 / A, etc.', '`$ll`: the log-likelihood of the model  `$proba`: a matrix of group membership probabilities, with individuals in rows and groups in columns; each value correspond to the probability that a given individual genotype was generated under a given group, under Hardy-Weinberg hypotheses.', '`$converged` a logical indicating if the algorithm converged; if FALSE, it is doubtful that the result is an actual Maximum Likelihood estimate.', '`$n.iter` an integer indicating the number of iterations the EM algorithm was run for.', 'DescriptionThis function implements the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018).', 'The underlying model is very close to the model implemented by STRUCTURE, but allows for much faster estimation of genetic clusters thanks to the use of the Expectation-Maximization (EM) algorithm.', 'Optionally, the model can explicitely account for hybridization and detect different types of hybrids (see `hybrids` and `hybrid.coef` arguments).', 'The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`.', 'DetailsThe method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem.', 'Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") .', 'A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`.', 'Examples```r Not run:data(microbov) try function using k-means initializationgrp.ini <- find.clusters(microbov, n.clust=15, n.pca=150) run EM algores <- snapclust(microbov, 15, pop.ini = grp.ini$grp)names(res)res$convergedres$n.iter plot resultcompoplot(res) flag potential hybridsto.flag <- apply(res$proba,1,max)<.9compoplot(res, subset=to.flag, show.lab=TRUE,                 posi=""bottomleft"", bg=""white"") Simulate hybrids F1zebu <- microbov[pop=""Zebu""]salers <- microbov[pop=""Salers""]hyb <- hybridize(zebu, salers, n=30)x <- repool(zebu, salers, hyb) method without hybridsres.no.hyb <- snapclust(x, k=2, hybrids=FALSE)compoplot(res.no.hyb, col.pal=spectral, n.col=2) method with hybridsres.hyb <- snapclust(x, k=2, hybrids=TRUE)compoplot(res.hyb, col.pal =          hybridpal(col.pal = spectral), n.col = 2) Simulate hybrids backcross (F1 / parental)f1.zebu <- hybridize(hyb, zebu, 20, pop = ""f1.zebu"")f1.salers <- hybridize(hyb, salers, 25, pop = ""f1.salers"")y <- repool(x, f1.zebu, f1.salers) method without hybridsres2.no.hyb <- snapclust(y, k = 2, hybrids = FALSE)compoplot(res2.no.hyb, col.pal = hybridpal(), n.col = 2) method with hybrids F1 onlyres2.hyb <- snapclust(y, k = 2, hybrids = TRUE)compoplot(res2.hyb, col.pal = hybridpal(), n.col = 2) method with back-crossres2.back <- snapclust(y, k = 2, hybrids = TRUE, hybrid.coef = c(.25,.5))compoplot(res2.back, col.pal = hybridpal(), n.col = 2) End(Not run)``` See AlsoThe function `snapclust.choose.k` to investigate the optimal value number of clusters \'k\'.', 'Author(s)Thibaut Jombart thibautjombart@gmail.com and Marie-Pauline Beugin']",1," Maximum-likelihood genetic clustering using EM algorithm```rsnapclust(  x,  k,  pop.ini = ""ward"",  max.iter = 100,  n.start = 10,  n.start.kmeans = 50,  hybrids = FALSE,  dim.ini = 100,  hybrid.coef = NULL,  parent.lab = c(""A"", ""B""),  ...)``` Arguments- `x`: a genind object- `k`: the number of clusters to look for- `pop.ini`: parameter indicating how the initial group membership should be found. If `NULL`, groups are chosen at random, and the algorithm will be run `n.start times`. If ""kmeans"", then the function `find.clusters` is used to define initial groups using the K-means algorithm. If ""ward"", then the function `find.clusters` is used to define initial groups using the Ward algorithm. Alternatively, a factor defining the initial cluster configuration can be provided.- `max.iter`: the maximum number of iteration of the EM algorithm- `n.start`: the number of times the EM algorithm is run, each time with different random starting conditions- `n.start.kmeans`: the number of times the K-means algorithm is run to define the starting point of the ML-EM algorithm, each time with different random starting conditions- `hybrids`: a logical indicating if hybrids should be modelled explicitely; this is currently implemented for 2 groups only.- `dim.ini`: the number of PCA axes to retain in the dimension reduction step for `find.clusters`, if this method is used to define initial group memberships (see argument `pop.ini`).- `hybrid.coef`: a vector of hybridization coefficients, defining the proportion of hybrid gene pool coming from the first parental population; this is symmetrized around 0.5, so that e.g. c(0.25, 0.5) will be converted to c(0.25, 0.5, 0.75)- `parent.lab`: a vector of 2 character strings used to label the two parental populations; only used if hybrids are detected (see argument `hybrids`)- `...`: further arguments passed on to `find.clusters` ReturnsThe function `snapclust` returns a list with the following components:  `$group` a factor indicating the maximum-likelihood assignment of individuals to groups; if identified, hybrids are labelled after hybridization coefficients, e.g. 0.5_A - 0.5_B for F1, 0.75_A - 0.25_B for backcross F1 / A, etc.  `$ll`: the log-likelihood of the model  `$proba`: a matrix of group membership probabilities, with individuals in rows and groups in columns; each value correspond to the probability that a given individual genotype was generated under a given group, under Hardy-Weinberg hypotheses.  `$converged` a logical indicating if the algorithm converged; if FALSE, it is doubtful that the result is an actual Maximum Likelihood estimate.  `$n.iter` an integer indicating the number of iterations the EM algorithm was run for. DescriptionThis function implements the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018). The underlying model is very close to the model implemented by STRUCTURE, but allows for much faster estimation of genetic clusters thanks to the use of the Expectation-Maximization (EM) algorithm. Optionally, the model can explicitely account for hybridization and detect different types of hybrids (see `hybrids` and `hybrid.coef` arguments). The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`. DetailsThe method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem. Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") . A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`. Examples```r Not run:data(microbov) try function using k-means initializationgrp.ini <- find.clusters(microbov, n.clust=15, n.pca=150) run EM algores <- snapclust(microbov, 15, pop.ini = grp.ini$grp)names(res)res$convergedres$n.iter plot resultcompoplot(res) flag potential hybridsto.flag <- apply(res$proba,1,max)<.9compoplot(res, subset=to.flag, show.lab=TRUE,                 posi=""bottomleft"", bg=""white"") Simulate hybrids F1zebu <- microbov[pop=""Zebu""]salers <- microbov[pop=""Salers""]hyb <- hybridize(zebu, salers, n=30)x <- repool(zebu, salers, hyb) method without hybridsres.no.hyb <- snapclust(x, k=2, hybrids=FALSE)compoplot(res.no.hyb, col.pal=spectral, n.col=2) method with hybridsres.hyb <- snapclust(x, k=2, hybrids=TRUE)compoplot(res.hyb, col.pal =          hybridpal(col.pal = spectral), n.col = 2) Simulate hybrids backcross (F1 / parental)f1.zebu <- hybridize(hyb, zebu, 20, pop = ""f1.zebu"")f1.salers <- hybridize(hyb, salers, 25, pop = ""f1.salers"")y <- repool(x, f1.zebu, f1.salers) method without hybridsres2.no.hyb <- snapclust(y, k = 2, hybrids = FALSE)compoplot(res2.no.hyb, col.pal = hybridpal(), n.col = 2) method with hybrids F1 onlyres2.hyb <- snapclust(y, k = 2, hybrids = TRUE)compoplot(res2.hyb, col.pal = hybridpal(), n.col = 2) method with back-crossres2.back <- snapclust(y, k = 2, hybrids = TRUE, hybrid.coef = c(.25,.5))compoplot(res2.back, col.pal = hybridpal(), n.col = 2) End(Not run)``` See AlsoThe function `snapclust.choose.k` to investigate the optimal value number of clusters 'k'. Author(s)Thibaut Jombart thibautjombart@gmail.com and Marie-Pauline Beugin",24
adegenet,population-methods.md," methods

# Manipulate the population factor of genind objects.

```r
setPop(x, formula = NULL)

setPop(x) <- value
```

## Arguments

- `x`: a genind or genlight object
- `formula`: a nested formula indicating the order of the population strata.
- `value`: same as formula

## Description

The following methods allow the user to quickly change the population of a genind object.

## Examples

```r
data(microbov)

strata(microbov) <- data.frame(other(microbov))

# Currently set on just 
head(pop(microbov)) 

# setting the strata to both Pop and Subpop
setPop(microbov) <- ~coun/breed 
head(pop(microbov))

## Not run:


# Can be used to create objects as well.
microbov.old <- setPop(microbov, ~spe) 
head(pop(microbov.old))
## End(Not run)
```

## Author(s)

Zhian N. Kamvar



","['methods Manipulate the population factor of genind objects.```rsetPop(x, formula = NULL)setPop(x) <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population strata.- `value`: same as formula DescriptionThe following methods allow the user to quickly change the population of a genind object.', 'Examples```rdata(microbov)strata(microbov) <- data.frame(other(microbov)) Currently set on just head(pop(microbov))  setting the strata to both Pop and SubpopsetPop(microbov) <- ~coun/breed head(pop(microbov)) Not run: Can be used to create objects as well.microbov.old <- setPop(microbov, ~spe) head(pop(microbov.old)) End(Not run)``` Author(s)Zhian N. Kamvar']",1," methods Manipulate the population factor of genind objects.```rsetPop(x, formula = NULL)setPop(x) <- value``` Arguments- `x`: a genind or genlight object- `formula`: a nested formula indicating the order of the population strata.- `value`: same as formula DescriptionThe following methods allow the user to quickly change the population of a genind object. Examples```rdata(microbov)strata(microbov) <- data.frame(other(microbov)) Currently set on just head(pop(microbov))  setting the strata to both Pop and SubpopsetPop(microbov) <- ~coun/breed head(pop(microbov)) Not run: Can be used to create objects as well.microbov.old <- setPop(microbov, ~spe) head(pop(microbov.old)) End(Not run)``` Author(s)Zhian N. Kamvar",24
adegenet,read.structure.md,"# Reading data from STRUCTURE

```r
read.structure(
  file,
  n.ind = NULL,
  n.loc = NULL,
  onerowperind = NULL,
  col.lab = NULL,
  col.pop = NULL,
  col.others = NULL,
  row.marknames = NULL,
  NA.char = ""-9"",
  pop = NULL,
  sep = NULL,
  ask = TRUE,
  quiet = FALSE
)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the appropriate extension.
- `n.ind`: an integer giving the number of genotypes (or 'individuals') in the dataset
- `n.loc`: an integer giving the number of markers in the dataset
- `onerowperind`: a STRUCTURE coding option: are genotypes coded on a single row (TRUE), or on two rows (FALSE, default)
- `col.lab`: an integer giving the index of the column containing labels of genotypes. '0' if absent.
- `col.pop`: an integer giving the index of the column containing population to which genotypes belong. '0' if absent.
- `col.others`: an vector of integers giving the indexes of the columns containing other informations to be read. Will be available in @other of the created object.
- `row.marknames`: an integer giving the index of the row containing the names of the markers. '0' if absent.
- `NA.char`: the character string coding missing data. ""-9"" by default. Note that in any case, series of zero (like ""000"") are interpreted as NA too.
- `pop`: an optional factor giving the population of each individual.
- `sep`: a character string used as separator between alleles.
- `ask`: a logical specifying if the function should ask for optional informations about the dataset (TRUE, default), or try to be as quiet as possible (FALSE).
- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).

## Returns

an object of the class `genind`

## Description

The function `read.structure` reads STRUCTURE data files (.str ou .stru) and convert them into a genind object. By default, this function is interactive and asks a few questions about data content. This can be disabled (for optional questions) by turning the 'ask' argument to FALSE. However, one has to know the number of genotypes, of markers and if genotypes are coded on a single or on two rows before importing data.

## Details

Note: `read.structure` is meant for DIPLOID DATA ONLY. Haploid data with the STRUCTURE format can easily be read into R using `read.table` or `read.csv` and then converted using `df2genind`.

## Examples

```r
obj <- read.structure(system.file(""files/nancycats.str"",package=""adegenet""),
  onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)

obj
```

## References

Pritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data. **Genetics**, 155 : 945-959

## See Also

`import2genind`, `df2genind`, `read.fstat`, `read.genetix`, `read.genepop`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Reading data from STRUCTURE```rread.structure(  file,  n.ind = NULL,  n.loc = NULL,  onerowperind = NULL,  col.lab = NULL,  col.pop = NULL,  col.others = NULL,  row.marknames = NULL,  NA.char = ""-9"",  pop = NULL,  sep = NULL,  ask = TRUE,  quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `n.ind`: an integer giving the number of genotypes (or \'individuals\') in the dataset- `n.loc`: an integer giving the number of markers in the dataset- `onerowperind`: a STRUCTURE coding option: are genotypes coded on a single row (TRUE), or on two rows (FALSE, default)- `col.lab`: an integer giving the index of the column containing labels of genotypes.', ""'0' if absent.- `col.pop`: an integer giving the index of the column containing population to which genotypes belong."", ""'0' if absent.- `col.others`: an vector of integers giving the indexes of the columns containing other informations to be read."", 'Will be available in @other of the created object.- `row.marknames`: an integer giving the index of the row containing the names of the markers.', ""'0' if absent.- `NA.char`: the character string coding missing data."", 'Note that in any case, series of zero (like ""000"") are interpreted as NA too.- `pop`: an optional factor giving the population of each individual.- `sep`: a character string used as separator between alleles.- `ask`: a logical specifying if the function should ask for optional informations about the dataset (TRUE, default), or try to be as quiet as possible (FALSE).- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE).', 'Returnsan object of the class `genind` DescriptionThe function `read.structure` reads STRUCTURE data files (.str ou .stru) and convert them into a genind object.', 'By default, this function is interactive and asks a few questions about data content.', ""This can be disabled (for optional questions) by turning the 'ask' argument to FALSE."", 'However, one has to know the number of genotypes, of markers and if genotypes are coded on a single or on two rows before importing data.', 'DetailsNote: `read.structure` is meant for DIPLOID DATA ONLY.', 'Haploid data with the STRUCTURE format can easily be read into R using `read.table` or `read.csv` and then converted using `df2genind`.', 'Examples```robj <- read.structure(system.file(""files/nancycats.str"",package=""adegenet""),  onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)obj``` ReferencesPritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data.', 'Genetics, 155 : 945-959 See Also`import2genind`, `df2genind`, `read.fstat`, `read.genetix`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Reading data from STRUCTURE```rread.structure(  file,  n.ind = NULL,  n.loc = NULL,  onerowperind = NULL,  col.lab = NULL,  col.pop = NULL,  col.others = NULL,  row.marknames = NULL,  NA.char = ""-9"",  pop = NULL,  sep = NULL,  ask = TRUE,  quiet = FALSE)``` Arguments- `file`: a character string giving the path to the file to convert, with the appropriate extension.- `n.ind`: an integer giving the number of genotypes (or 'individuals') in the dataset- `n.loc`: an integer giving the number of markers in the dataset- `onerowperind`: a STRUCTURE coding option: are genotypes coded on a single row (TRUE), or on two rows (FALSE, default)- `col.lab`: an integer giving the index of the column containing labels of genotypes. '0' if absent.- `col.pop`: an integer giving the index of the column containing population to which genotypes belong. '0' if absent.- `col.others`: an vector of integers giving the indexes of the columns containing other informations to be read. Will be available in @other of the created object.- `row.marknames`: an integer giving the index of the row containing the names of the markers. '0' if absent.- `NA.char`: the character string coding missing data. ""-9"" by default. Note that in any case, series of zero (like ""000"") are interpreted as NA too.- `pop`: an optional factor giving the population of each individual.- `sep`: a character string used as separator between alleles.- `ask`: a logical specifying if the function should ask for optional informations about the dataset (TRUE, default), or try to be as quiet as possible (FALSE).- `quiet`: logical stating whether a conversion message must be printed (TRUE,default) or not (FALSE). Returnsan object of the class `genind` DescriptionThe function `read.structure` reads STRUCTURE data files (.str ou .stru) and convert them into a genind object. By default, this function is interactive and asks a few questions about data content. This can be disabled (for optional questions) by turning the 'ask' argument to FALSE. However, one has to know the number of genotypes, of markers and if genotypes are coded on a single or on two rows before importing data. DetailsNote: `read.structure` is meant for DIPLOID DATA ONLY. Haploid data with the STRUCTURE format can easily be read into R using `read.table` or `read.csv` and then converted using `df2genind`. Examples```robj <- read.structure(system.file(""files/nancycats.str"",package=""adegenet""),  onerowperind=FALSE, n.ind=237, n.loc=9, col.lab=1, col.pop=2, ask=FALSE)obj``` ReferencesPritchard, J.; Stephens, M. & Donnelly, P. (2000) Inference of population structure using multilocus genotype data. Genetics, 155 : 945-959 See Also`import2genind`, `df2genind`, `read.fstat`, `read.genetix`, `read.genepop` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",24
adegenet,Hs.md,"# Expected heterozygosity (Hs)

```r
Hs(x, pop = NULL)
```

## Arguments

- `x`: a genind or genpop object.
- `pop`: only used if x is a genind ; an optional factor to be used as population; if not provided, pop(x) is used.

## Returns

a vector of Hs values (one value per population)

## Description

This function computes the expected heterozygosity (Hs) within populations of a genpop object. This function is available for codominant markers (`@type=""codom""`) only. Hs is commonly used for measuring within population genetic diversity (and as such, it still has sense when computed from haploid data).

## Details

Let **m(k)** be the number of alleles of locus **k**, with a total of **K** loci. We note `f_i` the allele frequency of allele **i** in a given population. Then, `Hs` is given for a given population by:

`\frac{1}{K} \sum_{k=1}^K (1 - \sum_{i=1}^{m(k)} f_i^2)`

## Examples

```r
## Not run:

data(nancycats)
Hs(genind2genpop(nancycats))
## End(Not run)
```

## See Also

`Hs.test` to test differences in Hs between two groups

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Expected heterozygosity (Hs)```rHs(x, pop = NULL)``` Arguments- `x`: a genind or genpop object.- `pop`: only used if x is a genind ; an optional factor to be used as population; if not provided, pop(x) is used.', 'Returnsa vector of Hs values (one value per population) DescriptionThis function computes the expected heterozygosity (Hs) within populations of a genpop object.', 'This function is available for codominant markers (`@type=""codom""`) only.', 'Hs is commonly used for measuring within population genetic diversity (and as such, it still has sense when computed from haploid data).', 'DetailsLet m(k) be the number of alleles of locus k, with a total of K loci.', 'We note `f_i` the allele frequency of allele i in a given population.', 'Then, `Hs` is given for a given population by:`\\frac{1}{K} \\sum_{k=1}^K (1 - \\sum_{i=1}^{m(k)} f_i^2)` Examples```r Not run:data(nancycats)Hs(genind2genpop(nancycats)) End(Not run)``` See Also`Hs.test` to test differences in Hs between two groups Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Expected heterozygosity (Hs)```rHs(x, pop = NULL)``` Arguments- `x`: a genind or genpop object.- `pop`: only used if x is a genind ; an optional factor to be used as population; if not provided, pop(x) is used. Returnsa vector of Hs values (one value per population) DescriptionThis function computes the expected heterozygosity (Hs) within populations of a genpop object. This function is available for codominant markers (`@type=""codom""`) only. Hs is commonly used for measuring within population genetic diversity (and as such, it still has sense when computed from haploid data). DetailsLet m(k) be the number of alleles of locus k, with a total of K loci. We note `f_i` the allele frequency of allele i in a given population. Then, `Hs` is given for a given population by:`\frac{1}{K} \sum_{k=1}^K (1 - \sum_{i=1}^{m(k)} f_i^2)` Examples```r Not run:data(nancycats)Hs(genind2genpop(nancycats)) End(Not run)``` See Also`Hs.test` to test differences in Hs between two groups Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",24
adegenet,mutations.md,"UTF-8

# Identify mutations between DNA sequences

## Description

The function `findMutations` identifies mutations (position and nature) of pairs of aligned DNA sequences. The function `graphMutations` does the same thing but plotting mutations on a directed graph.

Both functions are generics, but the only methods implemented in adegenet so far is for `DNAbin` objects.

```r
findMutations(...)

## S3 method for class 'DNAbin'
findMutations(x, from=NULL, to=NULL, allcomb=TRUE, ...)

graphMutations(...)

## S3 method for class 'DNAbin'
graphMutations(x, from=NULL, to=NULL, allcomb=TRUE, plot=TRUE,
               curved.edges=TRUE, ...)
```

## Arguments

- `x`: a `DNAbin` object containing aligned sequences, as a matrix.
- `from`: a vector indicating the DNA sequences from which mutations should be found. If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).
- `to`: a vector indicating the DNA sequences to which mutations should be found. If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).
- `allcomb`: a logical indicating whether all combinations of sequences (from and to) should be considered (TRUE, default), or not (FALSE).
- `plot`: a logical indicating whether the graph should be plotted.
- `curved.edges`: a logical indicating whether the edges of the graph should be curved.
- ``...``: further arguments to be passed to other methods. Used in `graphMutations` where it is passed to the plot method for `igraph` objects.

## Returns

For `findMutations`, a named list indicating the mutations from one sequence to another. For each comparison, a three-column matrix is provided, corresponding to the nucleotides in first and second sequence, and a summary of the mutation provided as: [position]:[nucleotide in first sequence]->[nucleotide in second sequence].

For `graphMutations`, a graph with the class `igraph`.

## See Also

The `fasta2DNAbin` to read fasta alignments with minimum RAM use.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk .

## Examples

```r
## Not run:

data(woodmouse)

## mutations between first 3 sequences
findMutations(woodmouse[1:3,])

## mutations from the first to sequences 2 and 3
findMutations(woodmouse[1:3,], from=1)

## same, graphical display
g <- graphMutations(woodmouse[1:3,], from=1)

## some manual checks
as.character(woodmouse)[1:3,35]
as.character(woodmouse)[1:3,36]
as.character(woodmouse)[1:3,106]
## End(Not run)
```



","['UTF-8 Identify mutations between DNA sequences DescriptionThe function `findMutations` identifies mutations (position and nature) of pairs of aligned DNA sequences.', ""The function `graphMutations` does the same thing but plotting mutations on a directed graph.Both functions are generics, but the only methods implemented in adegenet so far is for `DNAbin` objects.```rfindMutations(...) S3 method for class 'DNAbin'findMutations(x, from=NULL, to=NULL, allcomb=TRUE, ...)graphMutations(...) S3 method for class 'DNAbin'graphMutations(x, from=NULL, to=NULL, allcomb=TRUE, plot=TRUE,               curved.edges=TRUE, ...)``` Arguments- `x`: a `DNAbin` object containing aligned sequences, as a matrix.- `from`: a vector indicating the DNA sequences from which mutations should be found."", 'If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).- `to`: a vector indicating the DNA sequences to which mutations should be found.', 'If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).- `allcomb`: a logical indicating whether all combinations of sequences (from and to) should be considered (TRUE, default), or not (FALSE).- `plot`: a logical indicating whether the graph should be plotted.- `curved.edges`: a logical indicating whether the edges of the graph should be curved.- ``...``: further arguments to be passed to other methods.', 'Used in `graphMutations` where it is passed to the plot method for `igraph` objects.', 'ReturnsFor `findMutations`, a named list indicating the mutations from one sequence to another.', 'For each comparison, a three-column matrix is provided, corresponding to the nucleotides in first and second sequence, and a summary of the mutation provided as: [position]:[nucleotide in first sequence]->[nucleotide in second sequence].For `graphMutations`, a graph with the class `igraph`.', 'See AlsoThe `fasta2DNAbin` to read fasta alignments with minimum RAM use.', 'Examples```r Not run:data(woodmouse) mutations between first 3 sequencesfindMutations(woodmouse[1:3,]) mutations from the first to sequences 2 and 3findMutations(woodmouse[1:3,], from=1) same, graphical displayg <- graphMutations(woodmouse[1:3,], from=1) some manual checksas.character(woodmouse)[1:3,35]as.character(woodmouse)[1:3,36]as.character(woodmouse)[1:3,106] End(Not run)```']",1,"UTF-8 Identify mutations between DNA sequences DescriptionThe function `findMutations` identifies mutations (position and nature) of pairs of aligned DNA sequences. The function `graphMutations` does the same thing but plotting mutations on a directed graph.Both functions are generics, but the only methods implemented in adegenet so far is for `DNAbin` objects.```rfindMutations(...) S3 method for class 'DNAbin'findMutations(x, from=NULL, to=NULL, allcomb=TRUE, ...)graphMutations(...) S3 method for class 'DNAbin'graphMutations(x, from=NULL, to=NULL, allcomb=TRUE, plot=TRUE,               curved.edges=TRUE, ...)``` Arguments- `x`: a `DNAbin` object containing aligned sequences, as a matrix.- `from`: a vector indicating the DNA sequences from which mutations should be found. If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).- `to`: a vector indicating the DNA sequences to which mutations should be found. If `NULL`, all sequences are considered (i.e., `1:nrow(x)`).- `allcomb`: a logical indicating whether all combinations of sequences (from and to) should be considered (TRUE, default), or not (FALSE).- `plot`: a logical indicating whether the graph should be plotted.- `curved.edges`: a logical indicating whether the edges of the graph should be curved.- ``...``: further arguments to be passed to other methods. Used in `graphMutations` where it is passed to the plot method for `igraph` objects. ReturnsFor `findMutations`, a named list indicating the mutations from one sequence to another. For each comparison, a three-column matrix is provided, corresponding to the nucleotides in first and second sequence, and a summary of the mutation provided as: [position]:[nucleotide in first sequence]->[nucleotide in second sequence].For `graphMutations`, a graph with the class `igraph`. See AlsoThe `fasta2DNAbin` to read fasta alignments with minimum RAM use. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk . Examples```r Not run:data(woodmouse) mutations between first 3 sequencesfindMutations(woodmouse[1:3,]) mutations from the first to sequences 2 and 3findMutations(woodmouse[1:3,], from=1) same, graphical displayg <- graphMutations(woodmouse[1:3,], from=1) some manual checksas.character(woodmouse)[1:3,35]as.character(woodmouse)[1:3,36]as.character(woodmouse)[1:3,106] End(Not run)```",25
adegenet,rupica.md," data

utf-8

# Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France)

## Format

`rupica` is a genind object with 3 supplementary components inside the `@other` slot:

- **xy**: a matrix containing the spatial coordinates of the genotypes.
- **mnt**: a raster map of elevation, with the `asc` format from the `adehabitat` package.
- **showBauges**: a function to display the map of elevation with an appropriate legend (use `showBauges()`).

## Source

Daniel Maillard, 'Office National de la Chasse et de la Faune Sauvage' (ONCFS), France.

## Description

This data set contains the genotypes of 335 chamois (**Rupicapra rupicapra**) from the Bauges mountains, in France. No prior clustering about individuals is known. Each genotype is georeferenced. These data also contain a raster map of elevation of the sampling area.

## Examples

```r
data(rupica)
rupica


## Not run:

required_packages <- require(adehabitat) &&
  require(adespatial) &&
  require(spdep)
if (required_packages) {

## see the sampling area
showBauges <- rupica$other$showBauges
showBauges()
points(rupica$other$xy,col=""red"")

## perform a sPCA
spca1 <- spca(rupica,type=5,d1=0,d2=2300,plot=FALSE,scannf=FALSE,nfposi=2,nfnega=0)
barplot(spca1$eig,col=rep(c(""black"",""grey""),c(2,100)),main=""sPCA eigenvalues"")
screeplot(spca1,main=""sPCA eigenvalues: decomposition"")

## data visualization
showBauges(,labcex=1)
s.value(spca1$xy,spca1$ls[,1],add.p=TRUE,csize=.5)
add.scatter.eig(spca1$eig,1,1,1,posi=""topleft"",sub=""Eigenvalues"")

showBauges(,labcex=1)
s.value(spca1$xy,spca1$ls[,2],add.p=TRUE,csize=.5)
add.scatter.eig(spca1$eig,2,2,2,posi=""topleft"",sub=""Eigenvalues"")

rupica$other$showBauges()
colorplot(spca1$xy,spca1$li,cex=1.5,add.plot=TRUE)

## global and local tests
Gtest <- global.rtest(rupica@tab,spca1$lw,nperm=999)
Gtest
plot(Gtest)
Ltest <- local.rtest(rupica@tab,spca1$lw,nperm=999)
Ltest
plot(Ltest)
}
## End(Not run)
```

## References

Cassar S (2008) Organisation spatiale de la variabilité génétique et phénotypique a l'échelle du paysage: le cas du chamois et du chevreuil, en milieu de montagne. PhD Thesis. University Claude Bernard - Lyon 1, France.

Cassar S, Jombart T, Loison A, Pontier D, Dufour A-B, Jullien J-M, Chevrier T, Maillard D. Spatial genetic structure of Alpine chamois (**Rupicapra rupicapra**): a consequence of landscape features and social factors? submitted to **Molecular Ecology**.



","['datautf-8 Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France) Format`rupica` is a genind object with 3 supplementary components inside the `@other` slot:- xy: a matrix containing the spatial coordinates of the genotypes.- mnt: a raster map of elevation, with the `asc` format from the `adehabitat` package.- showBauges: a function to display the map of elevation with an appropriate legend (use `showBauges()`).', ""SourceDaniel Maillard, 'Office National de la Chasse et de la Faune Sauvage' (ONCFS), France."", 'DescriptionThis data set contains the genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains, in France.', 'No prior clustering about individuals is known.', 'These data also contain a raster map of elevation of the sampling area.', 'Examples```rdata(rupica)rupica Not run:required_packages <- require(adehabitat) &&  require(adespatial) &&  require(spdep)if (required_packages) { see the sampling areashowBauges <- rupica$other$showBaugesshowBauges()points(rupica$other$xy,col=""red"") perform a sPCAspca1 <- spca(rupica,type=5,d1=0,d2=2300,plot=FALSE,scannf=FALSE,nfposi=2,nfnega=0)barplot(spca1$eig,col=rep(c(""black"",""grey""),c(2,100)),main=""sPCA eigenvalues"")screeplot(spca1,main=""sPCA eigenvalues: decomposition"") data visualizationshowBauges(,labcex=1)s.value(spca1$xy,spca1$ls[,1],add.p=TRUE,csize=.5)add.scatter.eig(spca1$eig,1,1,1,posi=""topleft"",sub=""Eigenvalues"")showBauges(,labcex=1)s.value(spca1$xy,spca1$ls[,2],add.p=TRUE,csize=.5)add.scatter.eig(spca1$eig,2,2,2,posi=""topleft"",sub=""Eigenvalues"")rupica$other$showBauges()colorplot(spca1$xy,spca1$li,cex=1.5,add.plot=TRUE) global and local testsGtest <- global.rtest(rupica@tab,spca1$lw,nperm=999)Gtestplot(Gtest)Ltest <- local.rtest(rupica@tab,spca1$lw,nperm=999)Ltestplot(Ltest)} End(Not run)``` ReferencesCassar S (2008) Organisation spatiale de la variabilité génétique et phénotypique a l\'échelle du paysage: le cas du chamois et du chevreuil, en milieu de montagne.', 'University Claude Bernard - Lyon 1, France.Cassar S, Jombart T, Loison A, Pontier D, Dufour A-B, Jullien J-M, Chevrier T, Maillard D. Spatial genetic structure of Alpine chamois (Rupicapra rupicapra): a consequence of landscape features and social factors?']",1," datautf-8 Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France) Format`rupica` is a genind object with 3 supplementary components inside the `@other` slot:- xy: a matrix containing the spatial coordinates of the genotypes.- mnt: a raster map of elevation, with the `asc` format from the `adehabitat` package.- showBauges: a function to display the map of elevation with an appropriate legend (use `showBauges()`). SourceDaniel Maillard, 'Office National de la Chasse et de la Faune Sauvage' (ONCFS), France. DescriptionThis data set contains the genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains, in France. No prior clustering about individuals is known. Each genotype is georeferenced. These data also contain a raster map of elevation of the sampling area. Examples```rdata(rupica)rupica Not run:required_packages <- require(adehabitat) &&  require(adespatial) &&  require(spdep)if (required_packages) { see the sampling areashowBauges <- rupica$other$showBaugesshowBauges()points(rupica$other$xy,col=""red"") perform a sPCAspca1 <- spca(rupica,type=5,d1=0,d2=2300,plot=FALSE,scannf=FALSE,nfposi=2,nfnega=0)barplot(spca1$eig,col=rep(c(""black"",""grey""),c(2,100)),main=""sPCA eigenvalues"")screeplot(spca1,main=""sPCA eigenvalues: decomposition"") data visualizationshowBauges(,labcex=1)s.value(spca1$xy,spca1$ls[,1],add.p=TRUE,csize=.5)add.scatter.eig(spca1$eig,1,1,1,posi=""topleft"",sub=""Eigenvalues"")showBauges(,labcex=1)s.value(spca1$xy,spca1$ls[,2],add.p=TRUE,csize=.5)add.scatter.eig(spca1$eig,2,2,2,posi=""topleft"",sub=""Eigenvalues"")rupica$other$showBauges()colorplot(spca1$xy,spca1$li,cex=1.5,add.plot=TRUE) global and local testsGtest <- global.rtest(rupica@tab,spca1$lw,nperm=999)Gtestplot(Gtest)Ltest <- local.rtest(rupica@tab,spca1$lw,nperm=999)Ltestplot(Ltest)} End(Not run)``` ReferencesCassar S (2008) Organisation spatiale de la variabilité génétique et phénotypique a l'échelle du paysage: le cas du chamois et du chevreuil, en milieu de montagne. PhD Thesis. University Claude Bernard - Lyon 1, France.Cassar S, Jombart T, Loison A, Pontier D, Dufour A-B, Jullien J-M, Chevrier T, Maillard D. Spatial genetic structure of Alpine chamois (Rupicapra rupicapra): a consequence of landscape features and social factors? submitted to Molecular Ecology.",25
adegenet,fasta2genlight.md,"UTF-8

# Extract Single Nucleotide Polymorphism (SNPs) from alignments

## Description

The function `fasta2genlight` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), extracts the binary SNPs, and converts the output into a genlight object.

The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.

Multiple cores can be used to decrease the overall computational time on parallel architectures (needs the package `parallel`).

```r
fasta2genlight(file, quiet = FALSE, chunkSize = 1000, saveNbAlleles = FALSE,
               parallel = FALSE, n.cores = NULL, ...)
```

## Arguments

- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".
- `quiet`: logical stating whether a conversion messages should be printed (FALSE,default) or not (TRUE).
- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.
- `saveNbAlleles`: a logical indicating whether the number of alleles for each loci in the original alignment should be saved in the `other` slot (TRUE), or not (FALSE, default). In large genomes, this takes some space but allows for tracking SNPs with more than 2 alleles, lost during the conversion.
- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).
- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.
- ``...``: other arguments to be passed to other functions - currently not used.

## Details

 === Using multiple cores ===

Most recent machines have one or several processors with multiple cores. R processes usually use one single core. The package `parallel` allows for parallelizing some computations on multiple cores, which decreases drastically computational time.

To use this functionality, you need to have the last version of the `parallel` package installed.

## Returns

an object of the class genlight

## See Also

- `?genlight` for a description of the class genlight .

- `read.snp`: read SNPs in adegenet's '.snp' format.

- `read.PLINK`: read SNPs in PLINK's '.raw' format.

- `df2genind`: convert any multiallelic markers into adegenet genind .

- `import2genind`: read multiallelic markers from various software into adegenet.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## Examples

```r
## Not run:

## show the example file ##
## this is the path to the file:
myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")
myPath

## read the file
obj <- fasta2genlight(myPath, chunk=10) # process 10 sequences at a time
obj

## look at extracted information
position(obj)
alleles(obj)
locNames(obj)

## plot positions of polymorphic sites
temp <- density(position(obj), bw=10)
plot(temp, xlab=""Position in the alignment"", lwd=2, main=""Location of the SNPs"")
points(position(obj), rep(0, nLoc(obj)), pch=""|"", col=""red"")
## End(Not run)
```



","['UTF-8 Extract Single Nucleotide Polymorphism (SNPs) from alignments DescriptionThe function `fasta2genlight` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), extracts the binary SNPs, and converts the output into a genlight object.The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time).', 'The argument `chunkSize` indicates the number of genomes read at a time.', 'Increasing this value decreases the computational time required to read data in, while increasing memory requirements.Multiple cores can be used to decrease the overall computational time on parallel architectures (needs the package `parallel`).```rfasta2genlight(file, quiet = FALSE, chunkSize = 1000, saveNbAlleles = FALSE,               parallel = FALSE, n.cores = NULL, ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".- `quiet`: logical stating whether a conversion messages should be printed (FALSE,default) or not (TRUE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `saveNbAlleles`: a logical indicating whether the number of alleles for each loci in the original alignment should be saved in the `other` slot (TRUE), or not (FALSE, default).', 'In large genomes, this takes some space but allows for tracking SNPs with more than 2 alleles, lost during the conversion.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used.', 'Details === Using multiple cores ===Most recent machines have one or several processors with multiple cores.', 'R processes usually use one single core.', 'The package `parallel` allows for parallelizing some computations on multiple cores, which decreases drastically computational time.To use this functionality, you need to have the last version of the `parallel` package installed.', ""Returnsan object of the class genlight See Also- `?genlight` for a description of the class genlight .- `read.snp`: read SNPs in adegenet's '.snp' format.- `read.PLINK`: read SNPs in PLINK's '.raw' format.- `df2genind`: convert any multiallelic markers into adegenet genind .- `import2genind`: read multiallelic markers from various software into adegenet."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: show the example file  this is the path to the file:myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath read the fileobj <- fasta2genlight(myPath, chunk=10)  process 10 sequences at a timeobj look at extracted informationposition(obj)alleles(obj)locNames(obj) plot positions of polymorphic sitestemp <- density(position(obj), bw=10)plot(temp, xlab=""Position in the alignment"", lwd=2, main=""Location of the SNPs"")points(position(obj), rep(0, nLoc(obj)), pch=""|"", col=""red"") End(Not run)```']",1,"UTF-8 Extract Single Nucleotide Polymorphism (SNPs) from alignments DescriptionThe function `fasta2genlight` reads alignments with the fasta format (extensions "".fasta"", "".fas"", or "".fa""), extracts the binary SNPs, and converts the output into a genlight object.The function reads data by chunks of a few genomes (minimum 1, no maximum) at a time, which allows one to read massive datasets with negligible RAM requirements (albeit at a cost of computational time). The argument `chunkSize` indicates the number of genomes read at a time. Increasing this value decreases the computational time required to read data in, while increasing memory requirements.Multiple cores can be used to decrease the overall computational time on parallel architectures (needs the package `parallel`).```rfasta2genlight(file, quiet = FALSE, chunkSize = 1000, saveNbAlleles = FALSE,               parallel = FALSE, n.cores = NULL, ...)``` Arguments- `file`: a character string giving the path to the file to convert, with the extension "".fa"", "".fas"", or "".fasta"".- `quiet`: logical stating whether a conversion messages should be printed (FALSE,default) or not (TRUE).- `chunkSize`: an integer indicating the number of genomes to be read at a time; larger values require more RAM but decrease the time needed to read the data.- `saveNbAlleles`: a logical indicating whether the number of alleles for each loci in the original alignment should be saved in the `other` slot (TRUE), or not (FALSE, default). In large genomes, this takes some space but allows for tracking SNPs with more than 2 alleles, lost during the conversion.- `parallel`: a logical indicating whether multiple cores -if available- should be used for the computations (TRUE, default), or not (FALSE); requires the package `parallel` to be installed (see details).- `n.cores`: if `parallel` is TRUE, the number of cores to be used in the computations; if NULL, then the maximum number of cores available on the computer is used.- ``...``: other arguments to be passed to other functions - currently not used. Details === Using multiple cores ===Most recent machines have one or several processors with multiple cores. R processes usually use one single core. The package `parallel` allows for parallelizing some computations on multiple cores, which decreases drastically computational time.To use this functionality, you need to have the last version of the `parallel` package installed. Returnsan object of the class genlight See Also- `?genlight` for a description of the class genlight .- `read.snp`: read SNPs in adegenet's '.snp' format.- `read.PLINK`: read SNPs in PLINK's '.raw' format.- `df2genind`: convert any multiallelic markers into adegenet genind .- `import2genind`: read multiallelic markers from various software into adegenet. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk Examples```r Not run: show the example file  this is the path to the file:myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath read the fileobj <- fasta2genlight(myPath, chunk=10)  process 10 sequences at a timeobj look at extracted informationposition(obj)alleles(obj)locNames(obj) plot positions of polymorphic sitestemp <- density(position(obj), bw=10)plot(temp, xlab=""Position in the alignment"", lwd=2, main=""Location of the SNPs"")points(position(obj), rep(0, nLoc(obj)), pch=""|"", col=""red"") End(Not run)```",25
adegenet,H3N2.md," data

# Seasonal influenza (H3N2) HA segment data

## Format

`H3N2` is a genind object with several data frame as supplementary components (`H3N2@other) slort`, which contains the following items:

- **x**: a `data.frame` containing miscellaneous annotations of the sequences.
- **xy**: a matrix with two columns indicating the geographic coordinates of the strains, as longitudes and latitudes.
- **epid**: a character vector indicating the epidemic of the strains.

## Source

This dataset was prepared by Thibaut Jombart (t.jombart@imperia.ac.uk), from annotated sequences available on Genbank (http://www.ncbi.nlm.nih.gov/Genbank/).

## Description

The dataset `H3N2` consists of 1903 strains of seasonal influenza (H3N2) distributed worldwide, and typed at 125 SNPs located in the hemagglutinin (HA) segment. It is stored as an R object with class genind and can be accessed as usual using `data(H3N2)` (see example). These data were gathered from DNA sequences available from Genbank (http://www.ncbi.nlm.nih.gov/Genbank/).

## Details

The data file `usflu.fasta` is a toy dataset also gathered from Genbank, consisting of the aligned sequences of 80 seasonal influenza isolates (HA segment) sampled in the US, in `fasta` format. This file is installed alongside the package; the path to this file is automatically determined by R using `system.file` (see example in this manpage and in ?fasta2genlight) as well.

## Examples

```r
## Not run:

#### H3N2 ####
## LOAD DATA
data(H3N2)
H3N2

## set population to yearly epidemics
pop(H3N2) <- factor(H3N2$other$epid)



## PERFORM DAPC - USE POPULATIONS AS CLUSTERS
## to reproduce exactly analyses from the paper, use ""n.pca=1000""
dapc1 <- dapc(H3N2, all.contrib=TRUE, scale=FALSE, n.pca=150, n.da=5)
dapc1

## (see ?dapc for details about the output)


## SCREEPLOT OF EIGENVALUES
barplot(dapc1$eig, main=""H3N2 - DAPC eigenvalues"")


## SCATTERPLOT (axes 1-2)
scatter(dapc1, posi.da=""topleft"", cstar=FALSE, cex=2, pch=17:22,
solid=.5, bg=""white"")




#### usflu.fasta ####
myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")
myPath

## extract SNPs from alignments using fasta2genlight
## see ?fasta2genlight for more details
obj <- fasta2genlight(myPath, chunk=10) # process 10 sequences at a time
obj
## End(Not run)
```

## References

Jombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to **BMC genetics**.



","['data Seasonal influenza (H3N2) HA segment data Format`H3N2` is a genind object with several data frame as supplementary components (`H3N2@other) slort`, which contains the following items:- x: a `data.frame` containing miscellaneous annotations of the sequences.- xy: a matrix with two columns indicating the geographic coordinates of the strains, as longitudes and latitudes.- epid: a character vector indicating the epidemic of the strains.', 'SourceThis dataset was prepared by Thibaut Jombart (t.jombart@imperia.ac.uk), from annotated sequences available on Genbank (http://www.ncbi.nlm.nih.gov/Genbank/).', 'DescriptionThe dataset `H3N2` consists of 1903 strains of seasonal influenza (H3N2) distributed worldwide, and typed at 125 SNPs located in the hemagglutinin (HA) segment.', 'It is stored as an R object with class genind and can be accessed as usual using `data(H3N2)` (see example).', 'These data were gathered from DNA sequences available from Genbank (http://www.ncbi.nlm.nih.gov/Genbank/).', 'DetailsThe data file `usflu.fasta` is a toy dataset also gathered from Genbank, consisting of the aligned sequences of 80 seasonal influenza isolates (HA segment) sampled in the US, in `fasta` format.', 'This file is installed alongside the package; the path to this file is automatically determined by R using `system.file` (see example in this manpage and in ?fasta2genlight) as well.', 'Examples```r Not run: H3N2  LOAD DATAdata(H3N2)H3N2 set population to yearly epidemicspop(H3N2) <- factor(H3N2$other$epid) PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc1 <- dapc(H3N2, all.contrib=TRUE, scale=FALSE, n.pca=150, n.da=5)dapc1 (see ?dapc for details about the output) SCREEPLOT OF EIGENVALUESbarplot(dapc1$eig, main=""H3N2 - DAPC eigenvalues"") SCATTERPLOT (axes 1-2)scatter(dapc1, posi.da=""topleft"", cstar=FALSE, cex=2, pch=17:22,solid=.5, bg=""white"") usflu.fasta myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath extract SNPs from alignments using fasta2genlight see ?fasta2genlight for more detailsobj <- fasta2genlight(myPath, chunk=10)  process 10 sequences at a timeobj End(Not run)``` ReferencesJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.']",1," data Seasonal influenza (H3N2) HA segment data Format`H3N2` is a genind object with several data frame as supplementary components (`H3N2@other) slort`, which contains the following items:- x: a `data.frame` containing miscellaneous annotations of the sequences.- xy: a matrix with two columns indicating the geographic coordinates of the strains, as longitudes and latitudes.- epid: a character vector indicating the epidemic of the strains. SourceThis dataset was prepared by Thibaut Jombart (t.jombart@imperia.ac.uk), from annotated sequences available on Genbank (http://www.ncbi.nlm.nih.gov/Genbank/). DescriptionThe dataset `H3N2` consists of 1903 strains of seasonal influenza (H3N2) distributed worldwide, and typed at 125 SNPs located in the hemagglutinin (HA) segment. It is stored as an R object with class genind and can be accessed as usual using `data(H3N2)` (see example). These data were gathered from DNA sequences available from Genbank (http://www.ncbi.nlm.nih.gov/Genbank/). DetailsThe data file `usflu.fasta` is a toy dataset also gathered from Genbank, consisting of the aligned sequences of 80 seasonal influenza isolates (HA segment) sampled in the US, in `fasta` format. This file is installed alongside the package; the path to this file is automatically determined by R using `system.file` (see example in this manpage and in ?fasta2genlight) as well. Examples```r Not run: H3N2  LOAD DATAdata(H3N2)H3N2 set population to yearly epidemicspop(H3N2) <- factor(H3N2$other$epid) PERFORM DAPC - USE POPULATIONS AS CLUSTERS to reproduce exactly analyses from the paper, use ""n.pca=1000""dapc1 <- dapc(H3N2, all.contrib=TRUE, scale=FALSE, n.pca=150, n.da=5)dapc1 (see ?dapc for details about the output) SCREEPLOT OF EIGENVALUESbarplot(dapc1$eig, main=""H3N2 - DAPC eigenvalues"") SCATTERPLOT (axes 1-2)scatter(dapc1, posi.da=""topleft"", cstar=FALSE, cex=2, pch=17:22,solid=.5, bg=""white"") usflu.fasta myPath <- system.file(""files/usflu.fasta"",package=""adegenet"")myPath extract SNPs from alignments using fasta2genlight see ?fasta2genlight for more detailsobj <- fasta2genlight(myPath, chunk=10)  process 10 sequences at a timeobj End(Not run)``` ReferencesJombart, T., Devillard, S. and Balloux, F. Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. Submitted to BMC genetics.",25
adegenet,hybridize.md,"# Function hybridize takes two genind in inputs and generates hybrids individuals having one parent in both objects.

```r
hybridize(
  x1,
  x2,
  n,
  pop = ""hybrid"",
  res.type = c(""genind"", ""df"", ""STRUCTURE""),
  file = NULL,
  quiet = FALSE,
  sep = ""/"",
  hyb.label = ""h""
)
```

## Arguments

- `x1`: a genind object
- `x2`: a genind object
- `n`: an integer giving the number of hybrids requested
- `pop`: a character string giving naming the population of the created hybrids.
- `res.type`: a character giving the type of output requested. Must be ""genind"" (default), ""df"" (i.e. data.frame like in `genind2df`), or ""STRUCTURE"" to generate a .str file readable by STRUCTURE (in which case the 'file' must be supplied). See 'details' for STRUCTURE output.
- `file`: a character giving the name of the file to be written when 'res.type' is ""STRUCTURE""; if NULL, a the created file is of the form ""hybrids_[the current date].str"".
- `quiet`: a logical specifying whether the writing to a file (when 'res.type' is ""STRUCTURE"") should be announced (FALSE, default) or not (TRUE).
- `sep`: a character used to separate two alleles
- `hyb.label`: a character string used to construct the hybrids labels; by default, ""h"", which gives labels: ""h01"", ""h02"", ""h03"",...

## Returns

A genind object (by default), or a data.frame of alleles (res.type=""df""). No R output if res.type=""STRUCTURE"" (results written to the specified file).

## Description

The function `hybridize` performs hybridization between two set of genotypes stored in genind objects (referred as the ""2 populations""). Allelic frequencies are derived for each population, and then gametes are sampled following a multinomial distribution.

## Details

The result consists in a set of 'n' genotypes, with different possible outputs (see 'res.type' argument).

If the output is a STRUCTURE file, this file will have the following caracteristics:

- file contains the genotypes of the parents, and then the genotypes of hybrids

- the first column identifies genotypes

- the second column identifies the population (1 and 2 for parents x1 and x2; 3 for hybrids)

- the first line contains the names of the markers

- one row = one genotype (onerowperind will be true)

- missing values coded by ""-9"" (the software's default)

## Examples

```r
## Not run:

## Let's make some cattle hybrids
data(microbov)

## first, isolate each breed
temp <- seppop(microbov)
names(temp)
salers <- temp$Salers
zebu <- temp$Zebu

## let's make some... Zeblers
zebler <- hybridize(salers, zebu, n=40,
                    pop=""Zebler"")


## now let's merge all data into a single genind
newDat <- repool(microbov, zebler)

## make a correspondance analysis
## and see where hybrids are placed
X <- genind2genpop(newDat, quiet=TRUE)
coa1 <- dudi.coa(tab(X),scannf=FALSE,nf=3)
s.label(coa1$li)
add.scatter.eig(coa1$eig,2,1,2)
## End(Not run)
```

## See Also

`seploc`, `seppop`, `repool`

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk



","['Function hybridize takes two genind in inputs and generates hybrids individuals having one parent in both objects.```rhybridize(  x1,  x2,  n,  pop = ""hybrid"",  res.type = c(""genind"", ""df"", ""STRUCTURE""),  file = NULL,  quiet = FALSE,  sep = ""/"",  hyb.label = ""h"")``` Arguments- `x1`: a genind object- `x2`: a genind object- `n`: an integer giving the number of hybrids requested- `pop`: a character string giving naming the population of the created hybrids.- `res.type`: a character giving the type of output requested.', 'Must be ""genind"" (default), ""df"" (i.e.', 'data.frame like in `genind2df`), or ""STRUCTURE"" to generate a .str file readable by STRUCTURE (in which case the \'file\' must be supplied).', 'See \'details\' for STRUCTURE output.- `file`: a character giving the name of the file to be written when \'res.type\' is ""STRUCTURE""; if NULL, a the created file is of the form ""hybrids_[the current date].str"".- `quiet`: a logical specifying whether the writing to a file (when \'res.type\' is ""STRUCTURE"") should be announced (FALSE, default) or not (TRUE).- `sep`: a character used to separate two alleles- `hyb.label`: a character string used to construct the hybrids labels; by default, ""h"", which gives labels: ""h01"", ""h02"", ""h03"",... ReturnsA genind object (by default), or a data.frame of alleles (res.type=""df"").', 'No R output if res.type=""STRUCTURE"" (results written to the specified file).', 'DescriptionThe function `hybridize` performs hybridization between two set of genotypes stored in genind objects (referred as the ""2 populations"").', 'Allelic frequencies are derived for each population, and then gametes are sampled following a multinomial distribution.', 'DetailsThe result consists in a set of \'n\' genotypes, with different possible outputs (see \'res.type\' argument).If the output is a STRUCTURE file, this file will have the following caracteristics:- file contains the genotypes of the parents, and then the genotypes of hybrids- the first column identifies genotypes- the second column identifies the population (1 and 2 for parents x1 and x2; 3 for hybrids)- the first line contains the names of the markers- one row = one genotype (onerowperind will be true)- missing values coded by ""-9"" (the software\'s default) Examples```r Not run: Let\'s make some cattle hybridsdata(microbov) first, isolate each breedtemp <- seppop(microbov)names(temp)salers <- temp$Salerszebu <- temp$Zebu let\'s make some... Zeblerszebler <- hybridize(salers, zebu, n=40,                    pop=""Zebler"") now let\'s merge all data into a single genindnewDat <- repool(microbov, zebler) make a correspondance analysis and see where hybrids are placedX <- genind2genpop(newDat, quiet=TRUE)coa1 <- dudi.coa(tab(X),scannf=FALSE,nf=3)s.label(coa1$li)add.scatter.eig(coa1$eig,2,1,2) End(Not run)``` See Also`seploc`, `seppop`, `repool` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk']",1," Function hybridize takes two genind in inputs and generates hybrids individuals having one parent in both objects.```rhybridize(  x1,  x2,  n,  pop = ""hybrid"",  res.type = c(""genind"", ""df"", ""STRUCTURE""),  file = NULL,  quiet = FALSE,  sep = ""/"",  hyb.label = ""h"")``` Arguments- `x1`: a genind object- `x2`: a genind object- `n`: an integer giving the number of hybrids requested- `pop`: a character string giving naming the population of the created hybrids.- `res.type`: a character giving the type of output requested. Must be ""genind"" (default), ""df"" (i.e. data.frame like in `genind2df`), or ""STRUCTURE"" to generate a .str file readable by STRUCTURE (in which case the 'file' must be supplied). See 'details' for STRUCTURE output.- `file`: a character giving the name of the file to be written when 'res.type' is ""STRUCTURE""; if NULL, a the created file is of the form ""hybrids_[the current date].str"".- `quiet`: a logical specifying whether the writing to a file (when 'res.type' is ""STRUCTURE"") should be announced (FALSE, default) or not (TRUE).- `sep`: a character used to separate two alleles- `hyb.label`: a character string used to construct the hybrids labels; by default, ""h"", which gives labels: ""h01"", ""h02"", ""h03"",... ReturnsA genind object (by default), or a data.frame of alleles (res.type=""df""). No R output if res.type=""STRUCTURE"" (results written to the specified file). DescriptionThe function `hybridize` performs hybridization between two set of genotypes stored in genind objects (referred as the ""2 populations""). Allelic frequencies are derived for each population, and then gametes are sampled following a multinomial distribution. DetailsThe result consists in a set of 'n' genotypes, with different possible outputs (see 'res.type' argument).If the output is a STRUCTURE file, this file will have the following caracteristics:- file contains the genotypes of the parents, and then the genotypes of hybrids- the first column identifies genotypes- the second column identifies the population (1 and 2 for parents x1 and x2; 3 for hybrids)- the first line contains the names of the markers- one row = one genotype (onerowperind will be true)- missing values coded by ""-9"" (the software's default) Examples```r Not run: Let's make some cattle hybridsdata(microbov) first, isolate each breedtemp <- seppop(microbov)names(temp)salers <- temp$Salerszebu <- temp$Zebu let's make some... Zeblerszebler <- hybridize(salers, zebu, n=40,                    pop=""Zebler"") now let's merge all data into a single genindnewDat <- repool(microbov, zebler) make a correspondance analysis and see where hybrids are placedX <- genind2genpop(newDat, quiet=TRUE)coa1 <- dudi.coa(tab(X),scannf=FALSE,nf=3)s.label(coa1$li)add.scatter.eig(coa1$eig,2,1,2) End(Not run)``` See Also`seploc`, `seppop`, `repool` Author(s)Thibaut Jombart t.jombart@imperial.ac.uk",25
adegenet,adegenet.package.md," package

utf-8

# The adegenet package

## Description

This package is devoted to the multivariate analysis of genetic markers data. These data can be codominant markers (e.g. microsatellites) or presence/absence data (e.g. AFLP), and have any level of ploidy. 'adegenet' defines three formal (S4) classes:

- genind : a class for data of individuals (""genind"" stands for genotypes-individuals).

- genpop : a class for data of groups of individuals (""genpop"" stands for genotypes-populations)

- genlight : a class for genome-wide SNP data

## Details

For more information about these classes, type ""class ? genind"", ""class ? genpop"", or ""?genlight"".

Essential functionalities of the package are presented througout 4 tutorials, accessible using `adegenetTutorial(which=""name-below"")`:

- `basics`: introduction to the package.

- `spca`: multivariate analysis of spatial genetic patterns.

- `dapc`: population structure and group assignment using DAPC.

- `genomics`: introduction to the class genlight for the handling and analysis of genome-wide SNP data.

Note: In older versions of adegenet, these tutorials were avilable as vignettes, accessible through the function `vignette(""name-below"", package=""adegenet"")`:

- `adegenet-basics`.

- `adegenet-spca`.

- `adegenet-dapc`.

- `adegenet-genomics`.

Important functions are also summarized below.

=== IMPORTING DATA ===

= TO GENIND OBJECTS =

 `adegenet` imports data to genind object from the following softwares:

- STRUCTURE: see `read.structure`

- GENETIX: see `read.genetix`

- FSTAT: see `read.fstat`

- Genepop: see `read.genepop`

To import data from any of these formats, you can also use the general function `import2genind`.

In addition, it can extract polymorphic sites from nucleotide and amino-acid alignments:

- DNA files: use `read.dna` from the ape package, and then extract SNPs from DNA alignments using `DNAbin2genind`.

- protein sequences alignments: polymorphic sites can be extracted from protein sequences alignments in `alignment` format (package `seqinr`, see `as.alignment`) using the function `alignment2genind`.

The function `fasta2DNAbin` allows for reading fasta files into DNAbin object with minimum RAM requirements.

It is also possible to read genotypes coded by character strings from a data.frame in which genotypes are in rows, markers in columns. For this, use `df2genind`. Note that `df2genind` can be used for any level of ploidy.

= TO GENLIGHT OBJECTS =

SNP data can be read from the following formats:

- PLINK: see function `read.PLINK`

- .snp (adegenet's own format): see function `read.snp`

SNP can also be extracted from aligned DNA sequences with the fasta format, using `fasta2genlight`

=== EXPORTING DATA ===

 `adegenet` exports data from

Genotypes can also be recoded from a genind object into a data.frame of character strings, using any separator between alleles. This covers formats from many softwares like GENETIX or STRUCTURE. For this, see `genind2df`.

Also note that the `pegas` package imports genind objects using the function `as.loci`.

=== MANIPULATING DATA ===

Several functions allow one to manipulate genind or genpop objects

- `genind2genpop`: convert a genind object to a genpop

- `seploc`: creates one object per marker; for genlight objects, creates blocks of SNPs.

- `seppop`: creates one object per population

- - `tab`: access the allele data (counts or frequencies) of an object (genind and genpop )

- x[i,j]: create a new object keeping only genotypes (or populations) indexed by 'i' and the alleles indexed by 'j'.

- `makefreq`: returns a table of allelic frequencies from a genpop object.

- `repool` merges genoptypes from different gene pools into one single genind object.

- `propTyped` returns the proportion of available (typed) data, by individual, population, and/or locus.

- `selPopSize` subsets data, retaining only genotypes from a population whose sample size is above a given level.

- `pop` sets the population of a set of genotypes.

=== ANALYZING DATA ===

Several functions allow to use usual, and less usual analyses:

- `HWE.test.genind`: performs HWE test for all populations and loci combinations

- `dist.genpop`: computes 5 genetic distances among populations.

- `monmonier`: implementation of the Monmonier algorithm, used to seek genetic boundaries among individuals or populations. Optimized boundaries can be obtained using `optimize.monmonier`. Object of the class `monmonier` can be plotted and printed using the corresponding methods.

- `spca`: implements Jombart et al. (2008) spatial Principal Component Analysis

- `global.rtest`: implements Jombart et al. (2008) test for global spatial structures

- `local.rtest`: implements Jombart et al. (2008) test for local spatial structures

- `propShared`: computes the proportion of shared alleles in a set of genotypes (i.e. from a genind object)

- `propTyped`: function to investigate missing data in several ways

- `scaleGen`: generic method to scale genind or genpop before a principal component analysis

- `Hs`: computes the average expected heterozygosity by population in a genpop . Classically Used as a measure of genetic diversity.

- `find.clusters` and `dapc`: implement the Discriminant Analysis of Principal Component (DAPC, Jombart et al., 2010).

- `seqTrack`: implements the SeqTrack algorithm for recontructing transmission trees of pathogens (Jombart et al., 2010) .


`glPca`: implements PCA for genlight objects.

- `gengraph`: implements some simple graph-based clustering using genetic data. - `snpposi.plot` and `snpposi.test`: visualize the distribution of SNPs on a genetic sequence and test their randomness. - `adegenetServer`: opens up a web interface for some functionalities of the package (DAPC with cross validation and feature selection).

=== GRAPHICS ===

- `colorplot`: plots points with associated values for up to three variables represented by colors using the RGB system; useful for spatial mapping of principal components.

- `loadingplot`: plots loadings of variables. Useful for representing the contribution of alleles to a given principal component in a multivariate method.

- `scatter.dapc`: scatterplots for DAPC results.

- `compoplot`: plots membership probabilities from a DAPC object.

=== SIMULATING DATA ===

- `hybridize`: implements hybridization between two populations.

- `haploGen`: simulates genealogies of haplotypes, storing full genomes.


`glSim`: simulates simple genlight objects.

=== DATASETS ===

- `H3N2`: Seasonal influenza (H3N2) HA segment data.

- `dapcIllus`: Simulated data illustrating the DAPC.

- `eHGDP`: Extended HGDP-CEPH dataset.

- `microbov`: Microsatellites genotypes of 15 cattle breeds.

- `nancycats`: Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France).

- `rupica`: Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France).

- `sim2pop`: Simulated genotypes of two georeferenced populations.

- `spcaIllus`: Simulated data illustrating the sPCA.

For more information, visit the adegenet website using the function `adegenetWeb`.

Tutorials are available via the command `adegenetTutorial`.

To cite adegenet, please use the reference given by `citation(""adegenet"")` (or see references below).

## References

Jombart T. (2008) adegenet: a R package for the multivariate analysis of genetic markers **Bioinformatics** 24: 1403-1405. doi: 10.1093/bioinformatics/btn129

Jombart T. and Ahmed I. (2011) adegenet 1.3-1: new tools for the analysis of genome-wide SNP data. **Bioinformatics**. doi: 10.1093/bioinformatics/btr521

Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics 11:94. doi:10.1186/1471-2156-11-94

Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. **Heredity**. doi: 10.1038/hdy.2010.78.

Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. (2008) Revealing cryptic spatial patterns in genetic variability by a new multivariate method. **Heredity**, 101 , 92--103.

See adegenet website: [http://adegenet.r-forge.r-project.org/](http://adegenet.r-forge.r-project.org/)

Please post your questions on 'the adegenet forum': adegenet-forum@lists.r-forge.r-project.org

## See Also

adegenet is related to several packages, in particular:

- `ade4` for multivariate analysis

- `pegas` for population genetics tools

- `ape` for phylogenetics and DNA data handling

- `seqinr` for handling nucleic and proteic sequences

- `shiny` for R-based web interfaces

## Author(s)

Thibaut Jombart <t.jombart@imperial.ac.uk>

Developers: Zhian N. Kamvar <zkamvar@gmail.com>, Caitlin Collins <caitiecollins17@gmail.com>, Ismail Ahmed <ismail.ahmed@inserm.fr>, Federico Calboli, Tobias Erik Reiners, Peter Solymos, Anne Cori,

Contributed datasets from: Katayoun Moazami-Goudarzi, Denis Laloë, Dominique Pontier, Daniel Maillard, Francois Balloux.



","['packageutf-8 The adegenet package DescriptionThis package is devoted to the multivariate analysis of genetic markers data.', 'These data can be codominant markers (e.g.', 'microsatellites) or presence/absence data (e.g.', 'AFLP), and have any level of ploidy.', '\'adegenet\' defines three formal (S4) classes:- genind : a class for data of individuals (""genind"" stands for genotypes-individuals).- genpop : a class for data of groups of individuals (""genpop"" stands for genotypes-populations)- genlight : a class for genome-wide SNP data DetailsFor more information about these classes, type ""class ?', 'genpop"", or ""?genlight"".Essential functionalities of the package are presented througout 4 tutorials, accessible using `adegenetTutorial(which=""name-below"")`:- `basics`: introduction to the package.- `spca`: multivariate analysis of spatial genetic patterns.- `dapc`: population structure and group assignment using DAPC.- `genomics`: introduction to the class genlight for the handling and analysis of genome-wide SNP data.Note: In older versions of adegenet, these tutorials were avilable as vignettes, accessible through the function `vignette(""name-below"", package=""adegenet"")`:- `adegenet-basics`.- `adegenet-spca`.- `adegenet-dapc`.- `adegenet-genomics`.Important functions are also summarized below.=== IMPORTING DATA ==== TO GENIND OBJECTS = `adegenet` imports data to genind object from the following softwares:- STRUCTURE: see `read.structure`- GENETIX: see `read.genetix`- FSTAT: see `read.fstat`- Genepop: see `read.genepop`To import data from any of these formats, you can also use the general function `import2genind`.In addition, it can extract polymorphic sites from nucleotide and amino-acid alignments:- DNA files: use `read.dna` from the ape package, and then extract SNPs from DNA alignments using `DNAbin2genind`.- protein sequences alignments: polymorphic sites can be extracted from protein sequences alignments in `alignment` format (package `seqinr`, see `as.alignment`) using the function `alignment2genind`.The function `fasta2DNAbin` allows for reading fasta files into DNAbin object with minimum RAM requirements.It is also possible to read genotypes coded by character strings from a data.frame in which genotypes are in rows, markers in columns.', ""Note that `df2genind` can be used for any level of ploidy.= TO GENLIGHT OBJECTS =SNP data can be read from the following formats:- PLINK: see function `read.PLINK`- .snp (adegenet's own format): see function `read.snp`SNP can also be extracted from aligned DNA sequences with the fasta format, using `fasta2genlight`=== EXPORTING DATA === `adegenet` exports data fromGenotypes can also be recoded from a genind object into a data.frame of character strings, using any separator between alleles."", 'This covers formats from many softwares like GENETIX or STRUCTURE.', ""For this, see `genind2df`.Also note that the `pegas` package imports genind objects using the function `as.loci`.=== MANIPULATING DATA ===Several functions allow one to manipulate genind or genpop objects- `genind2genpop`: convert a genind object to a genpop- `seploc`: creates one object per marker; for genlight objects, creates blocks of SNPs.- `seppop`: creates one object per population- - `tab`: access the allele data (counts or frequencies) of an object (genind and genpop )- x[i,j]: create a new object keeping only genotypes (or populations) indexed by 'i' and the alleles indexed by 'j'.- `makefreq`: returns a table of allelic frequencies from a genpop object.- `repool` merges genoptypes from different gene pools into one single genind object.- `propTyped` returns the proportion of available (typed) data, by individual, population, and/or locus.- `selPopSize` subsets data, retaining only genotypes from a population whose sample size is above a given level.- `pop` sets the population of a set of genotypes.=== ANALYZING DATA ===Several functions allow to use usual, and less usual analyses:- `HWE.test.genind`: performs HWE test for all populations and loci combinations- `dist.genpop`: computes 5 genetic distances among populations.- `monmonier`: implementation of the Monmonier algorithm, used to seek genetic boundaries among individuals or populations."", 'Optimized boundaries can be obtained using `optimize.monmonier`.', 'Object of the class `monmonier` can be plotted and printed using the corresponding methods.- `spca`: implements Jombart et al.', '(2008) spatial Principal Component Analysis- `global.rtest`: implements Jombart et al.', '(2008) test for global spatial structures- `local.rtest`: implements Jombart et al.', '(2008) test for local spatial structures- `propShared`: computes the proportion of shared alleles in a set of genotypes (i.e.', 'from a genind object)- `propTyped`: function to investigate missing data in several ways- `scaleGen`: generic method to scale genind or genpop before a principal component analysis- `Hs`: computes the average expected heterozygosity by population in a genpop .', 'Classically Used as a measure of genetic diversity.- `find.clusters` and `dapc`: implement the Discriminant Analysis of Principal Component (DAPC, Jombart et al., 2010).- `seqTrack`: implements the SeqTrack algorithm for recontructing transmission trees of pathogens (Jombart et al., 2010) .`glPca`: implements PCA for genlight objects.- `gengraph`: implements some simple graph-based clustering using genetic data.', '- `snpposi.plot` and `snpposi.test`: visualize the distribution of SNPs on a genetic sequence and test their randomness.', '- `adegenetServer`: opens up a web interface for some functionalities of the package (DAPC with cross validation and feature selection).=== GRAPHICS ===- `colorplot`: plots points with associated values for up to three variables represented by colors using the RGB system; useful for spatial mapping of principal components.- `loadingplot`: plots loadings of variables.', 'Useful for representing the contribution of alleles to a given principal component in a multivariate method.- `scatter.dapc`: scatterplots for DAPC results.- `compoplot`: plots membership probabilities from a DAPC object.=== SIMULATING DATA ===- `hybridize`: implements hybridization between two populations.- `haploGen`: simulates genealogies of haplotypes, storing full genomes.`glSim`: simulates simple genlight objects.=== DATASETS ===- `H3N2`: Seasonal influenza (H3N2) HA segment data.- `dapcIllus`: Simulated data illustrating the DAPC.- `eHGDP`: Extended HGDP-CEPH dataset.- `microbov`: Microsatellites genotypes of 15 cattle breeds.- `nancycats`: Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France).- `rupica`: Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France).- `sim2pop`: Simulated genotypes of two georeferenced populations.- `spcaIllus`: Simulated data illustrating the sPCA.For more information, visit the adegenet website using the function `adegenetWeb`.Tutorials are available via the command `adegenetTutorial`.To cite adegenet, please use the reference given by `citation(""adegenet"")` (or see references below).', 'ReferencesJombart T. (2008) adegenet: a R package for the multivariate analysis of genetic markers Bioinformatics 24: 1403-1405. doi: 10.1093/bioinformatics/btn129Jombart T. and Ahmed I.', '(2011) adegenet 1.3-1: new tools for the analysis of genome-wide SNP data.', 'doi: 10.1093/bioinformatics/btr521Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations.', 'BMC Genetics 11:94. doi:10.1186/1471-2156-11-94Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach.', 'doi: 10.1038/hdy.2010.78.Jombart, T., Devillard, S., Dufour, A.-B.', 'and Pontier, D. (2008) Revealing cryptic spatial patterns in genetic variability by a new multivariate method.', ""Heredity, 101 , 92--103.See adegenet website: [http://adegenet.r-forge.r-project.org/](http://adegenet.r-forge.r-project.org/)Please post your questions on 'the adegenet forum': adegenet-forum@lists.r-forge.r-project.org See Alsoadegenet is related to several packages, in particular:- `ade4` for multivariate analysis- `pegas` for population genetics tools- `ape` for phylogenetics and DNA data handling- `seqinr` for handling nucleic and proteic sequences- `shiny` for R-based web interfaces Author(s)Thibaut Jombart <t.jombart@imperial.ac.uk>Developers: Zhian N. Kamvar <zkamvar@gmail.com>, Caitlin Collins <caitiecollins17@gmail.com>, Ismail Ahmed <ismail.ahmed@inserm.fr>, Federico Calboli, Tobias Erik Reiners, Peter Solymos, Anne Cori,Contributed datasets from: Katayoun Moazami-Goudarzi, Denis Laloë, Dominique Pontier, Daniel Maillard, Francois Balloux.""]",1," packageutf-8 The adegenet package DescriptionThis package is devoted to the multivariate analysis of genetic markers data. These data can be codominant markers (e.g. microsatellites) or presence/absence data (e.g. AFLP), and have any level of ploidy. 'adegenet' defines three formal (S4) classes:- genind : a class for data of individuals (""genind"" stands for genotypes-individuals).- genpop : a class for data of groups of individuals (""genpop"" stands for genotypes-populations)- genlight : a class for genome-wide SNP data DetailsFor more information about these classes, type ""class ? genind"", ""class ? genpop"", or ""?genlight"".Essential functionalities of the package are presented througout 4 tutorials, accessible using `adegenetTutorial(which=""name-below"")`:- `basics`: introduction to the package.- `spca`: multivariate analysis of spatial genetic patterns.- `dapc`: population structure and group assignment using DAPC.- `genomics`: introduction to the class genlight for the handling and analysis of genome-wide SNP data.Note: In older versions of adegenet, these tutorials were avilable as vignettes, accessible through the function `vignette(""name-below"", package=""adegenet"")`:- `adegenet-basics`.- `adegenet-spca`.- `adegenet-dapc`.- `adegenet-genomics`.Important functions are also summarized below.=== IMPORTING DATA ==== TO GENIND OBJECTS = `adegenet` imports data to genind object from the following softwares:- STRUCTURE: see `read.structure`- GENETIX: see `read.genetix`- FSTAT: see `read.fstat`- Genepop: see `read.genepop`To import data from any of these formats, you can also use the general function `import2genind`.In addition, it can extract polymorphic sites from nucleotide and amino-acid alignments:- DNA files: use `read.dna` from the ape package, and then extract SNPs from DNA alignments using `DNAbin2genind`.- protein sequences alignments: polymorphic sites can be extracted from protein sequences alignments in `alignment` format (package `seqinr`, see `as.alignment`) using the function `alignment2genind`.The function `fasta2DNAbin` allows for reading fasta files into DNAbin object with minimum RAM requirements.It is also possible to read genotypes coded by character strings from a data.frame in which genotypes are in rows, markers in columns. For this, use `df2genind`. Note that `df2genind` can be used for any level of ploidy.= TO GENLIGHT OBJECTS =SNP data can be read from the following formats:- PLINK: see function `read.PLINK`- .snp (adegenet's own format): see function `read.snp`SNP can also be extracted from aligned DNA sequences with the fasta format, using `fasta2genlight`=== EXPORTING DATA === `adegenet` exports data fromGenotypes can also be recoded from a genind object into a data.frame of character strings, using any separator between alleles. This covers formats from many softwares like GENETIX or STRUCTURE. For this, see `genind2df`.Also note that the `pegas` package imports genind objects using the function `as.loci`.=== MANIPULATING DATA ===Several functions allow one to manipulate genind or genpop objects- `genind2genpop`: convert a genind object to a genpop- `seploc`: creates one object per marker; for genlight objects, creates blocks of SNPs.- `seppop`: creates one object per population- - `tab`: access the allele data (counts or frequencies) of an object (genind and genpop )- x[i,j]: create a new object keeping only genotypes (or populations) indexed by 'i' and the alleles indexed by 'j'.- `makefreq`: returns a table of allelic frequencies from a genpop object.- `repool` merges genoptypes from different gene pools into one single genind object.- `propTyped` returns the proportion of available (typed) data, by individual, population, and/or locus.- `selPopSize` subsets data, retaining only genotypes from a population whose sample size is above a given level.- `pop` sets the population of a set of genotypes.=== ANALYZING DATA ===Several functions allow to use usual, and less usual analyses:- `HWE.test.genind`: performs HWE test for all populations and loci combinations- `dist.genpop`: computes 5 genetic distances among populations.- `monmonier`: implementation of the Monmonier algorithm, used to seek genetic boundaries among individuals or populations. Optimized boundaries can be obtained using `optimize.monmonier`. Object of the class `monmonier` can be plotted and printed using the corresponding methods.- `spca`: implements Jombart et al. (2008) spatial Principal Component Analysis- `global.rtest`: implements Jombart et al. (2008) test for global spatial structures- `local.rtest`: implements Jombart et al. (2008) test for local spatial structures- `propShared`: computes the proportion of shared alleles in a set of genotypes (i.e. from a genind object)- `propTyped`: function to investigate missing data in several ways- `scaleGen`: generic method to scale genind or genpop before a principal component analysis- `Hs`: computes the average expected heterozygosity by population in a genpop . Classically Used as a measure of genetic diversity.- `find.clusters` and `dapc`: implement the Discriminant Analysis of Principal Component (DAPC, Jombart et al., 2010).- `seqTrack`: implements the SeqTrack algorithm for recontructing transmission trees of pathogens (Jombart et al., 2010) .`glPca`: implements PCA for genlight objects.- `gengraph`: implements some simple graph-based clustering using genetic data. - `snpposi.plot` and `snpposi.test`: visualize the distribution of SNPs on a genetic sequence and test their randomness. - `adegenetServer`: opens up a web interface for some functionalities of the package (DAPC with cross validation and feature selection).=== GRAPHICS ===- `colorplot`: plots points with associated values for up to three variables represented by colors using the RGB system; useful for spatial mapping of principal components.- `loadingplot`: plots loadings of variables. Useful for representing the contribution of alleles to a given principal component in a multivariate method.- `scatter.dapc`: scatterplots for DAPC results.- `compoplot`: plots membership probabilities from a DAPC object.=== SIMULATING DATA ===- `hybridize`: implements hybridization between two populations.- `haploGen`: simulates genealogies of haplotypes, storing full genomes.`glSim`: simulates simple genlight objects.=== DATASETS ===- `H3N2`: Seasonal influenza (H3N2) HA segment data.- `dapcIllus`: Simulated data illustrating the DAPC.- `eHGDP`: Extended HGDP-CEPH dataset.- `microbov`: Microsatellites genotypes of 15 cattle breeds.- `nancycats`: Microsatellites genotypes of 237 cats from 17 colonies of Nancy (France).- `rupica`: Microsatellites genotypes of 335 chamois (Rupicapra rupicapra) from the Bauges mountains (France).- `sim2pop`: Simulated genotypes of two georeferenced populations.- `spcaIllus`: Simulated data illustrating the sPCA.For more information, visit the adegenet website using the function `adegenetWeb`.Tutorials are available via the command `adegenetTutorial`.To cite adegenet, please use the reference given by `citation(""adegenet"")` (or see references below). ReferencesJombart T. (2008) adegenet: a R package for the multivariate analysis of genetic markers Bioinformatics 24: 1403-1405. doi: 10.1093/bioinformatics/btn129Jombart T. and Ahmed I. (2011) adegenet 1.3-1: new tools for the analysis of genome-wide SNP data. Bioinformatics. doi: 10.1093/bioinformatics/btr521Jombart T, Devillard S and Balloux F (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genetics 11:94. doi:10.1186/1471-2156-11-94Jombart T, Eggo R, Dodd P, Balloux F (2010) Reconstructing disease outbreaks from genetic data: a graph approach. Heredity. doi: 10.1038/hdy.2010.78.Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. (2008) Revealing cryptic spatial patterns in genetic variability by a new multivariate method. Heredity, 101 , 92--103.See adegenet website: [http://adegenet.r-forge.r-project.org/](http://adegenet.r-forge.r-project.org/)Please post your questions on 'the adegenet forum': adegenet-forum@lists.r-forge.r-project.org See Alsoadegenet is related to several packages, in particular:- `ade4` for multivariate analysis- `pegas` for population genetics tools- `ape` for phylogenetics and DNA data handling- `seqinr` for handling nucleic and proteic sequences- `shiny` for R-based web interfaces Author(s)Thibaut Jombart <t.jombart@imperial.ac.uk>Developers: Zhian N. Kamvar <zkamvar@gmail.com>, Caitlin Collins <caitiecollins17@gmail.com>, Ismail Ahmed <ismail.ahmed@inserm.fr>, Federico Calboli, Tobias Erik Reiners, Peter Solymos, Anne Cori,Contributed datasets from: Katayoun Moazami-Goudarzi, Denis Laloë, Dominique Pontier, Daniel Maillard, Francois Balloux.",25
adegenet,snapclust.choose.k.md,"# Choose the number of clusters for snapclust using AIC, BIC or AICc

```r
snapclust.choose.k(max, ..., IC = AIC, IC.only = TRUE)
```

## Arguments

- `max`: An integer indicating the maximum number of clusters to seek; `snapclust` will be run for all k from 2 to max.
- `...`: Arguments passed to `snapclust`.
- `IC`: A function computing the information criterion for `snapclust` objects. Available statistics are `AIC` (default), `AICc`, and `BIC`.
- `IC.only`: A logical (TRUE by default) indicating if IC values only should be returned; if `FALSE`, full `snapclust` objects are returned.

## Description

This function implements methods for investigating the optimal number of genetic clusters ('k') using the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018). The method runs `snapclust` for varying values of 'k', and computes the requested summary statistics for each clustering solution to assess goodness of fit. The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`.

## Details

The method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem. Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") . A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`.

## See Also

`snapclust` to generate individual clustering solutions, and `BIC.snapclust` for computing BIC for `snapclust` objects.

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","['Choose the number of clusters for snapclust using AIC, BIC or AICc```rsnapclust.choose.k(max, ..., IC = AIC, IC.only = TRUE)``` Arguments- `max`: An integer indicating the maximum number of clusters to seek; `snapclust` will be run for all k from 2 to max.- `...`: Arguments passed to `snapclust`.- `IC`: A function computing the information criterion for `snapclust` objects.', 'Available statistics are `AIC` (default), `AICc`, and `BIC`.- `IC.only`: A logical (TRUE by default) indicating if IC values only should be returned; if `FALSE`, full `snapclust` objects are returned.', ""DescriptionThis function implements methods for investigating the optimal number of genetic clusters ('k') using the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018)."", ""The method runs `snapclust` for varying values of 'k', and computes the requested summary statistics for each clustering solution to assess goodness of fit."", 'The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`.', 'DetailsThe method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem.', 'Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") .', 'A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`.', 'See Also`snapclust` to generate individual clustering solutions, and `BIC.snapclust` for computing BIC for `snapclust` objects.']",1," Choose the number of clusters for snapclust using AIC, BIC or AICc```rsnapclust.choose.k(max, ..., IC = AIC, IC.only = TRUE)``` Arguments- `max`: An integer indicating the maximum number of clusters to seek; `snapclust` will be run for all k from 2 to max.- `...`: Arguments passed to `snapclust`.- `IC`: A function computing the information criterion for `snapclust` objects. Available statistics are `AIC` (default), `AICc`, and `BIC`.- `IC.only`: A logical (TRUE by default) indicating if IC values only should be returned; if `FALSE`, full `snapclust` objects are returned. DescriptionThis function implements methods for investigating the optimal number of genetic clusters ('k') using the fast maximum-likelihood genetic clustering approach described in Beugin et al (2018). The method runs `snapclust` for varying values of 'k', and computes the requested summary statistics for each clustering solution to assess goodness of fit. The method is fully documented in a dedicated tutorial which can be accessed using `adegenetTutorial(""snapclust"")`. DetailsThe method is described in Beugin et al (2018) A fast likelihood solution to the genetic clustering problem. Methods in Ecology and Evolution tools:::Rd_expr_doi(""10.1111/2041-210X.12968"") . A dedicated tutorial is available by typing `adegenetTutorial(""snapclust"")`. See Also`snapclust` to generate individual clustering solutions, and `BIC.snapclust` for computing BIC for `snapclust` objects. Author(s)Thibaut Jombart thibautjombart@gmail.com",25
adegenet,showmekittens.md,"# When you need a break...

```r
showmekittens(x = NULL, list = FALSE)
```

## Arguments

- `x`: the name or index of the video to display; if NULL, a random video is chosen
- `list`: a logical indicating if the list of available videos should be displayed

## Description

Genetic data analysis can be a harsh, tiring, daunting task. Sometimes, a mere break will not cut it. Sometimes, you need a kitten.

## Details

Please send us more! Either pull request or submit an issue with a URL (use `adegenetIssues()`).

## Author(s)

Thibaut Jombart thibautjombart@gmail.com



","['When you need a break...```rshowmekittens(x = NULL, list = FALSE)``` Arguments- `x`: the name or index of the video to display; if NULL, a random video is chosen- `list`: a logical indicating if the list of available videos should be displayed DescriptionGenetic data analysis can be a harsh, tiring, daunting task.', 'Sometimes, a mere break will not cut it.', 'Sometimes, you need a kitten.', 'Either pull request or submit an issue with a URL (use `adegenetIssues()`).']",1," When you need a break...```rshowmekittens(x = NULL, list = FALSE)``` Arguments- `x`: the name or index of the video to display; if NULL, a random video is chosen- `list`: a logical indicating if the list of available videos should be displayed DescriptionGenetic data analysis can be a harsh, tiring, daunting task. Sometimes, a mere break will not cut it. Sometimes, you need a kitten. DetailsPlease send us more! Either pull request or submit an issue with a URL (use `adegenetIssues()`). Author(s)Thibaut Jombart thibautjombart@gmail.com",26
adegenet,seppop.md,"UTF-8

methods

# Separate genotypes per population

## Description

The function `seppop` splits a genind or a genlight object by population, returning a list of objects whose components each correspond to a population.

For genind objects, the output can either be a list of genind (default), or a list of matrices corresponding to the `@tab` slot.

```r
## S4 method for signature 'genind'
seppop(x,pop=NULL,truenames=TRUE,res.type=c(""genind"",""matrix""),
  drop=FALSE, treatOther=TRUE, keepNA = FALSE, quiet=TRUE)

## S4 method for signature 'genlight'
seppop(x,pop=NULL, treatOther=TRUE, keepNA = FALSE, quiet=TRUE, ...)
```

## Arguments

- `x`: a genind object
- `pop`: a factor giving the population of each genotype in 'x' OR a formula specifying which strata are to be used when converting to a genpop object. If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.
- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".
- `res.type`: a character indicating the type of returned results, a list of genind object (default) or a matrix of data corresponding to the 'tab' slots.
- `drop`: a logical stating whether alleles that are no longer present in a subset of data should be discarded (TRUE) or kept anyway (FALSE, default).
- `treatOther`: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE). See details in accessor documentations (`pop`).
- `keepNA`: If there are individuals with missing population information, should they be pooled into a separate population (TRUE), or excluded (FALSE, default).
- `quiet`: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot (TRUE), or not (FALSE, default).
- ``...``: further arguments passed to the genlight constructor.

## Returns

According to 'res.type': a list of genind object (default) or a matrix of data corresponding to the 'tab' slots.

## Author(s)

Thibaut Jombart t.jombart@imperial.ac.uk

## See Also

`seploc`, `repool`

## Examples

```r
## Not run:

data(microbov)
strata(microbov) <- data.frame(other(microbov))

obj <- seppop(microbov)
names(obj)

obj$Salers

### example using strata
obj2 <- seppop(microbov, ~coun/spe)
names(obj2)

obj2$AF_BI

#### example for genlight objects ####
x <- new(""genlight"", list(a=rep(1,1e3),b=rep(0,1e3),c=rep(1, 1e3)))
x

pop(x) # no population info
pop(x) <- c(""pop1"",""pop2"", ""pop1"") # set population memberships
pop(x)
seppop(x)
as.matrix(seppop(x)$pop1)[,1:20]
as.matrix(seppop(x)$pop2)[,1:20,drop=FALSE]
## End(Not run)
```



","['UTF-8methods Separate genotypes per population DescriptionThe function `seppop` splits a genind or a genlight object by population, returning a list of objects whose components each correspond to a population.For genind objects, the output can either be a list of genind (default), or a list of matrices corresponding to the `@tab` slot.```r S4 method for signature \'genind\'seppop(x,pop=NULL,truenames=TRUE,res.type=c(""genind"",""matrix""),  drop=FALSE, treatOther=TRUE, keepNA = FALSE, quiet=TRUE) S4 method for signature \'genlight\'seppop(x,pop=NULL, treatOther=TRUE, keepNA = FALSE, quiet=TRUE, ...)``` Arguments- `x`: a genind object- `pop`: a factor giving the population of each genotype in \'x\' OR a formula specifying which strata are to be used when converting to a genpop object.', 'If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".- `res.type`: a character indicating the type of returned results, a list of genind object (default) or a matrix of data corresponding to the \'tab\' slots.- `drop`: a logical stating whether alleles that are no longer present in a subset of data should be discarded (TRUE) or kept anyway (FALSE, default).- `treatOther`: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE).', 'See details in accessor documentations (`pop`).- `keepNA`: If there are individuals with missing population information, should they be pooled into a separate population (TRUE), or excluded (FALSE, default).- `quiet`: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot (TRUE), or not (FALSE, default).- ``...``: further arguments passed to the genlight constructor.', ""ReturnsAccording to 'res.type': a list of genind object (default) or a matrix of data corresponding to the 'tab' slots."", 'Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seploc`, `repool` Examples```r Not run:data(microbov)strata(microbov) <- data.frame(other(microbov))obj <- seppop(microbov)names(obj)obj$Salers example using strataobj2 <- seppop(microbov, ~coun/spe)names(obj2)obj2$AF_BI example for genlight objects x <- new(""genlight"", list(a=rep(1,1e3),b=rep(0,1e3),c=rep(1, 1e3)))xpop(x)  no population infopop(x) <- c(""pop1"",""pop2"", ""pop1"")  set population membershipspop(x)seppop(x)as.matrix(seppop(x)$pop1)[,1:20]as.matrix(seppop(x)$pop2)[,1:20,drop=FALSE] End(Not run)```']",1,"UTF-8methods Separate genotypes per population DescriptionThe function `seppop` splits a genind or a genlight object by population, returning a list of objects whose components each correspond to a population.For genind objects, the output can either be a list of genind (default), or a list of matrices corresponding to the `@tab` slot.```r S4 method for signature 'genind'seppop(x,pop=NULL,truenames=TRUE,res.type=c(""genind"",""matrix""),  drop=FALSE, treatOther=TRUE, keepNA = FALSE, quiet=TRUE) S4 method for signature 'genlight'seppop(x,pop=NULL, treatOther=TRUE, keepNA = FALSE, quiet=TRUE, ...)``` Arguments- `x`: a genind object- `pop`: a factor giving the population of each genotype in 'x' OR a formula specifying which strata are to be used when converting to a genpop object. If none provided, population factors are sought in x@pop, but if given, the argument prevails on x@pop.- `truenames`: a logical indicating whether true names should be used (TRUE, default) instead of generic labels (FALSE); used if res.type is ""matrix"".- `res.type`: a character indicating the type of returned results, a list of genind object (default) or a matrix of data corresponding to the 'tab' slots.- `drop`: a logical stating whether alleles that are no longer present in a subset of data should be discarded (TRUE) or kept anyway (FALSE, default).- `treatOther`: a logical stating whether elements of the `@other` slot should be treated as well (TRUE), or not (FALSE). See details in accessor documentations (`pop`).- `keepNA`: If there are individuals with missing population information, should they be pooled into a separate population (TRUE), or excluded (FALSE, default).- `quiet`: a logical indicating whether warnings should be issued when trying to subset components of the `@other` slot (TRUE), or not (FALSE, default).- ``...``: further arguments passed to the genlight constructor. ReturnsAccording to 'res.type': a list of genind object (default) or a matrix of data corresponding to the 'tab' slots. Author(s)Thibaut Jombart t.jombart@imperial.ac.uk See Also`seploc`, `repool` Examples```r Not run:data(microbov)strata(microbov) <- data.frame(other(microbov))obj <- seppop(microbov)names(obj)obj$Salers example using strataobj2 <- seppop(microbov, ~coun/spe)names(obj2)obj2$AF_BI example for genlight objects x <- new(""genlight"", list(a=rep(1,1e3),b=rep(0,1e3),c=rep(1, 1e3)))xpop(x)  no population infopop(x) <- c(""pop1"",""pop2"", ""pop1"")  set population membershipspop(x)seppop(x)as.matrix(seppop(x)$pop1)[,1:20]as.matrix(seppop(x)$pop2)[,1:20,drop=FALSE] End(Not run)```",26
argo,argo.md,"# Construct ARGO object

```r
argo(
  data,
  exogen = xts::xts(NULL),
  N_lag = 1:52,
  N_training = 104,
  alpha = 1,
  use_all_previous = FALSE,
  mc.cores = 1,
  schedule = list()
)
```

## Arguments

- `data`: response variable as xts, last element can be NA. If the response is later revised, it should be an xts that resembles upper triangular square matrix, with each column being the data available as of date of column name
- `exogen`: exogenous predictors, default is NULL
- `N_lag`: vector of the AR model lags used, if NULL then no AR lags will be used
- `N_training`: number of training points, if `use_all_previous` is true, this is the least number of training points required
- `alpha`: penalty between lasso and ridge, alpha=1 represents lasso, alpha=0 represents ridge, alpha=NA represents no penalty
- `use_all_previous`: boolean variable indicating whether to use ""all available data"" (when `TRUE`) or ""a sliding window"" (when `FALSE`) for training
- `mc.cores`: number of cores to compute argo in parallel
- `schedule`: list to specify prediction schedule. Default to have `y_gap` as 1, and `forecast` as 0, i.e., nowcasting with past week ILI available from CDC.

## Returns

A list of following named objects

 * `pred` An xts object with the same index as input, which contains historical nowcast estimation
 * `coef` A matrix contains historical coefficient values of the predictors.
 * `parm` Parameter values passed to argo function.
 * `penalfac` the value of lambda ratio selected by cross-validation, NULL if `lamid` is NULL or has only one level.
 * `penalregion` the lambda ratios that has a cross validation error within one standard error of minimum cross validation error

## Description

Wrapper for ARGO. The real work horse is glmnet package and/or linear model.

## Details

This function takes the time series and exogenous variables (optional) as input, and produces out-of-sample prediction for each time point.

## Examples

```r
GFT_xts <- xts::xts(exp(matrix(rnorm(180), ncol=1)), order.by = Sys.Date() - (180:1))
randomx <- xts::xts(exp(matrix(rnorm(180*100), ncol=100)), order.by = Sys.Date() - (180:1))

argo_result1 <- argo(GFT_xts)
argo_result2 <- argo(GFT_xts, exogen = randomx)
```

## References

Yang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.



","['Construct ARGO object```rargo(  data,  exogen = xts::xts(NULL),  N_lag = 1:52,  N_training = 104,  alpha = 1,  use_all_previous = FALSE,  mc.cores = 1,  schedule = list())``` Arguments- `data`: response variable as xts, last element can be NA.', 'If the response is later revised, it should be an xts that resembles upper triangular square matrix, with each column being the data available as of date of column name- `exogen`: exogenous predictors, default is NULL- `N_lag`: vector of the AR model lags used, if NULL then no AR lags will be used- `N_training`: number of training points, if `use_all_previous` is true, this is the least number of training points required- `alpha`: penalty between lasso and ridge, alpha=1 represents lasso, alpha=0 represents ridge, alpha=NA represents no penalty- `use_all_previous`: boolean variable indicating whether to use ""all available data"" (when `TRUE`) or ""a sliding window"" (when `FALSE`) for training- `mc.cores`: number of cores to compute argo in parallel- `schedule`: list to specify prediction schedule.', 'Default to have `y_gap` as 1, and `forecast` as 0, i.e., nowcasting with past week ILI available from CDC.', 'ReturnsA list of following named objects  `pred` An xts object with the same index as input, which contains historical nowcast estimation  `coef` A matrix contains historical coefficient values of the predictors.', '`parm` Parameter values passed to argo function.', '`penalfac` the value of lambda ratio selected by cross-validation, NULL if `lamid` is NULL or has only one level.', '`penalregion` the lambda ratios that has a cross validation error within one standard error of minimum cross validation error DescriptionWrapper for ARGO.', 'The real work horse is glmnet package and/or linear model.', 'DetailsThis function takes the time series and exogenous variables (optional) as input, and produces out-of-sample prediction for each time point.', 'Examples```rGFT_xts <- xts::xts(exp(matrix(rnorm(180), ncol=1)), order.by = Sys.Date() - (180:1))randomx <- xts::xts(exp(matrix(rnorm(180100), ncol=100)), order.by = Sys.Date() - (180:1))argo_result1 <- argo(GFT_xts)argo_result2 <- argo(GFT_xts, exogen = randomx)``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015).', 'Accurate estimation of influenza epidemics using Google search data via ARGO.', 'Proceedings of the National Academy of Sciences.']",1," Construct ARGO object```rargo(  data,  exogen = xts::xts(NULL),  N_lag = 1:52,  N_training = 104,  alpha = 1,  use_all_previous = FALSE,  mc.cores = 1,  schedule = list())``` Arguments- `data`: response variable as xts, last element can be NA. If the response is later revised, it should be an xts that resembles upper triangular square matrix, with each column being the data available as of date of column name- `exogen`: exogenous predictors, default is NULL- `N_lag`: vector of the AR model lags used, if NULL then no AR lags will be used- `N_training`: number of training points, if `use_all_previous` is true, this is the least number of training points required- `alpha`: penalty between lasso and ridge, alpha=1 represents lasso, alpha=0 represents ridge, alpha=NA represents no penalty- `use_all_previous`: boolean variable indicating whether to use ""all available data"" (when `TRUE`) or ""a sliding window"" (when `FALSE`) for training- `mc.cores`: number of cores to compute argo in parallel- `schedule`: list to specify prediction schedule. Default to have `y_gap` as 1, and `forecast` as 0, i.e., nowcasting with past week ILI available from CDC. ReturnsA list of following named objects  `pred` An xts object with the same index as input, which contains historical nowcast estimation  `coef` A matrix contains historical coefficient values of the predictors.  `parm` Parameter values passed to argo function.  `penalfac` the value of lambda ratio selected by cross-validation, NULL if `lamid` is NULL or has only one level.  `penalregion` the lambda ratios that has a cross validation error within one standard error of minimum cross validation error DescriptionWrapper for ARGO. The real work horse is glmnet package and/or linear model. DetailsThis function takes the time series and exogenous variables (optional) as input, and produces out-of-sample prediction for each time point. Examples```rGFT_xts <- xts::xts(exp(matrix(rnorm(180), ncol=1)), order.by = Sys.Date() - (180:1))randomx <- xts::xts(exp(matrix(rnorm(180100), ncol=100)), order.by = Sys.Date() - (180:1))argo_result1 <- argo(GFT_xts)argo_result2 <- argo(GFT_xts, exogen = randomx)``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.",26
argo,heatmap_argo.md,"# Heatmap plot of ARGO coefficients applied on CDC's ILI data

```r
heatmap_argo(argo_coef, lim = 0.1, na.grey = TRUE, scale = 1)
```

## Arguments

- `argo_coef`: The coefficient matrix
- `lim`: the limit to truncate for large coefficients for better presentation
- `na.grey`: whether to plot grey for NA values
- `scale`: margin scale

## Returns

a graph on the default plot window

## Description

Heatmap plot of ARGO coefficients applied on CDC's ILI data

## Examples

```r
cor_coef <- matrix(runif(100, -1, 1), ncol=10)
colnames(cor_coef) <- as.character(Sys.Date() - 10:1)
rownames(cor_coef) <- paste0(""row"", 1:10)
pdf(file.path(tempdir(), ""heatmap_argo.pdf""), height=11,width=12)
heatmap_argo(cor_coef)
dev.off()
```



","['Heatmap plot of ARGO coefficients applied on CDC\'s ILI data```rheatmap_argo(argo_coef, lim = 0.1, na.grey = TRUE, scale = 1)``` Arguments- `argo_coef`: The coefficient matrix- `lim`: the limit to truncate for large coefficients for better presentation- `na.grey`: whether to plot grey for NA values- `scale`: margin scale Returnsa graph on the default plot window DescriptionHeatmap plot of ARGO coefficients applied on CDC\'s ILI data Examples```rcor_coef <- matrix(runif(100, -1, 1), ncol=10)colnames(cor_coef) <- as.character(Sys.Date() - 10:1)rownames(cor_coef) <- paste0(""row"", 1:10)pdf(file.path(tempdir(), ""heatmap_argo.pdf""), height=11,width=12)heatmap_argo(cor_coef)dev.off()```']",1," Heatmap plot of ARGO coefficients applied on CDC's ILI data```rheatmap_argo(argo_coef, lim = 0.1, na.grey = TRUE, scale = 1)``` Arguments- `argo_coef`: The coefficient matrix- `lim`: the limit to truncate for large coefficients for better presentation- `na.grey`: whether to plot grey for NA values- `scale`: margin scale Returnsa graph on the default plot window DescriptionHeatmap plot of ARGO coefficients applied on CDC's ILI data Examples```rcor_coef <- matrix(runif(100, -1, 1), ncol=10)colnames(cor_coef) <- as.character(Sys.Date() - 10:1)rownames(cor_coef) <- paste0(""row"", 1:10)pdf(file.path(tempdir(), ""heatmap_argo.pdf""), height=11,width=12)heatmap_argo(cor_coef)dev.off()```",26
argo,gt.parser.pub.api.md,"# Parsing each Google Trends file downloaded from Google Trends API

```r
gt.parser.pub.api(gt.folder, f)
```

## Arguments

- `gt.folder`: folder that contains Google Trends file
- `f`: filename for Google Trends file

## Description

Parsing each Google Trends file downloaded from Google Trends API



","['Parsing each Google Trends file downloaded from Google Trends API```rgt.parser.pub.api(gt.folder, f)``` Arguments- `gt.folder`: folder that contains Google Trends file- `f`: filename for Google Trends file DescriptionParsing each Google Trends file downloaded from Google Trends API']",1," Parsing each Google Trends file downloaded from Google Trends API```rgt.parser.pub.api(gt.folder, f)``` Arguments- `gt.folder`: folder that contains Google Trends file- `f`: filename for Google Trends file DescriptionParsing each Google Trends file downloaded from Google Trends API",26
argo,heatmap_cor.md,"# Heatmap plot of correlation matrix

```r
heatmap_cor(cor_heat, lim = 1)
```

## Arguments

- `cor_heat`: The coefficient matrix to draw heatmap
- `lim`: the limit to truncate for large coefficients for better presentation

## Returns

a graph on the default plot window

## Description

Heatmap plot of correlation matrix

## Examples

```r
cor_coef <- matrix(runif(100, -1, 1), ncol=10)
colnames(cor_coef) <- paste0(""col"", 1:10)
rownames(cor_coef) <- paste0(""row"", 1:10)
heatmap_cor(cor_coef)
```



","['Heatmap plot of correlation matrix```rheatmap_cor(cor_heat, lim = 1)``` Arguments- `cor_heat`: The coefficient matrix to draw heatmap- `lim`: the limit to truncate for large coefficients for better presentation Returnsa graph on the default plot window DescriptionHeatmap plot of correlation matrix Examples```rcor_coef <- matrix(runif(100, -1, 1), ncol=10)colnames(cor_coef) <- paste0(""col"", 1:10)rownames(cor_coef) <- paste0(""row"", 1:10)heatmap_cor(cor_coef)```']",1," Heatmap plot of correlation matrix```rheatmap_cor(cor_heat, lim = 1)``` Arguments- `cor_heat`: The coefficient matrix to draw heatmap- `lim`: the limit to truncate for large coefficients for better presentation Returnsa graph on the default plot window DescriptionHeatmap plot of correlation matrix Examples```rcor_coef <- matrix(runif(100, -1, 1), ncol=10)colnames(cor_coef) <- paste0(""col"", 1:10)rownames(cor_coef) <- paste0(""row"", 1:10)heatmap_cor(cor_coef)```",26
argo,argox_main.md,"# main function for argox

```r
argox_main(
  gt.folder,
  ili.folder,
  population.file,
  gft.file,
  mix,
  save.folder = NULL,
  NCORES = 8
)
```

## Arguments

- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""
- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""
- `population.file`: file path to population csv file
- `gft.file`: file path to Google Flu Trends csv file
- `mix`: the weighted avarage mixing of raw state-level Google Trends data. Set to be 0 for stand-alone model. Set to be 1/3 for spatial-pooling model.
- `save.folder`: output folder to save graphics. If NULL then do not output graphics.
- `NCORES`: number of parallel cpu cores to be used.

## Description

Main function that reproduce the results in ARGOX paper. The datasets are available at Harvard Dataverse <doi:10.7910/DVN/2IVDGK>.

## References

Yang, S., Ning, S. & Kou, S.C. Use Internet search data to accurately track state level influenza epidemics. Sci Rep 11, 4023 (2021)



","['main function for argox```rargox_main(  gt.folder,  ili.folder,  population.file,  gft.file,  mix,  save.folder = NULL,  NCORES = 8)``` Arguments- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""- `population.file`: file path to population csv file- `gft.file`: file path to Google Flu Trends csv file- `mix`: the weighted avarage mixing of raw state-level Google Trends data.', 'Set to be 0 for stand-alone model.', 'Set to be 1/3 for spatial-pooling model.- `save.folder`: output folder to save graphics.', 'If NULL then do not output graphics.- `NCORES`: number of parallel cpu cores to be used.', 'DescriptionMain function that reproduce the results in ARGOX paper.', 'The datasets are available at Harvard Dataverse <doi:10.7910/DVN/2IVDGK>.', 'ReferencesYang, S., Ning, S. & Kou, S.C. Use Internet search data to accurately track state level influenza epidemics.', 'Sci Rep 11, 4023 (2021)']",1," main function for argox```rargox_main(  gt.folder,  ili.folder,  population.file,  gft.file,  mix,  save.folder = NULL,  NCORES = 8)``` Arguments- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""- `population.file`: file path to population csv file- `gft.file`: file path to Google Flu Trends csv file- `mix`: the weighted avarage mixing of raw state-level Google Trends data. Set to be 0 for stand-alone model. Set to be 1/3 for spatial-pooling model.- `save.folder`: output folder to save graphics. If NULL then do not output graphics.- `NCORES`: number of parallel cpu cores to be used. DescriptionMain function that reproduce the results in ARGOX paper. The datasets are available at Harvard Dataverse <doi:10.7910/DVN/2IVDGK>. ReferencesYang, S., Ning, S. & Kou, S.C. Use Internet search data to accurately track state level influenza epidemics. Sci Rep 11, 4023 (2021)",26
argo,bootstrap_relative_efficiency.md,"# bootstrap relative efficiency confidence interval

```r
bootstrap_relative_efficiency(
  pred_data,
  model_good,
  model_bench,
  l = 50,
  N = 10000,
  truth = ""CDC.data"",
  sim = ""geom"",
  conf = 0.95,
  type = c(""mse"", ""mape"", ""mae"", ""mspe"", ""rmse"", ""rmspe"")
)
```

## Arguments

- `pred_data`: A matrix that contains the truth vector and the predictions. It can be data.frame or xts object
- `model_good`: The model to evaluate, must be in the column names of pred_data
- `model_bench`: The model to compare to, must be in the column names of pred_data
- `l`: stationary bootstrap mean block length
- `N`: number of bootstrap samples
- `truth`: the column name of the truth
- `sim`: simulation method, pass to boot::tsboot
- `conf`: confidence level
- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error)

## Returns

A vector of point estimate and corresponding bootstrap confidence interval

## Description

This function is used to reproduce the ARGO bootstrap confidence interval

## Examples

```r
GFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))
names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))
names(GFT_xts)[1] <- ""CDC.data""
bootstrap_relative_efficiency(
  pred_data = GFT_xts,
  model_good = ""col2"",
  model_bench = ""col3"",
  truth=""CDC.data"",
  N = 100
)
```



","['bootstrap relative efficiency confidence interval```rbootstrap_relative_efficiency(  pred_data,  model_good,  model_bench,  l = 50,  N = 10000,  truth = ""CDC.data"",  sim = ""geom"",  conf = 0.95,  type = c(""mse"", ""mape"", ""mae"", ""mspe"", ""rmse"", ""rmspe""))``` Arguments- `pred_data`: A matrix that contains the truth vector and the predictions.', 'It can be data.frame or xts object- `model_good`: The model to evaluate, must be in the column names of pred_data- `model_bench`: The model to compare to, must be in the column names of pred_data- `l`: stationary bootstrap mean block length- `N`: number of bootstrap samples- `truth`: the column name of the truth- `sim`: simulation method, pass to boot::tsboot- `conf`: confidence level- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error) ReturnsA vector of point estimate and corresponding bootstrap confidence interval DescriptionThis function is used to reproduce the ARGO bootstrap confidence interval Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""bootstrap_relative_efficiency(  pred_data = GFT_xts,  model_good = ""col2"",  model_bench = ""col3"",  truth=""CDC.data"",  N = 100)```']",1," bootstrap relative efficiency confidence interval```rbootstrap_relative_efficiency(  pred_data,  model_good,  model_bench,  l = 50,  N = 10000,  truth = ""CDC.data"",  sim = ""geom"",  conf = 0.95,  type = c(""mse"", ""mape"", ""mae"", ""mspe"", ""rmse"", ""rmspe""))``` Arguments- `pred_data`: A matrix that contains the truth vector and the predictions. It can be data.frame or xts object- `model_good`: The model to evaluate, must be in the column names of pred_data- `model_bench`: The model to compare to, must be in the column names of pred_data- `l`: stationary bootstrap mean block length- `N`: number of bootstrap samples- `truth`: the column name of the truth- `sim`: simulation method, pass to boot::tsboot- `conf`: confidence level- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error) ReturnsA vector of point estimate and corresponding bootstrap confidence interval DescriptionThis function is used to reproduce the ARGO bootstrap confidence interval Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""bootstrap_relative_efficiency(  pred_data = GFT_xts,  model_good = ""col2"",  model_bench = ""col3"",  truth=""CDC.data"",  N = 100)```",27
argo,logit_inv.md,"# inverse logit function

```r
logit_inv(x)
```

## Arguments

- `x`: numeric value for inverse logit transformation

## Description

inverse logit function

## Examples

```r
logit_inv(0)
```



",['inverse logit function```rlogit_inv(x)``` Arguments- `x`: numeric value for inverse logit transformation Descriptioninverse logit function Examples```rlogit_inv(0)```'],1, inverse logit function```rlogit_inv(x)``` Arguments- `x`: numeric value for inverse logit transformation Descriptioninverse logit function Examples```rlogit_inv(0)```,27
argo,load_data.md,"# Parsing of raw data

```r
load_data(type = ""extdata"", ili.weighted = TRUE)
```

## Arguments

- `type`: the type of the data to be loaded. If `type==""extdata""` it loads the data to reproduce the PNAS paper, and if `type==""athdata""` it loads the data to reproduce the CID(?) paper.
- `ili.weighted`: logical indicator to specify whether to load weighted ILI or not, if `FALSE` unweighted ILI is loaded.

## Returns

A list of following named xts objects if `type==""extdata""`

 * `GC10` Google Correlate trained with ILI available as of 2010. Google Correlate has been deprecated by Google as of Dec 2019 and is no longer publicly available.
 * `GC09` Google Correlate trained with ILI available as of 2009.
 * `GT` Google Trends data for search queries identified using Google Correlate. Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)
 * `CDC` CDC's ILI dataset. Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)
 * `GFT` Google Flu Trend (historical predictions).

A list of following named xts objects if `type==""athdata""`

 * `GT` Google Trends data for search queries identified. Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)
 * `CDC` CDC's ILI dataset. Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)
 * `ili_idx` the indexing information that includes the week number and year number, the date of ending Saturday, and the season number Available online at [https://www.cdc.gov/flu/weekly/](https://www.cdc.gov/flu/weekly/)
 * `ATH` Athenahealth data that includes the proportion of ""Flu Visit"", ""ILI Visit"", and ""Unspecified Viral or ILI Visit"" compared to total number of visit to the Athenahealth partner healthcare providers.
 * `ili_unrevised` Historical unrevised ILI activity level. The unrevised ILI published on week ZZ of season XXXX-YYYY is available at `www.cdc.gov/flu/weekly/weeklyarchivesXXXX-YYYY/data/senAllregtZZ.html` or `.htm`. For example, original ILI report for week 7 of season 2015-2016 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html](https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html), and original ILI report for week 50 of season 2012-2013 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm](https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm)

## Description

Data related to the PNAS paper. Accessed on Nov 14, 2015.

## Details

Parse and load CDC's ILI data, Google Flu Trend data, Google Correlate data trained with ILI as of 2010, Google Correlate data trained with ILI as of 2009, Google Trend data with search terms identified from Google Correlate (2010 version).

Each week ends on the Saturday indicated in the xts object

Google Correlate data is standardized by Google, and we rescale it to 0 -- 100 during parsing. Google Trends data is in the scale of 0 -- 100.

## Examples

```r
system.file(""extdata"", ""correlate-Influenza_like_Illness_h1n1_CDC_.csv"", package = ""argo"")
system.file(""extdata"", ""correlate-Influenza_like_Illness_CDC_.csv"", package = ""argo"")
system.file(""extdata"", ""GFT.csv"", package = ""argo"")
system.file(""extdata"", ""ILINet.csv"", package = ""argo"")
load_data()
```

## References

Yang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.



","['Parsing of raw data```rload_data(type = ""extdata"", ili.weighted = TRUE)``` Arguments- `type`: the type of the data to be loaded.', 'If `type==""extdata""` it loads the data to reproduce the PNAS paper, and if `type==""athdata""` it loads the data to reproduce the CID(?)', 'paper.- `ili.weighted`: logical indicator to specify whether to load weighted ILI or not, if `FALSE` unweighted ILI is loaded.', 'ReturnsA list of following named xts objects if `type==""extdata""`  `GC10` Google Correlate trained with ILI available as of 2010.', 'Google Correlate has been deprecated by Google as of Dec 2019 and is no longer publicly available.', '`GC09` Google Correlate trained with ILI available as of 2009.', '`GT` Google Trends data for search queries identified using Google Correlate.', ""Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)  `CDC` CDC's ILI dataset."", 'Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)  `GFT` Google Flu Trend (historical predictions).A list of following named xts objects if `type==""athdata""`  `GT` Google Trends data for search queries identified.', ""Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)  `CDC` CDC's ILI dataset."", 'Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)  `ili_idx` the indexing information that includes the week number and year number, the date of ending Saturday, and the season number Available online at [https://www.cdc.gov/flu/weekly/](https://www.cdc.gov/flu/weekly/)  `ATH` Athenahealth data that includes the proportion of ""Flu Visit"", ""ILI Visit"", and ""Unspecified Viral or ILI Visit"" compared to total number of visit to the Athenahealth partner healthcare providers.', '`ili_unrevised` Historical unrevised ILI activity level.', 'The unrevised ILI published on week ZZ of season XXXX-YYYY is available at `www.cdc.gov/flu/weekly/weeklyarchivesXXXX-YYYY/data/senAllregtZZ.html` or `.htm`.', 'For example, original ILI report for week 7 of season 2015-2016 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html](https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html), and original ILI report for week 50 of season 2012-2013 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm](https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm) DescriptionData related to the PNAS paper.', 'Accessed on Nov 14, 2015.', ""DetailsParse and load CDC's ILI data, Google Flu Trend data, Google Correlate data trained with ILI as of 2010, Google Correlate data trained with ILI as of 2009, Google Trend data with search terms identified from Google Correlate (2010 version).Each week ends on the Saturday indicated in the xts objectGoogle Correlate data is standardized by Google, and we rescale it to 0 -- 100 during parsing."", 'Google Trends data is in the scale of 0 -- 100.', 'Examples```rsystem.file(""extdata"", ""correlate-Influenza_like_Illness_h1n1_CDC_.csv"", package = ""argo"")system.file(""extdata"", ""correlate-Influenza_like_Illness_CDC_.csv"", package = ""argo"")system.file(""extdata"", ""GFT.csv"", package = ""argo"")system.file(""extdata"", ""ILINet.csv"", package = ""argo"")load_data()``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015).', 'Accurate estimation of influenza epidemics using Google search data via ARGO.', 'Proceedings of the National Academy of Sciences.']",1," Parsing of raw data```rload_data(type = ""extdata"", ili.weighted = TRUE)``` Arguments- `type`: the type of the data to be loaded. If `type==""extdata""` it loads the data to reproduce the PNAS paper, and if `type==""athdata""` it loads the data to reproduce the CID(?) paper.- `ili.weighted`: logical indicator to specify whether to load weighted ILI or not, if `FALSE` unweighted ILI is loaded. ReturnsA list of following named xts objects if `type==""extdata""`  `GC10` Google Correlate trained with ILI available as of 2010. Google Correlate has been deprecated by Google as of Dec 2019 and is no longer publicly available.  `GC09` Google Correlate trained with ILI available as of 2009.  `GT` Google Trends data for search queries identified using Google Correlate. Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)  `CDC` CDC's ILI dataset. Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)  `GFT` Google Flu Trend (historical predictions).A list of following named xts objects if `type==""athdata""`  `GT` Google Trends data for search queries identified. Not directly available online, you have to manually input query terms at [https://trends.google.com/trends/](https://trends.google.com/trends/)  `CDC` CDC's ILI dataset. Available online at [https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html](https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html)  `ili_idx` the indexing information that includes the week number and year number, the date of ending Saturday, and the season number Available online at [https://www.cdc.gov/flu/weekly/](https://www.cdc.gov/flu/weekly/)  `ATH` Athenahealth data that includes the proportion of ""Flu Visit"", ""ILI Visit"", and ""Unspecified Viral or ILI Visit"" compared to total number of visit to the Athenahealth partner healthcare providers.  `ili_unrevised` Historical unrevised ILI activity level. The unrevised ILI published on week ZZ of season XXXX-YYYY is available at `www.cdc.gov/flu/weekly/weeklyarchivesXXXX-YYYY/data/senAllregtZZ.html` or `.htm`. For example, original ILI report for week 7 of season 2015-2016 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html](https://www.cdc.gov/flu/weekly/weeklyarchives2015-2016/data/senAllregt07.html), and original ILI report for week 50 of season 2012-2013 is available at [https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm](https://www.cdc.gov/flu/weekly/weeklyarchives2012-2013/data/senAllregt50.htm) DescriptionData related to the PNAS paper. Accessed on Nov 14, 2015. DetailsParse and load CDC's ILI data, Google Flu Trend data, Google Correlate data trained with ILI as of 2010, Google Correlate data trained with ILI as of 2009, Google Trend data with search terms identified from Google Correlate (2010 version).Each week ends on the Saturday indicated in the xts objectGoogle Correlate data is standardized by Google, and we rescale it to 0 -- 100 during parsing. Google Trends data is in the scale of 0 -- 100. Examples```rsystem.file(""extdata"", ""correlate-Influenza_like_Illness_h1n1_CDC_.csv"", package = ""argo"")system.file(""extdata"", ""correlate-Influenza_like_Illness_CDC_.csv"", package = ""argo"")system.file(""extdata"", ""GFT.csv"", package = ""argo"")system.file(""extdata"", ""ILINet.csv"", package = ""argo"")load_data()``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.",27
argo,parse_gt_weekly.md,"# Parsing of Google Trends data

```r
parse_gt_weekly(folder)
```

## Arguments

- `folder`: folder with weekly Google Trends file

## Description

Parsing of Google Trends data

## Examples

```r
download.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",
file.path(tempdir(), ""gt2016-10-24.zip""))
unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())
gt.folder <- file.path(tempdir(), ""2016-10-19"")
parsed_data <- parse_gt_weekly(gt.folder)
```

## References

Yang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.



","['Parsing of Google Trends data```rparse_gt_weekly(folder)``` Arguments- `folder`: folder with weekly Google Trends file DescriptionParsing of Google Trends data Examples```rdownload.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")parsed_data <- parse_gt_weekly(gt.folder)``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015).', 'Accurate estimation of influenza epidemics using Google search data via ARGO.', 'Proceedings of the National Academy of Sciences.']",1," Parsing of Google Trends data```rparse_gt_weekly(folder)``` Arguments- `folder`: folder with weekly Google Trends file DescriptionParsing of Google Trends data Examples```rdownload.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")parsed_data <- parse_gt_weekly(gt.folder)``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.",27
argo,argo2.md,"# ARGO second step

```r
argo2(truth, argo1.p, argo.nat.p)
```

## Arguments

- `truth`: prediction target
- `argo1.p`: argo first step prediction
- `argo.nat.p`: argo national level prediction

## Description

Wrapper for ARGO second step. Best linear predictor / Bayesian posterior

## Examples

```r
truth <- xts::xts(exp(matrix(rnorm(180*10), ncol=10)), order.by = Sys.Date() - (180:1))
argo1.p <- xts::xts(exp(matrix(rnorm(180*10), ncol=10)), order.by = Sys.Date() - (180:1))
argo.nat.p <- xts::xts(exp(matrix(rnorm(180*10), ncol=10)), order.by = Sys.Date() - (180:1))
argo2result <- argo2(truth, argo1.p, argo.nat.p)
```

## References

Shaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports



","['ARGO second step```rargo2(truth, argo1.p, argo.nat.p)``` Arguments- `truth`: prediction target- `argo1.p`: argo first step prediction- `argo.nat.p`: argo national level prediction DescriptionWrapper for ARGO second step.', 'Best linear predictor / Bayesian posterior Examples```rtruth <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo1.p <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo.nat.p <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo2result <- argo2(truth, argo1.p, argo.nat.p)``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou.', 'Accurate Regional Influenza Epidemics Tracking Using Internet Search Data.']",1," ARGO second step```rargo2(truth, argo1.p, argo.nat.p)``` Arguments- `truth`: prediction target- `argo1.p`: argo first step prediction- `argo.nat.p`: argo national level prediction DescriptionWrapper for ARGO second step. Best linear predictor / Bayesian posterior Examples```rtruth <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo1.p <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo.nat.p <- xts::xts(exp(matrix(rnorm(18010), ncol=10)), order.by = Sys.Date() - (180:1))argo2result <- argo2(truth, argo1.p, argo.nat.p)``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports",27
argo,argo2_main.md,"# main function for argo2

```r
argo2_main(
  gt.folder,
  ili.folder,
  population.file,
  gft.file,
  save.folder = NULL
)
```

## Arguments

- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""
- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""
- `population.file`: file path to population csv file
- `gft.file`: file path to Google Flu Trends csv file
- `save.folder`: output folder to save graphics. If NULL then do not output graphics.

## Description

main function that reproduce the results in ARGO2 paper

## Examples

```r
## Not run:

download.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",
file.path(tempdir(), ""gt2016-10-24.zip""))
unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())
gt.folder <- file.path(tempdir(), ""2016-10-19"")
argo2_main(
  gt.folder=gt.folder,
  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),
  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),
  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo"")
)
## End(Not run)
```

## References

Shaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports



","['main function for argo2```rargo2_main(  gt.folder,  ili.folder,  population.file,  gft.file,  save.folder = NULL)``` Arguments- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""- `population.file`: file path to population csv file- `gft.file`: file path to Google Flu Trends csv file- `save.folder`: output folder to save graphics.', 'If NULL then do not output graphics.', 'Descriptionmain function that reproduce the results in ARGO2 paper Examples```r Not run:download.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")argo2_main(  gt.folder=gt.folder,  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo"")) End(Not run)``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou.', 'Accurate Regional Influenza Epidemics Tracking Using Internet Search Data.']",1," main function for argo2```rargo2_main(  gt.folder,  ili.folder,  population.file,  gft.file,  save.folder = NULL)``` Arguments- `gt.folder`: folder with Google Trends files, which should be thousands of csv file such as ""US-MA_fever cough.csv"" or ""US-NY_cold or flu.csv""- `ili.folder`: folder with ILINet data files: ""ILINet_nat.csv"" and ""ILINet_regional.csv""- `population.file`: file path to population csv file- `gft.file`: file path to Google Flu Trends csv file- `save.folder`: output folder to save graphics. If NULL then do not output graphics. Descriptionmain function that reproduce the results in ARGO2 paper Examples```r Not run:download.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")argo2_main(  gt.folder=gt.folder,  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo"")) End(Not run)``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports",27
argo,plot_argo.md,"# Time series plot of ARGO applied on CDC's ILI data

```r
plot_argo(GFT_xts, GC_GT_cut_date, model_names, legend_names, zoom_periods)
```

## Arguments

- `GFT_xts`: dataframe with all predicted values
- `GC_GT_cut_date`: cutting date for switching datasets
- `model_names`: name of predicting models
- `legend_names`: legend for predicting models
- `zoom_periods`: vector of periods to zoom into

## Returns

a graph on the default plot window

## Description

This function is used to reproduce the ARGO plot.

## Examples

```r
GFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))
names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))
names(GFT_xts)[1] <- ""CDC.data""
zoom_periods = c()
for (i in 0:5){
  zoom_periods = c(
    zoom_periods,
    paste0(zoo::index(GFT_xts)[i*30+1], ""/"", zoo::index(GFT_xts)[i*30+30])
  )
}
plot_argo(
  GFT_xts = GFT_xts,
  GC_GT_cut_date = zoo::index(GFT_xts)[50],
  model_names = colnames(GFT_xts)[-1],
  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),
  zoom_periods = zoom_periods
)
```



","[""Time series plot of ARGO applied on CDC's ILI data```rplot_argo(GFT_xts, GC_GT_cut_date, model_names, legend_names, zoom_periods)``` Arguments- `GFT_xts`: dataframe with all predicted values- `GC_GT_cut_date`: cutting date for switching datasets- `model_names`: name of predicting models- `legend_names`: legend for predicting models- `zoom_periods`: vector of periods to zoom into Returnsa graph on the default plot window DescriptionThis function is used to reproduce the ARGO plot."", 'Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""zoom_periods = c()for (i in 0:5){  zoom_periods = c(    zoom_periods,    paste0(zoo::index(GFT_xts)[i30+1], ""/"", zoo::index(GFT_xts)[i30+30])  )}plot_argo(  GFT_xts = GFT_xts,  GC_GT_cut_date = zoo::index(GFT_xts)[50],  model_names = colnames(GFT_xts)[-1],  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),  zoom_periods = zoom_periods)```']",1," Time series plot of ARGO applied on CDC's ILI data```rplot_argo(GFT_xts, GC_GT_cut_date, model_names, legend_names, zoom_periods)``` Arguments- `GFT_xts`: dataframe with all predicted values- `GC_GT_cut_date`: cutting date for switching datasets- `model_names`: name of predicting models- `legend_names`: legend for predicting models- `zoom_periods`: vector of periods to zoom into Returnsa graph on the default plot window DescriptionThis function is used to reproduce the ARGO plot. Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=5)), order.by = Sys.Date() - (200:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""zoom_periods = c()for (i in 0:5){  zoom_periods = c(    zoom_periods,    paste0(zoo::index(GFT_xts)[i30+1], ""/"", zoo::index(GFT_xts)[i30+30])  )}plot_argo(  GFT_xts = GFT_xts,  GC_GT_cut_date = zoo::index(GFT_xts)[50],  model_names = colnames(GFT_xts)[-1],  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),  zoom_periods = zoom_periods)```",27
argo,summary_argo.md,"# performance summary of ARGO applied on CDC's ILI data

```r
summary_argo(
  GFT_xts,
  model_names,
  legend_names,
  periods,
  whole_period = ""2009-03/2015-10""
)
```

## Arguments

- `GFT_xts`: dataframe with all predicted values
- `model_names`: name of predicting models
- `legend_names`: legend for predicting models
- `periods`: vector of periods to zoom into
- `whole_period`: the whole period duration

## Returns

A list of summary tables for the input periods, including RMSE, MAE, MAPE, corr

## Description

performance summary of ARGO applied on CDC's ILI data

## Examples

```r
GFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=10)), order.by = Sys.Date() - (100:1))
names(GFT_xts) <- paste0(""col"", 1:10)
names(GFT_xts)[1] <- ""CDC.data""
summary_argo(
  GFT_xts = GFT_xts,
  model_names = colnames(GFT_xts)[-1],
  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),
  periods = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[49]),
              paste0(zoo::index(GFT_xts)[50], ""/"", zoo::index(GFT_xts)[100])),
  whole_period=""2009-03/""
)
```

## References

Yang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>. Shaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports



","['performance summary of ARGO applied on CDC\'s ILI data```rsummary_argo(  GFT_xts,  model_names,  legend_names,  periods,  whole_period = ""2009-03/2015-10"")``` Arguments- `GFT_xts`: dataframe with all predicted values- `model_names`: name of predicting models- `legend_names`: legend for predicting models- `periods`: vector of periods to zoom into- `whole_period`: the whole period duration ReturnsA list of summary tables for the input periods, including RMSE, MAE, MAPE, corr Descriptionperformance summary of ARGO applied on CDC\'s ILI data Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=10)), order.by = Sys.Date() - (100:1))names(GFT_xts) <- paste0(""col"", 1:10)names(GFT_xts)[1] <- ""CDC.data""summary_argo(  GFT_xts = GFT_xts,  model_names = colnames(GFT_xts)[-1],  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),  periods = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[49]),              paste0(zoo::index(GFT_xts)[50], ""/"", zoo::index(GFT_xts)[100])),  whole_period=""2009-03/"")``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015).', 'Accurate estimation of influenza epidemics using Google search data via ARGO.', 'Proceedings of the National Academy of Sciences.', 'Shaoyang Ning, Shihao Yang, S. C. Kou.', 'Accurate Regional Influenza Epidemics Tracking Using Internet Search Data.']",1," performance summary of ARGO applied on CDC's ILI data```rsummary_argo(  GFT_xts,  model_names,  legend_names,  periods,  whole_period = ""2009-03/2015-10"")``` Arguments- `GFT_xts`: dataframe with all predicted values- `model_names`: name of predicting models- `legend_names`: legend for predicting models- `periods`: vector of periods to zoom into- `whole_period`: the whole period duration ReturnsA list of summary tables for the input periods, including RMSE, MAE, MAPE, corr Descriptionperformance summary of ARGO applied on CDC's ILI data Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(1000), ncol=10)), order.by = Sys.Date() - (100:1))names(GFT_xts) <- paste0(""col"", 1:10)names(GFT_xts)[1] <- ""CDC.data""summary_argo(  GFT_xts = GFT_xts,  model_names = colnames(GFT_xts)[-1],  legend_names = paste0(colnames(GFT_xts)[-1], ""legend""),  periods = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[49]),              paste0(zoo::index(GFT_xts)[50], ""/"", zoo::index(GFT_xts)[100])),  whole_period=""2009-03/"")``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>. Shaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports",28
argo,argo_main.md,"# main function for argo

```r
argo_main(save.folder = NULL)
```

## Arguments

- `save.folder`: output folder to save graphics. If NULL then do not output graphics.

## Description

main function that reproduce the results in ARGO paper

## Examples

```r
argo_main()
```



","['main function for argo```rargo_main(save.folder = NULL)``` Arguments- `save.folder`: output folder to save graphics.', 'If NULL then do not output graphics.', 'Descriptionmain function that reproduce the results in ARGO paper Examples```rargo_main()```']",1, main function for argo```rargo_main(save.folder = NULL)``` Arguments- `save.folder`: output folder to save graphics. If NULL then do not output graphics. Descriptionmain function that reproduce the results in ARGO paper Examples```rargo_main()```,28
argo,gt.parser.pub.web.md,"# Parsing each Google Trends file downloaded from website

```r
gt.parser.pub.web(gt.folder, f)
```

## Arguments

- `gt.folder`: folder that contains Google Trends file
- `f`: filename for Google Trends file

## Description

Parsing each Google Trends file downloaded from website



","['Parsing each Google Trends file downloaded from website```rgt.parser.pub.web(gt.folder, f)``` Arguments- `gt.folder`: folder that contains Google Trends file- `f`: filename for Google Trends file DescriptionParsing each Google Trends file downloaded from website']",1," Parsing each Google Trends file downloaded from website```rgt.parser.pub.web(gt.folder, f)``` Arguments- `gt.folder`: folder that contains Google Trends file- `f`: filename for Google Trends file DescriptionParsing each Google Trends file downloaded from website",28
argo,logit.md,"# logit function

```r
logit(x)
```

## Arguments

- `x`: numeric value for logit transformation

## Description

logit function

## Examples

```r
logit(0.5)
```



",['logit function```rlogit(x)``` Arguments- `x`: numeric value for logit transformation Descriptionlogit function Examples```rlogit(0.5)```'],1, logit function```rlogit(x)``` Arguments- `x`: numeric value for logit transformation Descriptionlogit function Examples```rlogit(0.5)```,28
argo,boot_re.md,"# wrapper for bootstrap relative efficiency confidence interval

```r
boot_re(
  pred_data,
  period.all,
  model_good,
  bench.all,
  type,
  truth = ""CDC.data"",
  l = 50,
  N = 10000,
  sim = ""geom"",
  conf = 0.95
)
```

## Arguments

- `pred_data`: A matrix that contains the truth vector and the predictions. It can be data.frame or xts object
- `period.all`: vector of the periods to evaluate relative efficiency
- `model_good`: The model to evaluate, must be in the column names of pred_data
- `bench.all`: vector of the models to compare to, must be in the column names of pred_data
- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error)
- `truth`: the column name of the truth
- `l`: stationary bootstrap mean block length
- `N`: number of bootstrap samples
- `sim`: simulation method, pass to boot::tsboot
- `conf`: confidence level

## Returns

A vector of point estimate and corresponding bootstrap confidence interval

## Description

This function is used to wrap the `bootstrap_relative_efficiency`, taking vectorized arguments.

## Examples

```r
GFT_xts = xts::xts(exp(matrix(rnorm(500), ncol=5)), order.by = Sys.Date() - (100:1))
names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))
names(GFT_xts)[1] <- ""CDC.data""

boot_re(
  pred_data = GFT_xts,
  period.all = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[50]),
                 paste0(zoo::index(GFT_xts)[51], ""/"", zoo::index(GFT_xts)[100])),
  model_good = ""col2"",
  bench.all = c(""col3"", ""col4""),
  type = ""mse"",
  truth=""CDC.data"",
  l = 5,
  N = 20
)
```



","['wrapper for bootstrap relative efficiency confidence interval```rboot_re(  pred_data,  period.all,  model_good,  bench.all,  type,  truth = ""CDC.data"",  l = 50,  N = 10000,  sim = ""geom"",  conf = 0.95)``` Arguments- `pred_data`: A matrix that contains the truth vector and the predictions.', 'It can be data.frame or xts object- `period.all`: vector of the periods to evaluate relative efficiency- `model_good`: The model to evaluate, must be in the column names of pred_data- `bench.all`: vector of the models to compare to, must be in the column names of pred_data- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error)- `truth`: the column name of the truth- `l`: stationary bootstrap mean block length- `N`: number of bootstrap samples- `sim`: simulation method, pass to boot::tsboot- `conf`: confidence level ReturnsA vector of point estimate and corresponding bootstrap confidence interval DescriptionThis function is used to wrap the `bootstrap_relative_efficiency`, taking vectorized arguments.', 'Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(500), ncol=5)), order.by = Sys.Date() - (100:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""boot_re(  pred_data = GFT_xts,  period.all = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[50]),                 paste0(zoo::index(GFT_xts)[51], ""/"", zoo::index(GFT_xts)[100])),  model_good = ""col2"",  bench.all = c(""col3"", ""col4""),  type = ""mse"",  truth=""CDC.data"",  l = 5,  N = 20)```']",1," wrapper for bootstrap relative efficiency confidence interval```rboot_re(  pred_data,  period.all,  model_good,  bench.all,  type,  truth = ""CDC.data"",  l = 50,  N = 10000,  sim = ""geom"",  conf = 0.95)``` Arguments- `pred_data`: A matrix that contains the truth vector and the predictions. It can be data.frame or xts object- `period.all`: vector of the periods to evaluate relative efficiency- `model_good`: The model to evaluate, must be in the column names of pred_data- `bench.all`: vector of the models to compare to, must be in the column names of pred_data- `type`: Must be one of ""mse"" (mean square error), ""mape"" (mean absolute percentage error), or ""mae"" (mean absolute error)- `truth`: the column name of the truth- `l`: stationary bootstrap mean block length- `N`: number of bootstrap samples- `sim`: simulation method, pass to boot::tsboot- `conf`: confidence level ReturnsA vector of point estimate and corresponding bootstrap confidence interval DescriptionThis function is used to wrap the `bootstrap_relative_efficiency`, taking vectorized arguments. Examples```rGFT_xts = xts::xts(exp(matrix(rnorm(500), ncol=5)), order.by = Sys.Date() - (100:1))names(GFT_xts) <- paste0(""col"", 1:ncol(GFT_xts))names(GFT_xts)[1] <- ""CDC.data""boot_re(  pred_data = GFT_xts,  period.all = c(paste0(zoo::index(GFT_xts)[1], ""/"", zoo::index(GFT_xts)[50]),                 paste0(zoo::index(GFT_xts)[51], ""/"", zoo::index(GFT_xts)[100])),  model_good = ""col2"",  bench.all = c(""col3"", ""col4""),  type = ""mse"",  truth=""CDC.data"",  l = 5,  N = 20)```",28
argo,load_reg_data.md,"# Parsing of raw data for regional ILI estimation

```r
load_reg_data(
  gt.folder,
  ili.folder,
  population.file,
  gft.file,
  gt.parser = gt.parser.pub.web
)
```

## Arguments

- `gt.folder`: folder with all Google Trends data
- `ili.folder`: folder with all ILI data
- `population.file`: csv file path with state population data
- `gft.file`: csv file path for Google Flu Trends
- `gt.parser`: Google Trends data parser function, could be `gt.parser.pub.web` or `gt.parser.pub.api`

## Description

Parsing of raw data for regional ILI estimation

## Examples

```r
download.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",
file.path(tempdir(), ""gt2016-10-24.zip""))
unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())
gt.folder <- file.path(tempdir(), ""2016-10-19"")

data_parsed <- load_reg_data(
  gt.folder=gt.folder,
  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),
  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),
  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo"")
)
```

## References

Shaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports



","['Parsing of raw data for regional ILI estimation```rload_reg_data(  gt.folder,  ili.folder,  population.file,  gft.file,  gt.parser = gt.parser.pub.web)``` Arguments- `gt.folder`: folder with all Google Trends data- `ili.folder`: folder with all ILI data- `population.file`: csv file path with state population data- `gft.file`: csv file path for Google Flu Trends- `gt.parser`: Google Trends data parser function, could be `gt.parser.pub.web` or `gt.parser.pub.api` DescriptionParsing of raw data for regional ILI estimation Examples```rdownload.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")data_parsed <- load_reg_data(  gt.folder=gt.folder,  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo""))``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou.', 'Accurate Regional Influenza Epidemics Tracking Using Internet Search Data.']",1," Parsing of raw data for regional ILI estimation```rload_reg_data(  gt.folder,  ili.folder,  population.file,  gft.file,  gt.parser = gt.parser.pub.web)``` Arguments- `gt.folder`: folder with all Google Trends data- `ili.folder`: folder with all ILI data- `population.file`: csv file path with state population data- `gft.file`: csv file path for Google Flu Trends- `gt.parser`: Google Trends data parser function, could be `gt.parser.pub.web` or `gt.parser.pub.api` DescriptionParsing of raw data for regional ILI estimation Examples```rdownload.file(""https://scholar.harvard.edu/files/syang/files/gt2016-10-24.zip"",file.path(tempdir(), ""gt2016-10-24.zip""))unzip(file.path(tempdir(), ""gt2016-10-24.zip""), exdir = tempdir())gt.folder <- file.path(tempdir(), ""2016-10-19"")data_parsed <- load_reg_data(  gt.folder=gt.folder,  ili.folder=system.file(""regiondata"", ""ili20161121"", package = ""argo""),  population.file=system.file(""regiondata"", ""Population.csv"", package = ""argo""),  gft.file=system.file(""regiondata"", ""GFT.txt"", package = ""argo""))``` ReferencesShaoyang Ning, Shihao Yang, S. C. Kou. Accurate Regional Influenza Epidemics Tracking Using Internet Search Data. Scientific Reports",28
argo,parse_unrevised_ili.md,"# Parsing of unrevised ili from online source

```r
parse_unrevised_ili(type = ""extdata"", ili.weighted = TRUE)
```

## Arguments

- `type`: the type of data folder to parse
- `ili.weighted`: indicator to use weighted ILI or not

## Description

Parsing of unrevised ili from online source

## Examples

```r
parse_unrevised_ili()
```

## References

Yang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.



","['Parsing of unrevised ili from online source```rparse_unrevised_ili(type = ""extdata"", ili.weighted = TRUE)``` Arguments- `type`: the type of data folder to parse- `ili.weighted`: indicator to use weighted ILI or not DescriptionParsing of unrevised ili from online source Examples```rparse_unrevised_ili()``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015).', 'Accurate estimation of influenza epidemics using Google search data via ARGO.', 'Proceedings of the National Academy of Sciences.']",1," Parsing of unrevised ili from online source```rparse_unrevised_ili(type = ""extdata"", ili.weighted = TRUE)``` Arguments- `type`: the type of data folder to parse- `ili.weighted`: indicator to use weighted ILI or not DescriptionParsing of unrevised ili from online source Examples```rparse_unrevised_ili()``` ReferencesYang, S., Santillana, M., & Kou, S. C. (2015). Accurate estimation of influenza epidemics using Google search data via ARGO. Proceedings of the National Academy of Sciences. <doi:10.1073/pnas.1515373112>.",28
